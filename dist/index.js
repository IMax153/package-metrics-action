'use strict';

var p2 = require('path');
var process$1 = require('process');
var perf_hooks = require('perf_hooks');
var promises = require('fs/promises');
var stream = require('stream');
var child_process = require('child_process');
var events = require('events');
var ve = require('module');
var fs = require('fs');
var util = require('util');
var url$1 = require('url');
var worker_threads = require('worker_threads');
var async_hooks = require('async_hooks');
var os = require('os');
var zlib = require('zlib');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var p2__default = /*#__PURE__*/_interopDefault(p2);
var process$1__default = /*#__PURE__*/_interopDefault(process$1);
var ve__default = /*#__PURE__*/_interopDefault(ve);
var fs__default = /*#__PURE__*/_interopDefault(fs);

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a2, b) => (typeof require !== "undefined" ? require : a2)[b]
}) : x2)(function(x2) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all8) => {
  for (var name in all8)
    __defProp(target, name, { get: all8[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget);
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp(target, "default", { value: mod, enumerable: true }) ,
  mod
));

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/core/symbols.js"(exports, module) {
    module.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kLocalAddress: Symbol("local address"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kBody: Symbol("abstracted request body"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol.for("nodejs.stream.destroyed"),
      kResume: Symbol("resume"),
      kOnError: Symbol("on error"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelining"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter"),
      kMaxResponseSize: Symbol("max response size"),
      kHTTP2Session: Symbol("http2Session"),
      kHTTP2SessionState: Symbol("http2Session state"),
      kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
      kConstruct: Symbol("constructable"),
      kListeners: Symbol("listeners"),
      kHTTPContext: Symbol("http context"),
      kMaxConcurrentStreams: Symbol("max concurrent streams"),
      kNoProxyAgent: Symbol("no proxy agent"),
      kHttpProxyAgent: Symbol("http proxy agent"),
      kHttpsProxyAgent: Symbol("https proxy agent")
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/core/errors.js"(exports, module) {
    var UndiciError = class extends Error {
      constructor(message, options) {
        super(message, options);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    var ConnectTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    };
    var HeadersTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    var HeadersOverflowError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    };
    var BodyTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    var ResponseStatusCodeError = class extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        this.name = "ResponseStatusCodeError";
        this.message = message || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    };
    var InvalidArgumentError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    var InvalidReturnValueError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    var AbortError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "AbortError";
        this.message = message || "The operation was aborted";
      }
    };
    var RequestAbortedError = class extends AbortError {
      constructor(message) {
        super(message);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    var InformationalError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    var RequestContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "RequestContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ResponseContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ResponseContentLengthMismatchError";
        this.message = message || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ClientDestroyedError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    var ClientClosedError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    var SocketError = class extends UndiciError {
      constructor(message, socket) {
        super(message);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    };
    var NotSupportedError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "MissingUpstreamError";
        this.message = message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    };
    var HTTPParserError = class extends Error {
      constructor(message, code, data) {
        super(message);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    var ResponseExceededMaxSizeError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ResponseExceededMaxSizeError";
        this.message = message || "Response content exceeded max size";
        this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    };
    var RequestRetryError = class extends UndiciError {
      constructor(message, code, { headers, data }) {
        super(message);
        this.name = "RequestRetryError";
        this.message = message || "Request retry error";
        this.code = "UND_ERR_REQ_RETRY";
        this.statusCode = code;
        this.data = data;
        this.headers = headers;
      }
    };
    var ResponseError = class extends UndiciError {
      constructor(message, code, { headers, body }) {
        super(message);
        this.name = "ResponseError";
        this.message = message || "Response error";
        this.code = "UND_ERR_RESPONSE";
        this.statusCode = code;
        this.body = body;
        this.headers = headers;
      }
    };
    var SecureProxyConnectionError = class extends UndiciError {
      constructor(cause3, message, options = {}) {
        super(message, { cause: cause3, ...options });
        this.name = "SecureProxyConnectionError";
        this.message = message || "Secure Proxy Connection failed";
        this.code = "UND_ERR_PRX_TLS";
        this.cause = cause3;
      }
    };
    module.exports = {
      AbortError,
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError,
      RequestRetryError,
      ResponseError,
      SecureProxyConnectionError
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/core/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/core/constants.js"(exports, module) {
    var wellknownHeaderNames = (
      /** @type {const} */
      [
        "Accept",
        "Accept-Encoding",
        "Accept-Language",
        "Accept-Ranges",
        "Access-Control-Allow-Credentials",
        "Access-Control-Allow-Headers",
        "Access-Control-Allow-Methods",
        "Access-Control-Allow-Origin",
        "Access-Control-Expose-Headers",
        "Access-Control-Max-Age",
        "Access-Control-Request-Headers",
        "Access-Control-Request-Method",
        "Age",
        "Allow",
        "Alt-Svc",
        "Alt-Used",
        "Authorization",
        "Cache-Control",
        "Clear-Site-Data",
        "Connection",
        "Content-Disposition",
        "Content-Encoding",
        "Content-Language",
        "Content-Length",
        "Content-Location",
        "Content-Range",
        "Content-Security-Policy",
        "Content-Security-Policy-Report-Only",
        "Content-Type",
        "Cookie",
        "Cross-Origin-Embedder-Policy",
        "Cross-Origin-Opener-Policy",
        "Cross-Origin-Resource-Policy",
        "Date",
        "Device-Memory",
        "Downlink",
        "ECT",
        "ETag",
        "Expect",
        "Expect-CT",
        "Expires",
        "Forwarded",
        "From",
        "Host",
        "If-Match",
        "If-Modified-Since",
        "If-None-Match",
        "If-Range",
        "If-Unmodified-Since",
        "Keep-Alive",
        "Last-Modified",
        "Link",
        "Location",
        "Max-Forwards",
        "Origin",
        "Permissions-Policy",
        "Pragma",
        "Proxy-Authenticate",
        "Proxy-Authorization",
        "RTT",
        "Range",
        "Referer",
        "Referrer-Policy",
        "Refresh",
        "Retry-After",
        "Sec-WebSocket-Accept",
        "Sec-WebSocket-Extensions",
        "Sec-WebSocket-Key",
        "Sec-WebSocket-Protocol",
        "Sec-WebSocket-Version",
        "Server",
        "Server-Timing",
        "Service-Worker-Allowed",
        "Service-Worker-Navigation-Preload",
        "Set-Cookie",
        "SourceMap",
        "Strict-Transport-Security",
        "Supports-Loading-Mode",
        "TE",
        "Timing-Allow-Origin",
        "Trailer",
        "Transfer-Encoding",
        "Upgrade",
        "Upgrade-Insecure-Requests",
        "User-Agent",
        "Vary",
        "Via",
        "WWW-Authenticate",
        "X-Content-Type-Options",
        "X-DNS-Prefetch-Control",
        "X-Frame-Options",
        "X-Permitted-Cross-Domain-Policies",
        "X-Powered-By",
        "X-Requested-With",
        "X-XSS-Protection"
      ]
    );
    var headerNameLowerCasedRecord = {};
    Object.setPrototypeOf(headerNameLowerCasedRecord, null);
    var wellknownHeaderNameBuffers = {};
    Object.setPrototypeOf(wellknownHeaderNameBuffers, null);
    function getHeaderNameAsBuffer(header) {
      let buffer4 = wellknownHeaderNameBuffers[header];
      if (buffer4 === void 0) {
        buffer4 = Buffer.from(header);
      }
      return buffer4;
    }
    for (let i = 0; i < wellknownHeaderNames.length; ++i) {
      const key = wellknownHeaderNames[i];
      const lowerCasedKey = key.toLowerCase();
      headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
    }
    module.exports = {
      wellknownHeaderNames,
      headerNameLowerCasedRecord,
      getHeaderNameAsBuffer
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/core/tree.js
var require_tree = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/core/tree.js"(exports, module) {
    var {
      wellknownHeaderNames,
      headerNameLowerCasedRecord
    } = require_constants();
    var TstNode = class _TstNode {
      /** @type {any} */
      value = null;
      /** @type {null | TstNode} */
      left = null;
      /** @type {null | TstNode} */
      middle = null;
      /** @type {null | TstNode} */
      right = null;
      /** @type {number} */
      code;
      /**
       * @param {string} key
       * @param {any} value
       * @param {number} index
       */
      constructor(key, value, index) {
        if (index === void 0 || index >= key.length) {
          throw new TypeError("Unreachable");
        }
        const code = this.code = key.charCodeAt(index);
        if (code > 127) {
          throw new TypeError("key must be ascii string");
        }
        if (key.length !== ++index) {
          this.middle = new _TstNode(key, value, index);
        } else {
          this.value = value;
        }
      }
      /**
       * @param {string} key
       * @param {any} value
       * @returns {void}
       */
      add(key, value) {
        const length3 = key.length;
        if (length3 === 0) {
          throw new TypeError("Unreachable");
        }
        let index = 0;
        let node = this;
        while (true) {
          const code = key.charCodeAt(index);
          if (code > 127) {
            throw new TypeError("key must be ascii string");
          }
          if (node.code === code) {
            if (length3 === ++index) {
              node.value = value;
              break;
            } else if (node.middle !== null) {
              node = node.middle;
            } else {
              node.middle = new _TstNode(key, value, index);
              break;
            }
          } else if (node.code < code) {
            if (node.left !== null) {
              node = node.left;
            } else {
              node.left = new _TstNode(key, value, index);
              break;
            }
          } else if (node.right !== null) {
            node = node.right;
          } else {
            node.right = new _TstNode(key, value, index);
            break;
          }
        }
      }
      /**
       * @param {Uint8Array} key
       * @return {TstNode | null}
       */
      search(key) {
        const keylength = key.length;
        let index = 0;
        let node = this;
        while (node !== null && index < keylength) {
          let code = key[index];
          if (code <= 90 && code >= 65) {
            code |= 32;
          }
          while (node !== null) {
            if (code === node.code) {
              if (keylength === ++index) {
                return node;
              }
              node = node.middle;
              break;
            }
            node = node.code < code ? node.left : node.right;
          }
        }
        return null;
      }
    };
    var TernarySearchTree = class {
      /** @type {TstNode | null} */
      node = null;
      /**
       * @param {string} key
       * @param {any} value
       * @returns {void}
       * */
      insert(key, value) {
        if (this.node === null) {
          this.node = new TstNode(key, value, 0);
        } else {
          this.node.add(key, value);
        }
      }
      /**
       * @param {Uint8Array} key
       * @returns {any}
       */
      lookup(key) {
        return this.node?.search(key)?.value ?? null;
      }
    };
    var tree = new TernarySearchTree();
    for (let i = 0; i < wellknownHeaderNames.length; ++i) {
      const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]];
      tree.insert(key, key);
    }
    module.exports = {
      TernarySearchTree,
      tree
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/core/util.js
var require_util = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/core/util.js"(exports, module) {
    var assert3 = __require("assert");
    var { kDestroyed, kBodyUsed, kListeners, kBody } = require_symbols();
    var { IncomingMessage } = __require("http");
    var stream = __require("stream");
    var net = __require("net");
    var { Blob: Blob2 } = __require("buffer");
    var nodeUtil = __require("util");
    var { stringify } = __require("querystring");
    var { EventEmitter: EE } = __require("events");
    var { InvalidArgumentError } = require_errors();
    var { headerNameLowerCasedRecord } = require_constants();
    var { tree } = require_tree();
    var [nodeMajor, nodeMinor] = process.versions.node.split(".", 2).map((v2) => Number(v2));
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert3(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    function wrapRequestBody(body) {
      if (isStream2(body)) {
        if (bodyLength(body) === 0) {
          body.on("data", function() {
            assert3(false);
          });
        }
        if (typeof body.readableDidRead !== "boolean") {
          body[kBodyUsed] = false;
          EE.prototype.on.call(body, "data", function() {
            this[kBodyUsed] = true;
          });
        }
        return body;
      } else if (body && typeof body.pipeTo === "function") {
        return new BodyAsyncIterable(body);
      } else if (body && typeof body !== "string" && !ArrayBuffer.isView(body) && isIterable2(body)) {
        return new BodyAsyncIterable(body);
      } else {
        return body;
      }
    }
    function isStream2(obj) {
      return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
    }
    function isBlobLike(object) {
      if (object === null) {
        return false;
      } else if (object instanceof Blob2) {
        return true;
      } else if (typeof object !== "object") {
        return false;
      } else {
        const sTag = object[Symbol.toStringTag];
        return (sTag === "Blob" || sTag === "File") && ("stream" in object && typeof object.stream === "function" || "arrayBuffer" in object && typeof object.arrayBuffer === "function");
      }
    }
    function serializePathWithQuery(url3, queryParams) {
      if (url3.includes("?") || url3.includes("#")) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const stringified = stringify(queryParams);
      if (stringified) {
        url3 += "?" + stringified;
      }
      return url3;
    }
    function isValidPort(port) {
      const value = parseInt(port, 10);
      return value === Number(port) && value >= 0 && value <= 65535;
    }
    function isHttpOrHttpsPrefixed(value) {
      return value != null && value[0] === "h" && value[1] === "t" && value[2] === "t" && value[3] === "p" && (value[4] === ":" || value[4] === "s" && value[5] === ":");
    }
    function parseURL(url3) {
      if (typeof url3 === "string") {
        url3 = new URL(url3);
        if (!isHttpOrHttpsPrefixed(url3.origin || url3.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        return url3;
      }
      if (!url3 || typeof url3 !== "object") {
        throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
      }
      if (!(url3 instanceof URL)) {
        if (url3.port != null && url3.port !== "" && isValidPort(url3.port) === false) {
          throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
        }
        if (url3.path != null && typeof url3.path !== "string") {
          throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
        }
        if (url3.pathname != null && typeof url3.pathname !== "string") {
          throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
        }
        if (url3.hostname != null && typeof url3.hostname !== "string") {
          throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
        }
        if (url3.origin != null && typeof url3.origin !== "string") {
          throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
        }
        if (!isHttpOrHttpsPrefixed(url3.origin || url3.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        const port = url3.port != null ? url3.port : url3.protocol === "https:" ? 443 : 80;
        let origin = url3.origin != null ? url3.origin : `${url3.protocol || ""}//${url3.hostname || ""}:${port}`;
        let path3 = url3.path != null ? url3.path : `${url3.pathname || ""}${url3.search || ""}`;
        if (origin[origin.length - 1] === "/") {
          origin = origin.slice(0, origin.length - 1);
        }
        if (path3 && path3[0] !== "/") {
          path3 = `/${path3}`;
        }
        return new URL(`${origin}${path3}`);
      }
      if (!isHttpOrHttpsPrefixed(url3.origin || url3.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      return url3;
    }
    function parseOrigin(url3) {
      url3 = parseURL(url3);
      if (url3.pathname !== "/" || url3.search || url3.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url3;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert3(idx2 !== -1);
        return host.substring(1, idx2);
      }
      const idx = host.indexOf(":");
      if (idx === -1) return host;
      return host.substring(0, idx);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert3(typeof host === "string");
      const servername = getHostname(host);
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }
    function isIterable2(obj) {
      return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream2(body)) {
        const state = body._readableState;
        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(body) {
      return body && !!(body.destroyed || body[kDestroyed] || stream.isDestroyed?.(body));
    }
    function destroy(stream2, err) {
      if (stream2 == null || !isStream2(stream2) || isDestroyed(stream2)) {
        return;
      }
      if (typeof stream2.destroy === "function") {
        if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
          stream2.socket = null;
        }
        stream2.destroy(err);
      } else if (err) {
        queueMicrotask(() => {
          stream2.emit("error", err);
        });
      }
      if (stream2.destroyed !== true) {
        stream2[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m2 = val.match(KEEPALIVE_TIMEOUT_EXPR);
      return m2 ? parseInt(m2[1], 10) * 1e3 : null;
    }
    function headerNameToString(value) {
      return typeof value === "string" ? headerNameLowerCasedRecord[value] ?? value.toLowerCase() : tree.lookup(value) ?? value.toString("latin1").toLowerCase();
    }
    function bufferToLowerCasedHeaderName(value) {
      return tree.lookup(value) ?? value.toString("latin1").toLowerCase();
    }
    function parseHeaders(headers, obj) {
      if (obj === void 0) obj = {};
      for (let i = 0; i < headers.length; i += 2) {
        const key = headerNameToString(headers[i]);
        let val = obj[key];
        if (val) {
          if (typeof val === "string") {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1].toString("utf8"));
        } else {
          const headersValue = headers[i + 1];
          if (typeof headersValue === "string") {
            obj[key] = headersValue;
          } else {
            obj[key] = Array.isArray(headersValue) ? headersValue.map((x2) => x2.toString("utf8")) : headersValue.toString("utf8");
          }
        }
      }
      if ("content-length" in obj && "content-disposition" in obj) {
        obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      const headersLength = headers.length;
      const ret = new Array(headersLength);
      let hasContentLength = false;
      let contentDispositionIdx = -1;
      let key;
      let val;
      let kLen = 0;
      for (let n2 = 0; n2 < headersLength; n2 += 2) {
        key = headers[n2];
        val = headers[n2 + 1];
        typeof key !== "string" && (key = key.toString());
        typeof val !== "string" && (val = val.toString("utf8"));
        kLen = key.length;
        if (kLen === 14 && key[7] === "-" && (key === "content-length" || key.toLowerCase() === "content-length")) {
          hasContentLength = true;
        } else if (kLen === 19 && key[7] === "-" && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
          contentDispositionIdx = n2 + 1;
        }
        ret[n2] = key;
        ret[n2 + 1] = val;
      }
      if (hasContentLength && contentDispositionIdx !== -1) {
        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
      }
      return ret;
    }
    function encodeRawHeaders(headers) {
      if (!Array.isArray(headers)) {
        throw new TypeError("expected headers to be an array");
      }
      return headers.map((x2) => Buffer.from(x2));
    }
    function isBuffer(buffer4) {
      return buffer4 instanceof Uint8Array || Buffer.isBuffer(buffer4);
    }
    function assertRequestHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      if (typeof handler.onRequestStart === "function") {
        return;
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    function ReadableStreamFrom(iterable) {
      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          pull(controller) {
            async function pull() {
              const { done: done11, value } = await iterator.next();
              if (done11) {
                queueMicrotask(() => {
                  controller.close();
                  controller.byobRequest?.respond(0);
                });
              } else {
                const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
                if (buf.byteLength) {
                  controller.enqueue(new Uint8Array(buf));
                } else {
                  return await pull();
                }
              }
            }
            return pull();
          },
          async cancel() {
            await iterator.return();
          },
          type: "bytes"
        }
      );
    }
    function isFormDataLike(object) {
      return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
    }
    function addAbortListener(signal, listener) {
      if ("addEventListener" in signal) {
        signal.addEventListener("abort", listener, { once: true });
        return () => signal.removeEventListener("abort", listener);
      }
      signal.once("abort", listener);
      return () => signal.removeListener("abort", listener);
    }
    var toUSVString = (() => {
      if (typeof String.prototype.toWellFormed === "function") {
        return (value) => `${value}`.toWellFormed();
      } else {
        return nodeUtil.toUSVString;
      }
    })();
    var isUSVString = (() => {
      if (typeof String.prototype.isWellFormed === "function") {
        return (value) => `${value}`.isWellFormed();
      } else {
        return (value) => toUSVString(value) === `${value}`;
      }
    })();
    function isTokenCharCode(c) {
      switch (c) {
        case 34:
        case 40:
        case 41:
        case 44:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 123:
        case 125:
          return false;
        default:
          return c >= 33 && c <= 126;
      }
    }
    function isValidHTTPToken(characters2) {
      if (characters2.length === 0) {
        return false;
      }
      for (let i = 0; i < characters2.length; ++i) {
        if (!isTokenCharCode(characters2.charCodeAt(i))) {
          return false;
        }
      }
      return true;
    }
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function isValidHeaderValue(characters2) {
      return !headerCharRegex.test(characters2);
    }
    var rangeHeaderRegex = /^bytes (\d+)-(\d+)\/(\d+)?$/;
    function parseRangeHeader(range4) {
      if (range4 == null || range4 === "") return { start: 0, end: null, size: null };
      const m2 = range4 ? range4.match(rangeHeaderRegex) : null;
      return m2 ? {
        start: parseInt(m2[1]),
        end: m2[2] ? parseInt(m2[2]) : null,
        size: m2[3] ? parseInt(m2[3]) : null
      } : null;
    }
    function addListener(obj, name, listener) {
      const listeners = obj[kListeners] ??= [];
      listeners.push([name, listener]);
      obj.on(name, listener);
      return obj;
    }
    function removeAllListeners(obj) {
      if (obj[kListeners] != null) {
        for (const [name, listener] of obj[kListeners]) {
          obj.removeListener(name, listener);
        }
        obj[kListeners] = null;
      }
      return obj;
    }
    function errorRequest(client, request2, err) {
      try {
        request2.onError(err);
        assert3(request2.aborted);
      } catch (err2) {
        client.emit("error", err2);
      }
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    var normalizedMethodRecordsBase = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT"
    };
    var normalizedMethodRecords = {
      ...normalizedMethodRecordsBase,
      patch: "patch",
      PATCH: "PATCH"
    };
    Object.setPrototypeOf(normalizedMethodRecordsBase, null);
    Object.setPrototypeOf(normalizedMethodRecords, null);
    module.exports = {
      kEnumerableProperty,
      isDisturbed,
      toUSVString,
      isUSVString,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream: isStream2,
      isIterable: isIterable2,
      isAsyncIterable,
      isDestroyed,
      headerNameToString,
      bufferToLowerCasedHeaderName,
      addListener,
      removeAllListeners,
      errorRequest,
      parseRawHeaders,
      encodeRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer,
      assertRequestHandler,
      getSocketInfo,
      isFormDataLike,
      serializePathWithQuery,
      addAbortListener,
      isValidHTTPToken,
      isValidHeaderValue,
      isTokenCharCode,
      parseRangeHeader,
      normalizedMethodRecordsBase,
      normalizedMethodRecords,
      isValidPort,
      isHttpOrHttpsPrefixed,
      nodeMajor,
      nodeMinor,
      safeHTTPMethods: Object.freeze(["GET", "HEAD", "OPTIONS", "TRACE"]),
      wrapRequestBody
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/core/diagnostics.js
var require_diagnostics = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/core/diagnostics.js"(exports, module) {
    var diagnosticsChannel = __require("diagnostics_channel");
    var util = __require("util");
    var undiciDebugLog = util.debuglog("undici");
    var fetchDebuglog = util.debuglog("fetch");
    var websocketDebuglog = util.debuglog("websocket");
    var channels = {
      // Client
      beforeConnect: diagnosticsChannel.channel("undici:client:beforeConnect"),
      connected: diagnosticsChannel.channel("undici:client:connected"),
      connectError: diagnosticsChannel.channel("undici:client:connectError"),
      sendHeaders: diagnosticsChannel.channel("undici:client:sendHeaders"),
      // Request
      create: diagnosticsChannel.channel("undici:request:create"),
      bodySent: diagnosticsChannel.channel("undici:request:bodySent"),
      headers: diagnosticsChannel.channel("undici:request:headers"),
      trailers: diagnosticsChannel.channel("undici:request:trailers"),
      error: diagnosticsChannel.channel("undici:request:error"),
      // WebSocket
      open: diagnosticsChannel.channel("undici:websocket:open"),
      close: diagnosticsChannel.channel("undici:websocket:close"),
      socketError: diagnosticsChannel.channel("undici:websocket:socket_error"),
      ping: diagnosticsChannel.channel("undici:websocket:ping"),
      pong: diagnosticsChannel.channel("undici:websocket:pong")
    };
    var isTrackingClientEvents = false;
    function trackClientEvents(debugLog = undiciDebugLog) {
      if (isTrackingClientEvents) {
        return;
      }
      isTrackingClientEvents = true;
      diagnosticsChannel.subscribe(
        "undici:client:beforeConnect",
        (evt) => {
          const {
            connectParams: { version: version3, protocol, port, host }
          } = evt;
          debugLog(
            "connecting to %s%s using %s%s",
            host,
            port ? `:${port}` : "",
            protocol,
            version3
          );
        }
      );
      diagnosticsChannel.subscribe(
        "undici:client:connected",
        (evt) => {
          const {
            connectParams: { version: version3, protocol, port, host }
          } = evt;
          debugLog(
            "connected to %s%s using %s%s",
            host,
            port ? `:${port}` : "",
            protocol,
            version3
          );
        }
      );
      diagnosticsChannel.subscribe(
        "undici:client:connectError",
        (evt) => {
          const {
            connectParams: { version: version3, protocol, port, host },
            error: error4
          } = evt;
          debugLog(
            "connection to %s%s using %s%s errored - %s",
            host,
            port ? `:${port}` : "",
            protocol,
            version3,
            error4.message
          );
        }
      );
      diagnosticsChannel.subscribe(
        "undici:client:sendHeaders",
        (evt) => {
          const {
            request: { method, path: path3, origin }
          } = evt;
          debugLog("sending request to %s %s/%s", method, origin, path3);
        }
      );
    }
    var isTrackingRequestEvents = false;
    function trackRequestEvents(debugLog = undiciDebugLog) {
      if (isTrackingRequestEvents) {
        return;
      }
      isTrackingRequestEvents = true;
      diagnosticsChannel.subscribe(
        "undici:request:headers",
        (evt) => {
          const {
            request: { method, path: path3, origin },
            response: { statusCode }
          } = evt;
          debugLog(
            "received response to %s %s/%s - HTTP %d",
            method,
            origin,
            path3,
            statusCode
          );
        }
      );
      diagnosticsChannel.subscribe(
        "undici:request:trailers",
        (evt) => {
          const {
            request: { method, path: path3, origin }
          } = evt;
          debugLog("trailers received from %s %s/%s", method, origin, path3);
        }
      );
      diagnosticsChannel.subscribe(
        "undici:request:error",
        (evt) => {
          const {
            request: { method, path: path3, origin },
            error: error4
          } = evt;
          debugLog(
            "request to %s %s/%s errored - %s",
            method,
            origin,
            path3,
            error4.message
          );
        }
      );
    }
    var isTrackingWebSocketEvents = false;
    function trackWebSocketEvents(debugLog = websocketDebuglog) {
      if (isTrackingWebSocketEvents) {
        return;
      }
      isTrackingWebSocketEvents = true;
      diagnosticsChannel.subscribe(
        "undici:websocket:open",
        (evt) => {
          const {
            address: { address, port }
          } = evt;
          debugLog("connection opened %s%s", address, port ? `:${port}` : "");
        }
      );
      diagnosticsChannel.subscribe(
        "undici:websocket:close",
        (evt) => {
          const { websocket, code, reason } = evt;
          debugLog(
            "closed connection to %s - %s %s",
            websocket.url,
            code,
            reason
          );
        }
      );
      diagnosticsChannel.subscribe(
        "undici:websocket:socket_error",
        (err) => {
          debugLog("connection errored - %s", err.message);
        }
      );
      diagnosticsChannel.subscribe(
        "undici:websocket:ping",
        (evt) => {
          debugLog("ping received");
        }
      );
      diagnosticsChannel.subscribe(
        "undici:websocket:pong",
        (evt) => {
          debugLog("pong received");
        }
      );
    }
    if (undiciDebugLog.enabled || fetchDebuglog.enabled) {
      trackClientEvents(fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog);
      trackRequestEvents(fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog);
    }
    if (websocketDebuglog.enabled) {
      trackClientEvents(undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog);
      trackWebSocketEvents(websocketDebuglog);
    }
    module.exports = {
      channels
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/core/request.js
var require_request = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/core/request.js"(exports, module) {
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors();
    var assert3 = __require("assert");
    var {
      isValidHTTPToken,
      isValidHeaderValue,
      isStream: isStream2,
      destroy,
      isBuffer,
      isFormDataLike,
      isIterable: isIterable2,
      isBlobLike,
      serializePathWithQuery,
      assertRequestHandler,
      getServerName,
      normalizedMethodRecords
    } = require_util();
    var { channels } = require_diagnostics();
    var { headerNameLowerCasedRecord } = require_constants();
    var invalidPathRegex = /[^\u0021-\u00ff]/;
    var kHandler = Symbol("handler");
    var Request = class {
      constructor(origin, {
        path: path3,
        method,
        body,
        headers,
        query,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout,
        reset,
        expectContinue,
        servername,
        throwOnError
      }, handler) {
        if (typeof path3 !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path3[0] !== "/" && !(path3.startsWith("http://") || path3.startsWith("https://")) && method !== "CONNECT") {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        } else if (invalidPathRegex.test(path3)) {
          throw new InvalidArgumentError("invalid request path");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        } else if (normalizedMethodRecords[method] === void 0 && !isValidHTTPToken(method)) {
          throw new InvalidArgumentError("invalid request method");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }
        if (reset != null && typeof reset !== "boolean") {
          throw new InvalidArgumentError("invalid reset");
        }
        if (expectContinue != null && typeof expectContinue !== "boolean") {
          throw new InvalidArgumentError("invalid expectContinue");
        }
        if (throwOnError != null) {
          throw new InvalidArgumentError("invalid throwOnError");
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.method = method;
        this.abort = null;
        if (body == null) {
          this.body = null;
        } else if (isStream2(body)) {
          this.body = body;
          const rState = this.body._readableState;
          if (!rState || !rState.autoDestroy) {
            this.endHandler = function autoDestroy() {
              destroy(this);
            };
            this.body.on("end", this.endHandler);
          }
          this.errorHandler = (err) => {
            if (this.abort) {
              this.abort(err);
            } else {
              this.error = err;
            }
          };
          this.body.on("error", this.errorHandler);
        } else if (isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (isFormDataLike(body) || isIterable2(body) || isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = query ? serializePathWithQuery(path3, query) : path3;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.blocking = blocking ?? this.method !== "HEAD";
        this.reset = reset == null ? null : reset;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = [];
        this.expectContinue = expectContinue != null ? expectContinue : false;
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i], headers[i + 1]);
          }
        } else if (headers && typeof headers === "object") {
          if (headers[Symbol.iterator]) {
            for (const header of headers) {
              if (!Array.isArray(header) || header.length !== 2) {
                throw new InvalidArgumentError("headers must be in key-value pair format");
              }
              processHeader(this, header[0], header[1]);
            }
          } else {
            const keys5 = Object.keys(headers);
            for (let i = 0; i < keys5.length; ++i) {
              processHeader(this, keys5[i], headers[keys5[i]]);
            }
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        assertRequestHandler(handler, method, upgrade);
        this.servername = servername || getServerName(this.host) || null;
        this[kHandler] = handler;
        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }
      onBodySent(chunk5) {
        if (this[kHandler].onBodySent) {
          try {
            return this[kHandler].onBodySent(chunk5);
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }
        if (this[kHandler].onRequestSent) {
          try {
            return this[kHandler].onRequestSent();
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onConnect(abort) {
        assert3(!this.aborted);
        assert3(!this.completed);
        if (this.error) {
          abort(this.error);
        } else {
          this.abort = abort;
          return this[kHandler].onConnect(abort);
        }
      }
      onResponseStarted() {
        return this[kHandler].onResponseStarted?.();
      }
      onHeaders(statusCode, headers, resume2, statusText) {
        assert3(!this.aborted);
        assert3(!this.completed);
        if (channels.headers.hasSubscribers) {
          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        try {
          return this[kHandler].onHeaders(statusCode, headers, resume2, statusText);
        } catch (err) {
          this.abort(err);
        }
      }
      onData(chunk5) {
        assert3(!this.aborted);
        assert3(!this.completed);
        try {
          return this[kHandler].onData(chunk5);
        } catch (err) {
          this.abort(err);
          return false;
        }
      }
      onUpgrade(statusCode, headers, socket) {
        assert3(!this.aborted);
        assert3(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        this.onFinally();
        assert3(!this.aborted);
        assert3(!this.completed);
        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }
        try {
          return this[kHandler].onComplete(trailers);
        } catch (err) {
          this.onError(err);
        }
      }
      onError(error4) {
        this.onFinally();
        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error: error4 });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error4);
      }
      onFinally() {
        if (this.errorHandler) {
          this.body.off("error", this.errorHandler);
          this.errorHandler = null;
        }
        if (this.endHandler) {
          this.body.off("end", this.endHandler);
          this.endHandler = null;
        }
      }
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
    };
    function processHeader(request2, key, val) {
      if (val && (typeof val === "object" && !Array.isArray(val))) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      let headerName = headerNameLowerCasedRecord[key];
      if (headerName === void 0) {
        headerName = key.toLowerCase();
        if (headerNameLowerCasedRecord[headerName] === void 0 && !isValidHTTPToken(headerName)) {
          throw new InvalidArgumentError("invalid header key");
        }
      }
      if (Array.isArray(val)) {
        const arr = [];
        for (let i = 0; i < val.length; i++) {
          if (typeof val[i] === "string") {
            if (!isValidHeaderValue(val[i])) {
              throw new InvalidArgumentError(`invalid ${key} header`);
            }
            arr.push(val[i]);
          } else if (val[i] === null) {
            arr.push("");
          } else if (typeof val[i] === "object") {
            throw new InvalidArgumentError(`invalid ${key} header`);
          } else {
            arr.push(`${val[i]}`);
          }
        }
        val = arr;
      } else if (typeof val === "string") {
        if (!isValidHeaderValue(val)) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
      } else if (val === null) {
        val = "";
      } else {
        val = `${val}`;
      }
      if (request2.host === null && headerName === "host") {
        if (typeof val !== "string") {
          throw new InvalidArgumentError("invalid host header");
        }
        request2.host = val;
      } else if (request2.contentLength === null && headerName === "content-length") {
        request2.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request2.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (request2.contentType === null && headerName === "content-type") {
        request2.contentType = val;
        request2.headers.push(key, val);
      } else if (headerName === "transfer-encoding" || headerName === "keep-alive" || headerName === "upgrade") {
        throw new InvalidArgumentError(`invalid ${headerName} header`);
      } else if (headerName === "connection") {
        const value = typeof val === "string" ? val.toLowerCase() : null;
        if (value !== "close" && value !== "keep-alive") {
          throw new InvalidArgumentError("invalid connection header");
        }
        if (value === "close") {
          request2.reset = true;
        }
      } else if (headerName === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else {
        request2.headers.push(key, val);
      }
    }
    module.exports = Request;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/handler/wrap-handler.js
var require_wrap_handler = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/handler/wrap-handler.js"(exports, module) {
    var { InvalidArgumentError } = require_errors();
    module.exports = class WrapHandler {
      #handler;
      constructor(handler) {
        this.#handler = handler;
      }
      static wrap(handler) {
        return handler.onRequestStart ? handler : new WrapHandler(handler);
      }
      // Unwrap Interface
      onConnect(abort, context8) {
        return this.#handler.onConnect?.(abort, context8);
      }
      onHeaders(statusCode, rawHeaders, resume2, statusMessage) {
        return this.#handler.onHeaders?.(statusCode, rawHeaders, resume2, statusMessage);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        return this.#handler.onUpgrade?.(statusCode, rawHeaders, socket);
      }
      onData(data) {
        return this.#handler.onData?.(data);
      }
      onComplete(trailers) {
        return this.#handler.onComplete?.(trailers);
      }
      onError(err) {
        if (!this.#handler.onError) {
          throw err;
        }
        return this.#handler.onError?.(err);
      }
      // Wrap Interface
      onRequestStart(controller, context8) {
        this.#handler.onConnect?.((reason) => controller.abort(reason), context8);
      }
      onRequestUpgrade(controller, statusCode, headers, socket) {
        const rawHeaders = [];
        for (const [key, val] of Object.entries(headers)) {
          rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map((v2) => Buffer.from(v2)) : Buffer.from(val));
        }
        this.#handler.onUpgrade?.(statusCode, rawHeaders, socket);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        const rawHeaders = [];
        for (const [key, val] of Object.entries(headers)) {
          rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map((v2) => Buffer.from(v2)) : Buffer.from(val));
        }
        if (this.#handler.onHeaders?.(statusCode, rawHeaders, () => controller.resume(), statusMessage) === false) {
          controller.pause();
        }
      }
      onResponseData(controller, data) {
        if (this.#handler.onData?.(data) === false) {
          controller.pause();
        }
      }
      onResponseEnd(controller, trailers) {
        const rawTrailers = [];
        for (const [key, val] of Object.entries(trailers)) {
          rawTrailers.push(Buffer.from(key), Array.isArray(val) ? val.map((v2) => Buffer.from(v2)) : Buffer.from(val));
        }
        this.#handler.onComplete?.(rawTrailers);
      }
      onResponseError(controller, err) {
        if (!this.#handler.onError) {
          throw new InvalidArgumentError("invalid onError method");
        }
        this.#handler.onError?.(err);
      }
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/dispatcher.js"(exports, module) {
    var EventEmitter3 = __require("events");
    var WrapHandler = require_wrap_handler();
    var wrapInterceptor = (dispatch) => (opts, handler) => dispatch(opts, WrapHandler.wrap(handler));
    var Dispatcher = class extends EventEmitter3 {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
      compose(...args2) {
        const interceptors = Array.isArray(args2[0]) ? args2[0] : args2;
        let dispatch = this.dispatch.bind(this);
        for (const interceptor of interceptors) {
          if (interceptor == null) {
            continue;
          }
          if (typeof interceptor !== "function") {
            throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`);
          }
          dispatch = interceptor(dispatch);
          dispatch = wrapInterceptor(dispatch);
          if (dispatch == null || typeof dispatch !== "function" || dispatch.length !== 2) {
            throw new TypeError("invalid interceptor");
          }
        }
        return new Proxy(this, {
          get: (target, key) => key === "dispatch" ? dispatch : target[key]
        });
      }
    };
    module.exports = Dispatcher;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/handler/unwrap-handler.js
var require_unwrap_handler = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/handler/unwrap-handler.js"(exports, module) {
    var { parseHeaders } = require_util();
    var { InvalidArgumentError } = require_errors();
    var kResume = Symbol("resume");
    var UnwrapController = class {
      #paused = false;
      #reason = null;
      #aborted = false;
      #abort;
      [kResume] = null;
      constructor(abort) {
        this.#abort = abort;
      }
      pause() {
        this.#paused = true;
      }
      resume() {
        if (this.#paused) {
          this.#paused = false;
          this[kResume]?.();
        }
      }
      abort(reason) {
        if (!this.#aborted) {
          this.#aborted = true;
          this.#reason = reason;
          this.#abort(reason);
        }
      }
      get aborted() {
        return this.#aborted;
      }
      get reason() {
        return this.#reason;
      }
      get paused() {
        return this.#paused;
      }
    };
    module.exports = class UnwrapHandler {
      #handler;
      #controller;
      constructor(handler) {
        this.#handler = handler;
      }
      static unwrap(handler) {
        return !handler.onRequestStart ? handler : new UnwrapHandler(handler);
      }
      onConnect(abort, context8) {
        this.#controller = new UnwrapController(abort);
        this.#handler.onRequestStart?.(this.#controller, context8);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        this.#handler.onRequestUpgrade?.(this.#controller, statusCode, parseHeaders(rawHeaders), socket);
      }
      onHeaders(statusCode, rawHeaders, resume2, statusMessage) {
        this.#controller[kResume] = resume2;
        this.#handler.onResponseStart?.(this.#controller, statusCode, parseHeaders(rawHeaders), statusMessage);
        return !this.#controller.paused;
      }
      onData(data) {
        this.#handler.onResponseData?.(this.#controller, data);
        return !this.#controller.paused;
      }
      onComplete(rawTrailers) {
        this.#handler.onResponseEnd?.(this.#controller, parseHeaders(rawTrailers));
      }
      onError(err) {
        if (!this.#handler.onResponseError) {
          throw new InvalidArgumentError("invalid onError method");
        }
        this.#handler.onResponseError?.(this.#controller, err);
      }
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/dispatcher-base.js"(exports, module) {
    var Dispatcher = require_dispatcher();
    var UnwrapHandler = require_unwrap_handler();
    var {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors();
    var { kDestroy, kClose, kClosed, kDestroyed, kDispatch } = require_symbols();
    var kOnDestroyed = Symbol("onDestroyed");
    var kOnClosed = Symbol("onClosed");
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = null;
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve9, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve9(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve9, reject) => {
            this.destroy(err, (err2, data) => {
              return err2 ? (
                /* istanbul ignore next: should never error */
                reject(err2)
              ) : resolve9(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed] = this[kOnDestroyed] || [];
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        handler = UnwrapHandler.unwrap(handler);
        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }
          if (this[kDestroyed] || this[kOnDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw err;
          }
          handler.onError(err);
          return false;
        }
      }
    };
    module.exports = DispatcherBase;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/util/timers.js
var require_timers = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/util/timers.js"(exports, module) {
    var fastNow = 0;
    var RESOLUTION_MS = 1e3;
    var TICK_MS = (RESOLUTION_MS >> 1) - 1;
    var fastNowTimeout;
    var kFastTimer = Symbol("kFastTimer");
    var fastTimers = [];
    var NOT_IN_LIST = -2;
    var TO_BE_CLEARED = -1;
    var PENDING = 0;
    var ACTIVE = 1;
    function onTick() {
      fastNow += TICK_MS;
      let idx = 0;
      let len = fastTimers.length;
      while (idx < len) {
        const timer = fastTimers[idx];
        if (timer._state === PENDING) {
          timer._idleStart = fastNow - TICK_MS;
          timer._state = ACTIVE;
        } else if (timer._state === ACTIVE && fastNow >= timer._idleStart + timer._idleTimeout) {
          timer._state = TO_BE_CLEARED;
          timer._idleStart = -1;
          timer._onTimeout(timer._timerArg);
        }
        if (timer._state === TO_BE_CLEARED) {
          timer._state = NOT_IN_LIST;
          if (--len !== 0) {
            fastTimers[idx] = fastTimers[len];
          }
        } else {
          ++idx;
        }
      }
      fastTimers.length = len;
      if (fastTimers.length !== 0) {
        refreshTimeout();
      }
    }
    function refreshTimeout() {
      if (fastNowTimeout) {
        fastNowTimeout.refresh();
      } else {
        clearTimeout(fastNowTimeout);
        fastNowTimeout = setTimeout(onTick, TICK_MS);
        if (fastNowTimeout.unref) {
          fastNowTimeout.unref();
        }
      }
    }
    var FastTimer = class {
      [kFastTimer] = true;
      /**
       * The state of the timer, which can be one of the following:
       * - NOT_IN_LIST (-2)
       * - TO_BE_CLEARED (-1)
       * - PENDING (0)
       * - ACTIVE (1)
       *
       * @type {-2|-1|0|1}
       * @private
       */
      _state = NOT_IN_LIST;
      /**
       * The number of milliseconds to wait before calling the callback.
       *
       * @type {number}
       * @private
       */
      _idleTimeout = -1;
      /**
       * The time in milliseconds when the timer was started. This value is used to
       * calculate when the timer should expire.
       *
       * @type {number}
       * @default -1
       * @private
       */
      _idleStart = -1;
      /**
       * The function to be executed when the timer expires.
       * @type {Function}
       * @private
       */
      _onTimeout;
      /**
       * The argument to be passed to the callback when the timer expires.
       *
       * @type {*}
       * @private
       */
      _timerArg;
      /**
       * @constructor
       * @param {Function} callback A function to be executed after the timer
       * expires.
       * @param {number} delay The time, in milliseconds that the timer should wait
       * before the specified function or code is executed.
       * @param {*} arg
       */
      constructor(callback, delay4, arg) {
        this._onTimeout = callback;
        this._idleTimeout = delay4;
        this._timerArg = arg;
        this.refresh();
      }
      /**
       * Sets the timer's start time to the current time, and reschedules the timer
       * to call its callback at the previously specified duration adjusted to the
       * current time.
       * Using this on a timer that has already called its callback will reactivate
       * the timer.
       *
       * @returns {void}
       */
      refresh() {
        if (this._state === NOT_IN_LIST) {
          fastTimers.push(this);
        }
        if (!fastNowTimeout || fastTimers.length === 1) {
          refreshTimeout();
        }
        this._state = PENDING;
      }
      /**
       * The `clear` method cancels the timer, preventing it from executing.
       *
       * @returns {void}
       * @private
       */
      clear() {
        this._state = TO_BE_CLEARED;
        this._idleStart = -1;
      }
    };
    module.exports = {
      /**
       * The setTimeout() method sets a timer which executes a function once the
       * timer expires.
       * @param {Function} callback A function to be executed after the timer
       * expires.
       * @param {number} delay The time, in milliseconds that the timer should
       * wait before the specified function or code is executed.
       * @param {*} [arg] An optional argument to be passed to the callback function
       * when the timer expires.
       * @returns {NodeJS.Timeout|FastTimer}
       */
      setTimeout(callback, delay4, arg) {
        return delay4 <= RESOLUTION_MS ? setTimeout(callback, delay4, arg) : new FastTimer(callback, delay4, arg);
      },
      /**
       * The clearTimeout method cancels an instantiated Timer previously created
       * by calling setTimeout.
       *
       * @param {NodeJS.Timeout|FastTimer} timeout
       */
      clearTimeout(timeout5) {
        if (timeout5[kFastTimer]) {
          timeout5.clear();
        } else {
          clearTimeout(timeout5);
        }
      },
      /**
       * The setFastTimeout() method sets a fastTimer which executes a function once
       * the timer expires.
       * @param {Function} callback A function to be executed after the timer
       * expires.
       * @param {number} delay The time, in milliseconds that the timer should
       * wait before the specified function or code is executed.
       * @param {*} [arg] An optional argument to be passed to the callback function
       * when the timer expires.
       * @returns {FastTimer}
       */
      setFastTimeout(callback, delay4, arg) {
        return new FastTimer(callback, delay4, arg);
      },
      /**
       * The clearTimeout method cancels an instantiated FastTimer previously
       * created by calling setFastTimeout.
       *
       * @param {FastTimer} timeout
       */
      clearFastTimeout(timeout5) {
        timeout5.clear();
      },
      /**
       * The now method returns the value of the internal fast timer clock.
       *
       * @returns {number}
       */
      now() {
        return fastNow;
      },
      /**
       * Trigger the onTick function to process the fastTimers array.
       * Exported for testing purposes only.
       * Marking as deprecated to discourage any use outside of testing.
       * @deprecated
       * @param {number} [delay=0] The delay in milliseconds to add to the now value.
       */
      tick(delay4 = 0) {
        fastNow += delay4 - RESOLUTION_MS + 1;
        onTick();
        onTick();
      },
      /**
       * Reset FastTimers.
       * Exported for testing purposes only.
       * Marking as deprecated to discourage any use outside of testing.
       * @deprecated
       */
      reset() {
        fastNow = 0;
        fastTimers.length = 0;
        clearTimeout(fastNowTimeout);
        fastNowTimeout = null;
      },
      /**
       * Exporting for testing purposes only.
       * Marking as deprecated to discourage any use outside of testing.
       * @deprecated
       */
      kFastTimer
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/core/connect.js"(exports, module) {
    var net = __require("net");
    var assert3 = __require("assert");
    var util = require_util();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
    var timers2 = require_timers();
    function noop2() {
    }
    var tls;
    var SessionCache;
    if (global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) {
      SessionCache = class WeakSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
          this._sessionRegistry = new global.FinalizationRegistry((key) => {
            if (this._sessionCache.size < this._maxCachedSessions) {
              return;
            }
            const ref = this._sessionCache.get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this._sessionCache.delete(key);
            }
          });
        }
        get(sessionKey) {
          const ref = this._sessionCache.get(sessionKey);
          return ref ? ref.deref() : null;
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          this._sessionCache.set(sessionKey, new WeakRef(session));
          this._sessionRegistry.register(session, sessionKey);
        }
      };
    } else {
      SessionCache = class SimpleSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(sessionKey) {
          return this._sessionCache.get(sessionKey);
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          if (this._sessionCache.size >= this._maxCachedSessions) {
            const { value: oldestKey } = this._sessionCache.keys().next();
            this._sessionCache.delete(oldestKey);
          }
          this._sessionCache.set(sessionKey, session);
        }
      };
    }
    function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout: timeout5, session: customSession, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      }
      const options = { path: socketPath, ...opts };
      const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
      timeout5 = timeout5 == null ? 1e4 : timeout5;
      allowH2 = allowH2 != null ? allowH2 : false;
      return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
        let socket;
        if (protocol === "https:") {
          if (!tls) {
            tls = __require("tls");
          }
          servername = servername || options.servername || util.getServerName(host) || null;
          const sessionKey = servername || hostname;
          assert3(sessionKey);
          const session = customSession || sessionCache.get(sessionKey) || null;
          port = port || 443;
          socket = tls.connect({
            highWaterMark: 16384,
            // TLS in node can't have bigger HWM anyway...
            ...options,
            servername,
            session,
            localAddress,
            // TODO(HTTP/2): Add support for h2c
            ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
            socket: httpSocket,
            // upgrade socket connection
            port,
            host: hostname
          });
          socket.on("session", function(session2) {
            sessionCache.set(sessionKey, session2);
          });
        } else {
          assert3(!httpSocket, "httpSocket can only be sent on TLS update");
          port = port || 80;
          socket = net.connect({
            highWaterMark: 64 * 1024,
            // Same as nodejs fs streams.
            ...options,
            localAddress,
            port,
            host: hostname
          });
        }
        if (options.keepAlive == null || options.keepAlive) {
          const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
          socket.setKeepAlive(true, keepAliveInitialDelay);
        }
        const clearConnectTimeout = setupConnectTimeout(new WeakRef(socket), { timeout: timeout5, hostname, port });
        socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          queueMicrotask(clearConnectTimeout);
          if (callback) {
            const cb = callback;
            callback = null;
            cb(null, this);
          }
        }).on("error", function(err) {
          queueMicrotask(clearConnectTimeout);
          if (callback) {
            const cb = callback;
            callback = null;
            cb(err);
          }
        });
        return socket;
      };
    }
    var setupConnectTimeout = process.platform === "win32" ? (socketWeakRef, opts) => {
      if (!opts.timeout) {
        return noop2;
      }
      let s1 = null;
      let s2 = null;
      const fastTimer = timers2.setFastTimeout(() => {
        s1 = setImmediate(() => {
          s2 = setImmediate(() => onConnectTimeout(socketWeakRef.deref(), opts));
        });
      }, opts.timeout);
      return () => {
        timers2.clearFastTimeout(fastTimer);
        clearImmediate(s1);
        clearImmediate(s2);
      };
    } : (socketWeakRef, opts) => {
      if (!opts.timeout) {
        return noop2;
      }
      let s1 = null;
      const fastTimer = timers2.setFastTimeout(() => {
        s1 = setImmediate(() => {
          onConnectTimeout(socketWeakRef.deref(), opts);
        });
      }, opts.timeout);
      return () => {
        timers2.clearFastTimeout(fastTimer);
        clearImmediate(s1);
      };
    };
    function onConnectTimeout(socket, opts) {
      if (socket == null) {
        return;
      }
      let message = "Connect Timeout Error";
      if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {
        message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(", ")},`;
      } else {
        message += ` (attempted address: ${opts.hostname}:${opts.port},`;
      }
      message += ` timeout: ${opts.timeout}ms)`;
      util.destroy(socket, new ConnectTimeoutError(message));
    }
    module.exports = buildConnector;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/llhttp/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/llhttp/utils.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.enumToMap = void 0;
    function enumToMap(obj, filter10 = [], exceptions = []) {
      var _a2, _b;
      const emptyFilter = ((_a2 = filter10 === null || filter10 === void 0 ? void 0 : filter10.length) !== null && _a2 !== void 0 ? _a2 : 0) === 0;
      const emptyExceptions = ((_b = exceptions === null || exceptions === void 0 ? void 0 : exceptions.length) !== null && _b !== void 0 ? _b : 0) === 0;
      return Object.fromEntries(Object.entries(obj).filter(([, value]) => {
        return typeof value === "number" && (emptyFilter || filter10.includes(value)) && (emptyExceptions || !exceptions.includes(value));
      }));
    }
    exports.enumToMap = enumToMap;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/llhttp/constants.js
var require_constants2 = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/llhttp/constants.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SPECIAL_HEADERS = exports.MINOR = exports.MAJOR = exports.HTAB_SP_VCHAR_OBS_TEXT = exports.QUOTED_STRING = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.HEX = exports.URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.STATUSES_HTTP = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.HEADER_STATE = exports.FINISH = exports.STATUSES = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
    var utils_1 = require_utils();
    exports.ERROR = {
      OK: 0,
      INTERNAL: 1,
      STRICT: 2,
      CR_EXPECTED: 25,
      LF_EXPECTED: 3,
      UNEXPECTED_CONTENT_LENGTH: 4,
      UNEXPECTED_SPACE: 30,
      CLOSED_CONNECTION: 5,
      INVALID_METHOD: 6,
      INVALID_URL: 7,
      INVALID_CONSTANT: 8,
      INVALID_VERSION: 9,
      INVALID_HEADER_TOKEN: 10,
      INVALID_CONTENT_LENGTH: 11,
      INVALID_CHUNK_SIZE: 12,
      INVALID_STATUS: 13,
      INVALID_EOF_STATE: 14,
      INVALID_TRANSFER_ENCODING: 15,
      CB_MESSAGE_BEGIN: 16,
      CB_HEADERS_COMPLETE: 17,
      CB_MESSAGE_COMPLETE: 18,
      CB_CHUNK_HEADER: 19,
      CB_CHUNK_COMPLETE: 20,
      PAUSED: 21,
      PAUSED_UPGRADE: 22,
      PAUSED_H2_UPGRADE: 23,
      USER: 24,
      CB_URL_COMPLETE: 26,
      CB_STATUS_COMPLETE: 27,
      CB_METHOD_COMPLETE: 32,
      CB_VERSION_COMPLETE: 33,
      CB_HEADER_FIELD_COMPLETE: 28,
      CB_HEADER_VALUE_COMPLETE: 29,
      CB_CHUNK_EXTENSION_NAME_COMPLETE: 34,
      CB_CHUNK_EXTENSION_VALUE_COMPLETE: 35,
      CB_RESET: 31
    };
    exports.TYPE = {
      BOTH: 0,
      // default
      REQUEST: 1,
      RESPONSE: 2
    };
    exports.FLAGS = {
      CONNECTION_KEEP_ALIVE: 1 << 0,
      CONNECTION_CLOSE: 1 << 1,
      CONNECTION_UPGRADE: 1 << 2,
      CHUNKED: 1 << 3,
      UPGRADE: 1 << 4,
      CONTENT_LENGTH: 1 << 5,
      SKIPBODY: 1 << 6,
      TRAILING: 1 << 7,
      // 1 << 8 is unused
      TRANSFER_ENCODING: 1 << 9
    };
    exports.LENIENT_FLAGS = {
      HEADERS: 1 << 0,
      CHUNKED_LENGTH: 1 << 1,
      KEEP_ALIVE: 1 << 2,
      TRANSFER_ENCODING: 1 << 3,
      VERSION: 1 << 4,
      DATA_AFTER_CLOSE: 1 << 5,
      OPTIONAL_LF_AFTER_CR: 1 << 6,
      OPTIONAL_CRLF_AFTER_CHUNK: 1 << 7,
      OPTIONAL_CR_BEFORE_LF: 1 << 8,
      SPACES_AFTER_CHUNK_SIZE: 1 << 9
    };
    exports.METHODS = {
      "DELETE": 0,
      "GET": 1,
      "HEAD": 2,
      "POST": 3,
      "PUT": 4,
      /* pathological */
      "CONNECT": 5,
      "OPTIONS": 6,
      "TRACE": 7,
      /* WebDAV */
      "COPY": 8,
      "LOCK": 9,
      "MKCOL": 10,
      "MOVE": 11,
      "PROPFIND": 12,
      "PROPPATCH": 13,
      "SEARCH": 14,
      "UNLOCK": 15,
      "BIND": 16,
      "REBIND": 17,
      "UNBIND": 18,
      "ACL": 19,
      /* subversion */
      "REPORT": 20,
      "MKACTIVITY": 21,
      "CHECKOUT": 22,
      "MERGE": 23,
      /* upnp */
      "M-SEARCH": 24,
      "NOTIFY": 25,
      "SUBSCRIBE": 26,
      "UNSUBSCRIBE": 27,
      /* RFC-5789 */
      "PATCH": 28,
      "PURGE": 29,
      /* CalDAV */
      "MKCALENDAR": 30,
      /* RFC-2068, section 19.6.1.2 */
      "LINK": 31,
      "UNLINK": 32,
      /* icecast */
      "SOURCE": 33,
      /* RFC-7540, section 11.6 */
      "PRI": 34,
      /* RFC-2326 RTSP */
      "DESCRIBE": 35,
      "ANNOUNCE": 36,
      "SETUP": 37,
      "PLAY": 38,
      "PAUSE": 39,
      "TEARDOWN": 40,
      "GET_PARAMETER": 41,
      "SET_PARAMETER": 42,
      "REDIRECT": 43,
      "RECORD": 44,
      /* RAOP */
      "FLUSH": 45,
      /* DRAFT https://www.ietf.org/archive/id/draft-ietf-httpbis-safe-method-w-body-02.html */
      "QUERY": 46
    };
    exports.STATUSES = {
      CONTINUE: 100,
      SWITCHING_PROTOCOLS: 101,
      PROCESSING: 102,
      EARLY_HINTS: 103,
      RESPONSE_IS_STALE: 110,
      // Unofficial
      REVALIDATION_FAILED: 111,
      // Unofficial
      DISCONNECTED_OPERATION: 112,
      // Unofficial
      HEURISTIC_EXPIRATION: 113,
      // Unofficial
      MISCELLANEOUS_WARNING: 199,
      // Unofficial
      OK: 200,
      CREATED: 201,
      ACCEPTED: 202,
      NON_AUTHORITATIVE_INFORMATION: 203,
      NO_CONTENT: 204,
      RESET_CONTENT: 205,
      PARTIAL_CONTENT: 206,
      MULTI_STATUS: 207,
      ALREADY_REPORTED: 208,
      TRANSFORMATION_APPLIED: 214,
      // Unofficial
      IM_USED: 226,
      MISCELLANEOUS_PERSISTENT_WARNING: 299,
      // Unofficial
      MULTIPLE_CHOICES: 300,
      MOVED_PERMANENTLY: 301,
      FOUND: 302,
      SEE_OTHER: 303,
      NOT_MODIFIED: 304,
      USE_PROXY: 305,
      SWITCH_PROXY: 306,
      // No longer used
      TEMPORARY_REDIRECT: 307,
      PERMANENT_REDIRECT: 308,
      BAD_REQUEST: 400,
      UNAUTHORIZED: 401,
      PAYMENT_REQUIRED: 402,
      FORBIDDEN: 403,
      NOT_FOUND: 404,
      METHOD_NOT_ALLOWED: 405,
      NOT_ACCEPTABLE: 406,
      PROXY_AUTHENTICATION_REQUIRED: 407,
      REQUEST_TIMEOUT: 408,
      CONFLICT: 409,
      GONE: 410,
      LENGTH_REQUIRED: 411,
      PRECONDITION_FAILED: 412,
      PAYLOAD_TOO_LARGE: 413,
      URI_TOO_LONG: 414,
      UNSUPPORTED_MEDIA_TYPE: 415,
      RANGE_NOT_SATISFIABLE: 416,
      EXPECTATION_FAILED: 417,
      IM_A_TEAPOT: 418,
      PAGE_EXPIRED: 419,
      // Unofficial
      ENHANCE_YOUR_CALM: 420,
      // Unofficial
      MISDIRECTED_REQUEST: 421,
      UNPROCESSABLE_ENTITY: 422,
      LOCKED: 423,
      FAILED_DEPENDENCY: 424,
      TOO_EARLY: 425,
      UPGRADE_REQUIRED: 426,
      PRECONDITION_REQUIRED: 428,
      TOO_MANY_REQUESTS: 429,
      REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL: 430,
      // Unofficial
      REQUEST_HEADER_FIELDS_TOO_LARGE: 431,
      LOGIN_TIMEOUT: 440,
      // Unofficial
      NO_RESPONSE: 444,
      // Unofficial
      RETRY_WITH: 449,
      // Unofficial
      BLOCKED_BY_PARENTAL_CONTROL: 450,
      // Unofficial
      UNAVAILABLE_FOR_LEGAL_REASONS: 451,
      CLIENT_CLOSED_LOAD_BALANCED_REQUEST: 460,
      // Unofficial
      INVALID_X_FORWARDED_FOR: 463,
      // Unofficial
      REQUEST_HEADER_TOO_LARGE: 494,
      // Unofficial
      SSL_CERTIFICATE_ERROR: 495,
      // Unofficial
      SSL_CERTIFICATE_REQUIRED: 496,
      // Unofficial
      HTTP_REQUEST_SENT_TO_HTTPS_PORT: 497,
      // Unofficial
      INVALID_TOKEN: 498,
      // Unofficial
      CLIENT_CLOSED_REQUEST: 499,
      // Unofficial
      INTERNAL_SERVER_ERROR: 500,
      NOT_IMPLEMENTED: 501,
      BAD_GATEWAY: 502,
      SERVICE_UNAVAILABLE: 503,
      GATEWAY_TIMEOUT: 504,
      HTTP_VERSION_NOT_SUPPORTED: 505,
      VARIANT_ALSO_NEGOTIATES: 506,
      INSUFFICIENT_STORAGE: 507,
      LOOP_DETECTED: 508,
      BANDWIDTH_LIMIT_EXCEEDED: 509,
      NOT_EXTENDED: 510,
      NETWORK_AUTHENTICATION_REQUIRED: 511,
      WEB_SERVER_UNKNOWN_ERROR: 520,
      // Unofficial
      WEB_SERVER_IS_DOWN: 521,
      // Unofficial
      CONNECTION_TIMEOUT: 522,
      // Unofficial
      ORIGIN_IS_UNREACHABLE: 523,
      // Unofficial
      TIMEOUT_OCCURED: 524,
      // Unofficial
      SSL_HANDSHAKE_FAILED: 525,
      // Unofficial
      INVALID_SSL_CERTIFICATE: 526,
      // Unofficial
      RAILGUN_ERROR: 527,
      // Unofficial
      SITE_IS_OVERLOADED: 529,
      // Unofficial
      SITE_IS_FROZEN: 530,
      // Unofficial
      IDENTITY_PROVIDER_AUTHENTICATION_ERROR: 561,
      // Unofficial
      NETWORK_READ_TIMEOUT: 598,
      // Unofficial
      NETWORK_CONNECT_TIMEOUT: 599
      // Unofficial
    };
    exports.FINISH = {
      SAFE: 0,
      SAFE_WITH_CB: 1,
      UNSAFE: 2
    };
    exports.HEADER_STATE = {
      GENERAL: 0,
      CONNECTION: 1,
      CONTENT_LENGTH: 2,
      TRANSFER_ENCODING: 3,
      UPGRADE: 4,
      CONNECTION_KEEP_ALIVE: 5,
      CONNECTION_CLOSE: 6,
      CONNECTION_UPGRADE: 7,
      TRANSFER_ENCODING_CHUNKED: 8
    };
    exports.METHODS_HTTP = [
      exports.METHODS.DELETE,
      exports.METHODS.GET,
      exports.METHODS.HEAD,
      exports.METHODS.POST,
      exports.METHODS.PUT,
      exports.METHODS.CONNECT,
      exports.METHODS.OPTIONS,
      exports.METHODS.TRACE,
      exports.METHODS.COPY,
      exports.METHODS.LOCK,
      exports.METHODS.MKCOL,
      exports.METHODS.MOVE,
      exports.METHODS.PROPFIND,
      exports.METHODS.PROPPATCH,
      exports.METHODS.SEARCH,
      exports.METHODS.UNLOCK,
      exports.METHODS.BIND,
      exports.METHODS.REBIND,
      exports.METHODS.UNBIND,
      exports.METHODS.ACL,
      exports.METHODS.REPORT,
      exports.METHODS.MKACTIVITY,
      exports.METHODS.CHECKOUT,
      exports.METHODS.MERGE,
      exports.METHODS["M-SEARCH"],
      exports.METHODS.NOTIFY,
      exports.METHODS.SUBSCRIBE,
      exports.METHODS.UNSUBSCRIBE,
      exports.METHODS.PATCH,
      exports.METHODS.PURGE,
      exports.METHODS.MKCALENDAR,
      exports.METHODS.LINK,
      exports.METHODS.UNLINK,
      exports.METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      exports.METHODS.SOURCE,
      exports.METHODS.QUERY
    ];
    exports.METHODS_ICE = [
      exports.METHODS.SOURCE
    ];
    exports.METHODS_RTSP = [
      exports.METHODS.OPTIONS,
      exports.METHODS.DESCRIBE,
      exports.METHODS.ANNOUNCE,
      exports.METHODS.SETUP,
      exports.METHODS.PLAY,
      exports.METHODS.PAUSE,
      exports.METHODS.TEARDOWN,
      exports.METHODS.GET_PARAMETER,
      exports.METHODS.SET_PARAMETER,
      exports.METHODS.REDIRECT,
      exports.METHODS.RECORD,
      exports.METHODS.FLUSH,
      // For AirPlay
      exports.METHODS.GET,
      exports.METHODS.POST
    ];
    exports.METHOD_MAP = (0, utils_1.enumToMap)(exports.METHODS);
    exports.H_METHOD_MAP = Object.fromEntries(Object.entries(exports.METHODS).filter(([k]) => k.startsWith("H")));
    exports.STATUSES_HTTP = [
      exports.STATUSES.CONTINUE,
      exports.STATUSES.SWITCHING_PROTOCOLS,
      exports.STATUSES.PROCESSING,
      exports.STATUSES.EARLY_HINTS,
      exports.STATUSES.RESPONSE_IS_STALE,
      exports.STATUSES.REVALIDATION_FAILED,
      exports.STATUSES.DISCONNECTED_OPERATION,
      exports.STATUSES.HEURISTIC_EXPIRATION,
      exports.STATUSES.MISCELLANEOUS_WARNING,
      exports.STATUSES.OK,
      exports.STATUSES.CREATED,
      exports.STATUSES.ACCEPTED,
      exports.STATUSES.NON_AUTHORITATIVE_INFORMATION,
      exports.STATUSES.NO_CONTENT,
      exports.STATUSES.RESET_CONTENT,
      exports.STATUSES.PARTIAL_CONTENT,
      exports.STATUSES.MULTI_STATUS,
      exports.STATUSES.ALREADY_REPORTED,
      exports.STATUSES.TRANSFORMATION_APPLIED,
      exports.STATUSES.IM_USED,
      exports.STATUSES.MISCELLANEOUS_PERSISTENT_WARNING,
      exports.STATUSES.MULTIPLE_CHOICES,
      exports.STATUSES.MOVED_PERMANENTLY,
      exports.STATUSES.FOUND,
      exports.STATUSES.SEE_OTHER,
      exports.STATUSES.NOT_MODIFIED,
      exports.STATUSES.USE_PROXY,
      exports.STATUSES.SWITCH_PROXY,
      exports.STATUSES.TEMPORARY_REDIRECT,
      exports.STATUSES.PERMANENT_REDIRECT,
      exports.STATUSES.BAD_REQUEST,
      exports.STATUSES.UNAUTHORIZED,
      exports.STATUSES.PAYMENT_REQUIRED,
      exports.STATUSES.FORBIDDEN,
      exports.STATUSES.NOT_FOUND,
      exports.STATUSES.METHOD_NOT_ALLOWED,
      exports.STATUSES.NOT_ACCEPTABLE,
      exports.STATUSES.PROXY_AUTHENTICATION_REQUIRED,
      exports.STATUSES.REQUEST_TIMEOUT,
      exports.STATUSES.CONFLICT,
      exports.STATUSES.GONE,
      exports.STATUSES.LENGTH_REQUIRED,
      exports.STATUSES.PRECONDITION_FAILED,
      exports.STATUSES.PAYLOAD_TOO_LARGE,
      exports.STATUSES.URI_TOO_LONG,
      exports.STATUSES.UNSUPPORTED_MEDIA_TYPE,
      exports.STATUSES.RANGE_NOT_SATISFIABLE,
      exports.STATUSES.EXPECTATION_FAILED,
      exports.STATUSES.IM_A_TEAPOT,
      exports.STATUSES.PAGE_EXPIRED,
      exports.STATUSES.ENHANCE_YOUR_CALM,
      exports.STATUSES.MISDIRECTED_REQUEST,
      exports.STATUSES.UNPROCESSABLE_ENTITY,
      exports.STATUSES.LOCKED,
      exports.STATUSES.FAILED_DEPENDENCY,
      exports.STATUSES.TOO_EARLY,
      exports.STATUSES.UPGRADE_REQUIRED,
      exports.STATUSES.PRECONDITION_REQUIRED,
      exports.STATUSES.TOO_MANY_REQUESTS,
      exports.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL,
      exports.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE,
      exports.STATUSES.LOGIN_TIMEOUT,
      exports.STATUSES.NO_RESPONSE,
      exports.STATUSES.RETRY_WITH,
      exports.STATUSES.BLOCKED_BY_PARENTAL_CONTROL,
      exports.STATUSES.UNAVAILABLE_FOR_LEGAL_REASONS,
      exports.STATUSES.CLIENT_CLOSED_LOAD_BALANCED_REQUEST,
      exports.STATUSES.INVALID_X_FORWARDED_FOR,
      exports.STATUSES.REQUEST_HEADER_TOO_LARGE,
      exports.STATUSES.SSL_CERTIFICATE_ERROR,
      exports.STATUSES.SSL_CERTIFICATE_REQUIRED,
      exports.STATUSES.HTTP_REQUEST_SENT_TO_HTTPS_PORT,
      exports.STATUSES.INVALID_TOKEN,
      exports.STATUSES.CLIENT_CLOSED_REQUEST,
      exports.STATUSES.INTERNAL_SERVER_ERROR,
      exports.STATUSES.NOT_IMPLEMENTED,
      exports.STATUSES.BAD_GATEWAY,
      exports.STATUSES.SERVICE_UNAVAILABLE,
      exports.STATUSES.GATEWAY_TIMEOUT,
      exports.STATUSES.HTTP_VERSION_NOT_SUPPORTED,
      exports.STATUSES.VARIANT_ALSO_NEGOTIATES,
      exports.STATUSES.INSUFFICIENT_STORAGE,
      exports.STATUSES.LOOP_DETECTED,
      exports.STATUSES.BANDWIDTH_LIMIT_EXCEEDED,
      exports.STATUSES.NOT_EXTENDED,
      exports.STATUSES.NETWORK_AUTHENTICATION_REQUIRED,
      exports.STATUSES.WEB_SERVER_UNKNOWN_ERROR,
      exports.STATUSES.WEB_SERVER_IS_DOWN,
      exports.STATUSES.CONNECTION_TIMEOUT,
      exports.STATUSES.ORIGIN_IS_UNREACHABLE,
      exports.STATUSES.TIMEOUT_OCCURED,
      exports.STATUSES.SSL_HANDSHAKE_FAILED,
      exports.STATUSES.INVALID_SSL_CERTIFICATE,
      exports.STATUSES.RAILGUN_ERROR,
      exports.STATUSES.SITE_IS_OVERLOADED,
      exports.STATUSES.SITE_IS_FROZEN,
      exports.STATUSES.IDENTITY_PROVIDER_AUTHENTICATION_ERROR,
      exports.STATUSES.NETWORK_READ_TIMEOUT,
      exports.STATUSES.NETWORK_CONNECT_TIMEOUT
    ];
    exports.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      exports.ALPHA.push(String.fromCharCode(i));
      exports.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
    exports.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports.URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports.ALPHANUM);
    exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports.TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports.ALPHANUM);
    exports.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports.HEADER_CHARS.push(i);
      }
    }
    exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
    exports.QUOTED_STRING = ["	", " "];
    for (let i = 33; i <= 255; i++) {
      if (i !== 34 && i !== 92) {
        exports.QUOTED_STRING.push(i);
      }
    }
    exports.HTAB_SP_VCHAR_OBS_TEXT = ["	", " "];
    for (let i = 33; i <= 126; i++) {
      exports.HTAB_SP_VCHAR_OBS_TEXT.push(i);
    }
    for (let i = 128; i <= 255; i++) {
      exports.HTAB_SP_VCHAR_OBS_TEXT.push(i);
    }
    exports.MAJOR = exports.NUM_MAP;
    exports.MINOR = exports.MAJOR;
    exports.SPECIAL_HEADERS = {
      "connection": exports.HEADER_STATE.CONNECTION,
      "content-length": exports.HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": exports.HEADER_STATE.CONNECTION,
      "transfer-encoding": exports.HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": exports.HEADER_STATE.UPGRADE
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports, module) {
    var { Buffer: Buffer2 } = __require("buffer");
    var wasmBase64 = "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzQzBQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEDAAADAAAABAUBcAESEgUDAQACBggBfwFBgNgECwfFBygGbWVtb3J5AgALX2luaXRpYWxpemUACBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQACRhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUANgxsbGh0dHBfYWxsb2MACwZtYWxsb2MAOAtsbGh0dHBfZnJlZQAMBGZyZWUADA9sbGh0dHBfZ2V0X3R5cGUADRVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADhVsbGh0dHBfZ2V0X2h0dHBfbWlub3IADxFsbGh0dHBfZ2V0X21ldGhvZAAQFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAERJsbGh0dHBfZ2V0X3VwZ3JhZGUAEgxsbGh0dHBfcmVzZXQAEw5sbGh0dHBfZXhlY3V0ZQAUFGxsaHR0cF9zZXR0aW5nc19pbml0ABUNbGxodHRwX2ZpbmlzaAAWDGxsaHR0cF9wYXVzZQAXDWxsaHR0cF9yZXN1bWUAGBtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGRBsbGh0dHBfZ2V0X2Vycm5vABoXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AGxdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAcFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB0RbGxodHRwX2Vycm5vX25hbWUAHhJsbGh0dHBfbWV0aG9kX25hbWUAHxJsbGh0dHBfc3RhdHVzX25hbWUAIBpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAhIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAiHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACMkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACQabGxodHRwX3NldF9sZW5pZW50X3ZlcnNpb24AJSNsbGh0dHBfc2V0X2xlbmllbnRfZGF0YV9hZnRlcl9jbG9zZQAmJ2xsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9sZl9hZnRlcl9jcgAnLGxsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9jcmxmX2FmdGVyX2NodW5rACgobGxodHRwX3NldF9sZW5pZW50X29wdGlvbmFsX2NyX2JlZm9yZV9sZgApKmxsaHR0cF9zZXRfbGVuaWVudF9zcGFjZXNfYWZ0ZXJfY2h1bmtfc2l6ZQAqGGxsaHR0cF9tZXNzYWdlX25lZWRzX2VvZgA1CRcBAEEBCxEBAgMEBQoGBzEzMi0uLCsvMAq8ywIzFgBB/NMAKAIABEAAC0H80wBBATYCAAsUACAAEDcgACACNgI4IAAgAToAKAsUACAAIAAvATQgAC0AMCAAEDYQAAseAQF/QcAAEDkiARA3IAFBgAg2AjggASAAOgAoIAELjwwBB38CQCAARQ0AIABBCGsiASAAQQRrKAIAIgBBeHEiBGohBQJAIABBAXENACAAQQNxRQ0BIAEgASgCACIAayIBQZDUACgCAEkNASAAIARqIQQCQAJAQZTUACgCACABRwRAIABB/wFNBEAgAEEDdiEDIAEoAggiACABKAIMIgJGBEBBgNQAQYDUACgCAEF+IAN3cTYCAAwFCyACIAA2AgggACACNgIMDAQLIAEoAhghBiABIAEoAgwiAEcEQCAAIAEoAggiAjYCCCACIAA2AgwMAwsgAUEUaiIDKAIAIgJFBEAgASgCECICRQ0CIAFBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUoAgQiAEEDcUEDRw0CIAUgAEF+cTYCBEGI1AAgBDYCACAFIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAEoAhwiAkECdEGw1gBqIgMoAgAgAUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECABRhtqIAA2AgAgAEUNAQsgACAGNgIYIAEoAhAiAgRAIAAgAjYCECACIAA2AhgLIAFBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIAVPDQAgBSgCBCIAQQFxRQ0AAkACQAJAAkAgAEECcUUEQEGY1AAoAgAgBUYEQEGY1AAgATYCAEGM1ABBjNQAKAIAIARqIgA2AgAgASAAQQFyNgIEIAFBlNQAKAIARw0GQYjUAEEANgIAQZTUAEEANgIADAYLQZTUACgCACAFRgRAQZTUACABNgIAQYjUAEGI1AAoAgAgBGoiADYCACABIABBAXI2AgQgACABaiAANgIADAYLIABBeHEgBGohBCAAQf8BTQRAIABBA3YhAyAFKAIIIgAgBSgCDCICRgRAQYDUAEGA1AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyAFKAIYIQYgBSAFKAIMIgBHBEBBkNQAKAIAGiAAIAUoAggiAjYCCCACIAA2AgwMAwsgBUEUaiIDKAIAIgJFBEAgBSgCECICRQ0CIAVBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUgAEF+cTYCBCABIARqIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAUoAhwiAkECdEGw1gBqIgMoAgAgBUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECAFRhtqIAA2AgAgAEUNAQsgACAGNgIYIAUoAhAiAgRAIAAgAjYCECACIAA2AhgLIAVBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIARqIAQ2AgAgASAEQQFyNgIEIAFBlNQAKAIARw0AQYjUACAENgIADAELIARB/wFNBEAgBEF4cUGo1ABqIQACf0GA1AAoAgAiAkEBIARBA3Z0IgNxRQRAQYDUACACIANyNgIAIAAMAQsgACgCCAsiAiABNgIMIAAgATYCCCABIAA2AgwgASACNgIIDAELQR8hAiAEQf///wdNBEAgBEEmIARBCHZnIgBrdkEBcSAAQQF0a0E+aiECCyABIAI2AhwgAUIANwIQIAJBAnRBsNYAaiEAAkBBhNQAKAIAIgNBASACdCIHcUUEQCAAIAE2AgBBhNQAIAMgB3I2AgAgASAANgIYIAEgATYCCCABIAE2AgwMAQsgBEEZIAJBAXZrQQAgAkEfRxt0IQIgACgCACEAAkADQCAAIgMoAgRBeHEgBEYNASACQR12IQAgAkEBdCECIAMgAEEEcWpBEGoiBygCACIADQALIAcgATYCACABIAM2AhggASABNgIMIAEgATYCCAwBCyADKAIIIgAgATYCDCADIAE2AgggAUEANgIYIAEgAzYCDCABIAA2AggLQaDUAEGg1AAoAgBBAWsiAEF/IAAbNgIACwsHACAALQAoCwcAIAAtACoLBwAgAC0AKwsHACAALQApCwcAIAAvATQLBwAgAC0AMAtAAQR/IAAoAhghASAALwEuIQIgAC0AKCEDIAAoAjghBCAAEDcgACAENgI4IAAgAzoAKCAAIAI7AS4gACABNgIYC8X4AQIHfwN+IAEgAmohBAJAIAAiAygCDCIADQAgAygCBARAIAMgATYCBAsjAEEQayIJJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAygCHCICQQFrDuwB7gEB6AECAwQFBgcICQoLDA0ODxAREucBE+YBFBXlARYX5AEYGRobHB0eHyDvAe0BIeMBIiMkJSYnKCkqK+IBLC0uLzAxMuEB4AEzNN8B3gE1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk/pAVBRUlPdAdwBVNsBVdoBVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHZAdgBxgHXAccB1gHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAQDqAQtBAAzUAQtBDgzTAQtBDQzSAQtBDwzRAQtBEAzQAQtBEQzPAQtBEgzOAQtBEwzNAQtBFAzMAQtBFQzLAQtBFgzKAQtBFwzJAQtBGAzIAQtBGQzHAQtBGgzGAQtBGwzFAQtBHAzEAQtBHQzDAQtBHgzCAQtBHwzBAQtBCAzAAQtBIAy/AQtBIgy+AQtBIQy9AQtBBwy8AQtBIwy7AQtBJAy6AQtBJQy5AQtBJgy4AQtBJwy3AQtBzgEMtgELQSgMtQELQSkMtAELQSoMswELQSsMsgELQc8BDLEBC0EtDLABC0EuDK8BC0EvDK4BC0EwDK0BC0ExDKwBC0EyDKsBC0EzDKoBC0HQAQypAQtBNAyoAQtBOAynAQtBDAymAQtBNQylAQtBNgykAQtBNwyjAQtBPQyiAQtBOQyhAQtB0QEMoAELQQsMnwELQT4MngELQToMnQELQQoMnAELQTsMmwELQTwMmgELQdIBDJkBC0HAAAyYAQtBPwyXAQtBwQAMlgELQQkMlQELQSwMlAELQcIADJMBC0HDAAySAQtBxAAMkQELQcUADJABC0HGAAyPAQtBxwAMjgELQcgADI0BC0HJAAyMAQtBygAMiwELQcsADIoBC0HMAAyJAQtBzQAMiAELQc4ADIcBC0HPAAyGAQtB0AAMhQELQdEADIQBC0HSAAyDAQtB1AAMggELQdMADIEBC0HVAAyAAQtB1gAMfwtB1wAMfgtB2AAMfQtB2QAMfAtB2gAMewtB2wAMegtB0wEMeQtB3AAMeAtB3QAMdwtBBgx2C0HeAAx1C0EFDHQLQd8ADHMLQQQMcgtB4AAMcQtB4QAMcAtB4gAMbwtB4wAMbgtBAwxtC0HkAAxsC0HlAAxrC0HmAAxqC0HoAAxpC0HnAAxoC0HpAAxnC0HqAAxmC0HrAAxlC0HsAAxkC0ECDGMLQe0ADGILQe4ADGELQe8ADGALQfAADF8LQfEADF4LQfIADF0LQfMADFwLQfQADFsLQfUADFoLQfYADFkLQfcADFgLQfgADFcLQfkADFYLQfoADFULQfsADFQLQfwADFMLQf0ADFILQf4ADFELQf8ADFALQYABDE8LQYEBDE4LQYIBDE0LQYMBDEwLQYQBDEsLQYUBDEoLQYYBDEkLQYcBDEgLQYgBDEcLQYkBDEYLQYoBDEULQYsBDEQLQYwBDEMLQY0BDEILQY4BDEELQY8BDEALQZABDD8LQZEBDD4LQZIBDD0LQZMBDDwLQZQBDDsLQZUBDDoLQZYBDDkLQZcBDDgLQZgBDDcLQZkBDDYLQZoBDDULQZsBDDQLQZwBDDMLQZ0BDDILQZ4BDDELQZ8BDDALQaABDC8LQaEBDC4LQaIBDC0LQaMBDCwLQaQBDCsLQaUBDCoLQaYBDCkLQacBDCgLQagBDCcLQakBDCYLQaoBDCULQasBDCQLQawBDCMLQa0BDCILQa4BDCELQa8BDCALQbABDB8LQbEBDB4LQbIBDB0LQbMBDBwLQbQBDBsLQbUBDBoLQbYBDBkLQbcBDBgLQbgBDBcLQQEMFgtBuQEMFQtBugEMFAtBuwEMEwtBvAEMEgtBvQEMEQtBvgEMEAtBvwEMDwtBwAEMDgtBwQEMDQtBwgEMDAtBwwEMCwtBxAEMCgtBxQEMCQtBxgEMCAtB1AEMBwtBxwEMBgtByAEMBQtByQEMBAtBygEMAwtBywEMAgtBzQEMAQtBzAELIQIDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDtQBAAECAwQFBgcICQoLDA0ODxARFBUWFxgZGhscHR4fICEjJCUnKCmIA4cDhQOEA/wC9QLuAusC6ALmAuMC4ALfAt0C2wLWAtUC1ALTAtICygLJAsgCxwLGAsUCxALDAr0CvAK6ArkCuAK3ArYCtQK0ArICsQKsAqoCqAKnAqYCpQKkAqMCogKhAqACnwKbApoCmQKYApcCkAKIAoQCgwKCAvkB9gH1AfQB8wHyAfEB8AHvAe0B6wHoAeMB4QHgAd8B3gHdAdwB2wHaAdkB2AHXAdYB1QHUAdIB0QHQAc8BzgHNAcwBywHKAckByAHHAcYBxQHEAcMBwgHBAcABvwG+Ab0BvAG7AboBuQG4AbcBtgG1AbQBswGyAbEBsAGvAa4BrQGsAasBqgGpAagBpwGmAaUBpAGjAaIBoQGgAZ8BngGdAZwBmwGaAZcBlgGRAZABjwGOAY0BjAGLAYoBiQGIAYUBhAGDAX59fHt6d3Z1LFFSU1RVVgsgASAERw1zQewBIQIMqQMLIAEgBEcNkAFB0QEhAgyoAwsgASAERw3pAUGEASECDKcDCyABIARHDfQBQfoAIQIMpgMLIAEgBEcNggJB9QAhAgylAwsgASAERw2JAkHzACECDKQDCyABIARHDYwCQfEAIQIMowMLIAEgBEcNHkEeIQIMogMLIAEgBEcNGUEYIQIMoQMLIAEgBEcNuAJBzQAhAgygAwsgASAERw3DAkHGACECDJ8DCyABIARHDcQCQcMAIQIMngMLIAEgBEcNygJBOCECDJ0DCyADLQAwQQFGDZUDDPICC0EAIQACQAJAAkAgAy0AKkUNACADLQArRQ0AIAMvATIiAkECcUUNAQwCCyADLwEyIgJBAXFFDQELQQEhACADLQAoQQFGDQAgAy8BNCIGQeQAa0HkAEkNACAGQcwBRg0AIAZBsAJGDQAgAkHAAHENAEEAIQAgAkGIBHFBgARGDQAgAkEocUEARyEACyADQQA7ATIgA0EAOgAxAkAgAEUEQCADQQA6ADEgAy0ALkEEcQ0BDJwDCyADQgA3AyALIANBADoAMSADQQE6ADYMSQtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAEUNSSAAQRVHDWMgA0EENgIcIAMgATYCFCADQb0aNgIQIANBFTYCDEEAIQIMmgMLIAEgBEYEQEEGIQIMmgMLIAEtAABBCkYNGQwBCyABIARGBEBBByECDJkDCwJAIAEtAABBCmsOBAIBAQABCyABQQFqIQFBECECDP4CCyADLQAuQYABcQ0YQQAhAiADQQA2AhwgAyABNgIUIANBqR82AhAgA0ECNgIMDJcDCyABQQFqIQEgA0Evai0AAEEBcQ0XQQAhAiADQQA2AhwgAyABNgIUIANBhB82AhAgA0EZNgIMDJYDCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMWg0ZQQghAgyVAwsgASAERwRAIANBCTYCCCADIAE2AgRBEiECDPsCC0EJIQIMlAMLIAMpAyBQDZwCDEQLIAEgBEYEQEELIQIMkwMLIAEtAABBCkcNFyABQQFqIQEMGAsgA0Evai0AAEEBcUUNGgwnC0EAIQACQCADKAI4IgJFDQAgAigCSCICRQ0AIAMgAhEAACEACyAADRoMQwtBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0bDCULQQAhAAJAIAMoAjgiAkUNACACKAJIIgJFDQAgAyACEQAAIQALIAANHAwzCyADQS9qLQAAQQFxRQ0dDCMLQQAhAAJAIAMoAjgiAkUNACACKAJMIgJFDQAgAyACEQAAIQALIAANHQxDC0EAIQACQCADKAI4IgJFDQAgAigCTCICRQ0AIAMgAhEAACEACyAADR4MIQsgASAERgRAQRMhAgyLAwsCQCABLQAAIgBBCmsOBCAkJAAjCyABQQFqIQEMIAtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0jDEMLIAEgBEYEQEEWIQIMiQMLIAEtAABB8D9qLQAAQQFHDSQM7QILAkADQCABLQAAQeA5ai0AACIAQQFHBEACQCAAQQJrDgIDACgLIAFBAWohAUEfIQIM8AILIAQgAUEBaiIBRw0AC0EYIQIMiAMLIAMoAgQhAEEAIQIgA0EANgIEIAMgACABQQFqIgEQMyIADSIMQgtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0kDCsLIAEgBEYEQEEcIQIMhgMLIANBCjYCCCADIAE2AgRBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0mQSIhAgzrAgsgASAERwRAA0AgAS0AAEHgO2otAAAiAEEDRwRAIABBAWsOBRkbJ+wCJicLIAQgAUEBaiIBRw0AC0EbIQIMhQMLQRshAgyEAwsDQCABLQAAQeA9ai0AACIAQQNHBEAgAEEBaw4FEBIoFCcoCyAEIAFBAWoiAUcNAAtBHiECDIMDCyABIARHBEAgA0ELNgIIIAMgATYCBEEHIQIM6QILQR8hAgyCAwsgASAERgRAQSAhAgyCAwsCQCABLQAAQQ1rDhQvQEBAQEBAQEBAQEBAQEBAQEBAAEALQQAhAiADQQA2AhwgA0G3CzYCECADQQI2AgwgAyABQQFqNgIUDIEDCyADQS9qIQIDQCABIARGBEBBISECDIIDCwJAAkACQCABLQAAIgBBCWsOGAIAKioBKioqKioqKioqKioqKioqKioqAigLIAFBAWohASADQS9qLQAAQQFxRQ0LDBkLIAFBAWohAQwYCyABQQFqIQEgAi0AAEECcQ0AC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAyAAwsgAUEBaiEBC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADQEM0QILIANCADcDIAw8CyAAQRVGBEAgA0EkNgIcIAMgATYCFCADQYYaNgIQIANBFTYCDEEAIQIM/QILQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDPwCCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDSsgA0EHNgIcIAMgATYCFCADIAA2AgwM+wILIAMtAC5BwABxRQ0BC0EAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAARQ0rIABBFUYEQCADQQo2AhwgAyABNgIUIANB8Rg2AhAgA0EVNgIMQQAhAgz6AgtBACECIANBADYCHCADIAE2AhQgA0GLDDYCECADQRM2AgwM+QILQQAhAiADQQA2AhwgAyABNgIUIANBsRQ2AhAgA0ECNgIMDPgCC0EAIQIgA0EANgIcIAMgATYCFCADQYwUNgIQIANBGTYCDAz3AgtBACECIANBADYCHCADIAE2AhQgA0HRHDYCECADQRk2AgwM9gILIABBFUYNPUEAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAz1AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQ0oIANBDTYCHCADIAE2AhQgAyAANgIMDPQCCyAAQRVGDTpBACECIANBADYCHCADIAE2AhQgA0GiDzYCECADQSI2AgwM8wILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDIiAEUEQCABQQFqIQEMKAsgA0EONgIcIAMgADYCDCADIAFBAWo2AhQM8gILIABBFUYNN0EAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAzxAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQRAIAFBAWohAQwnCyADQQ82AhwgAyAANgIMIAMgAUEBajYCFAzwAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM7wILIABBFUYNM0EAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzuAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMyIARQ0lIANBETYCHCADIAE2AhQgAyAANgIMDO0CCyAAQRVGDTBBACECIANBADYCHCADIAE2AhQgA0HODDYCECADQSM2AgwM7AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEMJQsgA0ESNgIcIAMgADYCDCADIAFBAWo2AhQM6wILIANBL2otAABBAXFFDQELQRUhAgzPAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM6AILIABBO0cNACABQQFqIQEMDAtBACECIANBADYCHCADIAE2AhQgA0GYFzYCECADQQI2AgwM5gILIABBFUYNKEEAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzlAgsgA0EUNgIcIAMgATYCFCADIAA2AgwM5AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEM3AILIANBFTYCHCADIAA2AgwgAyABQQFqNgIUDOMCCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNoCCyADQRc2AhwgAyAANgIMIAMgAUEBajYCFAziAgsgAEEVRg0jQQAhAiADQQA2AhwgAyABNgIUIANBzgw2AhAgA0EjNgIMDOECCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDB0LIANBGTYCHCADIAA2AgwgAyABQQFqNgIUDOACCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNYCCyADQRo2AhwgAyAANgIMIAMgAUEBajYCFAzfAgsgAEEVRg0fQQAhAiADQQA2AhwgAyABNgIUIANBog82AhAgA0EiNgIMDN4CCyADKAIEIQBBACECIANBADYCBCADIAAgARAyIgBFBEAgAUEBaiEBDBsLIANBHDYCHCADIAA2AgwgAyABQQFqNgIUDN0CCyADKAIEIQBBACECIANBADYCBCADIAAgARAyIgBFBEAgAUEBaiEBDNICCyADQR02AhwgAyAANgIMIAMgAUEBajYCFAzcAgsgAEE7Rw0BIAFBAWohAQtBJCECDMACC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAzZAgsgASAERwRAA0AgAS0AAEEgRw3xASAEIAFBAWoiAUcNAAtBLCECDNkCC0EsIQIM2AILIAEgBEYEQEE0IQIM2AILAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0E0IQIM2QILIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQ2MAiADQTI2AhwgAyABNgIUIAMgADYCDEEAIQIM2AILIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQRAIAFBAWohAQyMAgsgA0EyNgIcIAMgADYCDCADIAFBAWo2AhRBACECDNcCCyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE5IQIMwAILIAMpAyAiC0KZs+bMmbPmzBlWDQEgAyALQgp+Igo3AyAgCiAArUL/AYMiC0J/hVYNASADIAogC3w3AyAgBCABQQFqIgFHDQALQcAAIQIM2AILIAMoAgQhACADQQA2AgQgAyAAIAFBAWoiARAwIgANFwzJAgtBwAAhAgzWAgsgASAERgRAQckAIQIM1gILAkADQAJAIAEtAABBCWsOGAACjwKPApMCjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CAI8CCyAEIAFBAWoiAUcNAAtByQAhAgzWAgsgAUEBaiEBIANBL2otAABBAXENjwIgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIM1QILIAEgBEcEQANAIAEtAAAiAEEgRwRAAkACQAJAIABByABrDgsAAc0BzQHNAc0BzQHNAc0BzQECzQELIAFBAWohAUHZACECDL8CCyABQQFqIQFB2gAhAgy+AgsgAUEBaiEBQdsAIQIMvQILIAQgAUEBaiIBRw0AC0HuACECDNUCC0HuACECDNQCCyADQQI6ACgMMAtBACECIANBADYCHCADQbcLNgIQIANBAjYCDCADIAFBAWo2AhQM0gILQQAhAgy3AgtBDSECDLYCC0ERIQIMtQILQRMhAgy0AgtBFCECDLMCC0EWIQIMsgILQRchAgyxAgtBGCECDLACC0EZIQIMrwILQRohAgyuAgtBGyECDK0CC0EcIQIMrAILQR0hAgyrAgtBHiECDKoCC0EgIQIMqQILQSEhAgyoAgtBIyECDKcCC0EnIQIMpgILIANBPTYCHCADIAE2AhQgAyAANgIMQQAhAgy/AgsgA0EbNgIcIAMgATYCFCADQY8bNgIQIANBFTYCDEEAIQIMvgILIANBIDYCHCADIAE2AhQgA0GeGTYCECADQRU2AgxBACECDL0CCyADQRM2AhwgAyABNgIUIANBnhk2AhAgA0EVNgIMQQAhAgy8AgsgA0ELNgIcIAMgATYCFCADQZ4ZNgIQIANBFTYCDEEAIQIMuwILIANBEDYCHCADIAE2AhQgA0GeGTYCECADQRU2AgxBACECDLoCCyADQSA2AhwgAyABNgIUIANBjxs2AhAgA0EVNgIMQQAhAgy5AgsgA0ELNgIcIAMgATYCFCADQY8bNgIQIANBFTYCDEEAIQIMuAILIANBDDYCHCADIAE2AhQgA0GPGzYCECADQRU2AgxBACECDLcCC0EAIQIgA0EANgIcIAMgATYCFCADQa8ONgIQIANBEjYCDAy2AgsCQANAAkAgAS0AAEEKaw4EAAICAAILIAQgAUEBaiIBRw0AC0HsASECDLYCCwJAAkAgAy0ANkEBRw0AQQAhAAJAIAMoAjgiAkUNACACKAJYIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB6wE2AhwgAyABNgIUIANB4hg2AhAgA0EVNgIMQQAhAgy3AgtBzAEhAgycAgsgA0EANgIcIAMgATYCFCADQfELNgIQIANBHzYCDEEAIQIMtQILAkACQCADLQAoQQFrDgIEAQALQcsBIQIMmwILQcQBIQIMmgILIANBAjoAMUEAIQACQCADKAI4IgJFDQAgAigCACICRQ0AIAMgAhEAACEACyAARQRAQc0BIQIMmgILIABBFUcEQCADQQA2AhwgAyABNgIUIANBrAw2AhAgA0EQNgIMQQAhAgy0AgsgA0HqATYCHCADIAE2AhQgA0GHGTYCECADQRU2AgxBACECDLMCCyABIARGBEBB6QEhAgyzAgsgAS0AAEHIAEYNASADQQE6ACgLQbYBIQIMlwILQcoBIQIMlgILIAEgBEcEQCADQQw2AgggAyABNgIEQckBIQIMlgILQegBIQIMrwILIAEgBEYEQEHnASECDK8CCyABLQAAQcgARw0EIAFBAWohAUHIASECDJQCCyABIARGBEBB5gEhAgyuAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQcYBIQIMlAILIAFBAWohAUHHASECDJMCC0HlASECIAEgBEYNrAIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB99MAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMrQILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgBFBEBB1AEhAgyTAgsgA0HkATYCHCADIAE2AhQgAyAANgIMQQAhAgysAgtB4wEhAiABIARGDasCIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQfXTAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADKwCCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB0B42AhAgA0EINgIMDKkCC0HFASECDI4CCyADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDKcCC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ1lIABBFUcEQCADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgynAgsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDKYCC0HhASECIAQgASIARg2lAiAEIAFrIAMoAgAiAWohBSAAIAFrQQRqIQYCQANAIAAtAAAgAUHw0wBqLQAARw0BIAFBBEYNAyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBTYCAAymAgsgA0EANgIcIAMgADYCFCADQYQ3NgIQIANBCDYCDCADQQA2AgBBACECDKUCCyABIARHBEAgA0ENNgIIIAMgATYCBEHCASECDIsCC0HgASECDKQCCyADQQA2AgAgBkEBaiEBC0HDASECDIgCCyABIARGBEBB3wEhAgyiAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBwQEhAgyIAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYgCIANB3gE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAEgBEYEQEHdASECDKECCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYkCIANB3AE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILQcABIQIMhgILIAEgBEYEQEHbASECDKACC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDQIgA0HYATYCHCADIAE2AhQgAyAANgIMQQAhAgyiAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYsCIANB2QE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ2JAiADQdoBNgIcIAMgATYCFCADIAA2AgwMoAILQb8BIQIMhQILQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBnA02AhAgA0EhNgIMQQAhAgygAgtBvgEhAgyFAgsgA0HXATYCHCADIAE2AhQgA0HWGTYCECADQRU2AgxBACECDJ4CCyABIARGBEBB1wEhAgyeAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANB6xA2AhAgA0EJNgIMQQAhAgyeAgtBvQEhAgyDAgsgASAERgRAQdYBIQIMnQILAkAgAS0AAEEwa0H/AXEiAkEKSQRAIAFBAWohAQJAIAMvATQiAEGZM0sNACADIABBCmwiADsBNCAAQf7/A3EgAkH//wNzSw0AIAMgACACajsBNAwCC0EAIQIgA0EANgIcIAMgATYCFCADQYAdNgIQIANBDTYCDAyeAgsgA0EANgIcIAMgATYCFCADQYAdNgIQIANBDTYCDEEAIQIMnQILQbwBIQIMggILIAEgBEYEQEHVASECDJwCCwJAIAEtAABBMGtB/wFxIgJBCkkEQCABQQFqIQECQCADLwE0IgBBmTNLDQAgAyAAQQpsIgA7ATQgAEH+/wNxIAJB//8Dc0sNACADIAAgAmo7ATQMAgtBACECIANBADYCHCADIAE2AhQgA0GAHTYCECADQQ02AgwMnQILIANBADYCHCADIAE2AhQgA0GAHTYCECADQQ02AgxBACECDJwCC0G7ASECDIECCyABIARGBEBB1AEhAgybAgsCQCABLQAAQTBrQf8BcSICQQpJBEAgAUEBaiEBAkAgAy8BNCIAQZkzSw0AIAMgAEEKbCIAOwE0IABB/v8DcSACQf//A3NLDQAgAyAAIAJqOwE0DAILQQAhAiADQQA2AhwgAyABNgIUIANBgB02AhAgA0ENNgIMDJwCCyADQQA2AhwgAyABNgIUIANBgB02AhAgA0ENNgIMQQAhAgybAgtBugEhAgyAAgsgASAERgRAQdMBIQIMmgILAkACQAJAAkAgAS0AAEEKaw4XAgMDAAMDAwMDAwMDAwMDAwMDAwMDAwEDCyABQQFqDAULIAFBAWohAUG5ASECDIECCyABQQFqIQEgA0Evai0AAEEBcQ0IIANBADYCHCADIAE2AhQgA0GFCzYCECADQQ02AgxBACECDJoCCyADQQA2AhwgAyABNgIUIANBhQs2AhAgA0ENNgIMQQAhAgyZAgsgASAERwRAIANBDjYCCCADIAE2AgRBASECDP8BC0HSASECDJgCCwJAAkADQAJAIAEtAABBCmsOBAIAAAMACyAEIAFBAWoiAUcNAAtB0QEhAgyZAgsgAygCBCEAIANBADYCBCADIAAgARAsIgBFBEAgAUEBaiEBDAQLIANB0AE2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMmAILIAMoAgQhACADQQA2AgQgAyAAIAEQLCIADQEgAUEBagshAUG3ASECDPwBCyADQc8BNgIcIAMgADYCDCADIAFBAWo2AhRBACECDJUCC0G4ASECDPoBCyADQS9qLQAAQQFxDQEgA0EANgIcIAMgATYCFCADQc8bNgIQIANBGTYCDEEAIQIMkwILIAEgBEYEQEHPASECDJMCCwJAAkACQCABLQAAQQprDgQBAgIAAgsgAUEBaiEBDAILIAFBAWohAQwBCyADLQAuQcAAcUUNAQtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsgAEUNlgEgAEEVRgRAIANB2QA2AhwgAyABNgIUIANBvRk2AhAgA0EVNgIMQQAhAgySAgsgA0EANgIcIAMgATYCFCADQfgMNgIQIANBGzYCDEEAIQIMkQILIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDJACCyABIARHBEAgA0EMNgIIIAMgATYCBEG1ASECDPYBC0HOASECDI8CCyABIARGBEBBzQEhAgyPAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBwQBrDhUAAQIDWgQFBlpaWgcICQoLDA0ODxBaCyABQQFqIQFB8QAhAgyEAgsgAUEBaiEBQfIAIQIMgwILIAFBAWohAUH3ACECDIICCyABQQFqIQFB+wAhAgyBAgsgAUEBaiEBQfwAIQIMgAILIAFBAWohAUH/ACECDP8BCyABQQFqIQFBgAEhAgz+AQsgAUEBaiEBQYMBIQIM/QELIAFBAWohAUGMASECDPwBCyABQQFqIQFBjQEhAgz7AQsgAUEBaiEBQY4BIQIM+gELIAFBAWohAUGbASECDPkBCyABQQFqIQFBnAEhAgz4AQsgAUEBaiEBQaIBIQIM9wELIAFBAWohAUGqASECDPYBCyABQQFqIQFBrQEhAgz1AQsgAUEBaiEBQbQBIQIM9AELIAEgBEYEQEHMASECDI4CCyABLQAAQc4ARw1IIAFBAWohAUGzASECDPMBCyABIARGBEBBywEhAgyNAgsCQAJAAkAgAS0AAEHCAGsOEgBKSkpKSkpKSkoBSkpKSkpKAkoLIAFBAWohAUGuASECDPQBCyABQQFqIQFBsQEhAgzzAQsgAUEBaiEBQbIBIQIM8gELQcoBIQIgASAERg2LAiADKAIAIgAgBCABa2ohBSABIABrQQdqIQYCQANAIAEtAAAgAEHo0wBqLQAARw1FIABBB0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyMAgsgA0EANgIAIAZBAWohAUEbDEULIAEgBEYEQEHJASECDIsCCwJAAkAgAS0AAEHJAGsOBwBHR0dHRwFHCyABQQFqIQFBrwEhAgzxAQsgAUEBaiEBQbABIQIM8AELQcgBIQIgASAERg2JAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHm0wBqLQAARw1DIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyKAgsgA0EANgIAIAZBAWohAUEPDEMLQccBIQIgASAERg2IAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHk0wBqLQAARw1CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyJAgsgA0EANgIAIAZBAWohAUEgDEILQcYBIQIgASAERg2HAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw1BIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyIAgsgA0EANgIAIAZBAWohAUESDEELIAEgBEYEQEHFASECDIcCCwJAAkAgAS0AAEHFAGsODgBDQ0NDQ0NDQ0NDQ0MBQwsgAUEBaiEBQasBIQIM7QELIAFBAWohAUGsASECDOwBC0HEASECIAEgBEYNhQIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB3tMAai0AAEcNPyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhgILIANBADYCACAGQQFqIQFBBww/C0HDASECIAEgBEYNhAIgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABB2NMAai0AAEcNPiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhQILIANBADYCACAGQQFqIQFBKAw+CyABIARGBEBBwgEhAgyEAgsCQAJAAkAgAS0AAEHFAGsOEQBBQUFBQUFBQUEBQUFBQUECQQsgAUEBaiEBQacBIQIM6wELIAFBAWohAUGoASECDOoBCyABQQFqIQFBqQEhAgzpAQtBwQEhAiABIARGDYICIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQdHTAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADIMCCyADQQA2AgAgBkEBaiEBQRoMPAtBwAEhAiABIARGDYECIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQc3TAGotAABHDTsgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADIICCyADQQA2AgAgBkEBaiEBQSEMOwsgASAERgRAQb8BIQIMgQILAkACQCABLQAAQcEAaw4UAD09PT09PT09PT09PT09PT09PQE9CyABQQFqIQFBowEhAgznAQsgAUEBaiEBQaYBIQIM5gELIAEgBEYEQEG+ASECDIACCwJAAkAgAS0AAEHVAGsOCwA8PDw8PDw8PDwBPAsgAUEBaiEBQaQBIQIM5gELIAFBAWohAUGlASECDOUBC0G9ASECIAEgBEYN/gEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNOCAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/wELIANBADYCACAGQQFqIQFBKgw4CyABIARGBEBBvAEhAgz+AQsgAS0AAEHQAEcNOCABQQFqIQFBJQw3C0G7ASECIAEgBEYN/AEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBwdMAai0AAEcNNiAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/QELIANBADYCACAGQQFqIQFBDgw2CyABIARGBEBBugEhAgz8AQsgAS0AAEHFAEcNNiABQQFqIQFBoQEhAgzhAQsgASAERgRAQbkBIQIM+wELAkACQAJAAkAgAS0AAEHCAGsODwABAjk5OTk5OTk5OTk5AzkLIAFBAWohAUGdASECDOMBCyABQQFqIQFBngEhAgziAQsgAUEBaiEBQZ8BIQIM4QELIAFBAWohAUGgASECDOABC0G4ASECIAEgBEYN+QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBvtMAai0AAEcNMyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+gELIANBADYCACAGQQFqIQFBFAwzC0G3ASECIAEgBEYN+AEgAygCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBudMAai0AAEcNMiAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+QELIANBADYCACAGQQFqIQFBKwwyC0G2ASECIAEgBEYN9wEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBttMAai0AAEcNMSAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+AELIANBADYCACAGQQFqIQFBLAwxC0G1ASECIAEgBEYN9gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB4dMAai0AAEcNMCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM9wELIANBADYCACAGQQFqIQFBEQwwC0G0ASECIAEgBEYN9QEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBstMAai0AAEcNLyAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM9gELIANBADYCACAGQQFqIQFBLgwvCyABIARGBEBBswEhAgz1AQsCQAJAAkACQAJAIAEtAABBwQBrDhUANDQ0NDQ0NDQ0NAE0NAI0NAM0NAQ0CyABQQFqIQFBkQEhAgzeAQsgAUEBaiEBQZIBIQIM3QELIAFBAWohAUGTASECDNwBCyABQQFqIQFBmAEhAgzbAQsgAUEBaiEBQZoBIQIM2gELIAEgBEYEQEGyASECDPQBCwJAAkAgAS0AAEHSAGsOAwAwATALIAFBAWohAUGZASECDNoBCyABQQFqIQFBBAwtC0GxASECIAEgBEYN8gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBsNMAai0AAEcNLCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM8wELIANBADYCACAGQQFqIQFBHQwsCyABIARGBEBBsAEhAgzyAQsCQAJAIAEtAABByQBrDgcBLi4uLi4ALgsgAUEBaiEBQZcBIQIM2AELIAFBAWohAUEiDCsLIAEgBEYEQEGvASECDPEBCyABLQAAQdAARw0rIAFBAWohAUGWASECDNYBCyABIARGBEBBrgEhAgzwAQsCQAJAIAEtAABBxgBrDgsALCwsLCwsLCwsASwLIAFBAWohAUGUASECDNYBCyABQQFqIQFBlQEhAgzVAQtBrQEhAiABIARGDe4BIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazTAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO8BCyADQQA2AgAgBkEBaiEBQQ0MKAtBrAEhAiABIARGDe0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQeHTAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO4BCyADQQA2AgAgBkEBaiEBQQwMJwtBqwEhAiABIARGDewBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQarTAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO0BCyADQQA2AgAgBkEBaiEBQQMMJgtBqgEhAiABIARGDesBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQajTAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOwBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQakBIQIM6wELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBjwEhAgzRAQsgAUEBaiEBQZABIQIM0AELQagBIQIgASAERg3pASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm0wBqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzqAQsgA0EANgIAIAZBAWohAUEnDCMLQacBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk0wBqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEcDCILQaYBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGe0wBqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEGDCELQaUBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGZ0wBqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGkASECDOYBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQYQBIQIMzgELIAFBAWohAUGFASECDM0BCyABQQFqIQFBigEhAgzMAQsgAUEBaiEBQYsBIQIMywELQaMBIQIgASAERg3kASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGX0wBqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzlAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGiASECDOQBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGGASECDMoBCyABQQFqIQFBiQEhAgzJAQsgASAERgRAQaEBIQIM4wELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQYcBIQIMyQELIAFBAWohAUGIASECDMgBCyABIARGBEBBoAEhAgziAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GfASECIAEgBEYN4AEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBkdMAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4QELIANBADYCACAGQQFqIQFBHgwaC0GeASECIAEgBEYN3wEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBitMAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4AELIANBADYCACAGQQFqIQFBFQwZC0GdASECIAEgBEYN3gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBh9MAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3wELIANBADYCACAGQQFqIQFBFwwYC0GcASECIAEgBEYN3QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBgdMAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3gELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBmwEhAgzdAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYEBIQIMwwELIAFBAWohAUGCASECDMIBC0GaASECIAEgBEYN2wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5tMAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3AELIANBADYCACAGQQFqIQFBCQwVC0GZASECIAEgBEYN2gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5NMAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2wELIANBADYCACAGQQFqIQFBHwwUC0GYASECIAEgBEYN2QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB/tIAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2gELIANBADYCACAGQQFqIQFBAgwTC0GXASECIAEgBEYN2AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQfzSAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyABIARGBEBBlgEhAgzYAQtBASABLQAAQd8ARw0RGiABQQFqIQFB/QAhAgy9AQsgA0EANgIAIAZBAWohAUH+ACECDLwBC0GVASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBKQwPC0GUASECIAEgBEYN1AEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB+NIAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1QELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBkwEhAgzUAQsgAS0AAEHFAEcNDiABQQFqIQFB+gAhAgy5AQsgASAERgRAQZIBIQIM0wELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFB+AAhAgy5AQsgAUEBaiEBQfkAIQIMuAELQZEBIQIgASAERg3RASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHz0gBqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzSAQsgA0EANgIAIAZBAWohAUEjDAsLQZABIQIgASAERg3QASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHw0gBqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzRAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGPASECDNABCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQfMAIQIMtgELIAFBAWohAUH2ACECDLUBCyABIARGBEBBjgEhAgzPAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB9AAhAgy1AQsgAUEBaiEBQfUAIQIMtAELIAEgBEYEQEGNASECDM4BCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQYwBIQIgASAERg3MASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHs0gBqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzNAQsgA0EANgIAIAZBAWohAUEFDAYLQYsBIQIgASAERg3LASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHm0gBqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzMAQsgA0EANgIAIAZBAWohAUEWDAULQYoBIQIgASAERg3KASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzLAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGJASECDMoBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUHvACECDLABCyABQQFqIQFB8AAhAgyvAQtBiAEhAiABIARGDcgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQeDSAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMkBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGHASECDMcBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC0iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB6R42AhAgA0EGNgIMDMQBC0HuACECDKkBCyADQYYBNgIcIAMgATYCFCADIAA2AgxBACECDMIBC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgzBAQtB7QAhAgymAQsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDL8BCyABIARGBEBBhQEhAgy/AQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GGHjYCECADQQY2AgxBACECDL8BC0ECIQIMpAELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GEASECDL0BCyABIARGBEBBgwEhAgy9AQsCQCABLQAAQQlrDgRAAABAAAtB6wAhAgyiAQsgAy0AKUEFRgRAQewAIQIMogELQeoAIQIMoQELIAEgBEYEQEGCASECDLsBCyADQQ82AgggAyABNgIEDAoLIAEgBEYEQEGBASECDLoBCwJAIAEtAABBCWsOBD0AAD0AC0HpACECDJ8BCyABIARHBEAgA0EPNgIIIAMgATYCBEHnACECDJ8BC0GAASECDLgBCwJAIAEgBEcEQANAIAEtAABB4M4Aai0AACIAQQNHBEACQCAAQQFrDgI/AAQLQeYAIQIMoQELIAQgAUEBaiIBRw0AC0H+ACECDLkBC0H+ACECDLgBCyADQQA2AhwgAyABNgIUIANBxh82AhAgA0EHNgIMQQAhAgy3AQsgASAERgRAQf8AIQIMtwELAkACQAJAIAEtAABB4NAAai0AAEEBaw4DPAIAAQtB6AAhAgyeAQsgA0EANgIcIAMgATYCFCADQYYSNgIQIANBBzYCDEEAIQIMtwELQeAAIQIMnAELIAEgBEcEQCABQQFqIQFB5QAhAgycAQtB/QAhAgy1AQsgBCABIgBGBEBB/AAhAgy1AQsgAC0AACIBQS9GBEAgAEEBaiEBQeQAIQIMmwELIAFBCWsiAkEXSw0BIAAhAUEBIAJ0QZuAgARxDTcMAQsgBCABIgBGBEBB+wAhAgy0AQsgAC0AAEEvRw0AIABBAWohAQwDC0EAIQIgA0EANgIcIAMgADYCFCADQcYfNgIQIANBBzYCDAyyAQsCQAJAAkACQAJAA0AgAS0AAEHgzABqLQAAIgBBBUcEQAJAAkAgAEEBaw4IPQUGBwgABAEIC0HhACECDJ8BCyABQQFqIQFB4wAhAgyeAQsgBCABQQFqIgFHDQALQfoAIQIMtgELIAFBAWoMFAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgy0AQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyzAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyyAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMsQELIAEgBEYEQEH5ACECDLEBCwJAIAEtAABB4MwAai0AAEEBaw4INAQFBgAIAgMHCyABQQFqIQELQQMhAgyVAQsgAUEBagwNC0EAIQIgA0EANgIcIANBoxI2AhAgA0EHNgIMIAMgAUEBajYCFAytAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgysAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMqQELQeIAIQIMjgELIAEgBEYEQEH4ACECDKgBCyABQQFqDAILIAEgBEYEQEH3ACECDKcBCyABQQFqDAELIAEgBEYNASABQQFqCyEBQQQhAgyKAQtB9gAhAgyjAQsDQCABLQAAQeDKAGotAAAiAEECRwRAIABBAUcEQEHfACECDIsBCwwnCyAEIAFBAWoiAUcNAAtB9QAhAgyiAQsgASAERgRAQfQAIQIMogELAkAgAS0AAEEJaw43JQMGJQQGBgYGBgYGBgYGBgYGBgYGBgYFBgYCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAAYLIAFBAWoLIQFBBSECDIYBCyABQQFqDAYLIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMngELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMnQELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB8AA2AhwgAyABNgIUIAMgADYCDEEAIQIMnAELIANBADYCHCADIAE2AhQgA0G8EzYCECADQQc2AgxBACECDJsBCwJAAkACQAJAA0AgAS0AAEHgyABqLQAAIgBBBUcEQAJAIABBAWsOBiQDBAUGAAYLQd4AIQIMhgELIAQgAUEBaiIBRw0AC0HzACECDJ4BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQdsANgIcIAMgATYCFCADIAA2AgxBACECDJ0BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDJwBCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQfAANgIcIAMgATYCFCADIAA2AgxBACECDJsBCyADQQA2AhwgAyABNgIUIANB3Ag2AhAgA0EHNgIMQQAhAgyaAQsgASAERg0BIAFBAWoLIQFBBiECDH4LQfIAIQIMlwELAkACQAJAAkADQCABLQAAQeDGAGotAAAiAEEFRwRAIABBAWsOBB8CAwQFCyAEIAFBAWoiAUcNAAtB8QAhAgyaAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyZAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyYAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyXAQsgA0EANgIcIAMgATYCFCADQbQKNgIQIANBBzYCDEEAIQIMlgELQc4AIQIMewtB0AAhAgx6C0HdACECDHkLIAEgBEYEQEHwACECDJMBCwJAIAEtAABBCWsOBBYAABYACyABQQFqIQFB3AAhAgx4CyABIARGBEBB7wAhAgySAQsCQCABLQAAQQlrDgQVAAAVAAtBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUEQEHTASECDHgLIABBFUcEQCADQQA2AhwgAyABNgIUIANBwQ02AhAgA0EaNgIMQQAhAgySAQsgA0HuADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDJEBC0HtACECIAEgBEYNkAEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB18YAai0AAEcNBCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkQELIANBADYCACAGQQFqIQEgAy0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACECIANBADYCHCADIAE2AhQgA0HlCTYCECADQQg2AgwMkAELQewAIQIgASAERg2PASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHUxgBqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyQAQsgA0EANgIAIAZBAWohASADLQApQSFGDQMgA0EANgIcIAMgATYCFCADQYkKNgIQIANBCDYCDEEAIQIMjwELQesAIQIgASAERg2OASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHQxgBqLQAARw0CIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyPAQsgA0EANgIAIAZBAWohASADLQApIgBBI0kNAiAAQS5GDQIgA0EANgIcIAMgATYCFCADQcEJNgIQIANBCDYCDEEAIQIMjgELIANBADYCAAtBACECIANBADYCHCADIAE2AhQgA0GENzYCECADQQg2AgwMjAELQdgAIQIMcQsgASAERwRAIANBDTYCCCADIAE2AgRB1wAhAgxxC0HqACECDIoBCyABIARGBEBB6QAhAgyKAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1gAhAgxwCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdCADQegANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyABIARGBEBB5wAhAgyJAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ11IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMiQELQdUAIQIMbgsgASAERgRAQeUAIQIMiAELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDIoBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdyADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdSADQeQANgIcIAMgATYCFCADIAA2AgwMiAELQdMAIQIMbQsgAy0AKUEiRg2AAUHSACECDGwLQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALIABFBEBB1AAhAgxsCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQZwNNgIQIANBITYCDEEAIQIMhgELIANB4QA2AhwgAyABNgIUIANB1hk2AhAgA0EVNgIMQQAhAgyFAQsgASAERgRAQeAAIQIMhQELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HRACECDGwLIANBADYCHCADIAE2AhQgA0GIETYCECADQQk2AgxBACECDIUBCyADQQA2AhwgAyABNgIUIANBiBE2AhAgA0EJNgIMQQAhAgyEAQsgASAERgRAQd8AIQIMhAELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBiBE2AhAgA0ECNgIMQQAhAgyDAQsgASAERgRAQd0AIQIMgwELIAEtAAAiAkENRgRAIAFBAWohAUHPACECDGkLIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyCAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0G1LDYCECADQQc2AgwMgAELIAEgBEYEQEHbACECDIABCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc0AIQIMZAsgASAERgRAQdoAIQIMfgsgAS0AAEEJaw4EAAEBAAELQQAhAiADQQA2AhwgA0HsETYCECADQQc2AgwgAyABQQFqNgIUDHwLIANBgBI7ASpBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HZADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDHsLQcwAIQIMYAsgA0EANgIcIAMgATYCFCADQcENNgIQIANBGjYCDEEAIQIMeQsgASAERgRAQdkAIQIMeQsgAS0AAEEgRw06IAFBAWohASADLQAuQQFxDTogA0EANgIcIAMgATYCFCADQa0bNgIQIANBHjYCDEEAIQIMeAsgASAERgRAQdgAIQIMeAsCQAJAAkACQAJAIAEtAAAiAEEKaw4EAgMDAAELIAFBAWohAUErIQIMYQsgAEE6Rw0BIANBADYCHCADIAE2AhQgA0G5ETYCECADQQo2AgxBACECDHoLIAFBAWohASADQS9qLQAAQQFxRQ1tIAMtADJBgAFxRQRAIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsCQAJAIAAOFkpJSAEBAQEBAQEBAQEBAQEBAQEBAQABCyADQSk2AhwgAyABNgIUIANBshg2AhAgA0EVNgIMQQAhAgx7CyADQQA2AhwgAyABNgIUIANB3Qs2AhAgA0ERNgIMQQAhAgx6C0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAARQ1VIABBFUcNASADQQU2AhwgAyABNgIUIANBhho2AhAgA0EVNgIMQQAhAgx5C0HKACECDF4LQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDHcLIAMgAy8BMkGAAXI7ATIMOAsgASAERwRAIANBEDYCCCADIAE2AgRByQAhAgxcC0HXACECDHULIAEgBEYEQEHWACECDHULAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAPT09PT09PT09PT09AT09PQIDPQsgAUEBaiEBQcUAIQIMXQsgAUEBaiEBQcYAIQIMXAsgAUEBaiEBQccAIQIMWwsgAUEBaiEBQcgAIQIMWgtB1QAhAiAEIAEiAEYNcyAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcDQCABQcDGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQhBBCABQQVGDQoaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADHMLQdQAIQIgBCABIgBGDXIgBCABayADKAIAIgFqIQYgACABa0EPaiEHA0AgAUGwxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0HQQMgAUEPRg0JGiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxyC0HTACECIAQgASIARg1xIAQgAWsgAygCACIBaiEGIAAgAWtBDmohBwNAIAFBksYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNBiABQQ5GDQcgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMcQtB0gAhAiAEIAEiAEYNcCAEIAFrIAMoAgAiAWohBSAAIAFrQQFqIQYDQCABQZDGAGotAAAgAC0AACIHQSByIAcgB0HBAGtB/wFxQRpJG0H/AXFHDQUgAUEBRg0CIAFBAWohASAEIABBAWoiAEcNAAsgAyAFNgIADHALIAEgBEYEQEHRACECDHALAkACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcUHuAGsOBwA2NjY2NgE2CyABQQFqIQFBwgAhAgxWCyABQQFqIQFBwwAhAgxVCyADQQA2AgAgBkEBaiEBQcQAIQIMVAtB0AAhAiAEIAEiAEYNbSAEIAFrIAMoAgAiAWohBiAAIAFrQQlqIQcDQCABQYbGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQJBAiABQQlGDQQaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADG0LQc8AIQIgBCABIgBGDWwgBCABayADKAIAIgFqIQYgACABa0EFaiEHA0AgAUGAxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYNAiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxsCyAAIQEgA0EANgIADDALQQELOgAsIANBADYCACAHQQFqIQELQSwhAgxOCwJAA0AgAS0AAEGAxABqLQAAQQFHDQEgBCABQQFqIgFHDQALQc0AIQIMaAtBwQAhAgxNCyABIARGBEBBzAAhAgxnCyABLQAAQTpGBEAgAygCBCEAIANBADYCBCADIAAgARAvIgBFDTAgA0HLADYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxnCyADQQA2AhwgAyABNgIUIANBuRE2AhAgA0EKNgIMQQAhAgxmCwJAAkAgAy0ALEECaw4CAAEkCyADQTNqLQAAQQJxRQ0jIAMtAC5BAnENIyADQQA2AhwgAyABNgIUIANB1RM2AhAgA0ELNgIMQQAhAgxmCyADLQAyQSBxRQ0iIAMtAC5BAnENIiADQQA2AhwgAyABNgIUIANB7BI2AhAgA0EPNgIMQQAhAgxlC0EAIQACQCADKAI4IgJFDQAgAigCQCICRQ0AIAMgAhEAACEACyAARQRAQcAAIQIMSwsgAEEVRwRAIANBADYCHCADIAE2AhQgA0H4DjYCECADQRw2AgxBACECDGULIANBygA2AhwgAyABNgIUIANB8Bo2AhAgA0EVNgIMQQAhAgxkCyABIARHBEADQCABLQAAQfA/ai0AAEEBRw0XIAQgAUEBaiIBRw0AC0HEACECDGQLQcQAIQIMYwsgASAERwRAA0ACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcSIAQQlGDQAgAEEgRg0AAkACQAJAAkAgAEHjAGsOEwADAwMDAwMDAQMDAwMDAwMDAwIDCyABQQFqIQFBNSECDE4LIAFBAWohAUE2IQIMTQsgAUEBaiEBQTchAgxMCwwVCyAEIAFBAWoiAUcNAAtBPCECDGMLQTwhAgxiCyABIARGBEBByAAhAgxiCyADQRE2AgggAyABNgIEAkACQAJAAkACQCADLQAsQQFrDgQUAAECCQsgAy0AMkEgcQ0DQdEBIQIMSwsCQCADLwEyIgBBCHFFDQAgAy0AKEEBRw0AIAMtAC5BCHFFDQILIAMgAEH3+wNxQYAEcjsBMgwLCyADIAMvATJBEHI7ATIMBAsgA0EANgIEIAMgASABEDAiAARAIANBwQA2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMYwsgAUEBaiEBDFILIANBADYCHCADIAE2AhQgA0GjEzYCECADQQQ2AgxBACECDGELQccAIQIgASAERg1gIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEHwwwBqLQAAIAEtAABBIHJHDQEgAEEGRg1GIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADGELIANBADYCAAwFCwJAIAEgBEcEQANAIAEtAABB8MEAai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBxQAhAgxhC0HFACECDGALCyADQQA6ACwMAQtBCyECDEMLQT4hAgxCCwJAAkADQCABLQAAIgBBIEcEQAJAIABBCmsOBAMFBQMACyAAQSxGDQMMBAsgBCABQQFqIgFHDQALQcYAIQIMXQsgA0EIOgAsDA4LIAMtAChBAUcNAiADLQAuQQhxDQIgAygCBCEAIANBADYCBCADIAAgARAwIgAEQCADQcIANgIcIAMgADYCDCADIAFBAWo2AhRBACECDFwLIAFBAWohAQxKC0E6IQIMQAsCQANAIAEtAAAiAEEgRyAAQQlHcQ0BIAQgAUEBaiIBRw0AC0HDACECDFoLC0E7IQIMPgsCQAJAIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBAMEBAMECyAEIAFBAWoiAUcNAAtBPyECDFoLQT8hAgxZCyADIAMvATJBIHI7ATIMCgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFDUggA0E+NgIcIAMgATYCFCADIAA2AgxBACECDFcLAkAgASAERwRAA0AgAS0AAEHwwQBqLQAAIgBBAUcEQCAAQQJGDQMMDAsgBCABQQFqIgFHDQALQTchAgxYC0E3IQIMVwsgAUEBaiEBDAQLQTshAiAEIAEiAEYNVSAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcCQANAIAFBwMYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNASABQQVGBEBBByEBDDsLIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADFYLIANBADYCACAAIQEMBQtBOiECIAQgASIARg1UIAQgAWsgAygCACIBaiEGIAAgAWtBCGohBwJAA0AgAUHkP2otAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAUEIRgRAQQUhAQw6CyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxVCyADQQA2AgAgACEBDAQLQTkhAiAEIAEiAEYNUyAEIAFrIAMoAgAiAWohBiAAIAFrQQNqIQcCQANAIAFB4D9qLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBA0YEQEEGIQEMOQsgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMVAsgA0EANgIAIAAhAQwDCwJAA0AgAS0AACIAQSBHBEAgAEEKaw4EBwQEBwILIAQgAUEBaiIBRw0AC0E4IQIMUwsgAEEsRw0BIAFBAWohAEEBIQECQAJAAkACQAJAIAMtACxBBWsOBAMBAgQACyAAIQEMBAtBAiEBDAELQQQhAQsgA0EBOgAsIAMgAy8BMiABcjsBMiAAIQEMAQsgAyADLwEyQQhyOwEyIAAhAQtBPSECDDcLIANBADoALAtBOCECDDULIAEgBEYEQEE2IQIMTwsCQAJAAkACQAJAIAEtAABBCmsOBAACAgECCyADKAIEIQAgA0EANgIEIAMgACABEDAiAEUNAiADQTM2AhwgAyABNgIUIAMgADYCDEEAIQIMUgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFBEAgAUEBaiEBDAYLIANBMjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxRCyADLQAuQQFxBEBB0AEhAgw3CyADKAIEIQAgA0EANgIEIAMgACABEDAiAA0BDEMLQTMhAgw1CyADQTU2AhwgAyABNgIUIAMgADYCDEEAIQIMTgtBNCECDDMLIANBL2otAABBAXENACADQQA2AhwgAyABNgIUIANB8RU2AhAgA0EZNgIMQQAhAgxMC0EyIQIMMQsgASAERgRAQTIhAgxLCwJAIAEtAABBCkYEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQZgWNgIQIANBAzYCDEEAIQIMSwtBMSECDDALIAEgBEYEQEExIQIMSgsgAS0AACIAQQlHIABBIEdxDQEgAy0ALEEIRw0AIANBADoALAtBPCECDC4LQQEhAgJAAkACQAJAIAMtACxBBWsOBAMBAgAKCyADIAMvATJBCHI7ATIMCQtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgwGCyABIARGBEBBMCECDEcLIAEtAABBCkYEQCABQQFqIQEMAQsgAy0ALkEBcQ0AIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDEYLQS8hAgwrCyABQQFqIQFBMCECDCoLIAEgBEYEQEEvIQIMRAsgAS0AACIAQQlHIABBIEdxRQRAIAFBAWohASADLQAuQQFxDQEgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIMRAtBASECAkACQAJAAkACQAJAIAMtACxBAmsOBwUEBAMBAgAECyADIAMvATJBCHI7ATIMAwtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgtBLiECDCoLIANBADYCHCADIAE2AhQgA0GzEjYCECADQQs2AgxBACECDEMLQdIBIQIMKAsgASAERgRAQS4hAgxCCyADQQA2AgQgA0ERNgIIIAMgASABEDAiAA0BC0EtIQIMJgsgA0EtNgIcIAMgATYCFCADIAA2AgxBACECDD8LQQAhAAJAIAMoAjgiAkUNACACKAJEIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB2AA2AhwgAyABNgIUIANBnho2AhAgA0EVNgIMQQAhAgw+C0HLACECDCMLIANBADYCHCADIAE2AhQgA0GFDjYCECADQR02AgxBACECDDwLIAEgBEYEQEHOACECDDwLIAEtAAAiAEEgRg0CIABBOkYNAQsgA0EAOgAsQQkhAgwgCyADKAIEIQAgA0EANgIEIAMgACABEC8iAA0BDAILIAMtAC5BAXEEQEHPASECDB8LIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ0CIANBKjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgw4CyADQcsANgIcIAMgADYCDCADIAFBAWo2AhRBACECDDcLIAFBAWohAUE/IQIMHAsgAUEBaiEBDCkLIAEgBEYEQEErIQIMNQsCQCABLQAAQQpGBEAgAUEBaiEBDAELIAMtAC5BwABxRQ0GCyADLQAyQYABcQRAQQAhAAJAIAMoAjgiAkUNACACKAJUIgJFDQAgAyACEQAAIQALIABFDREgAEEVRgRAIANBBTYCHCADIAE2AhQgA0GGGjYCECADQRU2AgxBACECDDYLIANBADYCHCADIAE2AhQgA0HiDTYCECADQRQ2AgxBACECDDULIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsgAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIANBAToAMAsgAiACLwEAQcAAcjsBAAtBKiECDBcLIANBKTYCHCADIAE2AhQgA0GyGDYCECADQRU2AgxBACECDDALIANBADYCHCADIAE2AhQgA0HdCzYCECADQRE2AgxBACECDC8LIANBADYCHCADIAE2AhQgA0GdCzYCECADQQI2AgxBACECDC4LQQEhByADLwEyIgVBCHFFBEAgAykDIEIAUiEHCwJAIAMtADAEQEEBIQAgAy0AKUEFRg0BIAVBwABxRSAHcUUNAQsCQCADLQAoIgJBAkYEQEEBIQAgAy8BNCIGQeUARg0CQQAhACAFQcAAcQ0CIAZB5ABGDQIgBkHmAGtBAkkNAiAGQcwBRg0CIAZBsAJGDQIMAQtBACEAIAVBwABxDQELQQIhACAFQQhxDQAgBUGABHEEQAJAIAJBAUcNACADLQAuQQpxDQBBBSEADAILQQQhAAwBCyAFQSBxRQRAIAMQNUEAR0ECdCEADAELQQBBAyADKQMgUBshAAsCQCAAQQFrDgUAAQYHAgMLQQAhAgJAIAMoAjgiAEUNACAAKAIsIgBFDQAgAyAAEQAAIQILIAJFDSYgAkEVRgRAIANBAzYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDC4LQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDC0LQc4BIQIMEgtBACECIANBADYCHCADIAE2AhQgA0HkHzYCECADQQ82AgwMKwtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAA0BC0EOIQIMDwsgAEEVRgRAIANBAjYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDCkLQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDCgLQSkhAgwNCyADQQE6ADEMJAsgASAERwRAIANBCTYCCCADIAE2AgRBKCECDAwLQSYhAgwlCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMVARAQSUhAgwlCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDQAgA0EFNgIcIAMgATYCFCADIAA2AgwMJAtBDyECDAkLIAEgBEYEQEEjIQIMIwtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsONxcWAAECAwQFBgcUFBQUFBQUCAkKCwwNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQODxAREhMUC0ICIQoMFgtCAyEKDBULQgQhCgwUC0IFIQoMEwtCBiEKDBILQgchCgwRC0IIIQoMEAtCCSEKDA8LQgohCgwOC0ILIQoMDQtCDCEKDAwLQg0hCgwLC0IOIQoMCgtCDyEKDAkLQgohCgwIC0ILIQoMBwtCDCEKDAYLQg0hCgwFC0IOIQoMBAtCDyEKDAMLQQAhAiADQQA2AhwgAyABNgIUIANBzhQ2AhAgA0EMNgIMDCILIAEgBEYEQEEiIQIMIgtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQTBrDjcVFAABAgMEBQYHFhYWFhYWFggJCgsMDRYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWDg8QERITFgtCAiEKDBQLQgMhCgwTC0IEIQoMEgtCBSEKDBELQgYhCgwQC0IHIQoMDwtCCCEKDA4LQgkhCgwNC0IKIQoMDAtCCyEKDAsLQgwhCgwKC0INIQoMCQtCDiEKDAgLQg8hCgwHC0IKIQoMBgtCCyEKDAULQgwhCgwEC0INIQoMAwtCDiEKDAILQg8hCgwBC0IBIQoLIAFBAWohASADKQMgIgtC//////////8PWARAIAMgC0IEhiAKhDcDIAwCC0EAIQIgA0EANgIcIAMgATYCFCADQa0JNgIQIANBDDYCDAwfC0ElIQIMBAtBJiECDAMLIAMgAToALCADQQA2AgAgB0EBaiEBQQwhAgwCCyADQQA2AgAgBkEBaiEBQQohAgwBCyABQQFqIQFBCCECDAALAAtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMGAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMFwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMFgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMFQtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMFAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMEwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMEgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMEQtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMEAtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMDwtBACECIANBADYCHCADIAE2AhQgA0HIEjYCECADQQs2AgwMDgtBACECIANBADYCHCADIAE2AhQgA0GVCTYCECADQQs2AgwMDQtBACECIANBADYCHCADIAE2AhQgA0HpDzYCECADQQo2AgwMDAtBACECIANBADYCHCADIAE2AhQgA0GDEDYCECADQQo2AgwMCwtBACECIANBADYCHCADIAE2AhQgA0GmHDYCECADQQI2AgwMCgtBACECIANBADYCHCADIAE2AhQgA0HFFTYCECADQQI2AgwMCQtBACECIANBADYCHCADIAE2AhQgA0H/FzYCECADQQI2AgwMCAtBACECIANBADYCHCADIAE2AhQgA0HKFzYCECADQQI2AgwMBwsgA0ECNgIcIAMgATYCFCADQZQdNgIQIANBFjYCDEEAIQIMBgtB3gAhAiABIARGDQUgCUEIaiEHIAMoAgAhBQJAAkAgASAERwRAIAVBxsYAaiEIIAQgBWogAWshBiAFQX9zQQpqIgUgAWohAANAIAEtAAAgCC0AAEcEQEECIQgMAwsgBUUEQEEAIQggACEBDAMLIAVBAWshBSAIQQFqIQggBCABQQFqIgFHDQALIAYhBSAEIQELIAdBATYCACADIAU2AgAMAQsgA0EANgIAIAcgCDYCAAsgByABNgIEIAkoAgwhACAJKAIIDgMBBQIACwALIANBADYCHCADQa0dNgIQIANBFzYCDCADIABBAWo2AhRBACECDAMLIANBADYCHCADIAA2AhQgA0HCHTYCECADQQk2AgxBACECDAILIAEgBEYEQEEoIQIMAgsgA0EJNgIIIAMgATYCBEEnIQIMAQsgASAERgRAQQEhAgwBCwNAAkACQAJAIAEtAABBCmsOBAABAQABCyABQQFqIQEMAQsgAUEBaiEBIAMtAC5BIHENAEEAIQIgA0EANgIcIAMgATYCFCADQYwgNgIQIANBBTYCDAwCC0EBIQIgASAERw0ACwsgCUEQaiQAIAJFBEAgAygCDCEADAELIAMgAjYCHEEAIQAgAygCBCIBRQ0AIAMgASAEIAMoAggRAQAiAUUNACADIAQ2AhQgAyABNgIMIAEhAAsgAAu+AgECfyAAQQA6AAAgAEHcAGoiAUEBa0EAOgAAIABBADoAAiAAQQA6AAEgAUEDa0EAOgAAIAFBAmtBADoAACAAQQA6AAMgAUEEa0EAOgAAQQAgAGtBA3EiASAAaiIAQQA2AgBB3AAgAWtBfHEiAiAAaiIBQQRrQQA2AgACQCACQQlJDQAgAEEANgIIIABBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIAJBGUkNACAAQQA2AhggAEEANgIUIABBADYCECAAQQA2AgwgAUEQa0EANgIAIAFBFGtBADYCACABQRhrQQA2AgAgAUEca0EANgIAIAIgAEEEcUEYciICayIBQSBJDQAgACACaiEAA0AgAEIANwMYIABCADcDECAAQgA3AwggAEIANwMAIABBIGohACABQSBrIgFBH0sNAAsLC1YBAX8CQCAAKAIMDQACQAJAAkACQCAALQAxDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgAREAACIBDQMLQQAPCwALIABB0Bg2AhBBDiEBCyABCxoAIAAoAgxFBEAgAEHJHjYCECAAQRU2AgwLCxQAIAAoAgxBFUYEQCAAQQA2AgwLCxQAIAAoAgxBFkYEQCAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsXACAAQSRPBEAACyAAQQJ0QZQ3aigCAAsXACAAQS9PBEAACyAAQQJ0QaQ4aigCAAu/CQEBf0HfLCEBAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHkAGsO9ANjYgABYWFhYWFhAgMEBWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEGBwgJCgsMDQ4PYWFhYWEQYWFhYWFhYWFhYWERYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhEhMUFRYXGBkaG2FhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEcHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTZhNzg5OmFhYWFhYWFhO2FhYTxhYWFhPT4/YWFhYWFhYWFAYWFBYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhQkNERUZHSElKS0xNTk9QUVJTYWFhYWFhYWFUVVZXWFlaW2FcXWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYV5hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFfYGELQdUrDwtBgyUPC0G/MA8LQfI1DwtBtCgPC0GfKA8LQYEsDwtB1ioPC0H0Mw8LQa0zDwtByygPC0HOIw8LQcAjDwtB2SMPC0HRJA8LQZwzDwtBojYPC0H8Mw8LQeArDwtB4SUPC0HtIA8LQcQyDwtBqScPC0G5Ng8LQbggDwtBqyAPC0GjJA8LQbYkDwtBgSMPC0HhMg8LQZ80DwtByCkPC0HAMg8LQe4yDwtB8C8PC0HGNA8LQdAhDwtBmiQPC0HrLw8LQYQ1DwtByzUPC0GWMQ8LQcgrDwtB1C8PC0GTMA8LQd81DwtBtCMPC0G+NQ8LQdIpDwtBsyIPC0HNIA8LQZs2DwtBkCEPC0H/IA8LQa01DwtBsDQPC0HxJA8LQacqDwtB3TAPC0GLIg8LQcgvDwtB6yoPC0H0KQ8LQY8lDwtB3SIPC0HsJg8LQf0wDwtB1iYPC0GUNQ8LQY0jDwtBuikPC0HHIg8LQfIlDwtBtjMPC0GiIQ8LQf8vDwtBwCEPC0GBMw8LQcklDwtBqDEPC0HGMw8LQdM2DwtBxjYPC0HkNA8LQYgmDwtB7ScPC0H4IQ8LQakwDwtBjzQPC0GGNg8LQaovDwtBoSYPC0HsNg8LQZIpDwtBryYPC0GZIg8LQeAhDwsAC0G1JSEBCyABCxcAIAAgAC8BLkH+/wNxIAFBAEdyOwEuCxoAIAAgAC8BLkH9/wNxIAFBAEdBAXRyOwEuCxoAIAAgAC8BLkH7/wNxIAFBAEdBAnRyOwEuCxoAIAAgAC8BLkH3/wNxIAFBAEdBA3RyOwEuCxoAIAAgAC8BLkHv/wNxIAFBAEdBBHRyOwEuCxoAIAAgAC8BLkHf/wNxIAFBAEdBBXRyOwEuCxoAIAAgAC8BLkG//wNxIAFBAEdBBnRyOwEuCxoAIAAgAC8BLkH//gNxIAFBAEdBB3RyOwEuCxoAIAAgAC8BLkH//QNxIAFBAEdBCHRyOwEuCxoAIAAgAC8BLkH/+wNxIAFBAEdBCXRyOwEuCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBzhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB5Ao2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB5R02AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBnRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBoh42AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7hQ2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9xs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRU2AhBBGCEECyAECzgAIAACfyAALwEyQRRxQRRGBEBBASAALQAoQQFGDQEaIAAvATRB5QBGDAELIAAtAClBBUYLOgAwC1kBAn8CQCAALQAoQQFGDQAgAC8BNCIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMiIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEyIgFBAnFFDQEMAgsgAC8BMiIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATQiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtXACAAQRhqQgA3AwAgAEIANwMAIABBOGpCADcDACAAQTBqQgA3AwAgAEEoakIANwMAIABBIGpCADcDACAAQRBqQgA3AwAgAEEIakIANwMAIABB7AE2AhwLBgAgABA5C5otAQt/IwBBEGsiCiQAQZjUACgCACIJRQRAQdjXACgCACIFRQRAQeTXAEJ/NwIAQdzXAEKAgISAgIDAADcCAEHY1wAgCkEIakFwcUHYqtWqBXMiBTYCAEHs1wBBADYCAEG81wBBADYCAAtBwNcAQYDYBDYCAEGQ1ABBgNgENgIAQaTUACAFNgIAQaDUAEF/NgIAQcTXAEGAqAM2AgADQCABQbzUAGogAUGw1ABqIgI2AgAgAiABQajUAGoiAzYCACABQbTUAGogAzYCACABQcTUAGogAUG41ABqIgM2AgAgAyACNgIAIAFBzNQAaiABQcDUAGoiAjYCACACIAM2AgAgAUHI1ABqIAI2AgAgAUEgaiIBQYACRw0AC0GM2ARBwacDNgIAQZzUAEHo1wAoAgA2AgBBjNQAQcCnAzYCAEGY1ABBiNgENgIAQcz/B0E4NgIAQYjYBCEJCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFNBEBBgNQAKAIAIgZBECAAQRNqQXBxIABBC0kbIgRBA3YiAHYiAUEDcQRAAkAgAUEBcSAAckEBcyICQQN0IgBBqNQAaiIBIABBsNQAaigCACIAKAIIIgNGBEBBgNQAIAZBfiACd3E2AgAMAQsgASADNgIIIAMgATYCDAsgAEEIaiEBIAAgAkEDdCICQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDBELQYjUACgCACIIIARPDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxaCIAQQN0IgJBqNQAaiIBIAJBsNQAaigCACICKAIIIgNGBEBBgNQAIAZBfiAAd3EiBjYCAAwBCyABIAM2AgggAyABNgIMCyACIARBA3I2AgQgAEEDdCIAIARrIQUgACACaiAFNgIAIAIgBGoiBCAFQQFyNgIEIAgEQCAIQXhxQajUAGohAEGU1AAoAgAhAwJ/QQEgCEEDdnQiASAGcUUEQEGA1AAgASAGcjYCACAADAELIAAoAggLIgEgAzYCDCAAIAM2AgggAyAANgIMIAMgATYCCAsgAkEIaiEBQZTUACAENgIAQYjUACAFNgIADBELQYTUACgCACILRQ0BIAtoQQJ0QbDWAGooAgAiACgCBEF4cSAEayEFIAAhAgNAAkAgAigCECIBRQRAIAJBFGooAgAiAUUNAQsgASgCBEF4cSAEayIDIAVJIQIgAyAFIAIbIQUgASAAIAIbIQAgASECDAELCyAAKAIYIQkgACgCDCIDIABHBEBBkNQAKAIAGiADIAAoAggiATYCCCABIAM2AgwMEAsgAEEUaiICKAIAIgFFBEAgACgCECIBRQ0DIABBEGohAgsDQCACIQcgASIDQRRqIgIoAgAiAQ0AIANBEGohAiADKAIQIgENAAsgB0EANgIADA8LQX8hBCAAQb9/Sw0AIABBE2oiAUFwcSEEQYTUACgCACIIRQ0AQQAgBGshBQJAAkACQAJ/QQAgBEGAAkkNABpBHyAEQf///wdLDQAaIARBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmoLIgZBAnRBsNYAaigCACICRQRAQQAhAUEAIQMMAQtBACEBIARBGSAGQQF2a0EAIAZBH0cbdCEAQQAhAwNAAkAgAigCBEF4cSAEayIHIAVPDQAgAiEDIAciBQ0AQQAhBSACIQEMAwsgASACQRRqKAIAIgcgByACIABBHXZBBHFqQRBqKAIAIgJGGyABIAcbIQEgAEEBdCEAIAINAAsLIAEgA3JFBEBBACEDQQIgBnQiAEEAIABrciAIcSIARQ0DIABoQQJ0QbDWAGooAgAhAQsgAUUNAQsDQCABKAIEQXhxIARrIgIgBUkhACACIAUgABshBSABIAMgABshAyABKAIQIgAEfyAABSABQRRqKAIACyIBDQALCyADRQ0AIAVBiNQAKAIAIARrTw0AIAMoAhghByADIAMoAgwiAEcEQEGQ1AAoAgAaIAAgAygCCCIBNgIIIAEgADYCDAwOCyADQRRqIgIoAgAiAUUEQCADKAIQIgFFDQMgA0EQaiECCwNAIAIhBiABIgBBFGoiAigCACIBDQAgAEEQaiECIAAoAhAiAQ0ACyAGQQA2AgAMDQtBiNQAKAIAIgMgBE8EQEGU1AAoAgAhAQJAIAMgBGsiAkEQTwRAIAEgBGoiACACQQFyNgIEIAEgA2ogAjYCACABIARBA3I2AgQMAQsgASADQQNyNgIEIAEgA2oiACAAKAIEQQFyNgIEQQAhAEEAIQILQYjUACACNgIAQZTUACAANgIAIAFBCGohAQwPC0GM1AAoAgAiAyAESwRAIAQgCWoiACADIARrIgFBAXI2AgRBmNQAIAA2AgBBjNQAIAE2AgAgCSAEQQNyNgIEIAlBCGohAQwPC0EAIQEgBAJ/QdjXACgCAARAQeDXACgCAAwBC0Hk1wBCfzcCAEHc1wBCgICEgICAwAA3AgBB2NcAIApBDGpBcHFB2KrVqgVzNgIAQezXAEEANgIAQbzXAEEANgIAQYCABAsiACAEQccAaiIFaiIGQQAgAGsiB3EiAk8EQEHw1wBBMDYCAAwPCwJAQbjXACgCACIBRQ0AQbDXACgCACIIIAJqIQAgACABTSAAIAhLcQ0AQQAhAUHw1wBBMDYCAAwPC0G81wAtAABBBHENBAJAAkAgCQRAQcDXACEBA0AgASgCACIAIAlNBEAgACABKAIEaiAJSw0DCyABKAIIIgENAAsLQQAQOiIAQX9GDQUgAiEGQdzXACgCACIBQQFrIgMgAHEEQCACIABrIAAgA2pBACABa3FqIQYLIAQgBk8NBSAGQf7///8HSw0FQbjXACgCACIDBEBBsNcAKAIAIgcgBmohASABIAdNDQYgASADSw0GCyAGEDoiASAARw0BDAcLIAYgA2sgB3EiBkH+////B0sNBCAGEDohACAAIAEoAgAgASgCBGpGDQMgACEBCwJAIAYgBEHIAGpPDQAgAUF/Rg0AQeDXACgCACIAIAUgBmtqQQAgAGtxIgBB/v///wdLBEAgASEADAcLIAAQOkF/RwRAIAAgBmohBiABIQAMBwtBACAGaxA6GgwECyABIgBBf0cNBQwDC0EAIQMMDAtBACEADAoLIABBf0cNAgtBvNcAQbzXACgCAEEEcjYCAAsgAkH+////B0sNASACEDohAEEAEDohASAAQX9GDQEgAUF/Rg0BIAAgAU8NASABIABrIgYgBEE4ak0NAQtBsNcAQbDXACgCACAGaiIBNgIAQbTXACgCACABSQRAQbTXACABNgIACwJAAkACQEGY1AAoAgAiAgRAQcDXACEBA0AgACABKAIAIgMgASgCBCIFakYNAiABKAIIIgENAAsMAgtBkNQAKAIAIgFBAEcgACABT3FFBEBBkNQAIAA2AgALQQAhAUHE1wAgBjYCAEHA1wAgADYCAEGg1ABBfzYCAEGk1ABB2NcAKAIANgIAQczXAEEANgIAA0AgAUG81ABqIAFBsNQAaiICNgIAIAIgAUGo1ABqIgM2AgAgAUG01ABqIAM2AgAgAUHE1ABqIAFBuNQAaiIDNgIAIAMgAjYCACABQczUAGogAUHA1ABqIgI2AgAgAiADNgIAIAFByNQAaiACNgIAIAFBIGoiAUGAAkcNAAtBeCAAa0EPcSIBIABqIgIgBkE4ayIDIAFrIgFBAXI2AgRBnNQAQejXACgCADYCAEGM1AAgATYCAEGY1AAgAjYCACAAIANqQTg2AgQMAgsgACACTQ0AIAIgA0kNACABKAIMQQhxDQBBeCACa0EPcSIAIAJqIgNBjNQAKAIAIAZqIgcgAGsiAEEBcjYCBCABIAUgBmo2AgRBnNQAQejXACgCADYCAEGM1AAgADYCAEGY1AAgAzYCACACIAdqQTg2AgQMAQsgAEGQ1AAoAgBJBEBBkNQAIAA2AgALIAAgBmohA0HA1wAhAQJAAkACQANAIAMgASgCAEcEQCABKAIIIgENAQwCCwsgAS0ADEEIcUUNAQtBwNcAIQEDQCABKAIAIgMgAk0EQCADIAEoAgRqIgUgAksNAwsgASgCCCEBDAALAAsgASAANgIAIAEgASgCBCAGajYCBCAAQXggAGtBD3FqIgkgBEEDcjYCBCADQXggA2tBD3FqIgYgBCAJaiIEayEBIAIgBkYEQEGY1AAgBDYCAEGM1ABBjNQAKAIAIAFqIgA2AgAgBCAAQQFyNgIEDAgLQZTUACgCACAGRgRAQZTUACAENgIAQYjUAEGI1AAoAgAgAWoiADYCACAEIABBAXI2AgQgACAEaiAANgIADAgLIAYoAgQiBUEDcUEBRw0GIAVBeHEhCCAFQf8BTQRAIAVBA3YhAyAGKAIIIgAgBigCDCICRgRAQYDUAEGA1AAoAgBBfiADd3E2AgAMBwsgAiAANgIIIAAgAjYCDAwGCyAGKAIYIQcgBiAGKAIMIgBHBEAgACAGKAIIIgI2AgggAiAANgIMDAULIAZBFGoiAigCACIFRQRAIAYoAhAiBUUNBCAGQRBqIQILA0AgAiEDIAUiAEEUaiICKAIAIgUNACAAQRBqIQIgACgCECIFDQALIANBADYCAAwEC0F4IABrQQ9xIgEgAGoiByAGQThrIgMgAWsiAUEBcjYCBCAAIANqQTg2AgQgAiAFQTcgBWtBD3FqQT9rIgMgAyACQRBqSRsiA0EjNgIEQZzUAEHo1wAoAgA2AgBBjNQAIAE2AgBBmNQAIAc2AgAgA0EQakHI1wApAgA3AgAgA0HA1wApAgA3AghByNcAIANBCGo2AgBBxNcAIAY2AgBBwNcAIAA2AgBBzNcAQQA2AgAgA0EkaiEBA0AgAUEHNgIAIAUgAUEEaiIBSw0ACyACIANGDQAgAyADKAIEQX5xNgIEIAMgAyACayIFNgIAIAIgBUEBcjYCBCAFQf8BTQRAIAVBeHFBqNQAaiEAAn9BgNQAKAIAIgFBASAFQQN2dCIDcUUEQEGA1AAgASADcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbDWAGohAEGE1AAoAgAiA0EBIAF0IgZxRQRAIAAgAjYCAEGE1AAgAyAGcjYCACACIAA2AhggAiACNgIIIAIgAjYCDAwBCyAFQRkgAUEBdmtBACABQR9HG3QhASAAKAIAIQMCQANAIAMiACgCBEF4cSAFRg0BIAFBHXYhAyABQQF0IQEgACADQQRxakEQaiIGKAIAIgMNAAsgBiACNgIAIAIgADYCGCACIAI2AgwgAiACNgIIDAELIAAoAggiASACNgIMIAAgAjYCCCACQQA2AhggAiAANgIMIAIgATYCCAtBjNQAKAIAIgEgBE0NAEGY1AAoAgAiACAEaiICIAEgBGsiAUEBcjYCBEGM1AAgATYCAEGY1AAgAjYCACAAIARBA3I2AgQgAEEIaiEBDAgLQQAhAUHw1wBBMDYCAAwHC0EAIQALIAdFDQACQCAGKAIcIgJBAnRBsNYAaiIDKAIAIAZGBEAgAyAANgIAIAANAUGE1ABBhNQAKAIAQX4gAndxNgIADAILIAdBEEEUIAcoAhAgBkYbaiAANgIAIABFDQELIAAgBzYCGCAGKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAGQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAIaiEBIAYgCGoiBigCBCEFCyAGIAVBfnE2AgQgASAEaiABNgIAIAQgAUEBcjYCBCABQf8BTQRAIAFBeHFBqNQAaiEAAn9BgNQAKAIAIgJBASABQQN2dCIBcUUEQEGA1AAgASACcjYCACAADAELIAAoAggLIgEgBDYCDCAAIAQ2AgggBCAANgIMIAQgATYCCAwBC0EfIQUgAUH///8HTQRAIAFBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmohBQsgBCAFNgIcIARCADcCECAFQQJ0QbDWAGohAEGE1AAoAgAiAkEBIAV0IgNxRQRAIAAgBDYCAEGE1AAgAiADcjYCACAEIAA2AhggBCAENgIIIAQgBDYCDAwBCyABQRkgBUEBdmtBACAFQR9HG3QhBSAAKAIAIQACQANAIAAiAigCBEF4cSABRg0BIAVBHXYhACAFQQF0IQUgAiAAQQRxakEQaiIDKAIAIgANAAsgAyAENgIAIAQgAjYCGCAEIAQ2AgwgBCAENgIIDAELIAIoAggiACAENgIMIAIgBDYCCCAEQQA2AhggBCACNgIMIAQgADYCCAsgCUEIaiEBDAILAkAgB0UNAAJAIAMoAhwiAUECdEGw1gBqIgIoAgAgA0YEQCACIAA2AgAgAA0BQYTUACAIQX4gAXdxIgg2AgAMAgsgB0EQQRQgBygCECADRhtqIAA2AgAgAEUNAQsgACAHNgIYIAMoAhAiAQRAIAAgATYCECABIAA2AhgLIANBFGooAgAiAUUNACAAQRRqIAE2AgAgASAANgIYCwJAIAVBD00EQCADIAQgBWoiAEEDcjYCBCAAIANqIgAgACgCBEEBcjYCBAwBCyADIARqIgIgBUEBcjYCBCADIARBA3I2AgQgAiAFaiAFNgIAIAVB/wFNBEAgBUF4cUGo1ABqIQACf0GA1AAoAgAiAUEBIAVBA3Z0IgVxRQRAQYDUACABIAVyNgIAIAAMAQsgACgCCAsiASACNgIMIAAgAjYCCCACIAA2AgwgAiABNgIIDAELQR8hASAFQf///wdNBEAgBUEmIAVBCHZnIgBrdkEBcSAAQQF0a0E+aiEBCyACIAE2AhwgAkIANwIQIAFBAnRBsNYAaiEAQQEgAXQiBCAIcUUEQCAAIAI2AgBBhNQAIAQgCHI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEEAkADQCAEIgAoAgRBeHEgBUYNASABQR12IQQgAUEBdCEBIAAgBEEEcWpBEGoiBigCACIEDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLIANBCGohAQwBCwJAIAlFDQACQCAAKAIcIgFBAnRBsNYAaiICKAIAIABGBEAgAiADNgIAIAMNAUGE1AAgC0F+IAF3cTYCAAwCCyAJQRBBFCAJKAIQIABGG2ogAzYCACADRQ0BCyADIAk2AhggACgCECIBBEAgAyABNgIQIAEgAzYCGAsgAEEUaigCACIBRQ0AIANBFGogATYCACABIAM2AhgLAkAgBUEPTQRAIAAgBCAFaiIBQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAELIAAgBGoiByAFQQFyNgIEIAAgBEEDcjYCBCAFIAdqIAU2AgAgCARAIAhBeHFBqNQAaiEBQZTUACgCACEDAn9BASAIQQN2dCICIAZxRQRAQYDUACACIAZyNgIAIAEMAQsgASgCCAsiAiADNgIMIAEgAzYCCCADIAE2AgwgAyACNgIIC0GU1AAgBzYCAEGI1AAgBTYCAAsgAEEIaiEBCyAKQRBqJAAgAQtDACAARQRAPwBBEHQPCwJAIABB//8DcQ0AIABBAEgNACAAQRB2QAAiAEF/RgRAQfDXAEEwNgIAQX8PCyAAQRB0DwsACwvbQCIAQYAICwkBAAAAAgAAAAMAQZQICwUEAAAABQBBpAgLCQYAAAAHAAAACABB3AgLgjFJbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBFeHBlY3RlZCBMRiBhZnRlciBoZWFkZXJzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABUcmFuc2Zlci1FbmNvZGluZyBjYW4ndCBiZSBwcmVzZW50IHdpdGggQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBzaXplAEV4cGVjdGVkIExGIGFmdGVyIGNodW5rIHNpemUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBleHRlbnNpb24gdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIHF1b3RlZC1wYWlyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciByZXNwb25zZSBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIG5hbWUASW52YWxpZCBzdGF0dXMgY29kZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGRhdGEARXhwZWN0ZWQgTEYgYWZ0ZXIgY2h1bmsgZGF0YQBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AARGF0YSBhZnRlciBgQ29ubmVjdGlvbjogY2xvc2VgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBRVUVSWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAEV4cGVjdGVkIExGIGFmdGVyIENSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAUhUAABoVAAAPEgAA5BkAAJEVAAAJFAAALRkAAOQUAADpEQAAaRQAAKEUAAB2FQAAQxYAAF4SAACUFwAAFxYAAH0UAAB/FgAAQRcAALMTAADDFgAABBoAAL0YAADQGAAAoBMAANQZAACvFgAAaBYAAHAXAADZFgAA/BgAAP4RAABZFwAAlxYAABwXAAD2FgAAjRcAAAsSAAB/GwAALhEAALMQAABJEgAArRIAAPYYAABoEAAAYhUAABAVAABaFgAAShkAALUVAADBFQAAYBUAAFwZAABaGQAAUxkAABYVAACtEQAAQhAAALcQAABXGAAAvxUAAIkQAAAcGQAAGhkAALkVAABRGAAA3BMAAFsVAABZFQAA5hgAAGcVAAARGQAA7RgAAOcTAACuEAAAwhcAAAAUAACSEwAAhBMAAEASAAAmGQAArxUAAGIQAEHpOQsBAQBBgDoL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB6jsLBAEAAAIAQYE8C14DBAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAUAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEHqPQsEAQAAAgBBgT4LXgMAAwMDAwMAAAMDAAMDAAMDAwMDAwMDAwMABAAFAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAAMAQeA/Cw1sb3NlZWVwLWFsaXZlAEH5PwsBAQBBkMAAC+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnBAAsBAQBBkMIAC+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGhxAALXgEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAQYDGAAshZWN0aW9uZW50LWxlbmd0aG9ucm94eS1jb25uZWN0aW9uAEGwxgALK3JhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KU00NCg0KVFRQL0NFL1RTUC8AQenGAAsFAQIAAQMAQYDHAAtfBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQenIAAsFAQIAAQMAQYDJAAtfBAUFBgUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQenKAAsEAQAAAQBBgcsAC14CAgACAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAEHpzAALBQECAAEDAEGAzQALXwQFAAAFBQUFBQUFBQUFBQYFBQUFBQUFBQUFBQUABQAHCAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAUABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAAAAFAEHpzgALBQEBAAEBAEGAzwALAQEAQZrPAAtBAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQenQAAsFAQEAAQEAQYDRAAsBAQBBitEACwYCAAAAAAIAQaHRAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB4NIAC5oBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRVVFUllPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
    var wasmBuffer;
    Object.defineProperty(module, "exports", {
      get: () => {
        return wasmBuffer ? wasmBuffer : wasmBuffer = Buffer2.from(wasmBase64, "base64");
      }
    });
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports, module) {
    var { Buffer: Buffer2 } = __require("buffer");
    var wasmBase64 = "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzQzBQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEDAAADAAAABAUBcAESEgUDAQACBggBfwFBgNgECwfFBygGbWVtb3J5AgALX2luaXRpYWxpemUACBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQACRhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUANgxsbGh0dHBfYWxsb2MACwZtYWxsb2MAOAtsbGh0dHBfZnJlZQAMBGZyZWUADA9sbGh0dHBfZ2V0X3R5cGUADRVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADhVsbGh0dHBfZ2V0X2h0dHBfbWlub3IADxFsbGh0dHBfZ2V0X21ldGhvZAAQFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAERJsbGh0dHBfZ2V0X3VwZ3JhZGUAEgxsbGh0dHBfcmVzZXQAEw5sbGh0dHBfZXhlY3V0ZQAUFGxsaHR0cF9zZXR0aW5nc19pbml0ABUNbGxodHRwX2ZpbmlzaAAWDGxsaHR0cF9wYXVzZQAXDWxsaHR0cF9yZXN1bWUAGBtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGRBsbGh0dHBfZ2V0X2Vycm5vABoXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AGxdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAcFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB0RbGxodHRwX2Vycm5vX25hbWUAHhJsbGh0dHBfbWV0aG9kX25hbWUAHxJsbGh0dHBfc3RhdHVzX25hbWUAIBpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAhIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAiHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACMkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACQabGxodHRwX3NldF9sZW5pZW50X3ZlcnNpb24AJSNsbGh0dHBfc2V0X2xlbmllbnRfZGF0YV9hZnRlcl9jbG9zZQAmJ2xsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9sZl9hZnRlcl9jcgAnLGxsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9jcmxmX2FmdGVyX2NodW5rACgobGxodHRwX3NldF9sZW5pZW50X29wdGlvbmFsX2NyX2JlZm9yZV9sZgApKmxsaHR0cF9zZXRfbGVuaWVudF9zcGFjZXNfYWZ0ZXJfY2h1bmtfc2l6ZQAqGGxsaHR0cF9tZXNzYWdlX25lZWRzX2VvZgA1CRcBAEEBCxEBAgMEBQoGBzEzMi0uLCsvMArYywIzFgBB/NMAKAIABEAAC0H80wBBATYCAAsUACAAEDcgACACNgI4IAAgAToAKAsUACAAIAAvATQgAC0AMCAAEDYQAAseAQF/QcAAEDkiARA3IAFBgAg2AjggASAAOgAoIAELjwwBB38CQCAARQ0AIABBCGsiASAAQQRrKAIAIgBBeHEiBGohBQJAIABBAXENACAAQQNxRQ0BIAEgASgCACIAayIBQZDUACgCAEkNASAAIARqIQQCQAJAQZTUACgCACABRwRAIABB/wFNBEAgAEEDdiEDIAEoAggiACABKAIMIgJGBEBBgNQAQYDUACgCAEF+IAN3cTYCAAwFCyACIAA2AgggACACNgIMDAQLIAEoAhghBiABIAEoAgwiAEcEQCAAIAEoAggiAjYCCCACIAA2AgwMAwsgAUEUaiIDKAIAIgJFBEAgASgCECICRQ0CIAFBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUoAgQiAEEDcUEDRw0CIAUgAEF+cTYCBEGI1AAgBDYCACAFIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAEoAhwiAkECdEGw1gBqIgMoAgAgAUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECABRhtqIAA2AgAgAEUNAQsgACAGNgIYIAEoAhAiAgRAIAAgAjYCECACIAA2AhgLIAFBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIAVPDQAgBSgCBCIAQQFxRQ0AAkACQAJAAkAgAEECcUUEQEGY1AAoAgAgBUYEQEGY1AAgATYCAEGM1ABBjNQAKAIAIARqIgA2AgAgASAAQQFyNgIEIAFBlNQAKAIARw0GQYjUAEEANgIAQZTUAEEANgIADAYLQZTUACgCACAFRgRAQZTUACABNgIAQYjUAEGI1AAoAgAgBGoiADYCACABIABBAXI2AgQgACABaiAANgIADAYLIABBeHEgBGohBCAAQf8BTQRAIABBA3YhAyAFKAIIIgAgBSgCDCICRgRAQYDUAEGA1AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyAFKAIYIQYgBSAFKAIMIgBHBEBBkNQAKAIAGiAAIAUoAggiAjYCCCACIAA2AgwMAwsgBUEUaiIDKAIAIgJFBEAgBSgCECICRQ0CIAVBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUgAEF+cTYCBCABIARqIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAUoAhwiAkECdEGw1gBqIgMoAgAgBUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECAFRhtqIAA2AgAgAEUNAQsgACAGNgIYIAUoAhAiAgRAIAAgAjYCECACIAA2AhgLIAVBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIARqIAQ2AgAgASAEQQFyNgIEIAFBlNQAKAIARw0AQYjUACAENgIADAELIARB/wFNBEAgBEF4cUGo1ABqIQACf0GA1AAoAgAiAkEBIARBA3Z0IgNxRQRAQYDUACACIANyNgIAIAAMAQsgACgCCAsiAiABNgIMIAAgATYCCCABIAA2AgwgASACNgIIDAELQR8hAiAEQf///wdNBEAgBEEmIARBCHZnIgBrdkEBcSAAQQF0a0E+aiECCyABIAI2AhwgAUIANwIQIAJBAnRBsNYAaiEAAkBBhNQAKAIAIgNBASACdCIHcUUEQCAAIAE2AgBBhNQAIAMgB3I2AgAgASAANgIYIAEgATYCCCABIAE2AgwMAQsgBEEZIAJBAXZrQQAgAkEfRxt0IQIgACgCACEAAkADQCAAIgMoAgRBeHEgBEYNASACQR12IQAgAkEBdCECIAMgAEEEcWpBEGoiBygCACIADQALIAcgATYCACABIAM2AhggASABNgIMIAEgATYCCAwBCyADKAIIIgAgATYCDCADIAE2AgggAUEANgIYIAEgAzYCDCABIAA2AggLQaDUAEGg1AAoAgBBAWsiAEF/IAAbNgIACwsHACAALQAoCwcAIAAtACoLBwAgAC0AKwsHACAALQApCwcAIAAvATQLBwAgAC0AMAtAAQR/IAAoAhghASAALwEuIQIgAC0AKCEDIAAoAjghBCAAEDcgACAENgI4IAAgAzoAKCAAIAI7AS4gACABNgIYC8X4AQIHfwN+IAEgAmohBAJAIAAiAygCDCIADQAgAygCBARAIAMgATYCBAsjAEEQayIJJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAygCHCICQQFrDuwB7gEB6AECAwQFBgcICQoLDA0ODxAREucBE+YBFBXlARYX5AEYGRobHB0eHyDvAe0BIeMBIiMkJSYnKCkqK+IBLC0uLzAxMuEB4AEzNN8B3gE1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk/pAVBRUlPdAdwBVNsBVdoBVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHZAdgBxgHXAccB1gHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAQDqAQtBAAzUAQtBDgzTAQtBDQzSAQtBDwzRAQtBEAzQAQtBEQzPAQtBEgzOAQtBEwzNAQtBFAzMAQtBFQzLAQtBFgzKAQtBFwzJAQtBGAzIAQtBGQzHAQtBGgzGAQtBGwzFAQtBHAzEAQtBHQzDAQtBHgzCAQtBHwzBAQtBCAzAAQtBIAy/AQtBIgy+AQtBIQy9AQtBBwy8AQtBIwy7AQtBJAy6AQtBJQy5AQtBJgy4AQtBJwy3AQtBzgEMtgELQSgMtQELQSkMtAELQSoMswELQSsMsgELQc8BDLEBC0EtDLABC0EuDK8BC0EvDK4BC0EwDK0BC0ExDKwBC0EyDKsBC0EzDKoBC0HQAQypAQtBNAyoAQtBOAynAQtBDAymAQtBNQylAQtBNgykAQtBNwyjAQtBPQyiAQtBOQyhAQtB0QEMoAELQQsMnwELQT4MngELQToMnQELQQoMnAELQTsMmwELQTwMmgELQdIBDJkBC0HAAAyYAQtBPwyXAQtBwQAMlgELQQkMlQELQSwMlAELQcIADJMBC0HDAAySAQtBxAAMkQELQcUADJABC0HGAAyPAQtBxwAMjgELQcgADI0BC0HJAAyMAQtBygAMiwELQcsADIoBC0HMAAyJAQtBzQAMiAELQc4ADIcBC0HPAAyGAQtB0AAMhQELQdEADIQBC0HSAAyDAQtB1AAMggELQdMADIEBC0HVAAyAAQtB1gAMfwtB1wAMfgtB2AAMfQtB2QAMfAtB2gAMewtB2wAMegtB0wEMeQtB3AAMeAtB3QAMdwtBBgx2C0HeAAx1C0EFDHQLQd8ADHMLQQQMcgtB4AAMcQtB4QAMcAtB4gAMbwtB4wAMbgtBAwxtC0HkAAxsC0HlAAxrC0HmAAxqC0HoAAxpC0HnAAxoC0HpAAxnC0HqAAxmC0HrAAxlC0HsAAxkC0ECDGMLQe0ADGILQe4ADGELQe8ADGALQfAADF8LQfEADF4LQfIADF0LQfMADFwLQfQADFsLQfUADFoLQfYADFkLQfcADFgLQfgADFcLQfkADFYLQfoADFULQfsADFQLQfwADFMLQf0ADFILQf4ADFELQf8ADFALQYABDE8LQYEBDE4LQYIBDE0LQYMBDEwLQYQBDEsLQYUBDEoLQYYBDEkLQYcBDEgLQYgBDEcLQYkBDEYLQYoBDEULQYsBDEQLQYwBDEMLQY0BDEILQY4BDEELQY8BDEALQZABDD8LQZEBDD4LQZIBDD0LQZMBDDwLQZQBDDsLQZUBDDoLQZYBDDkLQZcBDDgLQZgBDDcLQZkBDDYLQZoBDDULQZsBDDQLQZwBDDMLQZ0BDDILQZ4BDDELQZ8BDDALQaABDC8LQaEBDC4LQaIBDC0LQaMBDCwLQaQBDCsLQaUBDCoLQaYBDCkLQacBDCgLQagBDCcLQakBDCYLQaoBDCULQasBDCQLQawBDCMLQa0BDCILQa4BDCELQa8BDCALQbABDB8LQbEBDB4LQbIBDB0LQbMBDBwLQbQBDBsLQbUBDBoLQbYBDBkLQbcBDBgLQbgBDBcLQQEMFgtBuQEMFQtBugEMFAtBuwEMEwtBvAEMEgtBvQEMEQtBvgEMEAtBvwEMDwtBwAEMDgtBwQEMDQtBwgEMDAtBwwEMCwtBxAEMCgtBxQEMCQtBxgEMCAtB1AEMBwtBxwEMBgtByAEMBQtByQEMBAtBygEMAwtBywEMAgtBzQEMAQtBzAELIQIDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDtQBAAECAwQFBgcICQoLDA0ODxARFBUWFxgZGhscHR4fICEjJCUnKCmIA4cDhQOEA/wC9QLuAusC6ALmAuMC4ALfAt0C2wLWAtUC1ALTAtICygLJAsgCxwLGAsUCxALDAr0CvAK6ArkCuAK3ArYCtQK0ArICsQKsAqoCqAKnAqYCpQKkAqMCogKhAqACnwKbApoCmQKYApcCkAKIAoQCgwKCAvkB9gH1AfQB8wHyAfEB8AHvAe0B6wHoAeMB4QHgAd8B3gHdAdwB2wHaAdkB2AHXAdYB1QHUAdIB0QHQAc8BzgHNAcwBywHKAckByAHHAcYBxQHEAcMBwgHBAcABvwG+Ab0BvAG7AboBuQG4AbcBtgG1AbQBswGyAbEBsAGvAa4BrQGsAasBqgGpAagBpwGmAaUBpAGjAaIBoQGgAZ8BngGdAZwBmwGaAZcBlgGRAZABjwGOAY0BjAGLAYoBiQGIAYUBhAGDAX59fHt6d3Z1LFFSU1RVVgsgASAERw1zQewBIQIMqQMLIAEgBEcNkAFB0QEhAgyoAwsgASAERw3pAUGEASECDKcDCyABIARHDfQBQfoAIQIMpgMLIAEgBEcNggJB9QAhAgylAwsgASAERw2JAkHzACECDKQDCyABIARHDYwCQfEAIQIMowMLIAEgBEcNHkEeIQIMogMLIAEgBEcNGUEYIQIMoQMLIAEgBEcNuAJBzQAhAgygAwsgASAERw3DAkHGACECDJ8DCyABIARHDcQCQcMAIQIMngMLIAEgBEcNygJBOCECDJ0DCyADLQAwQQFGDZUDDPICC0EAIQACQAJAAkAgAy0AKkUNACADLQArRQ0AIAMvATIiAkECcUUNAQwCCyADLwEyIgJBAXFFDQELQQEhACADLQAoQQFGDQAgAy8BNCIGQeQAa0HkAEkNACAGQcwBRg0AIAZBsAJGDQAgAkHAAHENAEEAIQAgAkGIBHFBgARGDQAgAkEocUEARyEACyADQQA7ATIgA0EAOgAxAkAgAEUEQCADQQA6ADEgAy0ALkEEcQ0BDJwDCyADQgA3AyALIANBADoAMSADQQE6ADYMSQtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAEUNSSAAQRVHDWMgA0EENgIcIAMgATYCFCADQb0aNgIQIANBFTYCDEEAIQIMmgMLIAEgBEYEQEEGIQIMmgMLIAEtAABBCkYNGQwBCyABIARGBEBBByECDJkDCwJAIAEtAABBCmsOBAIBAQABCyABQQFqIQFBECECDP4CCyADLQAuQYABcQ0YQQAhAiADQQA2AhwgAyABNgIUIANBqR82AhAgA0ECNgIMDJcDCyABQQFqIQEgA0Evai0AAEEBcQ0XQQAhAiADQQA2AhwgAyABNgIUIANBhB82AhAgA0EZNgIMDJYDCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMWg0ZQQghAgyVAwsgASAERwRAIANBCTYCCCADIAE2AgRBEiECDPsCC0EJIQIMlAMLIAMpAyBQDZwCDEQLIAEgBEYEQEELIQIMkwMLIAEtAABBCkcNFyABQQFqIQEMGAsgA0Evai0AAEEBcUUNGgwnC0EAIQACQCADKAI4IgJFDQAgAigCSCICRQ0AIAMgAhEAACEACyAADRoMQwtBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0bDCULQQAhAAJAIAMoAjgiAkUNACACKAJIIgJFDQAgAyACEQAAIQALIAANHAwzCyADQS9qLQAAQQFxRQ0dDCMLQQAhAAJAIAMoAjgiAkUNACACKAJMIgJFDQAgAyACEQAAIQALIAANHQxDC0EAIQACQCADKAI4IgJFDQAgAigCTCICRQ0AIAMgAhEAACEACyAADR4MIQsgASAERgRAQRMhAgyLAwsCQCABLQAAIgBBCmsOBCAkJAAjCyABQQFqIQEMIAtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0jDEMLIAEgBEYEQEEWIQIMiQMLIAEtAABB8D9qLQAAQQFHDSQM7QILAkADQCABLQAAQeA5ai0AACIAQQFHBEACQCAAQQJrDgIDACgLIAFBAWohAUEfIQIM8AILIAQgAUEBaiIBRw0AC0EYIQIMiAMLIAMoAgQhAEEAIQIgA0EANgIEIAMgACABQQFqIgEQMyIADSIMQgtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0kDCsLIAEgBEYEQEEcIQIMhgMLIANBCjYCCCADIAE2AgRBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0mQSIhAgzrAgsgASAERwRAA0AgAS0AAEHgO2otAAAiAEEDRwRAIABBAWsOBRkbJ+wCJicLIAQgAUEBaiIBRw0AC0EbIQIMhQMLQRshAgyEAwsDQCABLQAAQeA9ai0AACIAQQNHBEAgAEEBaw4FEBIoFCcoCyAEIAFBAWoiAUcNAAtBHiECDIMDCyABIARHBEAgA0ELNgIIIAMgATYCBEEHIQIM6QILQR8hAgyCAwsgASAERgRAQSAhAgyCAwsCQCABLQAAQQ1rDhQvQEBAQEBAQEBAQEBAQEBAQEBAAEALQQAhAiADQQA2AhwgA0G3CzYCECADQQI2AgwgAyABQQFqNgIUDIEDCyADQS9qIQIDQCABIARGBEBBISECDIIDCwJAAkACQCABLQAAIgBBCWsOGAIAKioBKioqKioqKioqKioqKioqKioqAigLIAFBAWohASADQS9qLQAAQQFxRQ0LDBkLIAFBAWohAQwYCyABQQFqIQEgAi0AAEECcQ0AC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAyAAwsgAUEBaiEBC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADQEM0QILIANCADcDIAw8CyAAQRVGBEAgA0EkNgIcIAMgATYCFCADQYYaNgIQIANBFTYCDEEAIQIM/QILQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDPwCCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDSsgA0EHNgIcIAMgATYCFCADIAA2AgwM+wILIAMtAC5BwABxRQ0BC0EAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAARQ0rIABBFUYEQCADQQo2AhwgAyABNgIUIANB8Rg2AhAgA0EVNgIMQQAhAgz6AgtBACECIANBADYCHCADIAE2AhQgA0GLDDYCECADQRM2AgwM+QILQQAhAiADQQA2AhwgAyABNgIUIANBsRQ2AhAgA0ECNgIMDPgCC0EAIQIgA0EANgIcIAMgATYCFCADQYwUNgIQIANBGTYCDAz3AgtBACECIANBADYCHCADIAE2AhQgA0HRHDYCECADQRk2AgwM9gILIABBFUYNPUEAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAz1AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQ0oIANBDTYCHCADIAE2AhQgAyAANgIMDPQCCyAAQRVGDTpBACECIANBADYCHCADIAE2AhQgA0GiDzYCECADQSI2AgwM8wILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDIiAEUEQCABQQFqIQEMKAsgA0EONgIcIAMgADYCDCADIAFBAWo2AhQM8gILIABBFUYNN0EAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAzxAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQRAIAFBAWohAQwnCyADQQ82AhwgAyAANgIMIAMgAUEBajYCFAzwAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM7wILIABBFUYNM0EAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzuAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMyIARQ0lIANBETYCHCADIAE2AhQgAyAANgIMDO0CCyAAQRVGDTBBACECIANBADYCHCADIAE2AhQgA0HODDYCECADQSM2AgwM7AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEMJQsgA0ESNgIcIAMgADYCDCADIAFBAWo2AhQM6wILIANBL2otAABBAXFFDQELQRUhAgzPAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM6AILIABBO0cNACABQQFqIQEMDAtBACECIANBADYCHCADIAE2AhQgA0GYFzYCECADQQI2AgwM5gILIABBFUYNKEEAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzlAgsgA0EUNgIcIAMgATYCFCADIAA2AgwM5AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEM3AILIANBFTYCHCADIAA2AgwgAyABQQFqNgIUDOMCCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNoCCyADQRc2AhwgAyAANgIMIAMgAUEBajYCFAziAgsgAEEVRg0jQQAhAiADQQA2AhwgAyABNgIUIANBzgw2AhAgA0EjNgIMDOECCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDB0LIANBGTYCHCADIAA2AgwgAyABQQFqNgIUDOACCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNYCCyADQRo2AhwgAyAANgIMIAMgAUEBajYCFAzfAgsgAEEVRg0fQQAhAiADQQA2AhwgAyABNgIUIANBog82AhAgA0EiNgIMDN4CCyADKAIEIQBBACECIANBADYCBCADIAAgARAyIgBFBEAgAUEBaiEBDBsLIANBHDYCHCADIAA2AgwgAyABQQFqNgIUDN0CCyADKAIEIQBBACECIANBADYCBCADIAAgARAyIgBFBEAgAUEBaiEBDNICCyADQR02AhwgAyAANgIMIAMgAUEBajYCFAzcAgsgAEE7Rw0BIAFBAWohAQtBJCECDMACC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAzZAgsgASAERwRAA0AgAS0AAEEgRw3xASAEIAFBAWoiAUcNAAtBLCECDNkCC0EsIQIM2AILIAEgBEYEQEE0IQIM2AILAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0E0IQIM2QILIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQ2MAiADQTI2AhwgAyABNgIUIAMgADYCDEEAIQIM2AILIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQRAIAFBAWohAQyMAgsgA0EyNgIcIAMgADYCDCADIAFBAWo2AhRBACECDNcCCyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE5IQIMwAILIAMpAyAiC0KZs+bMmbPmzBlWDQEgAyALQgp+Igo3AyAgCiAArUL/AYMiC0J/hVYNASADIAogC3w3AyAgBCABQQFqIgFHDQALQcAAIQIM2AILIAMoAgQhACADQQA2AgQgAyAAIAFBAWoiARAwIgANFwzJAgtBwAAhAgzWAgsgASAERgRAQckAIQIM1gILAkADQAJAIAEtAABBCWsOGAACjwKPApMCjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CAI8CCyAEIAFBAWoiAUcNAAtByQAhAgzWAgsgAUEBaiEBIANBL2otAABBAXENjwIgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIM1QILIAEgBEcEQANAIAEtAAAiAEEgRwRAAkACQAJAIABByABrDgsAAc0BzQHNAc0BzQHNAc0BzQECzQELIAFBAWohAUHZACECDL8CCyABQQFqIQFB2gAhAgy+AgsgAUEBaiEBQdsAIQIMvQILIAQgAUEBaiIBRw0AC0HuACECDNUCC0HuACECDNQCCyADQQI6ACgMMAtBACECIANBADYCHCADQbcLNgIQIANBAjYCDCADIAFBAWo2AhQM0gILQQAhAgy3AgtBDSECDLYCC0ERIQIMtQILQRMhAgy0AgtBFCECDLMCC0EWIQIMsgILQRchAgyxAgtBGCECDLACC0EZIQIMrwILQRohAgyuAgtBGyECDK0CC0EcIQIMrAILQR0hAgyrAgtBHiECDKoCC0EgIQIMqQILQSEhAgyoAgtBIyECDKcCC0EnIQIMpgILIANBPTYCHCADIAE2AhQgAyAANgIMQQAhAgy/AgsgA0EbNgIcIAMgATYCFCADQY8bNgIQIANBFTYCDEEAIQIMvgILIANBIDYCHCADIAE2AhQgA0GeGTYCECADQRU2AgxBACECDL0CCyADQRM2AhwgAyABNgIUIANBnhk2AhAgA0EVNgIMQQAhAgy8AgsgA0ELNgIcIAMgATYCFCADQZ4ZNgIQIANBFTYCDEEAIQIMuwILIANBEDYCHCADIAE2AhQgA0GeGTYCECADQRU2AgxBACECDLoCCyADQSA2AhwgAyABNgIUIANBjxs2AhAgA0EVNgIMQQAhAgy5AgsgA0ELNgIcIAMgATYCFCADQY8bNgIQIANBFTYCDEEAIQIMuAILIANBDDYCHCADIAE2AhQgA0GPGzYCECADQRU2AgxBACECDLcCC0EAIQIgA0EANgIcIAMgATYCFCADQa8ONgIQIANBEjYCDAy2AgsCQANAAkAgAS0AAEEKaw4EAAICAAILIAQgAUEBaiIBRw0AC0HsASECDLYCCwJAAkAgAy0ANkEBRw0AQQAhAAJAIAMoAjgiAkUNACACKAJYIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB6wE2AhwgAyABNgIUIANB4hg2AhAgA0EVNgIMQQAhAgy3AgtBzAEhAgycAgsgA0EANgIcIAMgATYCFCADQfELNgIQIANBHzYCDEEAIQIMtQILAkACQCADLQAoQQFrDgIEAQALQcsBIQIMmwILQcQBIQIMmgILIANBAjoAMUEAIQACQCADKAI4IgJFDQAgAigCACICRQ0AIAMgAhEAACEACyAARQRAQc0BIQIMmgILIABBFUcEQCADQQA2AhwgAyABNgIUIANBrAw2AhAgA0EQNgIMQQAhAgy0AgsgA0HqATYCHCADIAE2AhQgA0GHGTYCECADQRU2AgxBACECDLMCCyABIARGBEBB6QEhAgyzAgsgAS0AAEHIAEYNASADQQE6ACgLQbYBIQIMlwILQcoBIQIMlgILIAEgBEcEQCADQQw2AgggAyABNgIEQckBIQIMlgILQegBIQIMrwILIAEgBEYEQEHnASECDK8CCyABLQAAQcgARw0EIAFBAWohAUHIASECDJQCCyABIARGBEBB5gEhAgyuAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQcYBIQIMlAILIAFBAWohAUHHASECDJMCC0HlASECIAEgBEYNrAIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB99MAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMrQILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgBFBEBB1AEhAgyTAgsgA0HkATYCHCADIAE2AhQgAyAANgIMQQAhAgysAgtB4wEhAiABIARGDasCIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQfXTAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADKwCCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB0B42AhAgA0EINgIMDKkCC0HFASECDI4CCyADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDKcCC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ1lIABBFUcEQCADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgynAgsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDKYCC0HhASECIAQgASIARg2lAiAEIAFrIAMoAgAiAWohBSAAIAFrQQRqIQYCQANAIAAtAAAgAUHw0wBqLQAARw0BIAFBBEYNAyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBTYCAAymAgsgA0EANgIcIAMgADYCFCADQYQ3NgIQIANBCDYCDCADQQA2AgBBACECDKUCCyABIARHBEAgA0ENNgIIIAMgATYCBEHCASECDIsCC0HgASECDKQCCyADQQA2AgAgBkEBaiEBC0HDASECDIgCCyABIARGBEBB3wEhAgyiAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBwQEhAgyIAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYgCIANB3gE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAEgBEYEQEHdASECDKECCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYkCIANB3AE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILQcABIQIMhgILIAEgBEYEQEHbASECDKACC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDQIgA0HYATYCHCADIAE2AhQgAyAANgIMQQAhAgyiAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYsCIANB2QE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ2JAiADQdoBNgIcIAMgATYCFCADIAA2AgwMoAILQb8BIQIMhQILQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBnA02AhAgA0EhNgIMQQAhAgygAgtBvgEhAgyFAgsgA0HXATYCHCADIAE2AhQgA0HWGTYCECADQRU2AgxBACECDJ4CCyABIARGBEBB1wEhAgyeAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANB6xA2AhAgA0EJNgIMQQAhAgyeAgtBvQEhAgyDAgsgASAERgRAQdYBIQIMnQILAkAgAS0AAEEwa0H/AXEiAkEKSQRAIAFBAWohAQJAIAMvATQiAEGZM0sNACADIABBCmwiADsBNCAAQf7/A3EgAkH//wNzSw0AIAMgACACajsBNAwCC0EAIQIgA0EANgIcIAMgATYCFCADQYAdNgIQIANBDTYCDAyeAgsgA0EANgIcIAMgATYCFCADQYAdNgIQIANBDTYCDEEAIQIMnQILQbwBIQIMggILIAEgBEYEQEHVASECDJwCCwJAIAEtAABBMGtB/wFxIgJBCkkEQCABQQFqIQECQCADLwE0IgBBmTNLDQAgAyAAQQpsIgA7ATQgAEH+/wNxIAJB//8Dc0sNACADIAAgAmo7ATQMAgtBACECIANBADYCHCADIAE2AhQgA0GAHTYCECADQQ02AgwMnQILIANBADYCHCADIAE2AhQgA0GAHTYCECADQQ02AgxBACECDJwCC0G7ASECDIECCyABIARGBEBB1AEhAgybAgsCQCABLQAAQTBrQf8BcSICQQpJBEAgAUEBaiEBAkAgAy8BNCIAQZkzSw0AIAMgAEEKbCIAOwE0IABB/v8DcSACQf//A3NLDQAgAyAAIAJqOwE0DAILQQAhAiADQQA2AhwgAyABNgIUIANBgB02AhAgA0ENNgIMDJwCCyADQQA2AhwgAyABNgIUIANBgB02AhAgA0ENNgIMQQAhAgybAgtBugEhAgyAAgsgASAERgRAQdMBIQIMmgILAkACQAJAAkAgAS0AAEEKaw4XAgMDAAMDAwMDAwMDAwMDAwMDAwMDAwEDCyABQQFqDAULIAFBAWohAUG5ASECDIECCyABQQFqIQEgA0Evai0AAEEBcQ0IIANBADYCHCADIAE2AhQgA0GFCzYCECADQQ02AgxBACECDJoCCyADQQA2AhwgAyABNgIUIANBhQs2AhAgA0ENNgIMQQAhAgyZAgsgASAERwRAIANBDjYCCCADIAE2AgRBASECDP8BC0HSASECDJgCCwJAAkADQAJAIAEtAABBCmsOBAIAAAMACyAEIAFBAWoiAUcNAAtB0QEhAgyZAgsgAygCBCEAIANBADYCBCADIAAgARAsIgBFBEAgAUEBaiEBDAQLIANB0AE2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMmAILIAMoAgQhACADQQA2AgQgAyAAIAEQLCIADQEgAUEBagshAUG3ASECDPwBCyADQc8BNgIcIAMgADYCDCADIAFBAWo2AhRBACECDJUCC0G4ASECDPoBCyADQS9qLQAAQQFxDQEgA0EANgIcIAMgATYCFCADQc8bNgIQIANBGTYCDEEAIQIMkwILIAEgBEYEQEHPASECDJMCCwJAAkACQCABLQAAQQprDgQBAgIAAgsgAUEBaiEBDAILIAFBAWohAQwBCyADLQAuQcAAcUUNAQtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsgAEUNlgEgAEEVRgRAIANB2QA2AhwgAyABNgIUIANBvRk2AhAgA0EVNgIMQQAhAgySAgsgA0EANgIcIAMgATYCFCADQfgMNgIQIANBGzYCDEEAIQIMkQILIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDJACCyABIARHBEAgA0EMNgIIIAMgATYCBEG1ASECDPYBC0HOASECDI8CCyABIARGBEBBzQEhAgyPAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBwQBrDhUAAQIDWgQFBlpaWgcICQoLDA0ODxBaCyABQQFqIQFB8QAhAgyEAgsgAUEBaiEBQfIAIQIMgwILIAFBAWohAUH3ACECDIICCyABQQFqIQFB+wAhAgyBAgsgAUEBaiEBQfwAIQIMgAILIAFBAWohAUH/ACECDP8BCyABQQFqIQFBgAEhAgz+AQsgAUEBaiEBQYMBIQIM/QELIAFBAWohAUGMASECDPwBCyABQQFqIQFBjQEhAgz7AQsgAUEBaiEBQY4BIQIM+gELIAFBAWohAUGbASECDPkBCyABQQFqIQFBnAEhAgz4AQsgAUEBaiEBQaIBIQIM9wELIAFBAWohAUGqASECDPYBCyABQQFqIQFBrQEhAgz1AQsgAUEBaiEBQbQBIQIM9AELIAEgBEYEQEHMASECDI4CCyABLQAAQc4ARw1IIAFBAWohAUGzASECDPMBCyABIARGBEBBywEhAgyNAgsCQAJAAkAgAS0AAEHCAGsOEgBKSkpKSkpKSkoBSkpKSkpKAkoLIAFBAWohAUGuASECDPQBCyABQQFqIQFBsQEhAgzzAQsgAUEBaiEBQbIBIQIM8gELQcoBIQIgASAERg2LAiADKAIAIgAgBCABa2ohBSABIABrQQdqIQYCQANAIAEtAAAgAEHo0wBqLQAARw1FIABBB0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyMAgsgA0EANgIAIAZBAWohAUEbDEULIAEgBEYEQEHJASECDIsCCwJAAkAgAS0AAEHJAGsOBwBHR0dHRwFHCyABQQFqIQFBrwEhAgzxAQsgAUEBaiEBQbABIQIM8AELQcgBIQIgASAERg2JAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHm0wBqLQAARw1DIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyKAgsgA0EANgIAIAZBAWohAUEPDEMLQccBIQIgASAERg2IAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHk0wBqLQAARw1CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyJAgsgA0EANgIAIAZBAWohAUEgDEILQcYBIQIgASAERg2HAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw1BIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyIAgsgA0EANgIAIAZBAWohAUESDEELIAEgBEYEQEHFASECDIcCCwJAAkAgAS0AAEHFAGsODgBDQ0NDQ0NDQ0NDQ0MBQwsgAUEBaiEBQasBIQIM7QELIAFBAWohAUGsASECDOwBC0HEASECIAEgBEYNhQIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB3tMAai0AAEcNPyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhgILIANBADYCACAGQQFqIQFBBww/C0HDASECIAEgBEYNhAIgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABB2NMAai0AAEcNPiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhQILIANBADYCACAGQQFqIQFBKAw+CyABIARGBEBBwgEhAgyEAgsCQAJAAkAgAS0AAEHFAGsOEQBBQUFBQUFBQUEBQUFBQUECQQsgAUEBaiEBQacBIQIM6wELIAFBAWohAUGoASECDOoBCyABQQFqIQFBqQEhAgzpAQtBwQEhAiABIARGDYICIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQdHTAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADIMCCyADQQA2AgAgBkEBaiEBQRoMPAtBwAEhAiABIARGDYECIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQc3TAGotAABHDTsgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADIICCyADQQA2AgAgBkEBaiEBQSEMOwsgASAERgRAQb8BIQIMgQILAkACQCABLQAAQcEAaw4UAD09PT09PT09PT09PT09PT09PQE9CyABQQFqIQFBowEhAgznAQsgAUEBaiEBQaYBIQIM5gELIAEgBEYEQEG+ASECDIACCwJAAkAgAS0AAEHVAGsOCwA8PDw8PDw8PDwBPAsgAUEBaiEBQaQBIQIM5gELIAFBAWohAUGlASECDOUBC0G9ASECIAEgBEYN/gEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNOCAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/wELIANBADYCACAGQQFqIQFBKgw4CyABIARGBEBBvAEhAgz+AQsgAS0AAEHQAEcNOCABQQFqIQFBJQw3C0G7ASECIAEgBEYN/AEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBwdMAai0AAEcNNiAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/QELIANBADYCACAGQQFqIQFBDgw2CyABIARGBEBBugEhAgz8AQsgAS0AAEHFAEcNNiABQQFqIQFBoQEhAgzhAQsgASAERgRAQbkBIQIM+wELAkACQAJAAkAgAS0AAEHCAGsODwABAjk5OTk5OTk5OTk5AzkLIAFBAWohAUGdASECDOMBCyABQQFqIQFBngEhAgziAQsgAUEBaiEBQZ8BIQIM4QELIAFBAWohAUGgASECDOABC0G4ASECIAEgBEYN+QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBvtMAai0AAEcNMyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+gELIANBADYCACAGQQFqIQFBFAwzC0G3ASECIAEgBEYN+AEgAygCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBudMAai0AAEcNMiAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+QELIANBADYCACAGQQFqIQFBKwwyC0G2ASECIAEgBEYN9wEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBttMAai0AAEcNMSAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+AELIANBADYCACAGQQFqIQFBLAwxC0G1ASECIAEgBEYN9gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB4dMAai0AAEcNMCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM9wELIANBADYCACAGQQFqIQFBEQwwC0G0ASECIAEgBEYN9QEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBstMAai0AAEcNLyAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM9gELIANBADYCACAGQQFqIQFBLgwvCyABIARGBEBBswEhAgz1AQsCQAJAAkACQAJAIAEtAABBwQBrDhUANDQ0NDQ0NDQ0NAE0NAI0NAM0NAQ0CyABQQFqIQFBkQEhAgzeAQsgAUEBaiEBQZIBIQIM3QELIAFBAWohAUGTASECDNwBCyABQQFqIQFBmAEhAgzbAQsgAUEBaiEBQZoBIQIM2gELIAEgBEYEQEGyASECDPQBCwJAAkAgAS0AAEHSAGsOAwAwATALIAFBAWohAUGZASECDNoBCyABQQFqIQFBBAwtC0GxASECIAEgBEYN8gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBsNMAai0AAEcNLCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM8wELIANBADYCACAGQQFqIQFBHQwsCyABIARGBEBBsAEhAgzyAQsCQAJAIAEtAABByQBrDgcBLi4uLi4ALgsgAUEBaiEBQZcBIQIM2AELIAFBAWohAUEiDCsLIAEgBEYEQEGvASECDPEBCyABLQAAQdAARw0rIAFBAWohAUGWASECDNYBCyABIARGBEBBrgEhAgzwAQsCQAJAIAEtAABBxgBrDgsALCwsLCwsLCwsASwLIAFBAWohAUGUASECDNYBCyABQQFqIQFBlQEhAgzVAQtBrQEhAiABIARGDe4BIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazTAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO8BCyADQQA2AgAgBkEBaiEBQQ0MKAtBrAEhAiABIARGDe0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQeHTAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO4BCyADQQA2AgAgBkEBaiEBQQwMJwtBqwEhAiABIARGDewBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQarTAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO0BCyADQQA2AgAgBkEBaiEBQQMMJgtBqgEhAiABIARGDesBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQajTAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOwBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQakBIQIM6wELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBjwEhAgzRAQsgAUEBaiEBQZABIQIM0AELQagBIQIgASAERg3pASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm0wBqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzqAQsgA0EANgIAIAZBAWohAUEnDCMLQacBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk0wBqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEcDCILQaYBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGe0wBqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEGDCELQaUBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGZ0wBqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGkASECDOYBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQYQBIQIMzgELIAFBAWohAUGFASECDM0BCyABQQFqIQFBigEhAgzMAQsgAUEBaiEBQYsBIQIMywELQaMBIQIgASAERg3kASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGX0wBqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzlAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGiASECDOQBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGGASECDMoBCyABQQFqIQFBiQEhAgzJAQsgASAERgRAQaEBIQIM4wELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQYcBIQIMyQELIAFBAWohAUGIASECDMgBCyABIARGBEBBoAEhAgziAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GfASECIAEgBEYN4AEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBkdMAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4QELIANBADYCACAGQQFqIQFBHgwaC0GeASECIAEgBEYN3wEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBitMAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4AELIANBADYCACAGQQFqIQFBFQwZC0GdASECIAEgBEYN3gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBh9MAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3wELIANBADYCACAGQQFqIQFBFwwYC0GcASECIAEgBEYN3QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBgdMAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3gELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBmwEhAgzdAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYEBIQIMwwELIAFBAWohAUGCASECDMIBC0GaASECIAEgBEYN2wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5tMAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3AELIANBADYCACAGQQFqIQFBCQwVC0GZASECIAEgBEYN2gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5NMAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2wELIANBADYCACAGQQFqIQFBHwwUC0GYASECIAEgBEYN2QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB/tIAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2gELIANBADYCACAGQQFqIQFBAgwTC0GXASECIAEgBEYN2AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQfzSAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyABIARGBEBBlgEhAgzYAQtBASABLQAAQd8ARw0RGiABQQFqIQFB/QAhAgy9AQsgA0EANgIAIAZBAWohAUH+ACECDLwBC0GVASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBKQwPC0GUASECIAEgBEYN1AEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB+NIAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1QELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBkwEhAgzUAQsgAS0AAEHFAEcNDiABQQFqIQFB+gAhAgy5AQsgASAERgRAQZIBIQIM0wELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFB+AAhAgy5AQsgAUEBaiEBQfkAIQIMuAELQZEBIQIgASAERg3RASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHz0gBqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzSAQsgA0EANgIAIAZBAWohAUEjDAsLQZABIQIgASAERg3QASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHw0gBqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzRAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGPASECDNABCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQfMAIQIMtgELIAFBAWohAUH2ACECDLUBCyABIARGBEBBjgEhAgzPAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB9AAhAgy1AQsgAUEBaiEBQfUAIQIMtAELIAEgBEYEQEGNASECDM4BCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQYwBIQIgASAERg3MASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHs0gBqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzNAQsgA0EANgIAIAZBAWohAUEFDAYLQYsBIQIgASAERg3LASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHm0gBqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzMAQsgA0EANgIAIAZBAWohAUEWDAULQYoBIQIgASAERg3KASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzLAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGJASECDMoBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUHvACECDLABCyABQQFqIQFB8AAhAgyvAQtBiAEhAiABIARGDcgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQeDSAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMkBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGHASECDMcBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC0iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB6R42AhAgA0EGNgIMDMQBC0HuACECDKkBCyADQYYBNgIcIAMgATYCFCADIAA2AgxBACECDMIBC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgzBAQtB7QAhAgymAQsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDL8BCyABIARGBEBBhQEhAgy/AQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GGHjYCECADQQY2AgxBACECDL8BC0ECIQIMpAELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GEASECDL0BCyABIARGBEBBgwEhAgy9AQsCQCABLQAAQQlrDgRAAABAAAtB6wAhAgyiAQsgAy0AKUEFRgRAQewAIQIMogELQeoAIQIMoQELIAEgBEYEQEGCASECDLsBCyADQQ82AgggAyABNgIEDAoLIAEgBEYEQEGBASECDLoBCwJAIAEtAABBCWsOBD0AAD0AC0HpACECDJ8BCyABIARHBEAgA0EPNgIIIAMgATYCBEHnACECDJ8BC0GAASECDLgBCwJAIAEgBEcEQANAIAEtAABB4M4Aai0AACIAQQNHBEACQCAAQQFrDgI/AAQLQeYAIQIMoQELIAQgAUEBaiIBRw0AC0H+ACECDLkBC0H+ACECDLgBCyADQQA2AhwgAyABNgIUIANBxh82AhAgA0EHNgIMQQAhAgy3AQsgASAERgRAQf8AIQIMtwELAkACQAJAIAEtAABB4NAAai0AAEEBaw4DPAIAAQtB6AAhAgyeAQsgA0EANgIcIAMgATYCFCADQYYSNgIQIANBBzYCDEEAIQIMtwELQeAAIQIMnAELIAEgBEcEQCABQQFqIQFB5QAhAgycAQtB/QAhAgy1AQsgBCABIgBGBEBB/AAhAgy1AQsgAC0AACIBQS9GBEAgAEEBaiEBQeQAIQIMmwELIAFBCWsiAkEXSw0BIAAhAUEBIAJ0QZuAgARxDTcMAQsgBCABIgBGBEBB+wAhAgy0AQsgAC0AAEEvRw0AIABBAWohAQwDC0EAIQIgA0EANgIcIAMgADYCFCADQcYfNgIQIANBBzYCDAyyAQsCQAJAAkACQAJAA0AgAS0AAEHgzABqLQAAIgBBBUcEQAJAAkAgAEEBaw4IPQUGBwgABAEIC0HhACECDJ8BCyABQQFqIQFB4wAhAgyeAQsgBCABQQFqIgFHDQALQfoAIQIMtgELIAFBAWoMFAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgy0AQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyzAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyyAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMsQELIAEgBEYEQEH5ACECDLEBCwJAIAEtAABB4MwAai0AAEEBaw4INAQFBgAIAgMHCyABQQFqIQELQQMhAgyVAQsgAUEBagwNC0EAIQIgA0EANgIcIANBoxI2AhAgA0EHNgIMIAMgAUEBajYCFAytAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgysAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMqQELQeIAIQIMjgELIAEgBEYEQEH4ACECDKgBCyABQQFqDAILIAEgBEYEQEH3ACECDKcBCyABQQFqDAELIAEgBEYNASABQQFqCyEBQQQhAgyKAQtB9gAhAgyjAQsDQCABLQAAQeDKAGotAAAiAEECRwRAIABBAUcEQEHfACECDIsBCwwnCyAEIAFBAWoiAUcNAAtB9QAhAgyiAQsgASAERgRAQfQAIQIMogELAkAgAS0AAEEJaw43JQMGJQQGBgYGBgYGBgYGBgYGBgYGBgYFBgYCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAAYLIAFBAWoLIQFBBSECDIYBCyABQQFqDAYLIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMngELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMnQELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB8AA2AhwgAyABNgIUIAMgADYCDEEAIQIMnAELIANBADYCHCADIAE2AhQgA0G8EzYCECADQQc2AgxBACECDJsBCwJAAkACQAJAA0AgAS0AAEHgyABqLQAAIgBBBUcEQAJAIABBAWsOBiQDBAUGAAYLQd4AIQIMhgELIAQgAUEBaiIBRw0AC0HzACECDJ4BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQdsANgIcIAMgATYCFCADIAA2AgxBACECDJ0BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDJwBCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQfAANgIcIAMgATYCFCADIAA2AgxBACECDJsBCyADQQA2AhwgAyABNgIUIANB3Ag2AhAgA0EHNgIMQQAhAgyaAQsgASAERg0BIAFBAWoLIQFBBiECDH4LQfIAIQIMlwELAkACQAJAAkADQCABLQAAQeDGAGotAAAiAEEFRwRAIABBAWsOBB8CAwQFCyAEIAFBAWoiAUcNAAtB8QAhAgyaAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyZAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyYAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyXAQsgA0EANgIcIAMgATYCFCADQbQKNgIQIANBBzYCDEEAIQIMlgELQc4AIQIMewtB0AAhAgx6C0HdACECDHkLIAEgBEYEQEHwACECDJMBCwJAIAEtAABBCWsOBBYAABYACyABQQFqIQFB3AAhAgx4CyABIARGBEBB7wAhAgySAQsCQCABLQAAQQlrDgQVAAAVAAtBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUEQEHTASECDHgLIABBFUcEQCADQQA2AhwgAyABNgIUIANBwQ02AhAgA0EaNgIMQQAhAgySAQsgA0HuADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDJEBC0HtACECIAEgBEYNkAEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB18YAai0AAEcNBCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkQELIANBADYCACAGQQFqIQEgAy0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACECIANBADYCHCADIAE2AhQgA0HlCTYCECADQQg2AgwMkAELQewAIQIgASAERg2PASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHUxgBqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyQAQsgA0EANgIAIAZBAWohASADLQApQSFGDQMgA0EANgIcIAMgATYCFCADQYkKNgIQIANBCDYCDEEAIQIMjwELQesAIQIgASAERg2OASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHQxgBqLQAARw0CIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyPAQsgA0EANgIAIAZBAWohASADLQApIgBBI0kNAiAAQS5GDQIgA0EANgIcIAMgATYCFCADQcEJNgIQIANBCDYCDEEAIQIMjgELIANBADYCAAtBACECIANBADYCHCADIAE2AhQgA0GENzYCECADQQg2AgwMjAELQdgAIQIMcQsgASAERwRAIANBDTYCCCADIAE2AgRB1wAhAgxxC0HqACECDIoBCyABIARGBEBB6QAhAgyKAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1gAhAgxwCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdCADQegANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyABIARGBEBB5wAhAgyJAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ11IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMiQELQdUAIQIMbgsgASAERgRAQeUAIQIMiAELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDIoBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdyADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdSADQeQANgIcIAMgATYCFCADIAA2AgwMiAELQdMAIQIMbQsgAy0AKUEiRg2AAUHSACECDGwLQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALIABFBEBB1AAhAgxsCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQZwNNgIQIANBITYCDEEAIQIMhgELIANB4QA2AhwgAyABNgIUIANB1hk2AhAgA0EVNgIMQQAhAgyFAQsgASAERgRAQeAAIQIMhQELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HRACECDGwLIANBADYCHCADIAE2AhQgA0GIETYCECADQQk2AgxBACECDIUBCyADQQA2AhwgAyABNgIUIANBiBE2AhAgA0EJNgIMQQAhAgyEAQsgASAERgRAQd8AIQIMhAELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBiBE2AhAgA0ECNgIMQQAhAgyDAQsgASAERgRAQd0AIQIMgwELIAEtAAAiAkENRgRAIAFBAWohAUHPACECDGkLIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyCAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0G1LDYCECADQQc2AgwMgAELIAEgBEYEQEHbACECDIABCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc0AIQIMZAsgASAERgRAQdoAIQIMfgsgAS0AAEEJaw4EAAEBAAELQQAhAiADQQA2AhwgA0HsETYCECADQQc2AgwgAyABQQFqNgIUDHwLIANBgBI7ASpBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HZADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDHsLQcwAIQIMYAsgA0EANgIcIAMgATYCFCADQcENNgIQIANBGjYCDEEAIQIMeQsgASAERgRAQdkAIQIMeQsgAS0AAEEgRw06IAFBAWohASADLQAuQQFxDTogA0EANgIcIAMgATYCFCADQa0bNgIQIANBHjYCDEEAIQIMeAsgASAERgRAQdgAIQIMeAsCQAJAAkACQAJAIAEtAAAiAEEKaw4EAgMDAAELIAFBAWohAUErIQIMYQsgAEE6Rw0BIANBADYCHCADIAE2AhQgA0G5ETYCECADQQo2AgxBACECDHoLIAFBAWohASADQS9qLQAAQQFxRQ1tIAMtADJBgAFxRQRAIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsCQAJAIAAOFkpJSAEBAQEBAQEBAQEBAQEBAQEBAQABCyADQSk2AhwgAyABNgIUIANBshg2AhAgA0EVNgIMQQAhAgx7CyADQQA2AhwgAyABNgIUIANB3Qs2AhAgA0ERNgIMQQAhAgx6C0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAARQ1VIABBFUcNASADQQU2AhwgAyABNgIUIANBhho2AhAgA0EVNgIMQQAhAgx5C0HKACECDF4LQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDHcLIAMgAy8BMkGAAXI7ATIMOAsgASAERwRAIANBEDYCCCADIAE2AgRByQAhAgxcC0HXACECDHULIAEgBEYEQEHWACECDHULAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAPT09PT09PT09PT09AT09PQIDPQsgAUEBaiEBQcUAIQIMXQsgAUEBaiEBQcYAIQIMXAsgAUEBaiEBQccAIQIMWwsgAUEBaiEBQcgAIQIMWgtB1QAhAiAEIAEiAEYNcyAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcDQCABQcDGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQhBBCABQQVGDQoaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADHMLQdQAIQIgBCABIgBGDXIgBCABayADKAIAIgFqIQYgACABa0EPaiEHA0AgAUGwxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0HQQMgAUEPRg0JGiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxyC0HTACECIAQgASIARg1xIAQgAWsgAygCACIBaiEGIAAgAWtBDmohBwNAIAFBksYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNBiABQQ5GDQcgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMcQtB0gAhAiAEIAEiAEYNcCAEIAFrIAMoAgAiAWohBSAAIAFrQQFqIQYDQCABQZDGAGotAAAgAC0AACIHQSByIAcgB0HBAGtB/wFxQRpJG0H/AXFHDQUgAUEBRg0CIAFBAWohASAEIABBAWoiAEcNAAsgAyAFNgIADHALIAEgBEYEQEHRACECDHALAkACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcUHuAGsOBwA2NjY2NgE2CyABQQFqIQFBwgAhAgxWCyABQQFqIQFBwwAhAgxVCyADQQA2AgAgBkEBaiEBQcQAIQIMVAtB0AAhAiAEIAEiAEYNbSAEIAFrIAMoAgAiAWohBiAAIAFrQQlqIQcDQCABQYbGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQJBAiABQQlGDQQaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADG0LQc8AIQIgBCABIgBGDWwgBCABayADKAIAIgFqIQYgACABa0EFaiEHA0AgAUGAxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYNAiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxsCyAAIQEgA0EANgIADDALQQELOgAsIANBADYCACAHQQFqIQELQSwhAgxOCwJAA0AgAS0AAEGAxABqLQAAQQFHDQEgBCABQQFqIgFHDQALQc0AIQIMaAtBwQAhAgxNCyABIARGBEBBzAAhAgxnCyABLQAAQTpGBEAgAygCBCEAIANBADYCBCADIAAgARAvIgBFDTAgA0HLADYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxnCyADQQA2AhwgAyABNgIUIANBuRE2AhAgA0EKNgIMQQAhAgxmCwJAAkAgAy0ALEECaw4CAAEkCyADQTNqLQAAQQJxRQ0jIAMtAC5BAnENIyADQQA2AhwgAyABNgIUIANB1RM2AhAgA0ELNgIMQQAhAgxmCyADLQAyQSBxRQ0iIAMtAC5BAnENIiADQQA2AhwgAyABNgIUIANB7BI2AhAgA0EPNgIMQQAhAgxlC0EAIQACQCADKAI4IgJFDQAgAigCQCICRQ0AIAMgAhEAACEACyAARQRAQcAAIQIMSwsgAEEVRwRAIANBADYCHCADIAE2AhQgA0H4DjYCECADQRw2AgxBACECDGULIANBygA2AhwgAyABNgIUIANB8Bo2AhAgA0EVNgIMQQAhAgxkCyABIARHBEADQCABLQAAQfA/ai0AAEEBRw0XIAQgAUEBaiIBRw0AC0HEACECDGQLQcQAIQIMYwsgASAERwRAA0ACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcSIAQQlGDQAgAEEgRg0AAkACQAJAAkAgAEHjAGsOEwADAwMDAwMDAQMDAwMDAwMDAwIDCyABQQFqIQFBNSECDE4LIAFBAWohAUE2IQIMTQsgAUEBaiEBQTchAgxMCwwVCyAEIAFBAWoiAUcNAAtBPCECDGMLQTwhAgxiCyABIARGBEBByAAhAgxiCyADQRE2AgggAyABNgIEAkACQAJAAkACQCADLQAsQQFrDgQUAAECCQsgAy0AMkEgcQ0DQdEBIQIMSwsCQCADLwEyIgBBCHFFDQAgAy0AKEEBRw0AIAMtAC5BCHFFDQILIAMgAEH3+wNxQYAEcjsBMgwLCyADIAMvATJBEHI7ATIMBAsgA0EANgIEIAMgASABEDAiAARAIANBwQA2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMYwsgAUEBaiEBDFILIANBADYCHCADIAE2AhQgA0GjEzYCECADQQQ2AgxBACECDGELQccAIQIgASAERg1gIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEHwwwBqLQAAIAEtAABBIHJHDQEgAEEGRg1GIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADGELIANBADYCAAwFCwJAIAEgBEcEQANAIAEtAABB8MEAai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBxQAhAgxhC0HFACECDGALCyADQQA6ACwMAQtBCyECDEMLQT4hAgxCCwJAAkADQCABLQAAIgBBIEcEQAJAIABBCmsOBAMFBQMACyAAQSxGDQMMBAsgBCABQQFqIgFHDQALQcYAIQIMXQsgA0EIOgAsDA4LIAMtAChBAUcNAiADLQAuQQhxDQIgAygCBCEAIANBADYCBCADIAAgARAwIgAEQCADQcIANgIcIAMgADYCDCADIAFBAWo2AhRBACECDFwLIAFBAWohAQxKC0E6IQIMQAsCQANAIAEtAAAiAEEgRyAAQQlHcQ0BIAQgAUEBaiIBRw0AC0HDACECDFoLC0E7IQIMPgsCQAJAIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBAMEBAMECyAEIAFBAWoiAUcNAAtBPyECDFoLQT8hAgxZCyADIAMvATJBIHI7ATIMCgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFDUggA0E+NgIcIAMgATYCFCADIAA2AgxBACECDFcLAkAgASAERwRAA0AgAS0AAEHwwQBqLQAAIgBBAUcEQCAAQQJGDQMMDAsgBCABQQFqIgFHDQALQTchAgxYC0E3IQIMVwsgAUEBaiEBDAQLQTshAiAEIAEiAEYNVSAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcCQANAIAFBwMYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNASABQQVGBEBBByEBDDsLIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADFYLIANBADYCACAAIQEMBQtBOiECIAQgASIARg1UIAQgAWsgAygCACIBaiEGIAAgAWtBCGohBwJAA0AgAUHkP2otAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAUEIRgRAQQUhAQw6CyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxVCyADQQA2AgAgACEBDAQLQTkhAiAEIAEiAEYNUyAEIAFrIAMoAgAiAWohBiAAIAFrQQNqIQcCQANAIAFB4D9qLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBA0YEQEEGIQEMOQsgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMVAsgA0EANgIAIAAhAQwDCwJAA0AgAS0AACIAQSBHBEAgAEEKaw4EBwQEBwILIAQgAUEBaiIBRw0AC0E4IQIMUwsgAEEsRw0BIAFBAWohAEEBIQECQAJAAkACQAJAIAMtACxBBWsOBAMBAgQACyAAIQEMBAtBAiEBDAELQQQhAQsgA0EBOgAsIAMgAy8BMiABcjsBMiAAIQEMAQsgAyADLwEyQQhyOwEyIAAhAQtBPSECDDcLIANBADoALAtBOCECDDULIAEgBEYEQEE2IQIMTwsCQAJAAkACQAJAIAEtAABBCmsOBAACAgECCyADKAIEIQAgA0EANgIEIAMgACABEDAiAEUNAiADQTM2AhwgAyABNgIUIAMgADYCDEEAIQIMUgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFBEAgAUEBaiEBDAYLIANBMjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxRCyADLQAuQQFxBEBB0AEhAgw3CyADKAIEIQAgA0EANgIEIAMgACABEDAiAA0BDEMLQTMhAgw1CyADQTU2AhwgAyABNgIUIAMgADYCDEEAIQIMTgtBNCECDDMLIANBL2otAABBAXENACADQQA2AhwgAyABNgIUIANB8RU2AhAgA0EZNgIMQQAhAgxMC0EyIQIMMQsgASAERgRAQTIhAgxLCwJAIAEtAABBCkYEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQZgWNgIQIANBAzYCDEEAIQIMSwtBMSECDDALIAEgBEYEQEExIQIMSgsgAS0AACIAQQlHIABBIEdxDQEgAy0ALEEIRw0AIANBADoALAtBPCECDC4LQQEhAgJAAkACQAJAIAMtACxBBWsOBAMBAgAKCyADIAMvATJBCHI7ATIMCQtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgwGCyABIARGBEBBMCECDEcLIAEtAABBCkYEQCABQQFqIQEMAQsgAy0ALkEBcQ0AIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDEYLQS8hAgwrCyABQQFqIQFBMCECDCoLIAEgBEYEQEEvIQIMRAsgAS0AACIAQQlHIABBIEdxRQRAIAFBAWohASADLQAuQQFxDQEgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIMRAtBASECAkACQAJAAkACQAJAIAMtACxBAmsOBwUEBAMBAgAECyADIAMvATJBCHI7ATIMAwtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgtBLiECDCoLIANBADYCHCADIAE2AhQgA0GzEjYCECADQQs2AgxBACECDEMLQdIBIQIMKAsgASAERgRAQS4hAgxCCyADQQA2AgQgA0ERNgIIIAMgASABEDAiAA0BC0EtIQIMJgsgA0EtNgIcIAMgATYCFCADIAA2AgxBACECDD8LQQAhAAJAIAMoAjgiAkUNACACKAJEIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB2AA2AhwgAyABNgIUIANBnho2AhAgA0EVNgIMQQAhAgw+C0HLACECDCMLIANBADYCHCADIAE2AhQgA0GFDjYCECADQR02AgxBACECDDwLIAEgBEYEQEHOACECDDwLIAEtAAAiAEEgRg0CIABBOkYNAQsgA0EAOgAsQQkhAgwgCyADKAIEIQAgA0EANgIEIAMgACABEC8iAA0BDAILIAMtAC5BAXEEQEHPASECDB8LIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ0CIANBKjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgw4CyADQcsANgIcIAMgADYCDCADIAFBAWo2AhRBACECDDcLIAFBAWohAUE/IQIMHAsgAUEBaiEBDCkLIAEgBEYEQEErIQIMNQsCQCABLQAAQQpGBEAgAUEBaiEBDAELIAMtAC5BwABxRQ0GCyADLQAyQYABcQRAQQAhAAJAIAMoAjgiAkUNACACKAJUIgJFDQAgAyACEQAAIQALIABFDREgAEEVRgRAIANBBTYCHCADIAE2AhQgA0GGGjYCECADQRU2AgxBACECDDYLIANBADYCHCADIAE2AhQgA0HiDTYCECADQRQ2AgxBACECDDULIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsgAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIANBAToAMAsgAiACLwEAQcAAcjsBAAtBKiECDBcLIANBKTYCHCADIAE2AhQgA0GyGDYCECADQRU2AgxBACECDDALIANBADYCHCADIAE2AhQgA0HdCzYCECADQRE2AgxBACECDC8LIANBADYCHCADIAE2AhQgA0GdCzYCECADQQI2AgxBACECDC4LQQEhByADLwEyIgVBCHFFBEAgAykDIEIAUiEHCwJAIAMtADAEQEEBIQAgAy0AKUEFRg0BIAVBwABxRSAHcUUNAQsCQCADLQAoIgJBAkYEQEEBIQAgAy8BNCIGQeUARg0CQQAhACAFQcAAcQ0CIAZB5ABGDQIgBkHmAGtBAkkNAiAGQcwBRg0CIAZBsAJGDQIMAQtBACEAIAVBwABxDQELQQIhACAFQQhxDQAgBUGABHEEQAJAIAJBAUcNACADLQAuQQpxDQBBBSEADAILQQQhAAwBCyAFQSBxRQRAIAMQNUEAR0ECdCEADAELQQBBAyADKQMgUBshAAsCQCAAQQFrDgUAAQYHAgMLQQAhAgJAIAMoAjgiAEUNACAAKAIsIgBFDQAgAyAAEQAAIQILIAJFDSYgAkEVRgRAIANBAzYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDC4LQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDC0LQc4BIQIMEgtBACECIANBADYCHCADIAE2AhQgA0HkHzYCECADQQ82AgwMKwtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAA0BC0EOIQIMDwsgAEEVRgRAIANBAjYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDCkLQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDCgLQSkhAgwNCyADQQE6ADEMJAsgASAERwRAIANBCTYCCCADIAE2AgRBKCECDAwLQSYhAgwlCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMVARAQSUhAgwlCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDQAgA0EFNgIcIAMgATYCFCADIAA2AgwMJAtBDyECDAkLIAEgBEYEQEEjIQIMIwtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsONxcWAAECAwQFBgcUFBQUFBQUCAkKCwwNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQODxAREhMUC0ICIQoMFgtCAyEKDBULQgQhCgwUC0IFIQoMEwtCBiEKDBILQgchCgwRC0IIIQoMEAtCCSEKDA8LQgohCgwOC0ILIQoMDQtCDCEKDAwLQg0hCgwLC0IOIQoMCgtCDyEKDAkLQgohCgwIC0ILIQoMBwtCDCEKDAYLQg0hCgwFC0IOIQoMBAtCDyEKDAMLQQAhAiADQQA2AhwgAyABNgIUIANBzhQ2AhAgA0EMNgIMDCILIAEgBEYEQEEiIQIMIgtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQTBrDjcVFAABAgMEBQYHFhYWFhYWFggJCgsMDRYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWDg8QERITFgtCAiEKDBQLQgMhCgwTC0IEIQoMEgtCBSEKDBELQgYhCgwQC0IHIQoMDwtCCCEKDA4LQgkhCgwNC0IKIQoMDAtCCyEKDAsLQgwhCgwKC0INIQoMCQtCDiEKDAgLQg8hCgwHC0IKIQoMBgtCCyEKDAULQgwhCgwEC0INIQoMAwtCDiEKDAILQg8hCgwBC0IBIQoLIAFBAWohASADKQMgIgtC//////////8PWARAIAMgC0IEhiAKhDcDIAwCC0EAIQIgA0EANgIcIAMgATYCFCADQa0JNgIQIANBDDYCDAwfC0ElIQIMBAtBJiECDAMLIAMgAToALCADQQA2AgAgB0EBaiEBQQwhAgwCCyADQQA2AgAgBkEBaiEBQQohAgwBCyABQQFqIQFBCCECDAALAAtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMGAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMFwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMFgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMFQtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMFAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMEwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMEgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMEQtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMEAtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMDwtBACECIANBADYCHCADIAE2AhQgA0HIEjYCECADQQs2AgwMDgtBACECIANBADYCHCADIAE2AhQgA0GVCTYCECADQQs2AgwMDQtBACECIANBADYCHCADIAE2AhQgA0HpDzYCECADQQo2AgwMDAtBACECIANBADYCHCADIAE2AhQgA0GDEDYCECADQQo2AgwMCwtBACECIANBADYCHCADIAE2AhQgA0GmHDYCECADQQI2AgwMCgtBACECIANBADYCHCADIAE2AhQgA0HFFTYCECADQQI2AgwMCQtBACECIANBADYCHCADIAE2AhQgA0H/FzYCECADQQI2AgwMCAtBACECIANBADYCHCADIAE2AhQgA0HKFzYCECADQQI2AgwMBwsgA0ECNgIcIAMgATYCFCADQZQdNgIQIANBFjYCDEEAIQIMBgtB3gAhAiABIARGDQUgCUEIaiEHIAMoAgAhBQJAAkAgASAERwRAIAVBxsYAaiEIIAQgBWogAWshBiAFQX9zQQpqIgUgAWohAANAIAEtAAAgCC0AAEcEQEECIQgMAwsgBUUEQEEAIQggACEBDAMLIAVBAWshBSAIQQFqIQggBCABQQFqIgFHDQALIAYhBSAEIQELIAdBATYCACADIAU2AgAMAQsgA0EANgIAIAcgCDYCAAsgByABNgIEIAkoAgwhACAJKAIIDgMBBQIACwALIANBADYCHCADQa0dNgIQIANBFzYCDCADIABBAWo2AhRBACECDAMLIANBADYCHCADIAA2AhQgA0HCHTYCECADQQk2AgxBACECDAILIAEgBEYEQEEoIQIMAgsgA0EJNgIIIAMgATYCBEEnIQIMAQsgASAERgRAQQEhAgwBCwNAAkACQAJAIAEtAABBCmsOBAABAQABCyABQQFqIQEMAQsgAUEBaiEBIAMtAC5BIHENAEEAIQIgA0EANgIcIAMgATYCFCADQYwgNgIQIANBBTYCDAwCC0EBIQIgASAERw0ACwsgCUEQaiQAIAJFBEAgAygCDCEADAELIAMgAjYCHEEAIQAgAygCBCIBRQ0AIAMgASAEIAMoAggRAQAiAUUNACADIAQ2AhQgAyABNgIMIAEhAAsgAAu+AgECfyAAQQA6AAAgAEHcAGoiAUEBa0EAOgAAIABBADoAAiAAQQA6AAEgAUEDa0EAOgAAIAFBAmtBADoAACAAQQA6AAMgAUEEa0EAOgAAQQAgAGtBA3EiASAAaiIAQQA2AgBB3AAgAWtBfHEiAiAAaiIBQQRrQQA2AgACQCACQQlJDQAgAEEANgIIIABBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIAJBGUkNACAAQQA2AhggAEEANgIUIABBADYCECAAQQA2AgwgAUEQa0EANgIAIAFBFGtBADYCACABQRhrQQA2AgAgAUEca0EANgIAIAIgAEEEcUEYciICayIBQSBJDQAgACACaiEAA0AgAEIANwMYIABCADcDECAAQgA3AwggAEIANwMAIABBIGohACABQSBrIgFBH0sNAAsLC1YBAX8CQCAAKAIMDQACQAJAAkACQCAALQAxDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgAREAACIBDQMLQQAPCwALIABB0Bg2AhBBDiEBCyABCxoAIAAoAgxFBEAgAEHJHjYCECAAQRU2AgwLCxQAIAAoAgxBFUYEQCAAQQA2AgwLCxQAIAAoAgxBFkYEQCAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsXACAAQSRPBEAACyAAQQJ0QZQ3aigCAAsXACAAQS9PBEAACyAAQQJ0QaQ4aigCAAu/CQEBf0HfLCEBAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHkAGsO9ANjYgABYWFhYWFhAgMEBWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEGBwgJCgsMDQ4PYWFhYWEQYWFhYWFhYWFhYWERYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhEhMUFRYXGBkaG2FhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEcHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTZhNzg5OmFhYWFhYWFhO2FhYTxhYWFhPT4/YWFhYWFhYWFAYWFBYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhQkNERUZHSElKS0xNTk9QUVJTYWFhYWFhYWFUVVZXWFlaW2FcXWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYV5hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFfYGELQdUrDwtBgyUPC0G/MA8LQfI1DwtBtCgPC0GfKA8LQYEsDwtB1ioPC0H0Mw8LQa0zDwtByygPC0HOIw8LQcAjDwtB2SMPC0HRJA8LQZwzDwtBojYPC0H8Mw8LQeArDwtB4SUPC0HtIA8LQcQyDwtBqScPC0G5Ng8LQbggDwtBqyAPC0GjJA8LQbYkDwtBgSMPC0HhMg8LQZ80DwtByCkPC0HAMg8LQe4yDwtB8C8PC0HGNA8LQdAhDwtBmiQPC0HrLw8LQYQ1DwtByzUPC0GWMQ8LQcgrDwtB1C8PC0GTMA8LQd81DwtBtCMPC0G+NQ8LQdIpDwtBsyIPC0HNIA8LQZs2DwtBkCEPC0H/IA8LQa01DwtBsDQPC0HxJA8LQacqDwtB3TAPC0GLIg8LQcgvDwtB6yoPC0H0KQ8LQY8lDwtB3SIPC0HsJg8LQf0wDwtB1iYPC0GUNQ8LQY0jDwtBuikPC0HHIg8LQfIlDwtBtjMPC0GiIQ8LQf8vDwtBwCEPC0GBMw8LQcklDwtBqDEPC0HGMw8LQdM2DwtBxjYPC0HkNA8LQYgmDwtB7ScPC0H4IQ8LQakwDwtBjzQPC0GGNg8LQaovDwtBoSYPC0HsNg8LQZIpDwtBryYPC0GZIg8LQeAhDwsAC0G1JSEBCyABCxcAIAAgAC8BLkH+/wNxIAFBAEdyOwEuCxoAIAAgAC8BLkH9/wNxIAFBAEdBAXRyOwEuCxoAIAAgAC8BLkH7/wNxIAFBAEdBAnRyOwEuCxoAIAAgAC8BLkH3/wNxIAFBAEdBA3RyOwEuCxoAIAAgAC8BLkHv/wNxIAFBAEdBBHRyOwEuCxoAIAAgAC8BLkHf/wNxIAFBAEdBBXRyOwEuCxoAIAAgAC8BLkG//wNxIAFBAEdBBnRyOwEuCxoAIAAgAC8BLkH//gNxIAFBAEdBB3RyOwEuCxoAIAAgAC8BLkH//QNxIAFBAEdBCHRyOwEuCxoAIAAgAC8BLkH/+wNxIAFBAEdBCXRyOwEuCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBzhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB5Ao2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB5R02AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBnRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBoh42AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7hQ2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9xs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRU2AhBBGCEECyAECzgAIAACfyAALwEyQRRxQRRGBEBBASAALQAoQQFGDQEaIAAvATRB5QBGDAELIAAtAClBBUYLOgAwC1kBAn8CQCAALQAoQQFGDQAgAC8BNCIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMiIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEyIgFBAnFFDQEMAgsgAC8BMiIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATQiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtzACAAQRBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAA/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQTBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQSBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQewBNgIcCwYAIAAQOQuaLQELfyMAQRBrIgokAEGY1AAoAgAiCUUEQEHY1wAoAgAiBUUEQEHk1wBCfzcCAEHc1wBCgICEgICAwAA3AgBB2NcAIApBCGpBcHFB2KrVqgVzIgU2AgBB7NcAQQA2AgBBvNcAQQA2AgALQcDXAEGA2AQ2AgBBkNQAQYDYBDYCAEGk1AAgBTYCAEGg1ABBfzYCAEHE1wBBgKgDNgIAA0AgAUG81ABqIAFBsNQAaiICNgIAIAIgAUGo1ABqIgM2AgAgAUG01ABqIAM2AgAgAUHE1ABqIAFBuNQAaiIDNgIAIAMgAjYCACABQczUAGogAUHA1ABqIgI2AgAgAiADNgIAIAFByNQAaiACNgIAIAFBIGoiAUGAAkcNAAtBjNgEQcGnAzYCAEGc1ABB6NcAKAIANgIAQYzUAEHApwM2AgBBmNQAQYjYBDYCAEHM/wdBODYCAEGI2AQhCQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQewBTQRAQYDUACgCACIGQRAgAEETakFwcSAAQQtJGyIEQQN2IgB2IgFBA3EEQAJAIAFBAXEgAHJBAXMiAkEDdCIAQajUAGoiASAAQbDUAGooAgAiACgCCCIDRgRAQYDUACAGQX4gAndxNgIADAELIAEgAzYCCCADIAE2AgwLIABBCGohASAAIAJBA3QiAkEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBAwRC0GI1AAoAgAiCCAETw0BIAEEQAJAQQIgAHQiAkEAIAJrciABIAB0cWgiAEEDdCICQajUAGoiASACQbDUAGooAgAiAigCCCIDRgRAQYDUACAGQX4gAHdxIgY2AgAMAQsgASADNgIIIAMgATYCDAsgAiAEQQNyNgIEIABBA3QiACAEayEFIAAgAmogBTYCACACIARqIgQgBUEBcjYCBCAIBEAgCEF4cUGo1ABqIQBBlNQAKAIAIQMCf0EBIAhBA3Z0IgEgBnFFBEBBgNQAIAEgBnI2AgAgAAwBCyAAKAIICyIBIAM2AgwgACADNgIIIAMgADYCDCADIAE2AggLIAJBCGohAUGU1AAgBDYCAEGI1AAgBTYCAAwRC0GE1AAoAgAiC0UNASALaEECdEGw1gBqKAIAIgAoAgRBeHEgBGshBSAAIQIDQAJAIAIoAhAiAUUEQCACQRRqKAIAIgFFDQELIAEoAgRBeHEgBGsiAyAFSSECIAMgBSACGyEFIAEgACACGyEAIAEhAgwBCwsgACgCGCEJIAAoAgwiAyAARwRAQZDUACgCABogAyAAKAIIIgE2AgggASADNgIMDBALIABBFGoiAigCACIBRQRAIAAoAhAiAUUNAyAAQRBqIQILA0AgAiEHIAEiA0EUaiICKAIAIgENACADQRBqIQIgAygCECIBDQALIAdBADYCAAwPC0F/IQQgAEG/f0sNACAAQRNqIgFBcHEhBEGE1AAoAgAiCEUNAEEAIARrIQUCQAJAAkACf0EAIARBgAJJDQAaQR8gBEH///8HSw0AGiAEQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qCyIGQQJ0QbDWAGooAgAiAkUEQEEAIQFBACEDDAELQQAhASAEQRkgBkEBdmtBACAGQR9HG3QhAEEAIQMDQAJAIAIoAgRBeHEgBGsiByAFTw0AIAIhAyAHIgUNAEEAIQUgAiEBDAMLIAEgAkEUaigCACIHIAcgAiAAQR12QQRxakEQaigCACICRhsgASAHGyEBIABBAXQhACACDQALCyABIANyRQRAQQAhA0ECIAZ0IgBBACAAa3IgCHEiAEUNAyAAaEECdEGw1gBqKAIAIQELIAFFDQELA0AgASgCBEF4cSAEayICIAVJIQAgAiAFIAAbIQUgASADIAAbIQMgASgCECIABH8gAAUgAUEUaigCAAsiAQ0ACwsgA0UNACAFQYjUACgCACAEa08NACADKAIYIQcgAyADKAIMIgBHBEBBkNQAKAIAGiAAIAMoAggiATYCCCABIAA2AgwMDgsgA0EUaiICKAIAIgFFBEAgAygCECIBRQ0DIANBEGohAgsDQCACIQYgASIAQRRqIgIoAgAiAQ0AIABBEGohAiAAKAIQIgENAAsgBkEANgIADA0LQYjUACgCACIDIARPBEBBlNQAKAIAIQECQCADIARrIgJBEE8EQCABIARqIgAgAkEBcjYCBCABIANqIAI2AgAgASAEQQNyNgIEDAELIAEgA0EDcjYCBCABIANqIgAgACgCBEEBcjYCBEEAIQBBACECC0GI1AAgAjYCAEGU1AAgADYCACABQQhqIQEMDwtBjNQAKAIAIgMgBEsEQCAEIAlqIgAgAyAEayIBQQFyNgIEQZjUACAANgIAQYzUACABNgIAIAkgBEEDcjYCBCAJQQhqIQEMDwtBACEBIAQCf0HY1wAoAgAEQEHg1wAoAgAMAQtB5NcAQn83AgBB3NcAQoCAhICAgMAANwIAQdjXACAKQQxqQXBxQdiq1aoFczYCAEHs1wBBADYCAEG81wBBADYCAEGAgAQLIgAgBEHHAGoiBWoiBkEAIABrIgdxIgJPBEBB8NcAQTA2AgAMDwsCQEG41wAoAgAiAUUNAEGw1wAoAgAiCCACaiEAIAAgAU0gACAIS3ENAEEAIQFB8NcAQTA2AgAMDwtBvNcALQAAQQRxDQQCQAJAIAkEQEHA1wAhAQNAIAEoAgAiACAJTQRAIAAgASgCBGogCUsNAwsgASgCCCIBDQALC0EAEDoiAEF/Rg0FIAIhBkHc1wAoAgAiAUEBayIDIABxBEAgAiAAayAAIANqQQAgAWtxaiEGCyAEIAZPDQUgBkH+////B0sNBUG41wAoAgAiAwRAQbDXACgCACIHIAZqIQEgASAHTQ0GIAEgA0sNBgsgBhA6IgEgAEcNAQwHCyAGIANrIAdxIgZB/v///wdLDQQgBhA6IQAgACABKAIAIAEoAgRqRg0DIAAhAQsCQCAGIARByABqTw0AIAFBf0YNAEHg1wAoAgAiACAFIAZrakEAIABrcSIAQf7///8HSwRAIAEhAAwHCyAAEDpBf0cEQCAAIAZqIQYgASEADAcLQQAgBmsQOhoMBAsgASIAQX9HDQUMAwtBACEDDAwLQQAhAAwKCyAAQX9HDQILQbzXAEG81wAoAgBBBHI2AgALIAJB/v///wdLDQEgAhA6IQBBABA6IQEgAEF/Rg0BIAFBf0YNASAAIAFPDQEgASAAayIGIARBOGpNDQELQbDXAEGw1wAoAgAgBmoiATYCAEG01wAoAgAgAUkEQEG01wAgATYCAAsCQAJAAkBBmNQAKAIAIgIEQEHA1wAhAQNAIAAgASgCACIDIAEoAgQiBWpGDQIgASgCCCIBDQALDAILQZDUACgCACIBQQBHIAAgAU9xRQRAQZDUACAANgIAC0EAIQFBxNcAIAY2AgBBwNcAIAA2AgBBoNQAQX82AgBBpNQAQdjXACgCADYCAEHM1wBBADYCAANAIAFBvNQAaiABQbDUAGoiAjYCACACIAFBqNQAaiIDNgIAIAFBtNQAaiADNgIAIAFBxNQAaiABQbjUAGoiAzYCACADIAI2AgAgAUHM1ABqIAFBwNQAaiICNgIAIAIgAzYCACABQcjUAGogAjYCACABQSBqIgFBgAJHDQALQXggAGtBD3EiASAAaiICIAZBOGsiAyABayIBQQFyNgIEQZzUAEHo1wAoAgA2AgBBjNQAIAE2AgBBmNQAIAI2AgAgACADakE4NgIEDAILIAAgAk0NACACIANJDQAgASgCDEEIcQ0AQXggAmtBD3EiACACaiIDQYzUACgCACAGaiIHIABrIgBBAXI2AgQgASAFIAZqNgIEQZzUAEHo1wAoAgA2AgBBjNQAIAA2AgBBmNQAIAM2AgAgAiAHakE4NgIEDAELIABBkNQAKAIASQRAQZDUACAANgIACyAAIAZqIQNBwNcAIQECQAJAAkADQCADIAEoAgBHBEAgASgCCCIBDQEMAgsLIAEtAAxBCHFFDQELQcDXACEBA0AgASgCACIDIAJNBEAgAyABKAIEaiIFIAJLDQMLIAEoAgghAQwACwALIAEgADYCACABIAEoAgQgBmo2AgQgAEF4IABrQQ9xaiIJIARBA3I2AgQgA0F4IANrQQ9xaiIGIAQgCWoiBGshASACIAZGBEBBmNQAIAQ2AgBBjNQAQYzUACgCACABaiIANgIAIAQgAEEBcjYCBAwIC0GU1AAoAgAgBkYEQEGU1AAgBDYCAEGI1ABBiNQAKAIAIAFqIgA2AgAgBCAAQQFyNgIEIAAgBGogADYCAAwICyAGKAIEIgVBA3FBAUcNBiAFQXhxIQggBUH/AU0EQCAFQQN2IQMgBigCCCIAIAYoAgwiAkYEQEGA1ABBgNQAKAIAQX4gA3dxNgIADAcLIAIgADYCCCAAIAI2AgwMBgsgBigCGCEHIAYgBigCDCIARwRAIAAgBigCCCICNgIIIAIgADYCDAwFCyAGQRRqIgIoAgAiBUUEQCAGKAIQIgVFDQQgBkEQaiECCwNAIAIhAyAFIgBBFGoiAigCACIFDQAgAEEQaiECIAAoAhAiBQ0ACyADQQA2AgAMBAtBeCAAa0EPcSIBIABqIgcgBkE4ayIDIAFrIgFBAXI2AgQgACADakE4NgIEIAIgBUE3IAVrQQ9xakE/ayIDIAMgAkEQakkbIgNBIzYCBEGc1ABB6NcAKAIANgIAQYzUACABNgIAQZjUACAHNgIAIANBEGpByNcAKQIANwIAIANBwNcAKQIANwIIQcjXACADQQhqNgIAQcTXACAGNgIAQcDXACAANgIAQczXAEEANgIAIANBJGohAQNAIAFBBzYCACAFIAFBBGoiAUsNAAsgAiADRg0AIAMgAygCBEF+cTYCBCADIAMgAmsiBTYCACACIAVBAXI2AgQgBUH/AU0EQCAFQXhxQajUAGohAAJ/QYDUACgCACIBQQEgBUEDdnQiA3FFBEBBgNQAIAEgA3I2AgAgAAwBCyAAKAIICyIBIAI2AgwgACACNgIIIAIgADYCDCACIAE2AggMAQtBHyEBIAVB////B00EQCAFQSYgBUEIdmciAGt2QQFxIABBAXRrQT5qIQELIAIgATYCHCACQgA3AhAgAUECdEGw1gBqIQBBhNQAKAIAIgNBASABdCIGcUUEQCAAIAI2AgBBhNQAIAMgBnI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEDAkADQCADIgAoAgRBeHEgBUYNASABQR12IQMgAUEBdCEBIAAgA0EEcWpBEGoiBigCACIDDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLQYzUACgCACIBIARNDQBBmNQAKAIAIgAgBGoiAiABIARrIgFBAXI2AgRBjNQAIAE2AgBBmNQAIAI2AgAgACAEQQNyNgIEIABBCGohAQwIC0EAIQFB8NcAQTA2AgAMBwtBACEACyAHRQ0AAkAgBigCHCICQQJ0QbDWAGoiAygCACAGRgRAIAMgADYCACAADQFBhNQAQYTUACgCAEF+IAJ3cTYCAAwCCyAHQRBBFCAHKAIQIAZGG2ogADYCACAARQ0BCyAAIAc2AhggBigCECICBEAgACACNgIQIAIgADYCGAsgBkEUaigCACICRQ0AIABBFGogAjYCACACIAA2AhgLIAEgCGohASAGIAhqIgYoAgQhBQsgBiAFQX5xNgIEIAEgBGogATYCACAEIAFBAXI2AgQgAUH/AU0EQCABQXhxQajUAGohAAJ/QYDUACgCACICQQEgAUEDdnQiAXFFBEBBgNQAIAEgAnI2AgAgAAwBCyAAKAIICyIBIAQ2AgwgACAENgIIIAQgADYCDCAEIAE2AggMAQtBHyEFIAFB////B00EQCABQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qIQULIAQgBTYCHCAEQgA3AhAgBUECdEGw1gBqIQBBhNQAKAIAIgJBASAFdCIDcUUEQCAAIAQ2AgBBhNQAIAIgA3I2AgAgBCAANgIYIAQgBDYCCCAEIAQ2AgwMAQsgAUEZIAVBAXZrQQAgBUEfRxt0IQUgACgCACEAAkADQCAAIgIoAgRBeHEgAUYNASAFQR12IQAgBUEBdCEFIAIgAEEEcWpBEGoiAygCACIADQALIAMgBDYCACAEIAI2AhggBCAENgIMIAQgBDYCCAwBCyACKAIIIgAgBDYCDCACIAQ2AgggBEEANgIYIAQgAjYCDCAEIAA2AggLIAlBCGohAQwCCwJAIAdFDQACQCADKAIcIgFBAnRBsNYAaiICKAIAIANGBEAgAiAANgIAIAANAUGE1AAgCEF+IAF3cSIINgIADAILIAdBEEEUIAcoAhAgA0YbaiAANgIAIABFDQELIAAgBzYCGCADKAIQIgEEQCAAIAE2AhAgASAANgIYCyADQRRqKAIAIgFFDQAgAEEUaiABNgIAIAEgADYCGAsCQCAFQQ9NBEAgAyAEIAVqIgBBA3I2AgQgACADaiIAIAAoAgRBAXI2AgQMAQsgAyAEaiICIAVBAXI2AgQgAyAEQQNyNgIEIAIgBWogBTYCACAFQf8BTQRAIAVBeHFBqNQAaiEAAn9BgNQAKAIAIgFBASAFQQN2dCIFcUUEQEGA1AAgASAFcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbDWAGohAEEBIAF0IgQgCHFFBEAgACACNgIAQYTUACAEIAhyNgIAIAIgADYCGCACIAI2AgggAiACNgIMDAELIAVBGSABQQF2a0EAIAFBH0cbdCEBIAAoAgAhBAJAA0AgBCIAKAIEQXhxIAVGDQEgAUEddiEEIAFBAXQhASAAIARBBHFqQRBqIgYoAgAiBA0ACyAGIAI2AgAgAiAANgIYIAIgAjYCDCACIAI2AggMAQsgACgCCCIBIAI2AgwgACACNgIIIAJBADYCGCACIAA2AgwgAiABNgIICyADQQhqIQEMAQsCQCAJRQ0AAkAgACgCHCIBQQJ0QbDWAGoiAigCACAARgRAIAIgAzYCACADDQFBhNQAIAtBfiABd3E2AgAMAgsgCUEQQRQgCSgCECAARhtqIAM2AgAgA0UNAQsgAyAJNgIYIAAoAhAiAQRAIAMgATYCECABIAM2AhgLIABBFGooAgAiAUUNACADQRRqIAE2AgAgASADNgIYCwJAIAVBD00EQCAAIAQgBWoiAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAwBCyAAIARqIgcgBUEBcjYCBCAAIARBA3I2AgQgBSAHaiAFNgIAIAgEQCAIQXhxQajUAGohAUGU1AAoAgAhAwJ/QQEgCEEDdnQiAiAGcUUEQEGA1AAgAiAGcjYCACABDAELIAEoAggLIgIgAzYCDCABIAM2AgggAyABNgIMIAMgAjYCCAtBlNQAIAc2AgBBiNQAIAU2AgALIABBCGohAQsgCkEQaiQAIAELQwAgAEUEQD8AQRB0DwsCQCAAQf//A3ENACAAQQBIDQAgAEEQdkAAIgBBf0YEQEHw1wBBMDYCAEF/DwsgAEEQdA8LAAsL20AiAEGACAsJAQAAAAIAAAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4IxSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMARXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVycwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgAVHJhbnNmZXItRW5jb2RpbmcgY2FuJ3QgYmUgcHJlc2VudCB3aXRoIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgc2l6ZQBFeHBlY3RlZCBMRiBhZnRlciBjaHVuayBzaXplAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGhlYWRlciB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBxdW90ZWQtcGFpciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgcmVzcG9uc2UgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGV4dGVuc2lvbiBuYW1lAEludmFsaWQgc3RhdHVzIGNvZGUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBkYXRhAEV4cGVjdGVkIExGIGFmdGVyIGNodW5rIGRhdGEAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAERhdGEgYWZ0ZXIgYENvbm5lY3Rpb246IGNsb3NlYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAUVVFUlkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBFeHBlY3RlZCBMRiBhZnRlciBDUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAFIVAAAaFQAADxIAAOQZAACRFQAACRQAAC0ZAADkFAAA6REAAGkUAAChFAAAdhUAAEMWAABeEgAAlBcAABcWAAB9FAAAfxYAAEEXAACzEwAAwxYAAAQaAAC9GAAA0BgAAKATAADUGQAArxYAAGgWAABwFwAA2RYAAPwYAAD+EQAAWRcAAJcWAAAcFwAA9hYAAI0XAAALEgAAfxsAAC4RAACzEAAASRIAAK0SAAD2GAAAaBAAAGIVAAAQFQAAWhYAAEoZAAC1FQAAwRUAAGAVAABcGQAAWhkAAFMZAAAWFQAArREAAEIQAAC3EAAAVxgAAL8VAACJEAAAHBkAABoZAAC5FQAAURgAANwTAABbFQAAWRUAAOYYAABnFQAAERkAAO0YAADnEwAArhAAAMIXAAAAFAAAkhMAAIQTAABAEgAAJhkAAK8VAABiEABB6TkLAQEAQYA6C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAwEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQeo7CwQBAAACAEGBPAteAwQDAwMDAwAAAwMAAwMAAwMDAwMDAwMDAwAFAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMAAwBB6j0LBAEAAAIAQYE+C14DAAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAQABQAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEHgPwsNbG9zZWVlcC1hbGl2ZQBB+T8LAQEAQZDAAAvgAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5wQALAQEAQZDCAAvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBocQAC14BAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGAxgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBsMYACytyYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNClNNDQoNClRUUC9DRS9UU1AvAEHpxgALBQECAAEDAEGAxwALXwQFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAEHpyAALBQECAAEDAEGAyQALXwQFBQYFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAEHpygALBAEAAAEAQYHLAAteAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgBB6cwACwUBAgABAwBBgM0AC18EBQAABQUFBQUFBQUFBQUGBQUFBQUFBQUFBQUFAAUABwgFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUABQAFAAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAAAABQBB6c4ACwUBAQABAQBBgM8ACwEBAEGazwALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEHp0AALBQEBAAEBAEGA0QALAQEAQYrRAAsGAgAAAAACAEGh0QALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQeDSAAuaAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VVRVJZT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
    var wasmBuffer;
    Object.defineProperty(module, "exports", {
      get: () => {
        return wasmBuffer ? wasmBuffer : wasmBuffer = Buffer2.from(wasmBase64, "base64");
      }
    });
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/constants.js
var require_constants3 = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/constants.js"(exports, module) {
    var corsSafeListedMethods = (
      /** @type {const} */
      ["GET", "HEAD", "POST"]
    );
    var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
    var nullBodyStatus = (
      /** @type {const} */
      [101, 204, 205, 304]
    );
    var redirectStatus = (
      /** @type {const} */
      [301, 302, 303, 307, 308]
    );
    var redirectStatusSet = new Set(redirectStatus);
    var badPorts = (
      /** @type {const} */
      [
        "1",
        "7",
        "9",
        "11",
        "13",
        "15",
        "17",
        "19",
        "20",
        "21",
        "22",
        "23",
        "25",
        "37",
        "42",
        "43",
        "53",
        "69",
        "77",
        "79",
        "87",
        "95",
        "101",
        "102",
        "103",
        "104",
        "109",
        "110",
        "111",
        "113",
        "115",
        "117",
        "119",
        "123",
        "135",
        "137",
        "139",
        "143",
        "161",
        "179",
        "389",
        "427",
        "465",
        "512",
        "513",
        "514",
        "515",
        "526",
        "530",
        "531",
        "532",
        "540",
        "548",
        "554",
        "556",
        "563",
        "587",
        "601",
        "636",
        "989",
        "990",
        "993",
        "995",
        "1719",
        "1720",
        "1723",
        "2049",
        "3659",
        "4045",
        "4190",
        "5060",
        "5061",
        "6000",
        "6566",
        "6665",
        "6666",
        "6667",
        "6668",
        "6669",
        "6679",
        "6697",
        "10080"
      ]
    );
    var badPortsSet = new Set(badPorts);
    var referrerPolicyTokens = (
      /** @type {const} */
      [
        "no-referrer",
        "no-referrer-when-downgrade",
        "same-origin",
        "origin",
        "strict-origin",
        "origin-when-cross-origin",
        "strict-origin-when-cross-origin",
        "unsafe-url"
      ]
    );
    var referrerPolicy = (
      /** @type {const} */
      [
        "",
        ...referrerPolicyTokens
      ]
    );
    var referrerPolicyTokensSet = new Set(referrerPolicyTokens);
    var requestRedirect = (
      /** @type {const} */
      ["follow", "manual", "error"]
    );
    var safeMethods = (
      /** @type {const} */
      ["GET", "HEAD", "OPTIONS", "TRACE"]
    );
    var safeMethodsSet = new Set(safeMethods);
    var requestMode = (
      /** @type {const} */
      ["navigate", "same-origin", "no-cors", "cors"]
    );
    var requestCredentials = (
      /** @type {const} */
      ["omit", "same-origin", "include"]
    );
    var requestCache = (
      /** @type {const} */
      [
        "default",
        "no-store",
        "reload",
        "no-cache",
        "force-cache",
        "only-if-cached"
      ]
    );
    var requestBodyHeader = (
      /** @type {const} */
      [
        "content-encoding",
        "content-language",
        "content-location",
        "content-type",
        // See https://github.com/nodejs/undici/issues/2021
        // 'Content-Length' is a forbidden header name, which is typically
        // removed in the Headers implementation. However, undici doesn't
        // filter out headers, so we add it here.
        "content-length"
      ]
    );
    var requestDuplex = (
      /** @type {const} */
      [
        "half"
      ]
    );
    var forbiddenMethods = (
      /** @type {const} */
      ["CONNECT", "TRACE", "TRACK"]
    );
    var forbiddenMethodsSet = new Set(forbiddenMethods);
    var subresource = (
      /** @type {const} */
      [
        "audio",
        "audioworklet",
        "font",
        "image",
        "manifest",
        "paintworklet",
        "script",
        "style",
        "track",
        "video",
        "xslt",
        ""
      ]
    );
    var subresourceSet = new Set(subresource);
    module.exports = {
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex,
      subresourceSet,
      badPortsSet,
      redirectStatusSet,
      corsSafeListedMethodsSet,
      safeMethodsSet,
      forbiddenMethodsSet,
      referrerPolicyTokens: referrerPolicyTokensSet
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/global.js
var require_global = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/global.js"(exports, module) {
    var globalOrigin = Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: true,
          enumerable: false,
          configurable: false
        });
        return;
      }
      const parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      }
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    module.exports = {
      getGlobalOrigin,
      setGlobalOrigin
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/data-url.js
var require_data_url = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/data-url.js"(exports, module) {
    var assert3 = __require("assert");
    var encoder = new TextEncoder();
    var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/;
    var HTTP_WHITESPACE_REGEX = /[\u000A\u000D\u0009\u0020]/;
    var ASCII_WHITESPACE_REPLACE_REGEX = /[\u0009\u000A\u000C\u000D\u0020]/g;
    var HTTP_QUOTED_STRING_TOKENS = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
    function dataURLProcessor(dataURL) {
      assert3(dataURL.protocol === "data:");
      let input2 = URLSerializer(dataURL, true);
      input2 = input2.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePointsFast(
        ",",
        input2,
        position
      );
      const mimeTypeLength = mimeType.length;
      mimeType = removeASCIIWhitespace(mimeType, true, true);
      if (position.position >= input2.length) {
        return "failure";
      }
      position.position++;
      const encodedBody = input2.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = isomorphicDecode(body);
        body = forgivingBase64(stringBody);
        if (body === "failure") {
          return "failure";
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, "");
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url3, excludeFragment = false) {
      if (!excludeFragment) {
        return url3.href;
      }
      const href = url3.href;
      const hashLength = url3.hash.length;
      const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength);
      if (!hashLength && href.endsWith("#")) {
        return serialized.slice(0, -1);
      }
      return serialized;
    }
    function collectASequenceOfCodePoints(condition, input2, position) {
      let result = "";
      while (position.position < input2.length && condition(input2[position.position])) {
        result += input2[position.position];
        position.position++;
      }
      return result;
    }
    function collectASequenceOfCodePointsFast(char, input2, position) {
      const idx = input2.indexOf(char, position.position);
      const start3 = position.position;
      if (idx === -1) {
        position.position = input2.length;
        return input2.slice(start3);
      }
      position.position = idx;
      return input2.slice(start3, position.position);
    }
    function stringPercentDecode(input2) {
      const bytes = encoder.encode(input2);
      return percentDecode(bytes);
    }
    function isHexCharByte(byte) {
      return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
    }
    function hexByteToNumber(byte) {
      return (
        // 0-9
        byte >= 48 && byte <= 57 ? byte - 48 : (byte & 223) - 55
      );
    }
    function percentDecode(input2) {
      const length3 = input2.length;
      const output = new Uint8Array(length3);
      let j = 0;
      for (let i = 0; i < length3; ++i) {
        const byte = input2[i];
        if (byte !== 37) {
          output[j++] = byte;
        } else if (byte === 37 && !(isHexCharByte(input2[i + 1]) && isHexCharByte(input2[i + 2]))) {
          output[j++] = 37;
        } else {
          output[j++] = hexByteToNumber(input2[i + 1]) << 4 | hexByteToNumber(input2[i + 2]);
          i += 2;
        }
      }
      return length3 === j ? output : output.subarray(0, j);
    }
    function parseMIMEType(input2) {
      input2 = removeHTTPWhitespace(input2, true, true);
      const position = { position: 0 };
      const type = collectASequenceOfCodePointsFast(
        "/",
        input2,
        position
      );
      if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
        return "failure";
      }
      if (position.position >= input2.length) {
        return "failure";
      }
      position.position++;
      let subtype = collectASequenceOfCodePointsFast(
        ";",
        input2,
        position
      );
      subtype = removeHTTPWhitespace(subtype, false, true);
      if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
        return "failure";
      }
      const typeLowercase = type.toLowerCase();
      const subtypeLowercase = subtype.toLowerCase();
      const mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        /** @type {Map<string, string>} */
        parameters: /* @__PURE__ */ new Map(),
        // https://mimesniff.spec.whatwg.org/#mime-type-essence
        essence: `${typeLowercase}/${subtypeLowercase}`
      };
      while (position.position < input2.length) {
        position.position++;
        collectASequenceOfCodePoints(
          // https://fetch.spec.whatwg.org/#http-whitespace
          (char) => HTTP_WHITESPACE_REGEX.test(char),
          input2,
          position
        );
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input2,
          position
        );
        parameterName = parameterName.toLowerCase();
        if (position.position < input2.length) {
          if (input2[position.position] === ";") {
            continue;
          }
          position.position++;
        }
        if (position.position >= input2.length) {
          break;
        }
        let parameterValue = null;
        if (input2[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input2, position, true);
          collectASequenceOfCodePointsFast(
            ";",
            input2,
            position
          );
        } else {
          parameterValue = collectASequenceOfCodePointsFast(
            ";",
            input2,
            position
          );
          parameterValue = removeHTTPWhitespace(parameterValue, false, true);
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, "");
      let dataLength = data.length;
      if (dataLength % 4 === 0) {
        if (data.charCodeAt(dataLength - 1) === 61) {
          --dataLength;
          if (data.charCodeAt(dataLength - 1) === 61) {
            --dataLength;
          }
        }
      }
      if (dataLength % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {
        return "failure";
      }
      const buffer4 = Buffer.from(data, "base64");
      return new Uint8Array(buffer4.buffer, buffer4.byteOffset, buffer4.byteLength);
    }
    function collectAnHTTPQuotedString(input2, position, extractValue = false) {
      const positionStart = position.position;
      let value = "";
      assert3(input2[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== "\\",
          input2,
          position
        );
        if (position.position >= input2.length) {
          break;
        }
        const quoteOrBackslash = input2[position.position];
        position.position++;
        if (quoteOrBackslash === "\\") {
          if (position.position >= input2.length) {
            value += "\\";
            break;
          }
          value += input2[position.position];
          position.position++;
        } else {
          assert3(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue) {
        return value;
      }
      return input2.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert3(mimeType !== "failure");
      const { parameters, essence } = mimeType;
      let serialization = essence;
      for (let [name, value] of parameters.entries()) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
          value = value.replace(/(\\|")/g, "\\$1");
          value = '"' + value;
          value += '"';
        }
        serialization += value;
      }
      return serialization;
    }
    function isHTTPWhiteSpace(char) {
      return char === 13 || char === 10 || char === 9 || char === 32;
    }
    function removeHTTPWhitespace(str, leading = true, trailing = true) {
      return removeChars(str, leading, trailing, isHTTPWhiteSpace);
    }
    function isASCIIWhitespace(char) {
      return char === 13 || char === 10 || char === 9 || char === 12 || char === 32;
    }
    function removeASCIIWhitespace(str, leading = true, trailing = true) {
      return removeChars(str, leading, trailing, isASCIIWhitespace);
    }
    function removeChars(str, leading, trailing, predicate) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        while (lead < str.length && predicate(str.charCodeAt(lead))) lead++;
      }
      if (trailing) {
        while (trail > 0 && predicate(str.charCodeAt(trail))) trail--;
      }
      return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1);
    }
    function isomorphicDecode(input2) {
      const length3 = input2.length;
      if ((2 << 15) - 1 > length3) {
        return String.fromCharCode.apply(null, input2);
      }
      let result = "";
      let i = 0;
      let addition = (2 << 15) - 1;
      while (i < length3) {
        if (i + addition > length3) {
          addition = length3 - i;
        }
        result += String.fromCharCode.apply(null, input2.subarray(i, i += addition));
      }
      return result;
    }
    function minimizeSupportedMimeType(mimeType) {
      switch (mimeType.essence) {
        case "application/ecmascript":
        case "application/javascript":
        case "application/x-ecmascript":
        case "application/x-javascript":
        case "text/ecmascript":
        case "text/javascript":
        case "text/javascript1.0":
        case "text/javascript1.1":
        case "text/javascript1.2":
        case "text/javascript1.3":
        case "text/javascript1.4":
        case "text/javascript1.5":
        case "text/jscript":
        case "text/livescript":
        case "text/x-ecmascript":
        case "text/x-javascript":
          return "text/javascript";
        case "application/json":
        case "text/json":
          return "application/json";
        case "image/svg+xml":
          return "image/svg+xml";
        case "text/xml":
        case "application/xml":
          return "application/xml";
      }
      if (mimeType.subtype.endsWith("+json")) {
        return "application/json";
      }
      if (mimeType.subtype.endsWith("+xml")) {
        return "application/xml";
      }
      return "";
    }
    module.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType,
      removeChars,
      removeHTTPWhitespace,
      minimizeSupportedMimeType,
      HTTP_TOKEN_CODEPOINTS,
      isomorphicDecode
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/webidl.js
var require_webidl = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/webidl.js"(exports, module) {
    var { types, inspect } = __require("util");
    var { markAsUncloneable } = __require("worker_threads");
    var { toUSVString } = require_util();
    var UNDEFINED2 = 1;
    var BOOLEAN = 2;
    var STRING = 3;
    var SYMBOL = 4;
    var NUMBER = 5;
    var BIGINT = 6;
    var NULL2 = 7;
    var OBJECT = 8;
    var FunctionPrototypeSymbolHasInstance = Function.call.bind(Function.prototype[Symbol.hasInstance]);
    var webidl = {
      converters: {},
      util: {},
      errors: {},
      is: {}
    };
    webidl.errors.exception = function(message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function(context8) {
      const plural = context8.types.length === 1 ? "" : " one of";
      const message = `${context8.argument} could not be converted to${plural}: ${context8.types.join(", ")}.`;
      return webidl.errors.exception({
        header: context8.prefix,
        message
      });
    };
    webidl.errors.invalidArgument = function(context8) {
      return webidl.errors.exception({
        header: context8.prefix,
        message: `"${context8.value}" is an invalid ${context8.type}.`
      });
    };
    webidl.brandCheck = function(V2, I2) {
      if (!FunctionPrototypeSymbolHasInstance(I2, V2)) {
        const err = new TypeError("Illegal invocation");
        err.code = "ERR_INVALID_THIS";
        throw err;
      }
    };
    webidl.brandCheckMultiple = function(List) {
      const prototypes = List.map((c) => webidl.util.MakeTypeAssertion(c));
      return (V2) => {
        if (prototypes.every((typeCheck) => !typeCheck(V2))) {
          const err = new TypeError("Illegal invocation");
          err.code = "ERR_INVALID_THIS";
          throw err;
        }
      };
    };
    webidl.argumentLengthCheck = function({ length: length3 }, min3, ctx) {
      if (length3 < min3) {
        throw webidl.errors.exception({
          message: `${min3} argument${min3 !== 1 ? "s" : ""} required, but${length3 ? " only" : ""} ${length3} found.`,
          header: ctx
        });
      }
    };
    webidl.illegalConstructor = function() {
      throw webidl.errors.exception({
        header: "TypeError",
        message: "Illegal constructor"
      });
    };
    webidl.util.MakeTypeAssertion = function(I2) {
      return (O4) => FunctionPrototypeSymbolHasInstance(I2, O4);
    };
    webidl.util.Type = function(V2) {
      switch (typeof V2) {
        case "undefined":
          return UNDEFINED2;
        case "boolean":
          return BOOLEAN;
        case "string":
          return STRING;
        case "symbol":
          return SYMBOL;
        case "number":
          return NUMBER;
        case "bigint":
          return BIGINT;
        case "function":
        case "object": {
          if (V2 === null) {
            return NULL2;
          }
          return OBJECT;
        }
      }
    };
    webidl.util.Types = {
      UNDEFINED: UNDEFINED2,
      BOOLEAN,
      STRING,
      SYMBOL,
      NUMBER,
      BIGINT,
      NULL: NULL2,
      OBJECT
    };
    webidl.util.TypeValueToString = function(o2) {
      switch (webidl.util.Type(o2)) {
        case UNDEFINED2:
          return "Undefined";
        case BOOLEAN:
          return "Boolean";
        case STRING:
          return "String";
        case SYMBOL:
          return "Symbol";
        case NUMBER:
          return "Number";
        case BIGINT:
          return "BigInt";
        case NULL2:
          return "Null";
        case OBJECT:
          return "Object";
      }
    };
    webidl.util.markAsUncloneable = markAsUncloneable || (() => {
    });
    webidl.util.ConvertToInt = function(V2, bitLength, signedness, opts) {
      let upperBound2;
      let lowerBound2;
      if (bitLength === 64) {
        upperBound2 = Math.pow(2, 53) - 1;
        if (signedness === "unsigned") {
          lowerBound2 = 0;
        } else {
          lowerBound2 = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === "unsigned") {
        lowerBound2 = 0;
        upperBound2 = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound2 = Math.pow(-2, bitLength) - 1;
        upperBound2 = Math.pow(2, bitLength - 1) - 1;
      }
      let x2 = Number(V2);
      if (x2 === 0) {
        x2 = 0;
      }
      if (opts?.enforceRange === true) {
        if (Number.isNaN(x2) || x2 === Number.POSITIVE_INFINITY || x2 === Number.NEGATIVE_INFINITY) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${webidl.util.Stringify(V2)} to an integer.`
          });
        }
        x2 = webidl.util.IntegerPart(x2);
        if (x2 < lowerBound2 || x2 > upperBound2) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound2}-${upperBound2}, got ${x2}.`
          });
        }
        return x2;
      }
      if (!Number.isNaN(x2) && opts?.clamp === true) {
        x2 = Math.min(Math.max(x2, lowerBound2), upperBound2);
        if (Math.floor(x2) % 2 === 0) {
          x2 = Math.floor(x2);
        } else {
          x2 = Math.ceil(x2);
        }
        return x2;
      }
      if (Number.isNaN(x2) || x2 === 0 && Object.is(0, x2) || x2 === Number.POSITIVE_INFINITY || x2 === Number.NEGATIVE_INFINITY) {
        return 0;
      }
      x2 = webidl.util.IntegerPart(x2);
      x2 = x2 % Math.pow(2, bitLength);
      if (signedness === "signed" && x2 >= Math.pow(2, bitLength) - 1) {
        return x2 - Math.pow(2, bitLength);
      }
      return x2;
    };
    webidl.util.IntegerPart = function(n2) {
      const r = Math.floor(Math.abs(n2));
      if (n2 < 0) {
        return -1 * r;
      }
      return r;
    };
    webidl.util.Stringify = function(V2) {
      const type = webidl.util.Type(V2);
      switch (type) {
        case SYMBOL:
          return `Symbol(${V2.description})`;
        case OBJECT:
          return inspect(V2);
        case STRING:
          return `"${V2}"`;
        default:
          return `${V2}`;
      }
    };
    webidl.sequenceConverter = function(converter) {
      return (V2, prefix, argument, Iterable) => {
        if (webidl.util.Type(V2) !== OBJECT) {
          throw webidl.errors.exception({
            header: prefix,
            message: `${argument} (${webidl.util.Stringify(V2)}) is not iterable.`
          });
        }
        const method = typeof Iterable === "function" ? Iterable() : V2?.[Symbol.iterator]?.();
        const seq2 = [];
        let index = 0;
        if (method === void 0 || typeof method.next !== "function") {
          throw webidl.errors.exception({
            header: prefix,
            message: `${argument} is not iterable.`
          });
        }
        while (true) {
          const { done: done11, value } = method.next();
          if (done11) {
            break;
          }
          seq2.push(converter(value, prefix, `${argument}[${index++}]`));
        }
        return seq2;
      };
    };
    webidl.recordConverter = function(keyConverter, valueConverter) {
      return (O4, prefix, argument) => {
        if (webidl.util.Type(O4) !== OBJECT) {
          throw webidl.errors.exception({
            header: prefix,
            message: `${argument} ("${webidl.util.TypeValueToString(O4)}") is not an Object.`
          });
        }
        const result = {};
        if (!types.isProxy(O4)) {
          const keys6 = [...Object.getOwnPropertyNames(O4), ...Object.getOwnPropertySymbols(O4)];
          for (const key of keys6) {
            const keyName2 = webidl.util.Stringify(key);
            const typedKey = keyConverter(key, prefix, `Key ${keyName2} in ${argument}`);
            const typedValue = valueConverter(O4[key], prefix, `${argument}[${keyName2}]`);
            result[typedKey] = typedValue;
          }
          return result;
        }
        const keys5 = Reflect.ownKeys(O4);
        for (const key of keys5) {
          const desc = Reflect.getOwnPropertyDescriptor(O4, key);
          if (desc?.enumerable) {
            const typedKey = keyConverter(key, prefix, argument);
            const typedValue = valueConverter(O4[key], prefix, argument);
            result[typedKey] = typedValue;
          }
        }
        return result;
      };
    };
    webidl.interfaceConverter = function(TypeCheck, name) {
      return (V2, prefix, argument) => {
        if (!TypeCheck(V2)) {
          throw webidl.errors.exception({
            header: prefix,
            message: `Expected ${argument} ("${webidl.util.Stringify(V2)}") to be an instance of ${name}.`
          });
        }
        return V2;
      };
    };
    webidl.dictionaryConverter = function(converters) {
      return (dictionary, prefix, argument) => {
        const dict = {};
        if (dictionary != null && webidl.util.Type(dictionary) !== OBJECT) {
          throw webidl.errors.exception({
            header: prefix,
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
          });
        }
        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;
          if (required === true) {
            if (dictionary == null || !Object.hasOwn(dictionary, key)) {
              throw webidl.errors.exception({
                header: prefix,
                message: `Missing required key "${key}".`
              });
            }
          }
          let value = dictionary?.[key];
          const hasDefault = defaultValue !== void 0;
          if (hasDefault && value === void 0) {
            value = defaultValue();
          }
          if (required || hasDefault || value !== void 0) {
            value = converter(value, prefix, `${argument}.${key}`);
            if (options.allowedValues && !options.allowedValues.includes(value)) {
              throw webidl.errors.exception({
                header: prefix,
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
              });
            }
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function(converter) {
      return (V2, prefix, argument) => {
        if (V2 === null) {
          return V2;
        }
        return converter(V2, prefix, argument);
      };
    };
    webidl.is.ReadableStream = webidl.util.MakeTypeAssertion(ReadableStream);
    webidl.is.Blob = webidl.util.MakeTypeAssertion(Blob);
    webidl.is.URLSearchParams = webidl.util.MakeTypeAssertion(URLSearchParams);
    webidl.is.File = webidl.util.MakeTypeAssertion(globalThis.File ?? __require("buffer").File);
    webidl.is.URL = webidl.util.MakeTypeAssertion(URL);
    webidl.is.AbortSignal = webidl.util.MakeTypeAssertion(AbortSignal);
    webidl.is.MessagePort = webidl.util.MakeTypeAssertion(MessagePort);
    webidl.converters.DOMString = function(V2, prefix, argument, opts) {
      if (V2 === null && opts?.legacyNullToEmptyString) {
        return "";
      }
      if (typeof V2 === "symbol") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} is a symbol, which cannot be converted to a DOMString.`
        });
      }
      return String(V2);
    };
    webidl.converters.ByteString = function(V2, prefix, argument) {
      if (typeof V2 === "symbol") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} is a symbol, which cannot be converted to a ByteString.`
        });
      }
      const x2 = String(V2);
      for (let index = 0; index < x2.length; index++) {
        if (x2.charCodeAt(index) > 255) {
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x2.charCodeAt(index)} which is greater than 255.`
          );
        }
      }
      return x2;
    };
    webidl.converters.USVString = toUSVString;
    webidl.converters.boolean = function(V2) {
      const x2 = Boolean(V2);
      return x2;
    };
    webidl.converters.any = function(V2) {
      return V2;
    };
    webidl.converters["long long"] = function(V2, prefix, argument) {
      const x2 = webidl.util.ConvertToInt(V2, 64, "signed", void 0, prefix, argument);
      return x2;
    };
    webidl.converters["unsigned long long"] = function(V2, prefix, argument) {
      const x2 = webidl.util.ConvertToInt(V2, 64, "unsigned", void 0, prefix, argument);
      return x2;
    };
    webidl.converters["unsigned long"] = function(V2, prefix, argument) {
      const x2 = webidl.util.ConvertToInt(V2, 32, "unsigned", void 0, prefix, argument);
      return x2;
    };
    webidl.converters["unsigned short"] = function(V2, prefix, argument, opts) {
      const x2 = webidl.util.ConvertToInt(V2, 16, "unsigned", opts, prefix, argument);
      return x2;
    };
    webidl.converters.ArrayBuffer = function(V2, prefix, argument, opts) {
      if (webidl.util.Type(V2) !== OBJECT || !types.isAnyArrayBuffer(V2)) {
        throw webidl.errors.conversionFailed({
          prefix,
          argument: `${argument} ("${webidl.util.Stringify(V2)}")`,
          types: ["ArrayBuffer"]
        });
      }
      if (opts?.allowShared === false && types.isSharedArrayBuffer(V2)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      if (V2.resizable || V2.growable) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "Received a resizable ArrayBuffer."
        });
      }
      return V2;
    };
    webidl.converters.TypedArray = function(V2, T, prefix, name, opts) {
      if (webidl.util.Type(V2) !== OBJECT || !types.isTypedArray(V2) || V2.constructor.name !== T.name) {
        throw webidl.errors.conversionFailed({
          prefix,
          argument: `${name} ("${webidl.util.Stringify(V2)}")`,
          types: [T.name]
        });
      }
      if (opts?.allowShared === false && types.isSharedArrayBuffer(V2.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      if (V2.buffer.resizable || V2.buffer.growable) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "Received a resizable ArrayBuffer."
        });
      }
      return V2;
    };
    webidl.converters.DataView = function(V2, prefix, name, opts) {
      if (webidl.util.Type(V2) !== OBJECT || !types.isDataView(V2)) {
        throw webidl.errors.exception({
          header: prefix,
          message: `${name} is not a DataView.`
        });
      }
      if (opts?.allowShared === false && types.isSharedArrayBuffer(V2.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      if (V2.buffer.resizable || V2.buffer.growable) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "Received a resizable ArrayBuffer."
        });
      }
      return V2;
    };
    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );
    webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
      webidl.converters["sequence<ByteString>"]
    );
    webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    webidl.converters.Blob = webidl.interfaceConverter(webidl.is.Blob, "Blob");
    webidl.converters.AbortSignal = webidl.interfaceConverter(
      webidl.is.AbortSignal,
      "AbortSignal"
    );
    module.exports = {
      webidl
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/util.js
var require_util2 = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/util.js"(exports, module) {
    var { Transform } = __require("stream");
    var zlib = __require("zlib");
    var { redirectStatusSet, referrerPolicyTokens, badPortsSet } = require_constants3();
    var { getGlobalOrigin } = require_global();
    var { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = require_data_url();
    var { performance: performance3 } = __require("perf_hooks");
    var { ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = require_util();
    var assert3 = __require("assert");
    var { isUint8Array } = __require("util/types");
    var { webidl } = require_webidl();
    var supportedHashes = [];
    var crypto;
    try {
      crypto = __require("crypto");
      const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
      supportedHashes = crypto.getHashes().filter((hash2) => possibleRelevantHashes.includes(hash2));
    } catch {
    }
    function responseURL(response) {
      const urlList = response.urlList;
      const length3 = urlList.length;
      return length3 === 0 ? null : urlList[length3 - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatusSet.has(response.status)) {
        return null;
      }
      let location = response.headersList.get("location", true);
      if (location !== null && isValidHeaderValue(location)) {
        if (!isValidEncodedURL(location)) {
          location = normalizeBinaryStringToUtf8(location);
        }
        location = new URL(location, responseURL(response));
      }
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function isValidEncodedURL(url3) {
      for (let i = 0; i < url3.length; ++i) {
        const code = url3.charCodeAt(i);
        if (code > 126 || // Non-US-ASCII + DEL
        code < 32) {
          return false;
        }
      }
      return true;
    }
    function normalizeBinaryStringToUtf8(value) {
      return Buffer.from(value, "binary").toString("utf8");
    }
    function requestCurrentURL(request2) {
      return request2.urlList[request2.urlList.length - 1];
    }
    function requestBadPort(request2) {
      const url3 = requestCurrentURL(request2);
      if (urlIsHttpHttpsScheme(url3) && badPortsSet.has(url3.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isErrorLike(object) {
      return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
    }
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        const c = statusText.charCodeAt(i);
        if (!(c === 9 || // HTAB
        c >= 32 && c <= 126 || // SP / VCHAR
        c >= 128 && c <= 255)) {
          return false;
        }
      }
      return true;
    }
    var isValidHeaderName = isValidHTTPToken;
    function isValidHeaderValue(potentialValue) {
      return (potentialValue[0] === "	" || potentialValue[0] === " " || potentialValue[potentialValue.length - 1] === "	" || potentialValue[potentialValue.length - 1] === " " || potentialValue.includes("\n") || potentialValue.includes("\r") || potentialValue.includes("\0")) === false;
    }
    function parseReferrerPolicy(actualResponse) {
      const policyHeader = (actualResponse.headersList.get("referrer-policy", true) ?? "").split(",");
      let policy = "";
      if (policyHeader.length) {
        for (let i = policyHeader.length; i !== 0; i--) {
          const token = policyHeader[i - 1].trim();
          if (referrerPolicyTokens.has(token)) {
            policy = token;
            break;
          }
        }
      }
      return policy;
    }
    function setRequestReferrerPolicyOnRedirect(request2, actualResponse) {
      const policy = parseReferrerPolicy(actualResponse);
      if (policy !== "") {
        request2.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set("sec-fetch-mode", header, true);
    }
    function appendRequestOriginHeader(request2) {
      let serializedOrigin = request2.origin;
      if (serializedOrigin === "client" || serializedOrigin === void 0) {
        return;
      }
      if (request2.responseTainting === "cors" || request2.mode === "websocket") {
        request2.headersList.append("origin", serializedOrigin, true);
      } else if (request2.method !== "GET" && request2.method !== "HEAD") {
        switch (request2.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (request2.origin && urlHasHttpsScheme(request2.origin) && !urlHasHttpsScheme(requestCurrentURL(request2))) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(request2, requestCurrentURL(request2))) {
              serializedOrigin = null;
            }
            break;
        }
        request2.headersList.append("origin", serializedOrigin, true);
      }
    }
    function coarsenTime(timestamp, crossOriginIsolatedCapability) {
      return timestamp;
    }
    function clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {
      if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {
        return {
          domainLookupStartTime: defaultStartTime,
          domainLookupEndTime: defaultStartTime,
          connectionStartTime: defaultStartTime,
          connectionEndTime: defaultStartTime,
          secureConnectionStartTime: defaultStartTime,
          ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol
        };
      }
      return {
        domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime),
        domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime),
        connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime),
        connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime),
        secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime),
        ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol
      };
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return coarsenTime(performance3.now());
    }
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {
        referrerPolicy: "strict-origin-when-cross-origin"
      };
    }
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy
      };
    }
    function determineRequestsReferrer(request2) {
      const policy = request2.referrerPolicy;
      assert3(policy);
      let referrerSource = null;
      if (request2.referrer === "client") {
        const globalOrigin = getGlobalOrigin();
        if (!globalOrigin || globalOrigin.origin === "null") {
          return "no-referrer";
        }
        referrerSource = new URL(globalOrigin);
      } else if (webidl.is.URL(request2.referrer)) {
        referrerSource = request2.referrer;
      }
      let referrerURL = stripURLForReferrer(referrerSource);
      const referrerOrigin = stripURLForReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      switch (policy) {
        case "no-referrer":
          return "no-referrer";
        case "origin":
          if (referrerOrigin != null) {
            return referrerOrigin;
          }
          return stripURLForReferrer(referrerSource, true);
        case "unsafe-url":
          return referrerURL;
        case "strict-origin": {
          const currentURL = requestCurrentURL(request2);
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "strict-origin-when-cross-origin": {
          const currentURL = requestCurrentURL(request2);
          if (sameOrigin(referrerURL, currentURL)) {
            return referrerURL;
          }
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "same-origin":
          if (sameOrigin(request2, referrerURL)) {
            return referrerURL;
          }
          return "no-referrer";
        case "origin-when-cross-origin":
          if (sameOrigin(request2, referrerURL)) {
            return referrerURL;
          }
          return referrerOrigin;
        case "no-referrer-when-downgrade": {
          const currentURL = requestCurrentURL(request2);
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
      }
    }
    function stripURLForReferrer(url3, originOnly = false) {
      assert3(webidl.is.URL(url3));
      url3 = new URL(url3);
      if (urlIsLocal(url3)) {
        return "no-referrer";
      }
      url3.username = "";
      url3.password = "";
      url3.hash = "";
      if (originOnly === true) {
        url3.pathname = "";
        url3.search = "";
      }
      return url3;
    }
    var potentialleTrustworthyIPv4RegExp = new RegExp("^(?:(?:127\\.)(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){2}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9]))$");
    var potentialleTrustworthyIPv6RegExp = new RegExp("^(?:(?:(?:0{1,4}):){7}(?:(?:0{0,3}1))|(?:(?:0{1,4}):){1,6}(?::(?:0{0,3}1))|(?:::(?:0{0,3}1))|)$");
    function isOriginIPPotentiallyTrustworthy(origin) {
      if (origin.includes(":")) {
        if (origin[0] === "[" && origin[origin.length - 1] === "]") {
          origin = origin.slice(1, -1);
        }
        return potentialleTrustworthyIPv6RegExp.test(origin);
      }
      return potentialleTrustworthyIPv4RegExp.test(origin);
    }
    function isOriginPotentiallyTrustworthy(origin) {
      if (origin == null || origin === "null") {
        return false;
      }
      origin = new URL(origin);
      if (origin.protocol === "https:" || origin.protocol === "wss:") {
        return true;
      }
      if (isOriginIPPotentiallyTrustworthy(origin.hostname)) {
        return true;
      }
      if (origin.hostname === "localhost" || origin.hostname === "localhost.") {
        return true;
      }
      if (origin.hostname.endsWith(".localhost") || origin.hostname.endsWith(".localhost.")) {
        return true;
      }
      if (origin.protocol === "file:") {
        return true;
      }
      return false;
    }
    function isURLPotentiallyTrustworthy(url3) {
      if (!webidl.is.URL(url3)) {
        return false;
      }
      if (url3.href === "about:blank" || url3.href === "about:srcdoc") {
        return true;
      }
      if (url3.protocol === "data:") return true;
      if (url3.protocol === "blob:") return true;
      return isOriginPotentiallyTrustworthy(url3.origin);
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto === void 0) {
        return true;
      }
      const parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === "no metadata") {
        return true;
      }
      if (parsedMetadata.length === 0) {
        return true;
      }
      const strongest = getStrongestMetadata(parsedMetadata);
      const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
      for (const item of metadata) {
        const algorithm = item.algo;
        const expectedValue = item.hash;
        let actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
        if (actualValue[actualValue.length - 1] === "=") {
          if (actualValue[actualValue.length - 2] === "=") {
            actualValue = actualValue.slice(0, -2);
          } else {
            actualValue = actualValue.slice(0, -1);
          }
        }
        if (compareBase64Mixed(actualValue, expectedValue)) {
          return true;
        }
      }
      return false;
    }
    var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
    function parseMetadata(metadata) {
      const result = [];
      let empty34 = true;
      for (const token of metadata.split(" ")) {
        empty34 = false;
        const parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) {
          continue;
        }
        const algorithm = parsedToken.groups.algo.toLowerCase();
        if (supportedHashes.includes(algorithm)) {
          result.push(parsedToken.groups);
        }
      }
      if (empty34 === true) {
        return "no metadata";
      }
      return result;
    }
    function getStrongestMetadata(metadataList) {
      let algorithm = metadataList[0].algo;
      if (algorithm[3] === "5") {
        return algorithm;
      }
      for (let i = 1; i < metadataList.length; ++i) {
        const metadata = metadataList[i];
        if (metadata.algo[3] === "5") {
          algorithm = "sha512";
          break;
        } else if (algorithm[3] === "3") {
          continue;
        } else if (metadata.algo[3] === "3") {
          algorithm = "sha384";
        }
      }
      return algorithm;
    }
    function filterMetadataListByAlgorithm(metadataList, algorithm) {
      if (metadataList.length === 1) {
        return metadataList;
      }
      let pos = 0;
      for (let i = 0; i < metadataList.length; ++i) {
        if (metadataList[i].algo === algorithm) {
          metadataList[pos++] = metadataList[i];
        }
      }
      metadataList.length = pos;
      return metadataList;
    }
    function compareBase64Mixed(actualValue, expectedValue) {
      if (actualValue.length !== expectedValue.length) {
        return false;
      }
      for (let i = 0; i < actualValue.length; ++i) {
        if (actualValue[i] !== expectedValue[i]) {
          if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
            continue;
          }
          return false;
        }
      }
      return true;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request2) {
    }
    function sameOrigin(A3, B3) {
      if (A3.origin === B3.origin && A3.origin === "null") {
        return true;
      }
      if (A3.protocol === B3.protocol && A3.hostname === B3.hostname && A3.port === B3.port) {
        return true;
      }
      return false;
    }
    function createDeferredPromise() {
      let res;
      let rej;
      const promise3 = new Promise((resolve9, reject) => {
        res = resolve9;
        rej = reject;
      });
      return { promise: promise3, resolve: res, reject: rej };
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    function normalizeMethod(method) {
      return normalizedMethodRecordsBase[method.toLowerCase()] ?? method;
    }
    function serializeJavascriptValueToJSONString(value) {
      const result = JSON.stringify(value);
      if (result === void 0) {
        throw new TypeError("Value is not JSON serializable");
      }
      assert3(typeof result === "string");
      return result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function createIterator(name, kInternalIterator, keyIndex2 = 0, valueIndex = 1) {
      class FastIterableIterator {
        /** @type {any} */
        #target;
        /** @type {'key' | 'value' | 'key+value'} */
        #kind;
        /** @type {number} */
        #index;
        /**
         * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object
         * @param {unknown} target
         * @param {'key' | 'value' | 'key+value'} kind
         */
        constructor(target, kind) {
          this.#target = target;
          this.#kind = kind;
          this.#index = 0;
        }
        next() {
          if (typeof this !== "object" || this === null || !(#target in this)) {
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name} Iterator.`
            );
          }
          const index = this.#index;
          const values3 = kInternalIterator(this.#target);
          const len = values3.length;
          if (index >= len) {
            return {
              value: void 0,
              done: true
            };
          }
          const { [keyIndex2]: key, [valueIndex]: value } = values3[index];
          this.#index = index + 1;
          let result;
          switch (this.#kind) {
            case "key":
              result = key;
              break;
            case "value":
              result = value;
              break;
            case "key+value":
              result = [key, value];
              break;
          }
          return {
            value: result,
            done: false
          };
        }
      }
      delete FastIterableIterator.prototype.constructor;
      Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype);
      Object.defineProperties(FastIterableIterator.prototype, {
        [Symbol.toStringTag]: {
          writable: false,
          enumerable: false,
          configurable: true,
          value: `${name} Iterator`
        },
        next: { writable: true, enumerable: true, configurable: true }
      });
      return function(target, kind) {
        return new FastIterableIterator(target, kind);
      };
    }
    function iteratorMixin(name, object, kInternalIterator, keyIndex2 = 0, valueIndex = 1) {
      const makeIterator = createIterator(name, kInternalIterator, keyIndex2, valueIndex);
      const properties = {
        keys: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function keys5() {
            webidl.brandCheck(this, object);
            return makeIterator(this, "key");
          }
        },
        values: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function values3() {
            webidl.brandCheck(this, object);
            return makeIterator(this, "value");
          }
        },
        entries: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function entries2() {
            webidl.brandCheck(this, object);
            return makeIterator(this, "key+value");
          }
        },
        forEach: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function forEach13(callbackfn, thisArg = globalThis) {
            webidl.brandCheck(this, object);
            webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`);
            if (typeof callbackfn !== "function") {
              throw new TypeError(
                `Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`
              );
            }
            for (const { 0: key, 1: value } of makeIterator(this, "key+value")) {
              callbackfn.call(thisArg, value, key, this);
            }
          }
        }
      };
      return Object.defineProperties(object.prototype, {
        ...properties,
        [Symbol.iterator]: {
          writable: true,
          enumerable: false,
          configurable: true,
          value: properties.entries.value
        }
      });
    }
    function fullyReadBody(body, processBody, processBodyError) {
      const successSteps = processBody;
      const errorSteps = processBodyError;
      let reader;
      try {
        reader = body.stream.getReader();
      } catch (e) {
        errorSteps(e);
        return;
      }
      readAllBytes(reader, successSteps, errorSteps);
    }
    function readableStreamClose(controller) {
      try {
        controller.close();
        controller.byobRequest?.respond(0);
      } catch (err) {
        if (!err.message.includes("Controller is already closed") && !err.message.includes("ReadableStream is already closed")) {
          throw err;
        }
      }
    }
    var invalidIsomorphicEncodeValueRegex = /[^\x00-\xFF]/;
    function isomorphicEncode(input2) {
      assert3(!invalidIsomorphicEncodeValueRegex.test(input2));
      return input2;
    }
    async function readAllBytes(reader, successSteps, failureSteps) {
      const bytes = [];
      let byteLength = 0;
      try {
        do {
          const { done: done11, value: chunk5 } = await reader.read();
          if (done11) {
            successSteps(Buffer.concat(bytes, byteLength));
            return;
          }
          if (!isUint8Array(chunk5)) {
            failureSteps(TypeError("Received non-Uint8Array chunk"));
            return;
          }
          bytes.push(chunk5);
          byteLength += chunk5.length;
        } while (true);
      } catch (e) {
        failureSteps(e);
      }
    }
    function urlIsLocal(url3) {
      assert3("protocol" in url3);
      const protocol = url3.protocol;
      return protocol === "about:" || protocol === "blob:" || protocol === "data:";
    }
    function urlHasHttpsScheme(url3) {
      return typeof url3 === "string" && url3[5] === ":" && url3[0] === "h" && url3[1] === "t" && url3[2] === "t" && url3[3] === "p" && url3[4] === "s" || url3.protocol === "https:";
    }
    function urlIsHttpHttpsScheme(url3) {
      assert3("protocol" in url3);
      const protocol = url3.protocol;
      return protocol === "http:" || protocol === "https:";
    }
    function simpleRangeHeaderValue(value, allowWhitespace) {
      const data = value;
      if (!data.startsWith("bytes")) {
        return "failure";
      }
      const position = { position: 5 };
      if (allowWhitespace) {
        collectASequenceOfCodePoints(
          (char) => char === "	" || char === " ",
          data,
          position
        );
      }
      if (data.charCodeAt(position.position) !== 61) {
        return "failure";
      }
      position.position++;
      if (allowWhitespace) {
        collectASequenceOfCodePoints(
          (char) => char === "	" || char === " ",
          data,
          position
        );
      }
      const rangeStart = collectASequenceOfCodePoints(
        (char) => {
          const code = char.charCodeAt(0);
          return code >= 48 && code <= 57;
        },
        data,
        position
      );
      const rangeStartValue = rangeStart.length ? Number(rangeStart) : null;
      if (allowWhitespace) {
        collectASequenceOfCodePoints(
          (char) => char === "	" || char === " ",
          data,
          position
        );
      }
      if (data.charCodeAt(position.position) !== 45) {
        return "failure";
      }
      position.position++;
      if (allowWhitespace) {
        collectASequenceOfCodePoints(
          (char) => char === "	" || char === " ",
          data,
          position
        );
      }
      const rangeEnd = collectASequenceOfCodePoints(
        (char) => {
          const code = char.charCodeAt(0);
          return code >= 48 && code <= 57;
        },
        data,
        position
      );
      const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;
      if (position.position < data.length) {
        return "failure";
      }
      if (rangeEndValue === null && rangeStartValue === null) {
        return "failure";
      }
      if (rangeStartValue > rangeEndValue) {
        return "failure";
      }
      return { rangeStartValue, rangeEndValue };
    }
    function buildContentRange(rangeStart, rangeEnd, fullLength) {
      let contentRange = "bytes ";
      contentRange += isomorphicEncode(`${rangeStart}`);
      contentRange += "-";
      contentRange += isomorphicEncode(`${rangeEnd}`);
      contentRange += "/";
      contentRange += isomorphicEncode(`${fullLength}`);
      return contentRange;
    }
    var InflateStream = class extends Transform {
      #zlibOptions;
      /** @param {zlib.ZlibOptions} [zlibOptions] */
      constructor(zlibOptions) {
        super();
        this.#zlibOptions = zlibOptions;
      }
      _transform(chunk5, encoding, callback) {
        if (!this._inflateStream) {
          if (chunk5.length === 0) {
            callback();
            return;
          }
          this._inflateStream = (chunk5[0] & 15) === 8 ? zlib.createInflate(this.#zlibOptions) : zlib.createInflateRaw(this.#zlibOptions);
          this._inflateStream.on("data", this.push.bind(this));
          this._inflateStream.on("end", () => this.push(null));
          this._inflateStream.on("error", (err) => this.destroy(err));
        }
        this._inflateStream.write(chunk5, encoding, callback);
      }
      _final(callback) {
        if (this._inflateStream) {
          this._inflateStream.end();
          this._inflateStream = null;
        }
        callback();
      }
    };
    function createInflate(zlibOptions) {
      return new InflateStream(zlibOptions);
    }
    function extractMimeType(headers) {
      let charset = null;
      let essence = null;
      let mimeType = null;
      const values3 = getDecodeSplit("content-type", headers);
      if (values3 === null) {
        return "failure";
      }
      for (const value of values3) {
        const temporaryMimeType = parseMIMEType(value);
        if (temporaryMimeType === "failure" || temporaryMimeType.essence === "*/*") {
          continue;
        }
        mimeType = temporaryMimeType;
        if (mimeType.essence !== essence) {
          charset = null;
          if (mimeType.parameters.has("charset")) {
            charset = mimeType.parameters.get("charset");
          }
          essence = mimeType.essence;
        } else if (!mimeType.parameters.has("charset") && charset !== null) {
          mimeType.parameters.set("charset", charset);
        }
      }
      if (mimeType == null) {
        return "failure";
      }
      return mimeType;
    }
    function gettingDecodingSplitting(value) {
      const input2 = value;
      const position = { position: 0 };
      const values3 = [];
      let temporaryValue = "";
      while (position.position < input2.length) {
        temporaryValue += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== ",",
          input2,
          position
        );
        if (position.position < input2.length) {
          if (input2.charCodeAt(position.position) === 34) {
            temporaryValue += collectAnHTTPQuotedString(
              input2,
              position
            );
            if (position.position < input2.length) {
              continue;
            }
          } else {
            assert3(input2.charCodeAt(position.position) === 44);
            position.position++;
          }
        }
        temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 9 || char === 32);
        values3.push(temporaryValue);
        temporaryValue = "";
      }
      return values3;
    }
    function getDecodeSplit(name, list) {
      const value = list.get(name, true);
      if (value === null) {
        return null;
      }
      return gettingDecodingSplitting(value);
    }
    var textDecoder = new TextDecoder();
    function utf8DecodeBytes(buffer4) {
      if (buffer4.length === 0) {
        return "";
      }
      if (buffer4[0] === 239 && buffer4[1] === 187 && buffer4[2] === 191) {
        buffer4 = buffer4.subarray(3);
      }
      const output = textDecoder.decode(buffer4);
      return output;
    }
    var EnvironmentSettingsObjectBase = class {
      get baseUrl() {
        return getGlobalOrigin();
      }
      get origin() {
        return this.baseUrl?.origin;
      }
      policyContainer = makePolicyContainer();
    };
    var EnvironmentSettingsObject = class {
      settingsObject = new EnvironmentSettingsObjectBase();
    };
    var environmentSettingsObject = new EnvironmentSettingsObject();
    module.exports = {
      isAborted,
      isCancelled,
      isValidEncodedURL,
      createDeferredPromise,
      ReadableStreamFrom,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      clampAndCoarsenConnectionTimingInfo,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      iteratorMixin,
      createIterator,
      isValidHeaderName,
      isValidHeaderValue,
      isErrorLike,
      fullyReadBody,
      bytesMatch,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlHasHttpsScheme,
      urlIsHttpHttpsScheme,
      readAllBytes,
      simpleRangeHeaderValue,
      buildContentRange,
      parseMetadata,
      createInflate,
      extractMimeType,
      getDecodeSplit,
      utf8DecodeBytes,
      environmentSettingsObject,
      isOriginIPPotentiallyTrustworthy
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/formdata.js
var require_formdata = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/formdata.js"(exports, module) {
    var { iteratorMixin } = require_util2();
    var { kEnumerableProperty } = require_util();
    var { webidl } = require_webidl();
    var { File: NativeFile } = __require("buffer");
    var nodeUtil = __require("util");
    var File = globalThis.File ?? NativeFile;
    var FormData = class _FormData {
      #state = [];
      constructor(form) {
        webidl.util.markAsUncloneable(this);
        if (form !== void 0) {
          throw webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"]
          });
        }
      }
      append(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.append";
        webidl.argumentLengthCheck(arguments, 2, prefix);
        name = webidl.converters.USVString(name);
        if (arguments.length === 3 || webidl.is.Blob(value)) {
          value = webidl.converters.Blob(value, prefix, "value");
          if (filename !== void 0) {
            filename = webidl.converters.USVString(filename);
          }
        } else {
          value = webidl.converters.USVString(value);
        }
        const entry = makeEntry2(name, value, filename);
        this.#state.push(entry);
      }
      delete(name) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.delete";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        name = webidl.converters.USVString(name);
        this.#state = this.#state.filter((entry) => entry.name !== name);
      }
      get(name) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.get";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        name = webidl.converters.USVString(name);
        const idx = this.#state.findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }
        return this.#state[idx].value;
      }
      getAll(name) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.getAll";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        name = webidl.converters.USVString(name);
        return this.#state.filter((entry) => entry.name === name).map((entry) => entry.value);
      }
      has(name) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.has";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        name = webidl.converters.USVString(name);
        return this.#state.findIndex((entry) => entry.name === name) !== -1;
      }
      set(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.set";
        webidl.argumentLengthCheck(arguments, 2, prefix);
        name = webidl.converters.USVString(name);
        if (arguments.length === 3 || webidl.is.Blob(value)) {
          value = webidl.converters.Blob(value, prefix, "value");
          if (filename !== void 0) {
            filename = webidl.converters.USVString(filename);
          }
        } else {
          value = webidl.converters.USVString(value);
        }
        const entry = makeEntry2(name, value, filename);
        const idx = this.#state.findIndex((entry2) => entry2.name === name);
        if (idx !== -1) {
          this.#state = [
            ...this.#state.slice(0, idx),
            entry,
            ...this.#state.slice(idx + 1).filter((entry2) => entry2.name !== name)
          ];
        } else {
          this.#state.push(entry);
        }
      }
      [nodeUtil.inspect.custom](depth, options) {
        const state = this.#state.reduce((a2, b) => {
          if (a2[b.name]) {
            if (Array.isArray(a2[b.name])) {
              a2[b.name].push(b.value);
            } else {
              a2[b.name] = [a2[b.name], b.value];
            }
          } else {
            a2[b.name] = b.value;
          }
          return a2;
        }, { __proto__: null });
        options.depth ??= depth;
        options.colors ??= true;
        const output = nodeUtil.formatWithOptions(options, state);
        return `FormData ${output.slice(output.indexOf("]") + 2)}`;
      }
      /**
       * @param {FormData} formData
       */
      static getFormDataState(formData) {
        return formData.#state;
      }
      /**
       * @param {FormData} formData
       * @param {any[]} newState
       */
      static setFormDataState(formData, newState) {
        formData.#state = newState;
      }
    };
    var { getFormDataState, setFormDataState } = FormData;
    Reflect.deleteProperty(FormData, "getFormDataState");
    Reflect.deleteProperty(FormData, "setFormDataState");
    iteratorMixin("FormData", FormData, getFormDataState, "name", "value");
    Object.defineProperties(FormData.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      getAll: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FormData",
        configurable: true
      }
    });
    function makeEntry2(name, value, filename) {
      if (typeof value === "string") ; else {
        if (!webidl.is.File(value)) {
          value = new File([value], "blob", { type: value.type });
        }
        if (filename !== void 0) {
          const options = {
            type: value.type,
            lastModified: value.lastModified
          };
          value = new File([value], filename, options);
        }
      }
      return { name, value };
    }
    webidl.is.FormData = webidl.util.MakeTypeAssertion(FormData);
    module.exports = { FormData, makeEntry: makeEntry2, setFormDataState };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/formdata-parser.js
var require_formdata_parser = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/formdata-parser.js"(exports, module) {
    var { isUSVString, bufferToLowerCasedHeaderName } = require_util();
    var { utf8DecodeBytes } = require_util2();
    var { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = require_data_url();
    var { makeEntry: makeEntry2 } = require_formdata();
    var { webidl } = require_webidl();
    var assert3 = __require("assert");
    var { File: NodeFile } = __require("buffer");
    var File = globalThis.File ?? NodeFile;
    var formDataNameBuffer = Buffer.from('form-data; name="');
    var filenameBuffer = Buffer.from("filename");
    var dd = Buffer.from("--");
    var ddcrlf = Buffer.from("--\r\n");
    function isAsciiString(chars3) {
      for (let i = 0; i < chars3.length; ++i) {
        if ((chars3.charCodeAt(i) & -128) !== 0) {
          return false;
        }
      }
      return true;
    }
    function validateBoundary(boundary) {
      const length3 = boundary.length;
      if (length3 < 27 || length3 > 70) {
        return false;
      }
      for (let i = 0; i < length3; ++i) {
        const cp = boundary.charCodeAt(i);
        if (!(cp >= 48 && cp <= 57 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 39 || cp === 45 || cp === 95)) {
          return false;
        }
      }
      return true;
    }
    function multipartFormDataParser(input2, mimeType) {
      assert3(mimeType !== "failure" && mimeType.essence === "multipart/form-data");
      const boundaryString = mimeType.parameters.get("boundary");
      if (boundaryString === void 0) {
        throw parsingError("missing boundary in content-type header");
      }
      const boundary = Buffer.from(`--${boundaryString}`, "utf8");
      const entryList = [];
      const position = { position: 0 };
      while (input2[position.position] === 13 && input2[position.position + 1] === 10) {
        position.position += 2;
      }
      let trailing = input2.length;
      while (input2[trailing - 1] === 10 && input2[trailing - 2] === 13) {
        trailing -= 2;
      }
      if (trailing !== input2.length) {
        input2 = input2.subarray(0, trailing);
      }
      while (true) {
        if (input2.subarray(position.position, position.position + boundary.length).equals(boundary)) {
          position.position += boundary.length;
        } else {
          throw parsingError("expected a value starting with -- and the boundary");
        }
        if (position.position === input2.length - 2 && bufferStartsWith(input2, dd, position) || position.position === input2.length - 4 && bufferStartsWith(input2, ddcrlf, position)) {
          return entryList;
        }
        if (input2[position.position] !== 13 || input2[position.position + 1] !== 10) {
          throw parsingError("expected CRLF");
        }
        position.position += 2;
        const result = parseMultipartFormDataHeaders(input2, position);
        let { name, filename, contentType, encoding } = result;
        position.position += 2;
        let body;
        {
          const boundaryIndex = input2.indexOf(boundary.subarray(2), position.position);
          if (boundaryIndex === -1) {
            throw parsingError("expected boundary after body");
          }
          body = input2.subarray(position.position, boundaryIndex - 4);
          position.position += body.length;
          if (encoding === "base64") {
            body = Buffer.from(body.toString(), "base64");
          }
        }
        if (input2[position.position] !== 13 || input2[position.position + 1] !== 10) {
          throw parsingError("expected CRLF");
        } else {
          position.position += 2;
        }
        let value;
        if (filename !== null) {
          contentType ??= "text/plain";
          if (!isAsciiString(contentType)) {
            contentType = "";
          }
          value = new File([body], filename, { type: contentType });
        } else {
          value = utf8DecodeBytes(Buffer.from(body));
        }
        assert3(isUSVString(name));
        assert3(typeof value === "string" && isUSVString(value) || webidl.is.File(value));
        entryList.push(makeEntry2(name, value, filename));
      }
    }
    function parseMultipartFormDataHeaders(input2, position) {
      let name = null;
      let filename = null;
      let contentType = null;
      let encoding = null;
      while (true) {
        if (input2[position.position] === 13 && input2[position.position + 1] === 10) {
          if (name === null) {
            throw parsingError("header name is null");
          }
          return { name, filename, contentType, encoding };
        }
        let headerName = collectASequenceOfBytes(
          (char) => char !== 10 && char !== 13 && char !== 58,
          input2,
          position
        );
        headerName = removeChars(headerName, true, true, (char) => char === 9 || char === 32);
        if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {
          throw parsingError("header name does not match the field-name token production");
        }
        if (input2[position.position] !== 58) {
          throw parsingError("expected :");
        }
        position.position++;
        collectASequenceOfBytes(
          (char) => char === 32 || char === 9,
          input2,
          position
        );
        switch (bufferToLowerCasedHeaderName(headerName)) {
          case "content-disposition": {
            name = filename = null;
            if (!bufferStartsWith(input2, formDataNameBuffer, position)) {
              throw parsingError('expected form-data; name=" for content-disposition header');
            }
            position.position += 17;
            name = parseMultipartFormDataName(input2, position);
            if (input2[position.position] === 59 && input2[position.position + 1] === 32) {
              const at = { position: position.position + 2 };
              if (bufferStartsWith(input2, filenameBuffer, at)) {
                if (input2[at.position + 8] === 42) {
                  at.position += 10;
                  collectASequenceOfBytes(
                    (char) => char === 32 || char === 9,
                    input2,
                    at
                  );
                  const headerValue = collectASequenceOfBytes(
                    (char) => char !== 32 && char !== 13 && char !== 10,
                    // ' ' or CRLF
                    input2,
                    at
                  );
                  if (headerValue[0] !== 117 && headerValue[0] !== 85 || // u or U
                  headerValue[1] !== 116 && headerValue[1] !== 84 || // t or T
                  headerValue[2] !== 102 && headerValue[2] !== 70 || // f or F
                  headerValue[3] !== 45 || // -
                  headerValue[4] !== 56) {
                    throw parsingError("unknown encoding, expected utf-8''");
                  }
                  filename = decodeURIComponent(new TextDecoder().decode(headerValue.subarray(7)));
                  position.position = at.position;
                } else {
                  position.position += 11;
                  collectASequenceOfBytes(
                    (char) => char === 32 || char === 9,
                    input2,
                    position
                  );
                  position.position++;
                  filename = parseMultipartFormDataName(input2, position);
                }
              }
            }
            break;
          }
          case "content-type": {
            let headerValue = collectASequenceOfBytes(
              (char) => char !== 10 && char !== 13,
              input2,
              position
            );
            headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
            contentType = isomorphicDecode(headerValue);
            break;
          }
          case "content-transfer-encoding": {
            let headerValue = collectASequenceOfBytes(
              (char) => char !== 10 && char !== 13,
              input2,
              position
            );
            headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
            encoding = isomorphicDecode(headerValue);
            break;
          }
          default: {
            collectASequenceOfBytes(
              (char) => char !== 10 && char !== 13,
              input2,
              position
            );
          }
        }
        if (input2[position.position] !== 13 && input2[position.position + 1] !== 10) {
          throw parsingError("expected CRLF");
        } else {
          position.position += 2;
        }
      }
    }
    function parseMultipartFormDataName(input2, position) {
      assert3(input2[position.position - 1] === 34);
      let name = collectASequenceOfBytes(
        (char) => char !== 10 && char !== 13 && char !== 34,
        input2,
        position
      );
      if (input2[position.position] !== 34) {
        throw parsingError('expected "');
      } else {
        position.position++;
      }
      name = new TextDecoder().decode(name).replace(/%0A/ig, "\n").replace(/%0D/ig, "\r").replace(/%22/g, '"');
      return name;
    }
    function collectASequenceOfBytes(condition, input2, position) {
      let start3 = position.position;
      while (start3 < input2.length && condition(input2[start3])) {
        ++start3;
      }
      return input2.subarray(position.position, position.position = start3);
    }
    function removeChars(buf, leading, trailing, predicate) {
      let lead = 0;
      let trail = buf.length - 1;
      if (leading) {
        while (lead < buf.length && predicate(buf[lead])) lead++;
      }
      {
        while (trail > 0 && predicate(buf[trail])) trail--;
      }
      return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);
    }
    function bufferStartsWith(buffer4, start3, position) {
      if (buffer4.length < start3.length) {
        return false;
      }
      for (let i = 0; i < start3.length; i++) {
        if (start3[i] !== buffer4[position.position + i]) {
          return false;
        }
      }
      return true;
    }
    function parsingError(cause3) {
      return new TypeError("Failed to parse body as FormData.", { cause: new TypeError(cause3) });
    }
    module.exports = {
      multipartFormDataParser,
      validateBoundary
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/body.js
var require_body = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/body.js"(exports, module) {
    var util = require_util();
    var {
      ReadableStreamFrom,
      readableStreamClose,
      createDeferredPromise,
      fullyReadBody,
      extractMimeType,
      utf8DecodeBytes
    } = require_util2();
    var { FormData, setFormDataState } = require_formdata();
    var { webidl } = require_webidl();
    var { Blob: Blob2 } = __require("buffer");
    var assert3 = __require("assert");
    var { isErrored, isDisturbed } = __require("stream");
    var { isArrayBuffer } = __require("util/types");
    var { serializeAMimeType } = require_data_url();
    var { multipartFormDataParser } = require_formdata_parser();
    var random4;
    try {
      const crypto = __require("crypto");
      random4 = (max5) => crypto.randomInt(0, max5);
    } catch {
      random4 = (max5) => Math.floor(Math.random() * max5);
    }
    var textEncoder2 = new TextEncoder();
    function noop2() {
    }
    var hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0;
    var streamRegistry;
    if (hasFinalizationRegistry) {
      streamRegistry = new FinalizationRegistry((weakRef) => {
        const stream = weakRef.deref();
        if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {
          stream.cancel("Response object has been garbage collected").catch(noop2);
        }
      });
    }
    function extractBody(object, keepalive = false) {
      let stream = null;
      if (webidl.is.ReadableStream(object)) {
        stream = object;
      } else if (webidl.is.Blob(object)) {
        stream = object.stream();
      } else {
        stream = new ReadableStream({
          async pull(controller) {
            const buffer4 = typeof source === "string" ? textEncoder2.encode(source) : source;
            if (buffer4.byteLength) {
              controller.enqueue(buffer4);
            }
            queueMicrotask(() => readableStreamClose(controller));
          },
          start() {
          },
          type: "bytes"
        });
      }
      assert3(webidl.is.ReadableStream(stream));
      let action = null;
      let source = null;
      let length3 = null;
      let type = null;
      if (typeof object === "string") {
        source = object;
        type = "text/plain;charset=UTF-8";
      } else if (webidl.is.URLSearchParams(object)) {
        source = object.toString();
        type = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isArrayBuffer(object)) {
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      } else if (webidl.is.FormData(object)) {
        const boundary = `----formdata-undici-0${`${random4(1e11)}`.padStart(11, "0")}`;
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape3 = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
        const blobParts = [];
        const rn = new Uint8Array([13, 10]);
        length3 = 0;
        let hasUnknownSizeValue = false;
        for (const [name, value] of object) {
          if (typeof value === "string") {
            const chunk6 = textEncoder2.encode(prefix + `; name="${escape3(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
            blobParts.push(chunk6);
            length3 += chunk6.byteLength;
          } else {
            const chunk6 = textEncoder2.encode(`${prefix}; name="${escape3(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape3(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
            blobParts.push(chunk6, value, rn);
            if (typeof value.size === "number") {
              length3 += chunk6.byteLength + value.size + rn.byteLength;
            } else {
              hasUnknownSizeValue = true;
            }
          }
        }
        const chunk5 = textEncoder2.encode(`--${boundary}--\r
`);
        blobParts.push(chunk5);
        length3 += chunk5.byteLength;
        if (hasUnknownSizeValue) {
          length3 = null;
        }
        source = object;
        action = async function* () {
          for (const part of blobParts) {
            if (part.stream) {
              yield* part.stream();
            } else {
              yield part;
            }
          }
        };
        type = `multipart/form-data; boundary=${boundary}`;
      } else if (webidl.is.Blob(object)) {
        source = object;
        length3 = object.size;
        if (object.type) {
          type = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        if (keepalive) {
          throw new TypeError("keepalive");
        }
        if (util.isDisturbed(object) || object.locked) {
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        }
        stream = webidl.is.ReadableStream(object) ? object : ReadableStreamFrom(object);
      }
      if (typeof source === "string" || util.isBuffer(source)) {
        length3 = Buffer.byteLength(source);
      }
      if (action != null) {
        let iterator;
        stream = new ReadableStream({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done: done11 } = await iterator.next();
            if (done11) {
              queueMicrotask(() => {
                controller.close();
                controller.byobRequest?.respond(0);
              });
            } else {
              if (!isErrored(stream)) {
                const buffer4 = new Uint8Array(value);
                if (buffer4.byteLength) {
                  controller.enqueue(buffer4);
                }
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: "bytes"
        });
      }
      const body = { stream, source, length: length3 };
      return [body, type];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (webidl.is.ReadableStream(object)) {
        assert3(!util.isDisturbed(object), "The body has already been consumed.");
        assert3(!object.locked, "The stream is locked.");
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(instance, body) {
      const [out1, out2] = body.stream.tee();
      if (hasFinalizationRegistry) {
        streamRegistry.register(instance, new WeakRef(out1));
      }
      body.stream = out1;
      return {
        stream: out2,
        length: body.length,
        source: body.source
      };
    }
    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException("The operation was aborted.", "AbortError");
      }
    }
    function bodyMixinMethods(instance, getInternalState) {
      const methods = {
        blob() {
          return consumeBody(this, (bytes) => {
            let mimeType = bodyMimeType(getInternalState(this));
            if (mimeType === null) {
              mimeType = "";
            } else if (mimeType) {
              mimeType = serializeAMimeType(mimeType);
            }
            return new Blob2([bytes], { type: mimeType });
          }, instance, getInternalState);
        },
        arrayBuffer() {
          return consumeBody(this, (bytes) => {
            return new Uint8Array(bytes).buffer;
          }, instance, getInternalState);
        },
        text() {
          return consumeBody(this, utf8DecodeBytes, instance, getInternalState);
        },
        json() {
          return consumeBody(this, parseJSONFromBytes, instance, getInternalState);
        },
        formData() {
          return consumeBody(this, (value) => {
            const mimeType = bodyMimeType(getInternalState(this));
            if (mimeType !== null) {
              switch (mimeType.essence) {
                case "multipart/form-data": {
                  const parsed = multipartFormDataParser(value, mimeType);
                  const fd = new FormData();
                  setFormDataState(fd, parsed);
                  return fd;
                }
                case "application/x-www-form-urlencoded": {
                  const entries2 = new URLSearchParams(value.toString());
                  const fd = new FormData();
                  for (const [name, value2] of entries2) {
                    fd.append(name, value2);
                  }
                  return fd;
                }
              }
            }
            throw new TypeError(
              'Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".'
            );
          }, instance, getInternalState);
        },
        bytes() {
          return consumeBody(this, (bytes) => {
            return new Uint8Array(bytes);
          }, instance, getInternalState);
        }
      };
      return methods;
    }
    function mixinBody(prototype, getInternalState) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype, getInternalState));
    }
    async function consumeBody(object, convertBytesToJSValue, instance, getInternalState) {
      webidl.brandCheck(object, instance);
      const state = getInternalState(object);
      if (bodyUnusable(state)) {
        throw new TypeError("Body is unusable: Body has already been read");
      }
      throwIfAborted(state);
      const promise3 = createDeferredPromise();
      const errorSteps = (error4) => promise3.reject(error4);
      const successSteps = (data) => {
        try {
          promise3.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      };
      if (state.body == null) {
        successSteps(Buffer.allocUnsafe(0));
        return promise3.promise;
      }
      fullyReadBody(state.body, successSteps, errorSteps);
      return promise3.promise;
    }
    function bodyUnusable(object) {
      const body = object.body;
      return body != null && (body.stream.locked || util.isDisturbed(body.stream));
    }
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }
    function bodyMimeType(requestOrResponse) {
      const headers = requestOrResponse.headersList;
      const mimeType = extractMimeType(headers);
      if (mimeType === "failure") {
        return null;
      }
      return mimeType;
    }
    module.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody,
      streamRegistry,
      hasFinalizationRegistry,
      bodyUnusable
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/client-h1.js
var require_client_h1 = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/client-h1.js"(exports, module) {
    var assert3 = __require("assert");
    var util = require_util();
    var { channels } = require_diagnostics();
    var timers2 = require_timers();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError
    } = require_errors();
    var {
      kUrl,
      kReset,
      kClient,
      kParser,
      kBlocking,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kMaxRequests,
      kCounter,
      kMaxResponseSize,
      kOnError,
      kResume,
      kHTTPContext,
      kClosed
    } = require_symbols();
    var constants = require_constants2();
    var EMPTY_BUF = Buffer.alloc(0);
    var FastBuffer = Buffer[Symbol.species];
    var removeAllListeners = util.removeAllListeners;
    var extractBody;
    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = await WebAssembly.compile(require_llhttp_simd_wasm());
      } catch (e) {
        mod = await WebAssembly.compile(llhttpWasmData || require_llhttp_wasm());
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          /**
           * @param {number} p
           * @param {number} at
           * @param {number} len
           * @returns {number}
           */
          wasm_on_url: (p3, at, len) => {
            return 0;
          },
          /**
           * @param {number} p
           * @param {number} at
           * @param {number} len
           * @returns {number}
           */
          wasm_on_status: (p3, at, len) => {
            assert3(currentParser.ptr === p3);
            const start3 = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start3, len));
          },
          /**
           * @param {number} p
           * @returns {number}
           */
          wasm_on_message_begin: (p3) => {
            assert3(currentParser.ptr === p3);
            return currentParser.onMessageBegin();
          },
          /**
           * @param {number} p
           * @param {number} at
           * @param {number} len
           * @returns {number}
           */
          wasm_on_header_field: (p3, at, len) => {
            assert3(currentParser.ptr === p3);
            const start3 = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start3, len));
          },
          /**
           * @param {number} p
           * @param {number} at
           * @param {number} len
           * @returns {number}
           */
          wasm_on_header_value: (p3, at, len) => {
            assert3(currentParser.ptr === p3);
            const start3 = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start3, len));
          },
          /**
           * @param {number} p
           * @param {number} statusCode
           * @param {0|1} upgrade
           * @param {0|1} shouldKeepAlive
           * @returns {number}
           */
          wasm_on_headers_complete: (p3, statusCode, upgrade, shouldKeepAlive) => {
            assert3(currentParser.ptr === p3);
            return currentParser.onHeadersComplete(statusCode, upgrade === 1, shouldKeepAlive === 1);
          },
          /**
           * @param {number} p
           * @param {number} at
           * @param {number} len
           * @returns {number}
           */
          wasm_on_body: (p3, at, len) => {
            assert3(currentParser.ptr === p3);
            const start3 = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start3, len));
          },
          /**
           * @param {number} p
           * @returns {number}
           */
          wasm_on_message_complete: (p3) => {
            assert3(currentParser.ptr === p3);
            return currentParser.onMessageComplete();
          }
        }
      });
    }
    var llhttpInstance = null;
    var llhttpPromise = lazyllhttp();
    llhttpPromise.catch();
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var USE_NATIVE_TIMER = 0;
    var USE_FAST_TIMER = 1;
    var TIMEOUT_HEADERS = 2 | USE_FAST_TIMER;
    var TIMEOUT_BODY = 4 | USE_FAST_TIMER;
    var TIMEOUT_KEEP_ALIVE = 8 | USE_NATIVE_TIMER;
    var Parser = class {
      /**
         * @param {import('./client.js')} client
         * @param {import('net').Socket} socket
         * @param {*} llhttp
         */
      constructor(client, socket, { exports: exports2 }) {
        this.llhttp = exports2;
        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = 0;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = "";
        this.contentLength = "";
        this.connection = "";
        this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(delay4, type) {
        if (delay4 !== this.timeoutValue || type & USE_FAST_TIMER ^ this.timeoutType & USE_FAST_TIMER) {
          if (this.timeout) {
            timers2.clearTimeout(this.timeout);
            this.timeout = null;
          }
          if (delay4) {
            if (type & USE_FAST_TIMER) {
              this.timeout = timers2.setFastTimeout(onParserTimeout, delay4, new WeakRef(this));
            } else {
              this.timeout = setTimeout(onParserTimeout, delay4, new WeakRef(this));
              this.timeout.unref();
            }
          }
          this.timeoutValue = delay4;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.timeoutType = type;
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert3(this.ptr != null);
        assert3(currentParser === null);
        this.llhttp.llhttp_resume(this.ptr);
        assert3(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk5 = this.socket.read();
          if (chunk5 === null) {
            break;
          }
          this.execute(chunk5);
        }
      }
      /**
       * @param {Buffer} chunk
       */
      execute(chunk5) {
        assert3(currentParser === null);
        assert3(this.ptr != null);
        assert3(!this.paused);
        const { socket, llhttp } = this;
        if (chunk5.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(chunk5.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(chunk5);
        try {
          let ret;
          try {
            currentBufferRef = chunk5;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, chunk5.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          if (ret !== constants.ERROR.OK) {
            const data = chunk5.subarray(llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr);
            if (ret === constants.ERROR.PAUSED_UPGRADE) {
              this.onUpgrade(data);
            } else if (ret === constants.ERROR.PAUSED) {
              this.paused = true;
              socket.unshift(data);
            } else {
              const ptr = llhttp.llhttp_get_error_reason(this.ptr);
              let message = "";
              if (ptr) {
                const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
                message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
              }
              throw new HTTPParserError(message, constants.ERROR[ret], data);
            }
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }
      destroy() {
        assert3(currentParser === null);
        assert3(this.ptr != null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        this.timeout && timers2.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      /**
       * @param {Buffer} buf
       * @returns {0}
       */
      onStatus(buf) {
        this.statusText = buf.toString();
        return 0;
      }
      /**
       * @returns {0|-1}
       */
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request2 = client[kQueue][client[kRunningIdx]];
        if (!request2) {
          return -1;
        }
        request2.onResponseStarted();
        return 0;
      }
      /**
       * @param {Buffer} buf
       * @returns {number}
       */
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
        return 0;
      }
      /**
       * @param {Buffer} buf
       * @returns {number}
       */
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10) {
          const headerName = util.bufferToLowerCasedHeaderName(key);
          if (headerName === "keep-alive") {
            this.keepAlive += buf.toString();
          } else if (headerName === "connection") {
            this.connection += buf.toString();
          }
        } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === "content-length") {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
        return 0;
      }
      /**
       * @param {number} len
       */
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util.destroy(this.socket, new HeadersOverflowError());
        }
      }
      /**
       * @param {Buffer} head
       */
      onUpgrade(head6) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert3(upgrade);
        assert3(client[kSocket] === socket);
        assert3(!socket.destroyed);
        assert3(!this.paused);
        assert3((headers.length & 1) === 0);
        const request2 = client[kQueue][client[kRunningIdx]];
        assert3(request2);
        assert3(request2.upgrade || request2.method === "CONNECT");
        this.statusCode = 0;
        this.statusText = "";
        this.shouldKeepAlive = false;
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head6);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        removeAllListeners(socket);
        client[kSocket] = null;
        client[kHTTPContext] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request2.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }
        client[kResume]();
      }
      /**
       * @param {number} statusCode
       * @param {boolean} upgrade
       * @param {boolean} shouldKeepAlive
       * @returns {number}
       */
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request2 = client[kQueue][client[kRunningIdx]];
        if (!request2) {
          return -1;
        }
        assert3(!this.upgrade);
        assert3(this.statusCode < 200);
        if (statusCode === 100) {
          util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request2.upgrade) {
          util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
          return -1;
        }
        assert3(this.timeoutType === TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
        request2.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
        if (this.statusCode >= 200) {
          const bodyTimeout = request2.bodyTimeout != null ? request2.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request2.method === "CONNECT") {
          assert3(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert3(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert3((this.headers.length & 1) === 0);
        this.headers = [];
        this.headersSize = 0;
        if (this.shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout5 = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout5 <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout5;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        const pause = request2.onHeaders(statusCode, headers, this.resume, statusText) === false;
        if (request2.aborted) {
          return -1;
        }
        if (request2.method === "HEAD") {
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          client[kResume]();
        }
        return pause ? constants.ERROR.PAUSED : 0;
      }
      /**
       * @param {Buffer} buf
       * @returns {number}
       */
      onBody(buf) {
        const { client, socket, statusCode, maxResponseSize } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request2 = client[kQueue][client[kRunningIdx]];
        assert3(request2);
        assert3(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert3(statusCode >= 200);
        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
          util.destroy(socket, new ResponseExceededMaxSizeError());
          return -1;
        }
        this.bytesRead += buf.length;
        if (request2.onData(buf) === false) {
          return constants.ERROR.PAUSED;
        }
        return 0;
      }
      /**
       * @returns {number}
       */
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return 0;
        }
        assert3(statusCode >= 100);
        assert3((this.headers.length & 1) === 0);
        const request2 = client[kQueue][client[kRunningIdx]];
        assert3(request2);
        this.statusCode = 0;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        this.connection = "";
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return 0;
        }
        if (request2.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        request2.onComplete(headers);
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert3(client[kRunning] === 0);
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (client[kPipelining] == null || client[kPipelining] === 1) {
          setImmediate(() => client[kResume]());
        } else {
          client[kResume]();
        }
        return 0;
      }
    };
    function onParserTimeout(parser4) {
      const { socket, timeoutType, client, paused } = parser4.deref();
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
          assert3(!paused, "cannot be paused while waiting for headers");
          util.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!paused) {
          util.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_KEEP_ALIVE) {
        assert3(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }
    async function connectH1(client, socket) {
      client[kSocket] = socket;
      if (!llhttpInstance) {
        const noop2 = () => {
        };
        socket.on("error", noop2);
        llhttpInstance = await llhttpPromise;
        llhttpPromise = null;
        socket.off("error", noop2);
      }
      if (socket.errored) {
        throw socket.errored;
      }
      if (socket.destroyed) {
        throw new SocketError("destroyed");
      }
      socket[kNoRef] = false;
      socket[kWriting] = false;
      socket[kReset] = false;
      socket[kBlocking] = false;
      socket[kParser] = new Parser(client, socket, llhttpInstance);
      util.addListener(socket, "error", onHttpSocketError);
      util.addListener(socket, "readable", onHttpSocketReadable);
      util.addListener(socket, "end", onHttpSocketEnd);
      util.addListener(socket, "close", onHttpSocketClose);
      socket[kClosed] = false;
      socket.on("close", onSocketClose);
      return {
        version: "h1",
        defaultPipelining: 1,
        write(request2) {
          return writeH1(client, request2);
        },
        resume() {
          resumeH1(client);
        },
        /**
         * @param {Error|undefined} err
         * @param {() => void} callback
         */
        destroy(err, callback) {
          if (socket[kClosed]) {
            queueMicrotask(callback);
          } else {
            socket.on("close", callback);
            socket.destroy(err);
          }
        },
        /**
         * @returns {boolean}
         */
        get destroyed() {
          return socket.destroyed;
        },
        /**
         * @param {import('../core/request.js')} request
         * @returns {boolean}
         */
        busy(request2) {
          if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {
            return true;
          }
          if (request2) {
            if (client[kRunning] > 0 && !request2.idempotent) {
              return true;
            }
            if (client[kRunning] > 0 && (request2.upgrade || request2.method === "CONNECT")) {
              return true;
            }
            if (client[kRunning] > 0 && util.bodyLength(request2.body) !== 0 && (util.isStream(request2.body) || util.isAsyncIterable(request2.body) || util.isFormDataLike(request2.body))) {
              return true;
            }
          }
          return false;
        }
      };
    }
    function onHttpSocketError(err) {
      assert3(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      const parser4 = this[kParser];
      if (err.code === "ECONNRESET" && parser4.statusCode && !parser4.shouldKeepAlive) {
        parser4.onMessageComplete();
        return;
      }
      this[kError] = err;
      this[kClient][kOnError](err);
    }
    function onHttpSocketReadable() {
      this[kParser]?.readMore();
    }
    function onHttpSocketEnd() {
      const parser4 = this[kParser];
      if (parser4.statusCode && !parser4.shouldKeepAlive) {
        parser4.onMessageComplete();
        return;
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onHttpSocketClose() {
      const parser4 = this[kParser];
      if (parser4) {
        if (!this[kError] && parser4.statusCode && !parser4.shouldKeepAlive) {
          parser4.onMessageComplete();
        }
        this[kParser].destroy();
        this[kParser] = null;
      }
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      const client = this[kClient];
      client[kSocket] = null;
      client[kHTTPContext] = null;
      if (client.destroyed) {
        assert3(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request2 = requests[i];
          util.errorRequest(client, request2, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request2 = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        util.errorRequest(client, request2, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert3(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      client[kResume]();
    }
    function onSocketClose() {
      this[kClosed] = true;
    }
    function resumeH1(client) {
      const socket = client[kSocket];
      if (socket && !socket.destroyed) {
        if (client[kSize] === 0) {
          if (!socket[kNoRef] && socket.unref) {
            socket.unref();
            socket[kNoRef] = true;
          }
        } else if (socket[kNoRef] && socket.ref) {
          socket.ref();
          socket[kNoRef] = false;
        }
        if (client[kSize] === 0) {
          if (socket[kParser].timeoutType !== TIMEOUT_KEEP_ALIVE) {
            socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_KEEP_ALIVE);
          }
        } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
          if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
            const request2 = client[kQueue][client[kRunningIdx]];
            const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
            socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
          }
        }
      }
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function writeH1(client, request2) {
      const { method, path: path3, host, upgrade, blocking, reset } = request2;
      let { body, headers, contentLength } = request2;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH" || method === "QUERY" || method === "PROPFIND" || method === "PROPPATCH";
      if (util.isFormDataLike(body)) {
        if (!extractBody) {
          extractBody = require_body().extractBody;
        }
        const [bodyStream, contentType] = extractBody(body);
        if (request2.contentType == null) {
          headers.push("content-type", contentType);
        }
        body = bodyStream.stream;
        contentLength = bodyStream.length;
      } else if (util.isBlobLike(body) && request2.contentType == null && body.type) {
        headers.push("content-type", body.type);
      }
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      const bodyLength = util.bodyLength(body);
      contentLength = bodyLength ?? contentLength;
      if (contentLength === null) {
        contentLength = request2.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request2.contentLength !== null && request2.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          util.errorRequest(client, request2, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      const abort = (err) => {
        if (request2.aborted || request2.completed) {
          return;
        }
        util.errorRequest(client, request2, err || new RequestAbortedError());
        util.destroy(body);
        util.destroy(socket, new InformationalError("aborted"));
      };
      try {
        request2.onConnect(abort);
      } catch (err) {
        util.errorRequest(client, request2, err);
      }
      if (request2.aborted) {
        return false;
      }
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade || method === "CONNECT") {
        socket[kReset] = true;
      }
      if (reset != null) {
        socket[kReset] = reset;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path3} HTTP/1.1\r
`;
      if (typeof host === "string") {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining] && !socket[kReset]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }
      if (Array.isArray(headers)) {
        for (let n2 = 0; n2 < headers.length; n2 += 2) {
          const key = headers[n2 + 0];
          const val = headers[n2 + 1];
          if (Array.isArray(val)) {
            for (let i = 0; i < val.length; i++) {
              header += `${key}: ${val[i]}\r
`;
            }
          } else {
            header += `${key}: ${val}\r
`;
          }
        }
      }
      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request: request2, headers: header, socket });
      }
      if (!body || bodyLength === 0) {
        writeBuffer(abort, null, client, request2, socket, contentLength, header, expectsPayload);
      } else if (util.isBuffer(body)) {
        writeBuffer(abort, body, client, request2, socket, contentLength, header, expectsPayload);
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable(abort, body.stream(), client, request2, socket, contentLength, header, expectsPayload);
        } else {
          writeBlob(abort, body, client, request2, socket, contentLength, header, expectsPayload);
        }
      } else if (util.isStream(body)) {
        writeStream(abort, body, client, request2, socket, contentLength, header, expectsPayload);
      } else if (util.isIterable(body)) {
        writeIterable(abort, body, client, request2, socket, contentLength, header, expectsPayload);
      } else {
        assert3(false);
      }
      return true;
    }
    function writeStream(abort, body, client, request2, socket, contentLength, header, expectsPayload) {
      assert3(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      let finished = false;
      const writer = new AsyncWriter({ abort, socket, request: request2, contentLength, client, expectsPayload, header });
      const onData = function(chunk5) {
        if (finished) {
          return;
        }
        try {
          if (!writer.write(chunk5) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util.destroy(this, err);
        }
      };
      const onDrain = function() {
        if (finished) {
          return;
        }
        if (body.resume) {
          body.resume();
        }
      };
      const onClose = function() {
        queueMicrotask(() => {
          body.removeListener("error", onFinished);
        });
        if (!finished) {
          const err = new RequestAbortedError();
          queueMicrotask(() => onFinished(err));
        }
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert3(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
        socket.off("drain", onDrain).off("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("close", onClose);
        if (!err) {
          try {
            writer.end();
          } catch (er) {
            err = er;
          }
        }
        writer.destroy(err);
        if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
          util.destroy(body, err);
        } else {
          util.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onClose);
      if (body.resume) {
        body.resume();
      }
      socket.on("drain", onDrain).on("error", onFinished);
      if (body.errorEmitted ?? body.errored) {
        setImmediate(() => onFinished(body.errored));
      } else if (body.endEmitted ?? body.readableEnded) {
        setImmediate(() => onFinished(null));
      }
      if (body.closeEmitted ?? body.closed) {
        setImmediate(onClose);
      }
    }
    function writeBuffer(abort, body, client, request2, socket, contentLength, header, expectsPayload) {
      try {
        if (!body) {
          if (contentLength === 0) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            assert3(contentLength === null, "no body must not have content length");
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (util.isBuffer(body)) {
          assert3(contentLength === body.byteLength, "buffer body must have content length");
          socket.cork();
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          socket.write(body);
          socket.uncork();
          request2.onBodySent(body);
          if (!expectsPayload && request2.reset !== false) {
            socket[kReset] = true;
          }
        }
        request2.onRequestSent();
        client[kResume]();
      } catch (err) {
        abort(err);
      }
    }
    async function writeBlob(abort, body, client, request2, socket, contentLength, header, expectsPayload) {
      assert3(contentLength === body.size, "blob body must have content length");
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer4 = Buffer.from(await body.arrayBuffer());
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(buffer4);
        socket.uncork();
        request2.onBodySent(buffer4);
        request2.onRequestSent();
        if (!expectsPayload && request2.reset !== false) {
          socket[kReset] = true;
        }
        client[kResume]();
      } catch (err) {
        abort(err);
      }
    }
    async function writeIterable(abort, body, client, request2, socket, contentLength, header, expectsPayload) {
      assert3(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve9, reject) => {
        assert3(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve9;
        }
      });
      socket.on("close", onDrain).on("drain", onDrain);
      const writer = new AsyncWriter({ abort, socket, request: request2, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk5 of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk5)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      /**
       *
       * @param {object} arg
       * @param {AbortCallback} arg.abort
       * @param {import('net').Socket} arg.socket
       * @param {import('../core/request.js')} arg.request
       * @param {number} arg.contentLength
       * @param {import('./client.js')} arg.client
       * @param {boolean} arg.expectsPayload
       * @param {string} arg.header
       */
      constructor({ abort, socket, request: request2, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request2;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        this.abort = abort;
        socket[kWriting] = true;
      }
      /**
       * @param {Buffer} chunk
       * @returns
       */
      write(chunk5) {
        const { socket, request: request2, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk5);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket.cork();
        if (bytesWritten === 0) {
          if (!expectsPayload && request2.reset !== false) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
          } else {
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          }
        }
        if (contentLength === null) {
          socket.write(`\r
${len.toString(16)}\r
`, "latin1");
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk5);
        socket.uncork();
        request2.onBodySent(chunk5);
        if (!ret) {
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }
        return ret;
      }
      /**
       * @returns {void}
       */
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request: request2 } = this;
        request2.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "latin1");
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        client[kResume]();
      }
      /**
       * @param {Error} [err]
       * @returns {void}
       */
      destroy(err) {
        const { socket, client, abort } = this;
        socket[kWriting] = false;
        if (err) {
          assert3(client[kRunning] <= 1, "pipeline should only contain this request");
          abort(err);
        }
      }
    };
    module.exports = connectH1;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/client-h2.js
var require_client_h2 = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/client-h2.js"(exports, module) {
    var assert3 = __require("assert");
    var { pipeline } = __require("stream");
    var util = require_util();
    var {
      RequestContentLengthMismatchError,
      RequestAbortedError,
      SocketError,
      InformationalError
    } = require_errors();
    var {
      kUrl,
      kReset,
      kClient,
      kRunning,
      kPending,
      kQueue,
      kPendingIdx,
      kRunningIdx,
      kError,
      kSocket,
      kStrictContentLength,
      kOnError,
      kMaxConcurrentStreams,
      kHTTP2Session,
      kResume,
      kSize,
      kHTTPContext,
      kClosed,
      kBodyTimeout
    } = require_symbols();
    var { channels } = require_diagnostics();
    var kOpenStreams = Symbol("open streams");
    var extractBody;
    var http2;
    try {
      http2 = __require("http2");
    } catch {
      http2 = { constants: {} };
    }
    var {
      constants: {
        HTTP2_HEADER_AUTHORITY,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_CONTENT_LENGTH,
        HTTP2_HEADER_EXPECT,
        HTTP2_HEADER_STATUS
      }
    } = http2;
    function parseH2Headers(headers) {
      const result = [];
      for (const [name, value] of Object.entries(headers)) {
        if (Array.isArray(value)) {
          for (const subvalue of value) {
            result.push(Buffer.from(name), Buffer.from(subvalue));
          }
        } else {
          result.push(Buffer.from(name), Buffer.from(value));
        }
      }
      return result;
    }
    async function connectH2(client, socket) {
      client[kSocket] = socket;
      const session = http2.connect(client[kUrl], {
        createConnection: () => socket,
        peerMaxConcurrentStreams: client[kMaxConcurrentStreams],
        settings: {
          // TODO(metcoder95): add support for PUSH
          enablePush: false
        }
      });
      session[kOpenStreams] = 0;
      session[kClient] = client;
      session[kSocket] = socket;
      session[kHTTP2Session] = null;
      util.addListener(session, "error", onHttp2SessionError);
      util.addListener(session, "frameError", onHttp2FrameError);
      util.addListener(session, "end", onHttp2SessionEnd);
      util.addListener(session, "goaway", onHttp2SessionGoAway);
      util.addListener(session, "close", onHttp2SessionClose);
      session.unref();
      client[kHTTP2Session] = session;
      socket[kHTTP2Session] = session;
      util.addListener(socket, "error", onHttp2SocketError);
      util.addListener(socket, "end", onHttp2SocketEnd);
      util.addListener(socket, "close", onHttp2SocketClose);
      socket[kClosed] = false;
      socket.on("close", onSocketClose);
      return {
        version: "h2",
        defaultPipelining: Infinity,
        write(request2) {
          return writeH2(client, request2);
        },
        resume() {
          resumeH2(client);
        },
        destroy(err, callback) {
          if (socket[kClosed]) {
            queueMicrotask(callback);
          } else {
            socket.destroy(err).on("close", callback);
          }
        },
        get destroyed() {
          return socket.destroyed;
        },
        busy() {
          return false;
        }
      };
    }
    function resumeH2(client) {
      const socket = client[kSocket];
      if (socket?.destroyed === false) {
        if (client[kSize] === 0 || client[kMaxConcurrentStreams] === 0) {
          socket.unref();
          client[kHTTP2Session].unref();
        } else {
          socket.ref();
          client[kHTTP2Session].ref();
        }
      }
    }
    function onHttp2SessionError(err) {
      assert3(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kSocket][kError] = err;
      this[kClient][kOnError](err);
    }
    function onHttp2FrameError(type, code, id2) {
      if (id2 === 0) {
        const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
        this[kSocket][kError] = err;
        this[kClient][kOnError](err);
      }
    }
    function onHttp2SessionEnd() {
      const err = new SocketError("other side closed", util.getSocketInfo(this[kSocket]));
      this.destroy(err);
      util.destroy(this[kSocket], err);
    }
    function onHttp2SessionGoAway(errorCode) {
      const err = this[kError] || new SocketError(`HTTP/2: "GOAWAY" frame received with code ${errorCode}`, util.getSocketInfo(this[kSocket]));
      const client = this[kClient];
      client[kSocket] = null;
      client[kHTTPContext] = null;
      this.close();
      this[kHTTP2Session] = null;
      util.destroy(this[kSocket], err);
      if (client[kRunningIdx] < client[kQueue].length) {
        const request2 = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        util.errorRequest(client, request2, err);
        client[kPendingIdx] = client[kRunningIdx];
      }
      assert3(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      client[kResume]();
    }
    function onHttp2SessionClose() {
      const { [kClient]: client } = this;
      const { [kSocket]: socket } = client;
      const err = this[kSocket][kError] || this[kError] || new SocketError("closed", util.getSocketInfo(socket));
      client[kSocket] = null;
      client[kHTTPContext] = null;
      if (client.destroyed) {
        assert3(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request2 = requests[i];
          util.errorRequest(client, request2, err);
        }
      }
    }
    function onHttp2SocketClose() {
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      const client = this[kHTTP2Session][kClient];
      client[kSocket] = null;
      client[kHTTPContext] = null;
      if (this[kHTTP2Session] !== null) {
        this[kHTTP2Session].destroy(err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert3(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      client[kResume]();
    }
    function onHttp2SocketError(err) {
      assert3(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kError] = err;
      this[kClient][kOnError](err);
    }
    function onHttp2SocketEnd() {
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onSocketClose() {
      this[kClosed] = true;
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function writeH2(client, request2) {
      const requestTimeout = request2.bodyTimeout ?? client[kBodyTimeout];
      const session = client[kHTTP2Session];
      const { method, path: path3, host, upgrade, expectContinue, signal, headers: reqHeaders } = request2;
      let { body } = request2;
      if (upgrade) {
        util.errorRequest(client, request2, new Error("Upgrade not supported for H2"));
        return false;
      }
      const headers = {};
      for (let n2 = 0; n2 < reqHeaders.length; n2 += 2) {
        const key = reqHeaders[n2 + 0];
        const val = reqHeaders[n2 + 1];
        if (Array.isArray(val)) {
          for (let i = 0; i < val.length; i++) {
            if (headers[key]) {
              headers[key] += `,${val[i]}`;
            } else {
              headers[key] = val[i];
            }
          }
        } else {
          headers[key] = val;
        }
      }
      let stream = null;
      const { hostname, port } = client[kUrl];
      headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ""}`;
      headers[HTTP2_HEADER_METHOD] = method;
      const abort = (err) => {
        if (request2.aborted || request2.completed) {
          return;
        }
        err = err || new RequestAbortedError();
        util.errorRequest(client, request2, err);
        if (stream != null) {
          stream.removeAllListeners("data");
          stream.close();
          client[kOnError](err);
          client[kResume]();
        }
        util.destroy(body, err);
      };
      try {
        request2.onConnect(abort);
      } catch (err) {
        util.errorRequest(client, request2, err);
      }
      if (request2.aborted) {
        return false;
      }
      if (method === "CONNECT") {
        session.ref();
        stream = session.request(headers, { endStream: false, signal });
        if (!stream.pending) {
          request2.onUpgrade(null, null, stream);
          ++session[kOpenStreams];
          client[kQueue][client[kRunningIdx]++] = null;
        } else {
          stream.once("ready", () => {
            request2.onUpgrade(null, null, stream);
            ++session[kOpenStreams];
            client[kQueue][client[kRunningIdx]++] = null;
          });
        }
        stream.once("close", () => {
          session[kOpenStreams] -= 1;
          if (session[kOpenStreams] === 0) session.unref();
        });
        stream.setTimeout(requestTimeout);
        return true;
      }
      headers[HTTP2_HEADER_PATH] = path3;
      headers[HTTP2_HEADER_SCHEME] = "https";
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util.bodyLength(body);
      if (util.isFormDataLike(body)) {
        extractBody ??= require_body().extractBody;
        const [bodyStream, contentType] = extractBody(body);
        headers["content-type"] = contentType;
        body = bodyStream.stream;
        contentLength = bodyStream.length;
      }
      if (contentLength == null) {
        contentLength = request2.contentLength;
      }
      if (contentLength === 0 || !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request2.contentLength != null && request2.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          util.errorRequest(client, request2, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      if (contentLength != null) {
        assert3(body, "no body must not have content length");
        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
      }
      session.ref();
      if (channels.sendHeaders.hasSubscribers) {
        let header = "";
        for (const key in headers) {
          header += `${key}: ${headers[key]}\r
`;
        }
        channels.sendHeaders.publish({ request: request2, headers: header, socket: session[kSocket] });
      }
      const shouldEndStream = method === "GET" || method === "HEAD" || body === null;
      if (expectContinue) {
        headers[HTTP2_HEADER_EXPECT] = "100-continue";
        stream = session.request(headers, { endStream: shouldEndStream, signal });
        stream.once("continue", writeBodyH2);
      } else {
        stream = session.request(headers, {
          endStream: shouldEndStream,
          signal
        });
        writeBodyH2();
      }
      ++session[kOpenStreams];
      stream.setTimeout(requestTimeout);
      stream.once("response", (headers2) => {
        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
        request2.onResponseStarted();
        if (request2.aborted) {
          stream.removeAllListeners("data");
          return;
        }
        if (request2.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), "") === false) {
          stream.pause();
        }
      });
      stream.on("data", (chunk5) => {
        if (request2.onData(chunk5) === false) {
          stream.pause();
        }
      });
      stream.once("end", (err) => {
        stream.removeAllListeners("data");
        if (stream.state?.state == null || stream.state.state < 6) {
          if (!request2.aborted && !request2.completed) {
            request2.onComplete({});
          }
          client[kQueue][client[kRunningIdx]++] = null;
          client[kResume]();
        } else {
          --session[kOpenStreams];
          if (session[kOpenStreams] === 0) {
            session.unref();
          }
          abort(err ?? new InformationalError("HTTP/2: stream half-closed (remote)"));
          client[kQueue][client[kRunningIdx]++] = null;
          client[kPendingIdx] = client[kRunningIdx];
          client[kResume]();
        }
      });
      stream.once("close", () => {
        stream.removeAllListeners("data");
        session[kOpenStreams] -= 1;
        if (session[kOpenStreams] === 0) {
          session.unref();
        }
      });
      stream.once("error", function(err) {
        stream.removeAllListeners("data");
        abort(err);
      });
      stream.once("frameError", (type, code) => {
        stream.removeAllListeners("data");
        abort(new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`));
      });
      stream.on("aborted", () => {
        stream.removeAllListeners("data");
      });
      stream.on("timeout", () => {
        const err = new InformationalError(`HTTP/2: "stream timeout after ${requestTimeout}"`);
        stream.removeAllListeners("data");
        session[kOpenStreams] -= 1;
        if (session[kOpenStreams] === 0) {
          session.unref();
        }
        abort(err);
      });
      stream.once("trailers", (trailers) => {
        if (request2.aborted || request2.completed) {
          return;
        }
        request2.onComplete(trailers);
      });
      return true;
      function writeBodyH2() {
        if (!body || contentLength === 0) {
          writeBuffer(
            abort,
            stream,
            null,
            client,
            request2,
            client[kSocket],
            contentLength,
            expectsPayload
          );
        } else if (util.isBuffer(body)) {
          writeBuffer(
            abort,
            stream,
            body,
            client,
            request2,
            client[kSocket],
            contentLength,
            expectsPayload
          );
        } else if (util.isBlobLike(body)) {
          if (typeof body.stream === "function") {
            writeIterable(
              abort,
              stream,
              body.stream(),
              client,
              request2,
              client[kSocket],
              contentLength,
              expectsPayload
            );
          } else {
            writeBlob(
              abort,
              stream,
              body,
              client,
              request2,
              client[kSocket],
              contentLength,
              expectsPayload
            );
          }
        } else if (util.isStream(body)) {
          writeStream(
            abort,
            client[kSocket],
            expectsPayload,
            stream,
            body,
            client,
            request2,
            contentLength
          );
        } else if (util.isIterable(body)) {
          writeIterable(
            abort,
            stream,
            body,
            client,
            request2,
            client[kSocket],
            contentLength,
            expectsPayload
          );
        } else {
          assert3(false);
        }
      }
    }
    function writeBuffer(abort, h2stream, body, client, request2, socket, contentLength, expectsPayload) {
      try {
        if (body != null && util.isBuffer(body)) {
          assert3(contentLength === body.byteLength, "buffer body must have content length");
          h2stream.cork();
          h2stream.write(body);
          h2stream.uncork();
          h2stream.end();
          request2.onBodySent(body);
        }
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        request2.onRequestSent();
        client[kResume]();
      } catch (error4) {
        abort(error4);
      }
    }
    function writeStream(abort, socket, expectsPayload, h2stream, body, client, request2, contentLength) {
      assert3(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      const pipe2 = pipeline(
        body,
        h2stream,
        (err) => {
          if (err) {
            util.destroy(pipe2, err);
            abort(err);
          } else {
            util.removeAllListeners(pipe2);
            request2.onRequestSent();
            if (!expectsPayload) {
              socket[kReset] = true;
            }
            client[kResume]();
          }
        }
      );
      util.addListener(pipe2, "data", onPipeData);
      function onPipeData(chunk5) {
        request2.onBodySent(chunk5);
      }
    }
    async function writeBlob(abort, h2stream, body, client, request2, socket, contentLength, expectsPayload) {
      assert3(contentLength === body.size, "blob body must have content length");
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer4 = Buffer.from(await body.arrayBuffer());
        h2stream.cork();
        h2stream.write(buffer4);
        h2stream.uncork();
        h2stream.end();
        request2.onBodySent(buffer4);
        request2.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        client[kResume]();
      } catch (err) {
        abort(err);
      }
    }
    async function writeIterable(abort, h2stream, body, client, request2, socket, contentLength, expectsPayload) {
      assert3(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve9, reject) => {
        assert3(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve9;
        }
      });
      h2stream.on("close", onDrain).on("drain", onDrain);
      try {
        for await (const chunk5 of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          const res = h2stream.write(chunk5);
          request2.onBodySent(chunk5);
          if (!res) {
            await waitForDrain();
          }
        }
        h2stream.end();
        request2.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        client[kResume]();
      } catch (err) {
        abort(err);
      } finally {
        h2stream.off("close", onDrain).off("drain", onDrain);
      }
    }
    module.exports = connectH2;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/client.js
var require_client = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/client.js"(exports, module) {
    var assert3 = __require("assert");
    var net = __require("net");
    var http = __require("http");
    var util = require_util();
    var { channels } = require_diagnostics();
    var Request = require_request();
    var DispatcherBase = require_dispatcher_base();
    var {
      InvalidArgumentError,
      InformationalError,
      ClientDestroyedError
    } = require_errors();
    var buildConnector = require_connect();
    var {
      kUrl,
      kServerName,
      kClient,
      kBusy,
      kConnect,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kLocalAddress,
      kMaxResponseSize,
      kOnError,
      kHTTPContext,
      kMaxConcurrentStreams,
      kResume
    } = require_symbols();
    var connectH1 = require_client_h1();
    var connectH2 = require_client_h2();
    var kClosedResolve = Symbol("kClosedResolve");
    var getDefaultNodeMaxHeaderSize = http && http.maxHeaderSize && Number.isInteger(http.maxHeaderSize) && http.maxHeaderSize > 0 ? () => http.maxHeaderSize : () => {
      throw new InvalidArgumentError("http module not available or http.maxHeaderSize invalid");
    };
    var noop2 = () => {
    };
    function getPipelining(client) {
      return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1;
    }
    var Client = class extends DispatcherBase {
      /**
       *
       * @param {string|URL} url
       * @param {import('../../types/client.js').Client.Options} options
       */
      constructor(url3, {
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls,
        strictContentLength,
        maxCachedSessions,
        connect: connect2,
        maxRequestsPerClient,
        localAddress,
        maxResponseSize,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        // h2
        maxConcurrentStreams,
        allowH2
      } = {}) {
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null) {
          if (!Number.isInteger(maxHeaderSize) || maxHeaderSize < 1) {
            throw new InvalidArgumentError("invalid maxHeaderSize");
          }
        } else {
          maxHeaderSize = getDefaultNodeMaxHeaderSize();
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        }
        if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
          throw new InvalidArgumentError("localAddress must be valid string IP address");
        }
        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
          throw new InvalidArgumentError("maxResponseSize must be a positive number");
        }
        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
          throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
        }
        if (allowH2 != null && typeof allowH2 !== "boolean") {
          throw new InvalidArgumentError("allowH2 must be a valid boolean value");
        }
        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
          throw new InvalidArgumentError("maxConcurrentStreams must be a positive integer, greater than 0");
        }
        super();
        if (typeof connect2 !== "function") {
          connect2 = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...typeof autoSelectFamily === "boolean" ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect2
          });
        }
        this[kUrl] = util.parseOrigin(url3);
        this[kConnector] = connect2;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kLocalAddress] = localAddress != null ? localAddress : null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
        this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100;
        this[kHTTPContext] = null;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
        this[kResume] = (sync14) => resume2(this, sync14);
        this[kOnError] = (err) => onError7(this, err);
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        this[kResume](true);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;
      }
      get [kBusy]() {
        return Boolean(
          this[kHTTPContext]?.busy(null) || this[kSize] >= (getPipelining(this) || 1) || this[kPending] > 0
        );
      }
      /* istanbul ignore: only used for test */
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;
        const request2 = new Request(origin, opts, handler);
        this[kQueue].push(request2);
        if (this[kResuming]) ; else if (util.bodyLength(request2.body) == null && util.isIterable(request2.body)) {
          this[kResuming] = 1;
          queueMicrotask(() => resume2(this));
        } else {
          this[kResume](true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve9) => {
          if (this[kSize]) {
            this[kClosedResolve] = resolve9;
          } else {
            resolve9(null);
          }
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve9) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request2 = requests[i];
            util.errorRequest(this, request2, err);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve9(null);
          };
          if (this[kHTTPContext]) {
            this[kHTTPContext].destroy(err, callback);
            this[kHTTPContext] = null;
          } else {
            queueMicrotask(callback);
          }
          this[kResume]();
        });
      }
    };
    function onError7(client, err) {
      if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert3(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request2 = requests[i];
          util.errorRequest(client, request2, err);
        }
        assert3(client[kSize] === 0);
      }
    }
    async function connect(client) {
      assert3(!client[kConnecting]);
      assert3(!client[kHTTPContext]);
      let { host, hostname, protocol, port } = client[kUrl];
      if (hostname[0] === "[") {
        const idx = hostname.indexOf("]");
        assert3(idx !== -1);
        const ip = hostname.substring(1, idx);
        assert3(net.isIPv6(ip));
        hostname = ip;
      }
      client[kConnecting] = true;
      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            version: client[kHTTPContext]?.version,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector]
        });
      }
      try {
        const socket = await new Promise((resolve9, reject) => {
          client[kConnector]({
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          }, (err, socket2) => {
            if (err) {
              reject(err);
            } else {
              resolve9(socket2);
            }
          });
        });
        if (client.destroyed) {
          util.destroy(socket.on("error", noop2), new ClientDestroyedError());
          return;
        }
        assert3(socket);
        try {
          client[kHTTPContext] = socket.alpnProtocol === "h2" ? await connectH2(client, socket) : await connectH1(client, socket);
        } catch (err) {
          socket.destroy().on("error", noop2);
          throw err;
        }
        client[kConnecting] = false;
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket[kClient] = client;
        socket[kError] = null;
        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              version: client[kHTTPContext]?.version,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            socket
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        if (client.destroyed) {
          return;
        }
        client[kConnecting] = false;
        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              version: client[kHTTPContext]?.version,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            error: err
          });
        }
        if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert3(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request2 = client[kQueue][client[kPendingIdx]++];
            util.errorRequest(client, request2, err);
          }
        } else {
          onError7(client, err);
        }
        client.emit("connectionError", client[kUrl], [client], err);
      }
      client[kResume]();
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }
    function resume2(client, sync14) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync14);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync14) {
      while (true) {
        if (client.destroyed) {
          assert3(client[kPending] === 0);
          return;
        }
        if (client[kClosedResolve] && !client[kSize]) {
          client[kClosedResolve]();
          client[kClosedResolve] = null;
          return;
        }
        if (client[kHTTPContext]) {
          client[kHTTPContext].resume();
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync14) {
            client[kNeedDrain] = 1;
            queueMicrotask(() => emitDrain(client));
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (getPipelining(client) || 1)) {
          return;
        }
        const request2 = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request2.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request2.servername;
          client[kHTTPContext]?.destroy(new InformationalError("servername changed"), () => {
            client[kHTTPContext] = null;
            resume2(client);
          });
        }
        if (client[kConnecting]) {
          return;
        }
        if (!client[kHTTPContext]) {
          connect(client);
          return;
        }
        if (client[kHTTPContext].destroyed) {
          return;
        }
        if (client[kHTTPContext].busy(request2)) {
          return;
        }
        if (!request2.aborted && client[kHTTPContext].write(request2)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    module.exports = Client;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/fixed-queue.js
var require_fixed_queue = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/fixed-queue.js"(exports, module) {
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize).fill(void 0);
        this.next = null;
      }
      /**
       * @returns {boolean}
       */
      isEmpty() {
        return this.top === this.bottom;
      }
      /**
       * @returns {boolean}
       */
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      /**
       * @param {T} data
       * @returns {void}
       */
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      /**
       * @returns {T|null}
       */
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0) {
          return null;
        }
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    module.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      /**
       * @returns {boolean}
       */
      isEmpty() {
        return this.head.isEmpty();
      }
      /**
       * @param {T} data
       */
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      /**
       * @returns {T|null}
       */
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
          tail.next = null;
        }
        return next;
      }
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/pool-stats.js
var require_pool_stats = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/pool-stats.js"(exports, module) {
    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
    var kPool = Symbol("pool");
    var PoolStats = class {
      constructor(pool) {
        this[kPool] = pool;
      }
      get connected() {
        return this[kPool][kConnected];
      }
      get free() {
        return this[kPool][kFree];
      }
      get pending() {
        return this[kPool][kPending];
      }
      get queued() {
        return this[kPool][kQueued];
      }
      get running() {
        return this[kPool][kRunning];
      }
      get size() {
        return this[kPool][kSize];
      }
    };
    module.exports = PoolStats;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/pool-base.js
var require_pool_base = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/pool-base.js"(exports, module) {
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
    var PoolStats = require_pool_stats();
    var kClients = Symbol("clients");
    var kNeedDrain = Symbol("needDrain");
    var kQueue = Symbol("queue");
    var kClosedResolve = Symbol("closed resolve");
    var kOnDrain = Symbol("onDrain");
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kGetDispatcher = Symbol("get dispatcher");
    var kAddClient = Symbol("add client");
    var kRemoveClient = Symbol("remove client");
    var kStats = Symbol("stats");
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit("drain", origin, [pool, ...targets]);
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        };
        this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending3 } of this[kClients]) {
          ret += pending3;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running4 } of this[kClients]) {
          ret += running4;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size16 } of this[kClients]) {
          ret += size16;
        }
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          await Promise.all(this[kClients].map((c) => c.close()));
        } else {
          await new Promise((resolve9) => {
            this[kClosedResolve] = resolve9;
          });
        }
      }
      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        await Promise.all(this[kClients].map((c) => c.destroy(err)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          queueMicrotask(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
      }
    };
    module.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/pool.js
var require_pool = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/pool.js"(exports, module) {
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher
    } = require_pool_base();
    var Client = require_client();
    var {
      InvalidArgumentError
    } = require_errors();
    var util = require_util();
    var { kUrl } = require_symbols();
    var buildConnector = require_connect();
    var kOptions = Symbol("options");
    var kConnections = Symbol("connections");
    var kFactory = Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect,
        connectTimeout,
        tls,
        maxCachedSessions,
        socketPath,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        allowH2,
        ...options
      } = {}) {
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        super();
        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...typeof autoSelectFamily === "boolean" ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect
          });
        }
        this[kConnections] = connections || null;
        this[kUrl] = util.parseOrigin(origin);
        this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kFactory] = factory;
        this.on("connectionError", (origin2, targets, error4) => {
          for (const target of targets) {
            const idx = this[kClients].indexOf(target);
            if (idx !== -1) {
              this[kClients].splice(idx, 1);
            }
          }
        });
      }
      [kGetDispatcher]() {
        for (const client of this[kClients]) {
          if (!client[kNeedDrain]) {
            return client;
          }
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          const dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
          return dispatcher;
        }
      }
    };
    module.exports = Pool;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/balanced-pool.js
var require_balanced_pool = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/balanced-pool.js"(exports, module) {
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors();
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base();
    var Pool = require_pool();
    var { kUrl } = require_symbols();
    var { parseOrigin } = require_util();
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
    var kCurrentWeight = Symbol("kCurrentWeight");
    var kIndex = Symbol("kIndex");
    var kWeight = Symbol("kWeight");
    var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
    var kErrorPenalty = Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(a2, b) {
      if (a2 === 0) return b;
      while (b !== 0) {
        const t = b;
        b = a2 % b;
        a2 = t;
      }
      return a2;
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        super();
        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;
        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
          return this;
        }
        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool);
        pool.on("connect", () => {
          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
        });
        pool.on("connectionError", () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });
        pool.on("disconnect", (...args2) => {
          const err = args2[2];
          if (err && err.code === "UND_ERR_SOCKET") {
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });
        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        let result = 0;
        for (let i = 0; i < this[kClients].length; i++) {
          result = getGreatestCommonDivisor(this[kClients][i][kWeight], result);
        }
        this[kGreatestCommonDivisor] = result;
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
        if (pool) {
          this[kRemoveClient](pool);
        }
        return this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p3) => p3[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
        if (!dispatcher) {
          return;
        }
        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a2, b) => a2 && b, true);
        if (allClientsBusy) {
          return;
        }
        let counter6 = 0;
        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
        while (counter6++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool = this[kClients][this[kIndex]];
          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
            maxWeightIndex = this[kIndex];
          }
          if (this[kIndex] === 0) {
            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
            return pool;
          }
        }
        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    };
    module.exports = BalancedPool;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/agent.js
var require_agent = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/agent.js"(exports, module) {
    var { InvalidArgumentError } = require_errors();
    var { kClients, kRunning, kClose, kDestroy, kDispatch } = require_symbols();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client = require_client();
    var util = require_util();
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kOnDrain = Symbol("onDrain");
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
    }
    var Agent = class extends DispatcherBase {
      constructor({ factory = defaultFactory, connect, ...options } = {}) {
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        super();
        if (connect && typeof connect !== "function") {
          connect = { ...connect };
        }
        this[kOptions] = { ...util.deepClone(options), connect };
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kOnDrain] = (origin, targets) => {
          this.emit("drain", origin, [this, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          this.emit("connect", origin, [this, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          this.emit("disconnect", origin, [this, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          this.emit("connectionError", origin, [this, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const client of this[kClients].values()) {
          ret += client[kRunning];
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        }
        let dispatcher = this[kClients].get(key);
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].set(key, dispatcher);
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const client of this[kClients].values()) {
          closePromises.push(client.close());
        }
        this[kClients].clear();
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        const destroyPromises = [];
        for (const client of this[kClients].values()) {
          destroyPromises.push(client.destroy(err));
        }
        this[kClients].clear();
        await Promise.all(destroyPromises);
      }
    };
    module.exports = Agent;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/proxy-agent.js
var require_proxy_agent = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/proxy-agent.js"(exports, module) {
    var { kProxy, kClose, kDestroy } = require_symbols();
    var { URL: URL2 } = __require("url");
    var Agent = require_agent();
    var Pool = require_pool();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = require_errors();
    var buildConnector = require_connect();
    var kAgent = Symbol("proxy agent");
    var kClient = Symbol("proxy client");
    var kProxyHeaders = Symbol("proxy headers");
    var kRequestTls = Symbol("request tls settings");
    var kProxyTls = Symbol("proxy tls settings");
    var kConnectEndpoint = Symbol("connect endpoint function");
    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var noop2 = () => {
    };
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        if (!opts || typeof opts === "object" && !(opts instanceof URL2) && !opts.uri) {
          throw new InvalidArgumentError("Proxy uri is mandatory");
        }
        const { clientFactory = defaultFactory } = opts;
        if (typeof clientFactory !== "function") {
          throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
        }
        super();
        const url3 = this.#getUrl(opts);
        const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url3;
        this[kProxy] = { uri: href, protocol };
        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = opts.headers || {};
        if (opts.auth && opts.token) {
          throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
        } else if (opts.auth) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
        } else if (opts.token) {
          this[kProxyHeaders]["proxy-authorization"] = opts.token;
        } else if (username && password) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
        }
        const connect = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
        this[kClient] = clientFactory(url3, { connect });
        this[kAgent] = new Agent({
          ...opts,
          connect: async (opts2, callback) => {
            let requestedPath = opts2.host;
            if (!opts2.port) {
              requestedPath += `:${defaultProtocolPort(opts2.protocol)}`;
            }
            try {
              const { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedPath,
                signal: opts2.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host: opts2.host
                },
                servername: this[kProxyTls]?.servername || proxyHostname
              });
              if (statusCode !== 200) {
                socket.on("error", noop2).destroy();
                callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
              }
              if (opts2.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              if (this[kRequestTls]) {
                servername = this[kRequestTls].servername;
              } else {
                servername = opts2.servername;
              }
              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
            } catch (err) {
              if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
                callback(new SecureProxyConnectionError(err));
              } else {
                callback(err);
              }
            }
          }
        });
      }
      dispatch(opts, handler) {
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        if (headers && !("host" in headers) && !("Host" in headers)) {
          const { host } = new URL2(opts.origin);
          headers.host = host;
        }
        return this[kAgent].dispatch(
          {
            ...opts,
            headers
          },
          handler
        );
      }
      /**
       * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts
       * @returns {URL}
       */
      #getUrl(opts) {
        if (typeof opts === "string") {
          return new URL2(opts);
        } else if (opts instanceof URL2) {
          return opts;
        } else {
          return new URL2(opts.uri);
        }
      }
      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        const headersPair = {};
        for (let i = 0; i < headers.length; i += 2) {
          headersPair[headers[i]] = headers[i + 1];
        }
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
      if (existProxyAuth) {
        throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
    }
    module.exports = ProxyAgent;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/env-http-proxy-agent.js
var require_env_http_proxy_agent = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/env-http-proxy-agent.js"(exports, module) {
    var DispatcherBase = require_dispatcher_base();
    var { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = require_symbols();
    var ProxyAgent = require_proxy_agent();
    var Agent = require_agent();
    var DEFAULT_PORTS = {
      "http:": 80,
      "https:": 443
    };
    var EnvHttpProxyAgent = class extends DispatcherBase {
      #noProxyValue = null;
      #noProxyEntries = null;
      #opts = null;
      constructor(opts = {}) {
        super();
        this.#opts = opts;
        const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts;
        this[kNoProxyAgent] = new Agent(agentOpts);
        const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
        if (HTTP_PROXY) {
          this[kHttpProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTP_PROXY });
        } else {
          this[kHttpProxyAgent] = this[kNoProxyAgent];
        }
        const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
        if (HTTPS_PROXY) {
          this[kHttpsProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTPS_PROXY });
        } else {
          this[kHttpsProxyAgent] = this[kHttpProxyAgent];
        }
        this.#parseNoProxy();
      }
      [kDispatch](opts, handler) {
        const url3 = new URL(opts.origin);
        const agent = this.#getProxyAgentForUrl(url3);
        return agent.dispatch(opts, handler);
      }
      async [kClose]() {
        await this[kNoProxyAgent].close();
        if (!this[kHttpProxyAgent][kClosed]) {
          await this[kHttpProxyAgent].close();
        }
        if (!this[kHttpsProxyAgent][kClosed]) {
          await this[kHttpsProxyAgent].close();
        }
      }
      async [kDestroy](err) {
        await this[kNoProxyAgent].destroy(err);
        if (!this[kHttpProxyAgent][kDestroyed]) {
          await this[kHttpProxyAgent].destroy(err);
        }
        if (!this[kHttpsProxyAgent][kDestroyed]) {
          await this[kHttpsProxyAgent].destroy(err);
        }
      }
      #getProxyAgentForUrl(url3) {
        let { protocol, host: hostname, port } = url3;
        hostname = hostname.replace(/:\d*$/, "").toLowerCase();
        port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0;
        if (!this.#shouldProxy(hostname, port)) {
          return this[kNoProxyAgent];
        }
        if (protocol === "https:") {
          return this[kHttpsProxyAgent];
        }
        return this[kHttpProxyAgent];
      }
      #shouldProxy(hostname, port) {
        if (this.#noProxyChanged) {
          this.#parseNoProxy();
        }
        if (this.#noProxyEntries.length === 0) {
          return true;
        }
        if (this.#noProxyValue === "*") {
          return false;
        }
        for (let i = 0; i < this.#noProxyEntries.length; i++) {
          const entry = this.#noProxyEntries[i];
          if (entry.port && entry.port !== port) {
            continue;
          }
          if (!/^[.*]/.test(entry.hostname)) {
            if (hostname === entry.hostname) {
              return false;
            }
          } else {
            if (hostname.endsWith(entry.hostname.replace(/^\*/, ""))) {
              return false;
            }
          }
        }
        return true;
      }
      #parseNoProxy() {
        const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv;
        const noProxySplit = noProxyValue.split(/[,\s]/);
        const noProxyEntries = [];
        for (let i = 0; i < noProxySplit.length; i++) {
          const entry = noProxySplit[i];
          if (!entry) {
            continue;
          }
          const parsed = entry.match(/^(.+):(\d+)$/);
          noProxyEntries.push({
            hostname: (parsed ? parsed[1] : entry).toLowerCase(),
            port: parsed ? Number.parseInt(parsed[2], 10) : 0
          });
        }
        this.#noProxyValue = noProxyValue;
        this.#noProxyEntries = noProxyEntries;
      }
      get #noProxyChanged() {
        if (this.#opts.noProxy !== void 0) {
          return false;
        }
        return this.#noProxyValue !== this.#noProxyEnv;
      }
      get #noProxyEnv() {
        return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
      }
    };
    module.exports = EnvHttpProxyAgent;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/handler/retry-handler.js
var require_retry_handler = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/handler/retry-handler.js"(exports, module) {
    var assert3 = __require("assert");
    var { kRetryHandlerDefaultRetry } = require_symbols();
    var { RequestRetryError } = require_errors();
    var WrapHandler = require_wrap_handler();
    var {
      isDisturbed,
      parseRangeHeader,
      wrapRequestBody
    } = require_util();
    function calculateRetryAfterHeader(retryAfter) {
      const retryTime = new Date(retryAfter).getTime();
      return isNaN(retryTime) ? 0 : retryTime - Date.now();
    }
    var RetryHandler = class _RetryHandler {
      constructor(opts, { dispatch, handler }) {
        const { retryOptions, ...dispatchOpts } = opts;
        const {
          // Retry scoped
          retry: retryFn,
          maxRetries,
          maxTimeout,
          minTimeout,
          timeoutFactor,
          // Response scoped
          methods,
          errorCodes,
          retryAfter,
          statusCodes
        } = retryOptions ?? {};
        this.dispatch = dispatch;
        this.handler = WrapHandler.wrap(handler);
        this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) };
        this.retryOpts = {
          retry: retryFn ?? _RetryHandler[kRetryHandlerDefaultRetry],
          retryAfter: retryAfter ?? true,
          maxTimeout: maxTimeout ?? 30 * 1e3,
          // 30s,
          minTimeout: minTimeout ?? 500,
          // .5s
          timeoutFactor: timeoutFactor ?? 2,
          maxRetries: maxRetries ?? 5,
          // What errors we should retry
          methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
          // Indicates which errors to retry
          statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
          // List of errors to retry
          errorCodes: errorCodes ?? [
            "ECONNRESET",
            "ECONNREFUSED",
            "ENOTFOUND",
            "ENETDOWN",
            "ENETUNREACH",
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "EPIPE",
            "UND_ERR_SOCKET"
          ]
        };
        this.retryCount = 0;
        this.retryCountCheckpoint = 0;
        this.headersSent = false;
        this.start = 0;
        this.end = null;
        this.etag = null;
      }
      onRequestStart(controller, context8) {
        if (!this.headersSent) {
          this.handler.onRequestStart?.(controller, context8);
        }
      }
      onRequestUpgrade(controller, statusCode, headers, socket) {
        this.handler.onRequestUpgrade?.(controller, statusCode, headers, socket);
      }
      static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
        const { statusCode, code, headers } = err;
        const { method, retryOptions } = opts;
        const {
          maxRetries,
          minTimeout,
          maxTimeout,
          timeoutFactor,
          statusCodes,
          errorCodes,
          methods
        } = retryOptions;
        const { counter: counter6 } = state;
        if (code && code !== "UND_ERR_REQ_RETRY" && !errorCodes.includes(code)) {
          cb(err);
          return;
        }
        if (Array.isArray(methods) && !methods.includes(method)) {
          cb(err);
          return;
        }
        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
          cb(err);
          return;
        }
        if (counter6 > maxRetries) {
          cb(err);
          return;
        }
        let retryAfterHeader = headers?.["retry-after"];
        if (retryAfterHeader) {
          retryAfterHeader = Number(retryAfterHeader);
          retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader(headers["retry-after"]) : retryAfterHeader * 1e3;
        }
        const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter6 - 1), maxTimeout);
        setTimeout(() => cb(null), retryTimeout);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        this.retryCount += 1;
        if (statusCode >= 300) {
          if (this.retryOpts.statusCodes.includes(statusCode) === false) {
            this.headersSent = true;
            this.handler.onResponseStart?.(
              controller,
              statusCode,
              headers,
              statusMessage
            );
            return;
          } else {
            throw new RequestRetryError("Request failed", statusCode, {
              headers,
              data: {
                count: this.retryCount
              }
            });
          }
        }
        if (this.headersSent) {
          if (statusCode !== 206 && (this.start > 0 || statusCode !== 200)) {
            throw new RequestRetryError("server does not support the range header and the payload was partially consumed", statusCode, {
              headers,
              data: { count: this.retryCount }
            });
          }
          const contentRange = parseRangeHeader(headers["content-range"]);
          if (!contentRange) {
            throw new RequestRetryError("Content-Range mismatch", statusCode, {
              headers,
              data: { count: this.retryCount }
            });
          }
          if (this.etag != null && this.etag !== headers.etag) {
            throw new RequestRetryError("ETag mismatch", statusCode, {
              headers,
              data: { count: this.retryCount }
            });
          }
          const { start: start3, size: size16, end: end6 = size16 ? size16 - 1 : null } = contentRange;
          assert3(this.start === start3, "content-range mismatch");
          assert3(this.end == null || this.end === end6, "content-range mismatch");
          return;
        }
        if (this.end == null) {
          if (statusCode === 206) {
            const range4 = parseRangeHeader(headers["content-range"]);
            if (range4 == null) {
              this.headersSent = true;
              this.handler.onResponseStart?.(
                controller,
                statusCode,
                headers,
                statusMessage
              );
              return;
            }
            const { start: start3, size: size16, end: end6 = size16 ? size16 - 1 : null } = range4;
            assert3(
              start3 != null && Number.isFinite(start3),
              "content-range mismatch"
            );
            assert3(end6 != null && Number.isFinite(end6), "invalid content-length");
            this.start = start3;
            this.end = end6;
          }
          if (this.end == null) {
            const contentLength = headers["content-length"];
            this.end = contentLength != null ? Number(contentLength) - 1 : null;
          }
          assert3(Number.isFinite(this.start));
          assert3(
            this.end == null || Number.isFinite(this.end),
            "invalid content-length"
          );
          this.resume = true;
          this.etag = headers.etag != null ? headers.etag : null;
          if (this.etag != null && this.etag[0] === "W" && this.etag[1] === "/") {
            this.etag = null;
          }
          this.headersSent = true;
          this.handler.onResponseStart?.(
            controller,
            statusCode,
            headers,
            statusMessage
          );
        } else {
          throw new RequestRetryError("Request failed", statusCode, {
            headers,
            data: { count: this.retryCount }
          });
        }
      }
      onResponseData(controller, chunk5) {
        this.start += chunk5.length;
        this.handler.onResponseData?.(controller, chunk5);
      }
      onResponseEnd(controller, trailers) {
        this.retryCount = 0;
        return this.handler.onResponseEnd?.(controller, trailers);
      }
      onResponseError(controller, err) {
        if (controller?.aborted || isDisturbed(this.opts.body)) {
          this.handler.onResponseError?.(controller, err);
          return;
        }
        if (this.retryCount - this.retryCountCheckpoint > 0) {
          this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint);
        } else {
          this.retryCount += 1;
        }
        this.retryOpts.retry(
          err,
          {
            state: { counter: this.retryCount },
            opts: { retryOptions: this.retryOpts, ...this.opts }
          },
          onRetry.bind(this)
        );
        function onRetry(err2) {
          if (err2 != null || controller?.aborted || isDisturbed(this.opts.body)) {
            return this.handler.onResponseError?.(controller, err2);
          }
          if (this.start !== 0) {
            const headers = { range: `bytes=${this.start}-${this.end ?? ""}` };
            if (this.etag != null) {
              headers["if-match"] = this.etag;
            }
            this.opts = {
              ...this.opts,
              headers: {
                ...this.opts.headers,
                ...headers
              }
            };
          }
          try {
            this.retryCountCheckpoint = this.retryCount;
            this.dispatch(this.opts, this);
          } catch (err3) {
            this.handler.onResponseError?.(controller, err3);
          }
        }
      }
    };
    module.exports = RetryHandler;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/retry-agent.js
var require_retry_agent = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/dispatcher/retry-agent.js"(exports, module) {
    var Dispatcher = require_dispatcher();
    var RetryHandler = require_retry_handler();
    var RetryAgent = class extends Dispatcher {
      #agent = null;
      #options = null;
      constructor(agent, options = {}) {
        super(options);
        this.#agent = agent;
        this.#options = options;
      }
      dispatch(opts, handler) {
        const retry8 = new RetryHandler({
          ...opts,
          retryOptions: this.#options
        }, {
          dispatch: this.#agent.dispatch.bind(this.#agent),
          handler
        });
        return this.#agent.dispatch(opts, retry8);
      }
      close() {
        return this.#agent.close();
      }
      destroy() {
        return this.#agent.destroy();
      }
    };
    module.exports = RetryAgent;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/api/readable.js"(exports, module) {
    var assert3 = __require("assert");
    var { Readable: Readable2 } = __require("stream");
    var { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = require_errors();
    var util = require_util();
    var { ReadableStreamFrom } = require_util();
    var kConsume = Symbol("kConsume");
    var kReading = Symbol("kReading");
    var kBody = Symbol("kBody");
    var kAbort = Symbol("kAbort");
    var kContentType = Symbol("kContentType");
    var kContentLength = Symbol("kContentLength");
    var kUsed = Symbol("kUsed");
    var kBytesRead = Symbol("kBytesRead");
    var noop2 = () => {
    };
    var BodyReadable = class extends Readable2 {
      /**
       * @param {object} opts
       * @param {(this: Readable, size: number) => void} opts.resume
       * @param {() => (void | null)} opts.abort
       * @param {string} [opts.contentType = '']
       * @param {number} [opts.contentLength]
       * @param {number} [opts.highWaterMark = 64 * 1024]
       */
      constructor({
        resume: resume2,
        abort,
        contentType = "",
        contentLength,
        highWaterMark = 64 * 1024
        // Same as nodejs fs streams.
      }) {
        super({
          autoDestroy: true,
          read: resume2,
          highWaterMark
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBytesRead] = 0;
        this[kBody] = null;
        this[kUsed] = false;
        this[kContentType] = contentType;
        this[kContentLength] = Number.isFinite(contentLength) ? contentLength : null;
        this[kReading] = false;
      }
      /**
       * @param {Error|null} err
       * @param {(error:(Error|null)) => void} callback
       * @returns {void}
       */
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        if (!this[kUsed]) {
          setImmediate(() => {
            callback(err);
          });
        } else {
          callback(err);
        }
      }
      /**
       * @param {string} event
       * @param {(...args: any[]) => void} listener
       * @returns {this}
       */
      on(event, listener) {
        if (event === "data" || event === "readable") {
          this[kReading] = true;
          this[kUsed] = true;
        }
        return super.on(event, listener);
      }
      /**
       * @param {string} event
       * @param {(...args: any[]) => void} listener
       * @returns {this}
       */
      addListener(event, listener) {
        return this.on(event, listener);
      }
      /**
       * @param {string|symbol} event
       * @param {(...args: any[]) => void} listener
       * @returns {this}
       */
      off(event, listener) {
        const ret = super.off(event, listener);
        if (event === "data" || event === "readable") {
          this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return ret;
      }
      /**
       * @param {string|symbol} event
       * @param {(...args: any[]) => void} listener
       * @returns {this}
       */
      removeListener(event, listener) {
        return this.off(event, listener);
      }
      /**
       * @param {Buffer|null} chunk
       * @returns {boolean}
       */
      push(chunk5) {
        this[kBytesRead] += chunk5 ? chunk5.length : 0;
        if (this[kConsume] && chunk5 !== null) {
          consumePush(this[kConsume], chunk5);
          return this[kReading] ? super.push(chunk5) : true;
        }
        return super.push(chunk5);
      }
      /**
       * Consumes and returns the body as a string.
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-text
       * @returns {Promise<string>}
       */
      text() {
        return consume(this, "text");
      }
      /**
       * Consumes and returns the body as a JavaScript Object.
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-json
       * @returns {Promise<unknown>}
       */
      json() {
        return consume(this, "json");
      }
      /**
       * Consumes and returns the body as a Blob
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-blob
       * @returns {Promise<Blob>}
       */
      blob() {
        return consume(this, "blob");
      }
      /**
       * Consumes and returns the body as an Uint8Array.
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-bytes
       * @returns {Promise<Uint8Array>}
       */
      bytes() {
        return consume(this, "bytes");
      }
      /**
       * Consumes and returns the body as an ArrayBuffer.
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-arraybuffer
       * @returns {Promise<ArrayBuffer>}
       */
      arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      /**
       * Not implemented
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-formdata
       * @throws {NotSupportedError}
       */
      async formData() {
        throw new NotSupportedError();
      }
      /**
       * Returns true if the body is not null and the body has been consumed.
       * Otherwise, returns false.
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-bodyused
       * @readonly
       * @returns {boolean}
       */
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      /**
       * @see https://fetch.spec.whatwg.org/#dom-body-body
       * @readonly
       * @returns {ReadableStream}
       */
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert3(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      /**
       * Dumps the response body by reading `limit` number of bytes.
       * @param {object} opts
       * @param {number} [opts.limit = 131072] Number of bytes to read.
       * @param {AbortSignal} [opts.signal] An AbortSignal to cancel the dump.
       * @returns {Promise<null>}
       */
      async dump(opts) {
        const signal = opts?.signal;
        if (signal != null && (typeof signal !== "object" || !("aborted" in signal))) {
          throw new InvalidArgumentError("signal must be an AbortSignal");
        }
        const limit = opts?.limit && Number.isFinite(opts.limit) ? opts.limit : 128 * 1024;
        signal?.throwIfAborted();
        if (this._readableState.closeEmitted) {
          return null;
        }
        return await new Promise((resolve9, reject) => {
          if (this[kContentLength] && this[kContentLength] > limit || this[kBytesRead] > limit) {
            this.destroy(new AbortError());
          }
          if (signal) {
            const onAbort = () => {
              this.destroy(signal.reason ?? new AbortError());
            };
            signal.addEventListener("abort", onAbort);
            this.on("close", function() {
              signal.removeEventListener("abort", onAbort);
              if (signal.aborted) {
                reject(signal.reason ?? new AbortError());
              } else {
                resolve9(null);
              }
            });
          } else {
            this.on("close", resolve9);
          }
          this.on("error", noop2).on("data", () => {
            if (this[kBytesRead] > limit) {
              this.destroy();
            }
          }).resume();
        });
      }
      /**
       * @param {BufferEncoding} encoding
       * @returns {this}
       */
      setEncoding(encoding) {
        if (Buffer.isEncoding(encoding)) {
          this._readableState.encoding = encoding;
        }
        return this;
      }
    };
    function isLocked(bodyReadable) {
      return bodyReadable[kBody]?.locked === true || bodyReadable[kConsume] !== null;
    }
    function isUnusable(bodyReadable) {
      return util.isDisturbed(bodyReadable) || isLocked(bodyReadable);
    }
    function consume(stream, type) {
      assert3(!stream[kConsume]);
      return new Promise((resolve9, reject) => {
        if (isUnusable(stream)) {
          const rState = stream._readableState;
          if (rState.destroyed && rState.closeEmitted === false) {
            stream.on("error", (err) => {
              reject(err);
            }).on("close", () => {
              reject(new TypeError("unusable"));
            });
          } else {
            reject(rState.errored ?? new TypeError("unusable"));
          }
        } else {
          queueMicrotask(() => {
            stream[kConsume] = {
              type,
              stream,
              resolve: resolve9,
              reject,
              length: 0,
              body: []
            };
            stream.on("error", function(err) {
              consumeFinish(this[kConsume], err);
            }).on("close", function() {
              if (this[kConsume].body !== null) {
                consumeFinish(this[kConsume], new RequestAbortedError());
              }
            });
            consumeStart(stream[kConsume]);
          });
        }
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      if (state.bufferIndex) {
        const start3 = state.bufferIndex;
        const end6 = state.buffer.length;
        for (let n2 = start3; n2 < end6; n2++) {
          consumePush(consume2, state.buffer[n2]);
        }
      } else {
        for (const chunk5 of state.buffer) {
          consumePush(consume2, chunk5);
        }
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume], this._readableState.encoding);
      } else {
        consume2.stream.on("end", function() {
          consumeEnd(this[kConsume], this._readableState.encoding);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {
      }
    }
    function chunksDecode(chunks3, length3, encoding) {
      if (chunks3.length === 0 || length3 === 0) {
        return "";
      }
      const buffer4 = chunks3.length === 1 ? chunks3[0] : Buffer.concat(chunks3, length3);
      const bufferLength = buffer4.length;
      const start3 = bufferLength > 2 && buffer4[0] === 239 && buffer4[1] === 187 && buffer4[2] === 191 ? 3 : 0;
      if (!encoding || encoding === "utf8" || encoding === "utf-8") {
        return buffer4.utf8Slice(start3, bufferLength);
      } else {
        return buffer4.subarray(start3, bufferLength).toString(encoding);
      }
    }
    function chunksConcat(chunks3, length3) {
      if (chunks3.length === 0 || length3 === 0) {
        return new Uint8Array(0);
      }
      if (chunks3.length === 1) {
        return new Uint8Array(chunks3[0]);
      }
      const buffer4 = new Uint8Array(Buffer.allocUnsafeSlow(length3).buffer);
      let offset = 0;
      for (let i = 0; i < chunks3.length; ++i) {
        const chunk5 = chunks3[i];
        buffer4.set(chunk5, offset);
        offset += chunk5.length;
      }
      return buffer4;
    }
    function consumeEnd(consume2, encoding) {
      const { type, body, resolve: resolve9, stream, length: length3 } = consume2;
      try {
        if (type === "text") {
          resolve9(chunksDecode(body, length3, encoding));
        } else if (type === "json") {
          resolve9(JSON.parse(chunksDecode(body, length3, encoding)));
        } else if (type === "arrayBuffer") {
          resolve9(chunksConcat(body, length3).buffer);
        } else if (type === "blob") {
          resolve9(new Blob(body, { type: stream[kContentType] }));
        } else if (type === "bytes") {
          resolve9(chunksConcat(body, length3));
        }
        consumeFinish(consume2);
      } catch (err) {
        stream.destroy(err);
      }
    }
    function consumePush(consume2, chunk5) {
      consume2.length += chunk5.length;
      consume2.body.push(chunk5);
    }
    function consumeFinish(consume2, err) {
      if (consume2.body === null) {
        return;
      }
      if (err) {
        consume2.reject(err);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
    module.exports = {
      Readable: BodyReadable,
      chunksDecode
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/api/api-request.js"(exports, module) {
    var assert3 = __require("assert");
    var { AsyncResource: AsyncResource2 } = __require("async_hooks");
    var { Readable: Readable2 } = require_readable();
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var util = require_util();
    function noop2() {
    }
    var RequestHandler = class extends AsyncResource2 {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, highWaterMark } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
            throw new InvalidArgumentError("invalid highWaterMark");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", noop2), err);
          }
          throw err;
        }
        this.method = method;
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.highWaterMark = highWaterMark;
        this.reason = null;
        this.removeAbortListener = null;
        if (signal?.aborted) {
          this.reason = signal.reason ?? new RequestAbortedError();
        } else if (signal) {
          this.removeAbortListener = util.addAbortListener(signal, () => {
            this.reason = signal.reason ?? new RequestAbortedError();
            if (this.res) {
              util.destroy(this.res.on("error", noop2), this.reason);
            } else if (this.abort) {
              this.abort(this.reason);
            }
          });
        }
      }
      onConnect(abort, context8) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert3(this.callback);
        this.abort = abort;
        this.context = context8;
      }
      onHeaders(statusCode, rawHeaders, resume2, statusMessage) {
        const { callback, opaque, abort, context: context8, responseHeaders, highWaterMark } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        const contentLength = parsedHeaders["content-length"];
        const res = new Readable2({
          resume: resume2,
          abort,
          contentType,
          contentLength: this.method !== "HEAD" && contentLength ? Number(contentLength) : null,
          highWaterMark
        });
        if (this.removeAbortListener) {
          res.on("close", this.removeAbortListener);
          this.removeAbortListener = null;
        }
        this.callback = null;
        this.res = res;
        if (callback !== null) {
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers,
            trailers: this.trailers,
            opaque,
            body: res,
            context: context8
          });
        }
      }
      onData(chunk5) {
        return this.res.push(chunk5);
      }
      onComplete(trailers) {
        util.parseHeaders(trailers, this.trailers);
        this.res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util.destroy(res.on("error", noop2), err);
          });
        }
        if (body) {
          this.body = null;
          if (util.isStream(body)) {
            body.on("error", noop2);
            util.destroy(body, err);
          }
        }
        if (this.removeAbortListener) {
          this.removeAbortListener();
          this.removeAbortListener = null;
        }
      }
    };
    function request2(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve9, reject) => {
          request2.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve9(data);
          });
        });
      }
      try {
        const handler = new RequestHandler(opts, callback);
        this.dispatch(opts, handler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts?.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module.exports = request2;
    module.exports.RequestHandler = RequestHandler;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/api/abort-signal.js"(exports, module) {
    var { addAbortListener } = require_util();
    var { RequestAbortedError } = require_errors();
    var kListener = Symbol("kListener");
    var kSignal = Symbol("kSignal");
    function abort(self2) {
      if (self2.abort) {
        self2.abort(self2[kSignal]?.reason);
      } else {
        self2.reason = self2[kSignal]?.reason ?? new RequestAbortedError();
      }
      removeSignal(self2);
    }
    function addSignal(self2, signal) {
      self2.reason = null;
      self2[kSignal] = null;
      self2[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self2);
        return;
      }
      self2[kSignal] = signal;
      self2[kListener] = () => {
        abort(self2);
      };
      addAbortListener(self2[kSignal], self2[kListener]);
    }
    function removeSignal(self2) {
      if (!self2[kSignal]) {
        return;
      }
      if ("removeEventListener" in self2[kSignal]) {
        self2[kSignal].removeEventListener("abort", self2[kListener]);
      } else {
        self2[kSignal].removeListener("abort", self2[kListener]);
      }
      self2[kSignal] = null;
      self2[kListener] = null;
    }
    module.exports = {
      addSignal,
      removeSignal
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/api/api-stream.js"(exports, module) {
    var assert3 = __require("assert");
    var { finished } = __require("stream");
    var { AsyncResource: AsyncResource2 } = __require("async_hooks");
    var { InvalidArgumentError, InvalidReturnValueError } = require_errors();
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    function noop2() {
    }
    var StreamHandler = class extends AsyncResource2 {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", noop2), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context8) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert3(this.callback);
        this.abort = abort;
        this.context = context8;
      }
      onHeaders(statusCode, rawHeaders, resume2, statusMessage) {
        const { factory, opaque, context: context8, responseHeaders } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.factory = null;
        if (factory === null) {
          return;
        }
        const res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers,
          opaque,
          context: context8
        });
        if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
          throw new InvalidReturnValueError("expected Writable");
        }
        finished(res, { readable: false }, (err) => {
          const { callback, res: res2, opaque: opaque2, trailers, abort } = this;
          this.res = null;
          if (err || !res2.readable) {
            util.destroy(res2, err);
          }
          this.callback = null;
          this.runInAsyncScope(callback, null, err || null, { opaque: opaque2, trailers });
          if (err) {
            abort();
          }
        });
        res.on("drain", resume2);
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState?.needDrain;
        return needDrain !== true;
      }
      onData(chunk5) {
        const { res } = this;
        return res ? res.write(chunk5) : true;
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        if (!res) {
          return;
        }
        this.trailers = util.parseHeaders(trailers);
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function stream(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve9, reject) => {
          stream.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve9(data);
          });
        });
      }
      try {
        const handler = new StreamHandler(opts, factory, callback);
        this.dispatch(opts, handler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts?.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module.exports = stream;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/api/api-pipeline.js"(exports, module) {
    var {
      Readable: Readable2,
      Duplex,
      PassThrough
    } = __require("stream");
    var assert3 = __require("assert");
    var { AsyncResource: AsyncResource2 } = __require("async_hooks");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    function noop2() {
    }
    var kResume = Symbol("resume");
    var PipelineRequest = class extends Readable2 {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume2 } = this;
        if (resume2) {
          this[kResume] = null;
          resume2();
        }
      }
      _destroy(err, callback) {
        this._read();
        callback(err);
      }
    };
    var PipelineResponse = class extends Readable2 {
      constructor(resume2) {
        super({ autoDestroy: true });
        this[kResume] = resume2;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    var PipelineHandler = class extends AsyncResource2 {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on("error", noop2);
        this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body?.resume) {
              body.resume();
            }
          },
          write: (chunk5, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk5, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util.destroy(body, err);
            util.destroy(req, err);
            util.destroy(res, err);
            removeSignal(this);
            callback(err);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context8) {
        const { res } = this;
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert3(!res, "pipeline cannot be retried");
        this.abort = abort;
        this.context = context8;
      }
      onHeaders(statusCode, rawHeaders, resume2) {
        const { opaque, handler, context: context8 } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume2);
        let body;
        try {
          this.handler = null;
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context: context8
          });
        } catch (err) {
          this.res.on("error", noop2);
          throw err;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk5) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk5) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err) => {
          const { ret } = this;
          util.destroy(ret, err);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk5) {
        const { res } = this;
        return res.push(chunk5);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util.destroy(ret, err);
      }
    };
    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    module.exports = pipeline;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/api/api-upgrade.js"(exports, module) {
    var { InvalidArgumentError, SocketError } = require_errors();
    var { AsyncResource: AsyncResource2 } = __require("async_hooks");
    var assert3 = __require("assert");
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var UpgradeHandler = class extends AsyncResource2 {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context8) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert3(this.callback);
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        assert3(statusCode === 101);
        const { callback, opaque, context: context8 } = this;
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context: context8
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve9, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve9(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        const upgradeOpts = {
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        };
        this.dispatch(upgradeOpts, upgradeHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts?.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module.exports = upgrade;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/api/api-connect.js"(exports, module) {
    var assert3 = __require("assert");
    var { AsyncResource: AsyncResource2 } = __require("async_hooks");
    var { InvalidArgumentError, SocketError } = require_errors();
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource2 {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context8) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert3(this.callback);
        this.abort = abort;
        this.context = context8;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context: context8 } = this;
        removeSignal(this);
        this.callback = null;
        let headers = rawHeaders;
        if (headers != null) {
          headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        }
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context: context8
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function connect(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve9, reject) => {
          connect.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve9(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        const connectOptions = { ...opts, method: "CONNECT" };
        this.dispatch(connectOptions, connectHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts?.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module.exports = connect;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/api/index.js"(exports, module) {
    module.exports.request = require_api_request();
    module.exports.stream = require_api_stream();
    module.exports.pipeline = require_api_pipeline();
    module.exports.upgrade = require_api_upgrade();
    module.exports.connect = require_api_connect();
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/mock-errors.js"(exports, module) {
    var { UndiciError } = require_errors();
    var MockNotMatchedError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "MockNotMatchedError";
        this.message = message || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module.exports = {
      MockNotMatchedError
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/mock-symbols.js"(exports, module) {
    module.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOriginalDispatch: Symbol("original dispatch"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected"),
      kIgnoreTrailingSlash: Symbol("ignore trailing slash"),
      kMockAgentMockCallHistoryInstance: Symbol("mock agent mock call history name"),
      kMockAgentRegisterCallHistory: Symbol("mock agent register mock call history"),
      kMockAgentAddCallHistoryLog: Symbol("mock agent add call history log"),
      kMockAgentIsCallHistoryEnabled: Symbol("mock agent is call history enabled"),
      kMockCallHistoryAddLog: Symbol("mock call history add log")
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/mock-utils.js"(exports, module) {
    var { MockNotMatchedError } = require_mock_errors();
    var {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect
    } = require_mock_symbols();
    var { serializePathWithQuery } = require_util();
    var { STATUS_CODES } = __require("http");
    var {
      types: {
        isPromise
      }
    } = __require("util");
    var { InvalidArgumentError } = require_errors();
    function matchValue(match18, value) {
      if (typeof match18 === "string") {
        return match18 === value;
      }
      if (match18 instanceof RegExp) {
        return match18.test(value);
      }
      if (typeof match18 === "function") {
        return match18(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i + 1];
          }
        }
        return void 0;
      } else if (typeof headers.get === "function") {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(headers) {
      const clone4 = headers.slice();
      const entries2 = [];
      for (let index = 0; index < clone4.length; index += 2) {
        entries2.push([clone4[index], clone4[index + 1]]);
      }
      return Object.fromEntries(entries2);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === "function") {
        if (Array.isArray(headers)) {
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === "undefined") {
        return true;
      }
      if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        const headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue, headerValue)) {
          return false;
        }
      }
      return true;
    }
    function safeUrl(path3) {
      if (typeof path3 !== "string") {
        return path3;
      }
      const pathSegments = path3.split("?", 3);
      if (pathSegments.length !== 2) {
        return path3;
      }
      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join("?");
    }
    function matchKey(mockDispatch2, { path: path3, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path3);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (data instanceof Uint8Array) {
        return data;
      } else if (data instanceof ArrayBuffer) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else if (data) {
        return data.toString();
      } else {
        return "";
      }
    }
    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? serializePathWithQuery(key.path, key.query) : key.path;
      const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
      const resolvedPathWithoutTrailingSlash = removeTrailingSlash(resolvedPath);
      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path3, ignoreTrailingSlash }) => {
        return ignoreTrailingSlash ? matchValue(removeTrailingSlash(safeUrl(path3)), resolvedPathWithoutTrailingSlash) : matchValue(safeUrl(path3), resolvedPath);
      });
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        const headers = typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers;
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`);
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data, opts) {
      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false, ...opts };
      const replyData = typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function removeTrailingSlash(path3) {
      while (path3.endsWith("/")) {
        path3 = path3.slice(0, -1);
      }
      if (path3.length === 0) {
        path3 = "/";
      }
      return path3;
    }
    function buildKey(opts) {
      const { path: path3, method, body, headers, query } = opts;
      return {
        path: path3,
        method,
        body,
        headers,
        query
      };
    }
    function generateKeyValues(data) {
      const keys5 = Object.keys(data);
      const result = [];
      for (let i = 0; i < keys5.length; ++i) {
        const key = keys5[i];
        const value = data[key];
        const name = Buffer.from(`${key}`);
        if (Array.isArray(value)) {
          for (let j = 0; j < value.length; ++j) {
            result.push(name, Buffer.from(`${value[j]}`));
          }
        } else {
          result.push(name, Buffer.from(`${value}`));
        }
      }
      return result;
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++;
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
      }
      const { data: { statusCode, data, headers, trailers, error: error4 }, delay: delay4, persist } = mockDispatch2;
      const { timesInvoked, times: times2 } = mockDispatch2;
      mockDispatch2.consumed = !persist && timesInvoked >= times2;
      mockDispatch2.pending = timesInvoked < times2;
      if (error4 !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error4);
        return true;
      }
      if (typeof delay4 === "number" && delay4 > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay4);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches, _data = data) {
        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
        const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
        if (isPromise(body)) {
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }
        const responseData = getResponseData(body);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        handler.onConnect?.((err) => handler.onError(err), null);
        handler.onHeaders?.(statusCode, responseHeaders, resume2, getStatusText(statusCode));
        handler.onData?.(Buffer.from(responseData));
        handler.onComplete?.(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume2() {
      }
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error4) {
            if (error4 instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(`${error4.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(`${error4.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw error4;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url3 = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url3.host))) {
        return true;
      }
      return false;
    }
    function buildAndValidateMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        if ("enableCallHistory" in mockOptions && typeof mockOptions.enableCallHistory !== "boolean") {
          throw new InvalidArgumentError("options.enableCallHistory must to be a boolean");
        }
        return mockOptions;
      }
    }
    module.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildAndValidateMockOptions,
      getHeaderByName,
      buildHeadersFromArray
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/mock-interceptor.js"(exports, module) {
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch,
      kIgnoreTrailingSlash
    } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors();
    var { serializePathWithQuery } = require_util();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      /**
       * Delay a reply by a set amount in ms.
       */
      delay(waitInMs) {
        if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      /**
       * For a defined reply, never mark as consumed.
       */
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      /**
       * Allow one to define a reply for a set amount of matching requests.
       */
      times(repeatTimes) {
        if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        if (typeof opts.path === "string") {
          if (opts.query) {
            opts.path = serializePathWithQuery(opts.path, opts.query);
          } else {
            const parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === "string") {
          opts.method = opts.method.toUpperCase();
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData({ statusCode, data, responseOptions }) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(replyParameters) {
        if (typeof replyParameters.statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof replyParameters.responseOptions !== "object" || replyParameters.responseOptions === null) {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }
      /**
       * Mock an undici request with a defined reply.
       */
      reply(replyOptionsCallbackOrStatusCode) {
        if (typeof replyOptionsCallbackOrStatusCode === "function") {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyOptionsCallbackOrStatusCode(opts);
            if (typeof resolvedData !== "object" || resolvedData === null) {
              throw new InvalidArgumentError("reply options callback must return an object");
            }
            const replyParameters2 = { data: "", responseOptions: {}, ...resolvedData };
            this.validateReplyParameters(replyParameters2);
            return {
              ...this.createMockScopeDispatchData(replyParameters2)
            };
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] });
          return new MockScope(newMockDispatch2);
        }
        const replyParameters = {
          statusCode: replyOptionsCallbackOrStatusCode,
          data: arguments[1] === void 0 ? "" : arguments[1],
          responseOptions: arguments[2] === void 0 ? {} : arguments[2]
        };
        this.validateReplyParameters(replyParameters);
        const dispatchData = this.createMockScopeDispatchData(replyParameters);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] });
        return new MockScope(newMockDispatch);
      }
      /**
       * Mock an undici request with a defined error.
       */
      replyWithError(error4) {
        if (typeof error4 === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error: error4 }, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] });
        return new MockScope(newMockDispatch);
      }
      /**
       * Set default reply headers on the interceptor for subsequent replies
       */
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      /**
       * Set default reply trailers on the interceptor for subsequent replies
       */
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      /**
       * Set reply content length header for replies on the interceptor
       */
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module.exports.MockInterceptor = MockInterceptor;
    module.exports.MockScope = MockScope;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/mock-client.js"(exports, module) {
    var { promisify: promisify2 } = __require("util");
    var Client = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected,
      kIgnoreTrailingSlash
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockClient = class extends Client {
      constructor(origin, opts) {
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        super(origin, opts);
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(
          opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts },
          this[kDispatches]
        );
      }
      async [kClose]() {
        await promisify2(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module.exports = MockClient;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/mock-call-history.js
var require_mock_call_history = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/mock-call-history.js"(exports, module) {
    var { kMockCallHistoryAddLog } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors();
    function handleFilterCallsWithOptions(criteria, options, handler, store) {
      switch (options.operator) {
        case "OR":
          store.push(...handler(criteria));
          return store;
        case "AND":
          return handler.call({ logs: store }, criteria);
        default:
          throw new InvalidArgumentError("options.operator must to be a case insensitive string equal to 'OR' or 'AND'");
      }
    }
    function buildAndValidateFilterCallsOptions(options = {}) {
      const finalOptions = {};
      if ("operator" in options) {
        if (typeof options.operator !== "string" || options.operator.toUpperCase() !== "OR" && options.operator.toUpperCase() !== "AND") {
          throw new InvalidArgumentError("options.operator must to be a case insensitive string equal to 'OR' or 'AND'");
        }
        return {
          ...finalOptions,
          operator: options.operator.toUpperCase()
        };
      }
      return finalOptions;
    }
    function makeFilterCalls(parameterName) {
      return (parameterValue) => {
        if (typeof parameterValue === "string" || parameterValue == null) {
          return this.logs.filter((log5) => {
            return log5[parameterName] === parameterValue;
          });
        }
        if (parameterValue instanceof RegExp) {
          return this.logs.filter((log5) => {
            return parameterValue.test(log5[parameterName]);
          });
        }
        throw new InvalidArgumentError(`${parameterName} parameter should be one of string, regexp, undefined or null`);
      };
    }
    function computeUrlWithMaybeSearchParameters(requestInit) {
      try {
        const url3 = new URL(requestInit.path, requestInit.origin);
        if (url3.search.length !== 0) {
          return url3;
        }
        url3.search = new URLSearchParams(requestInit.query).toString();
        return url3;
      } catch (error4) {
        throw new InvalidArgumentError("An error occurred when computing MockCallHistoryLog.url", { cause: error4 });
      }
    }
    var MockCallHistoryLog = class {
      constructor(requestInit = {}) {
        this.body = requestInit.body;
        this.headers = requestInit.headers;
        this.method = requestInit.method;
        const url3 = computeUrlWithMaybeSearchParameters(requestInit);
        this.fullUrl = url3.toString();
        this.origin = url3.origin;
        this.path = url3.pathname;
        this.searchParams = Object.fromEntries(url3.searchParams);
        this.protocol = url3.protocol;
        this.host = url3.host;
        this.port = url3.port;
        this.hash = url3.hash;
      }
      toMap() {
        return /* @__PURE__ */ new Map(
          [
            ["protocol", this.protocol],
            ["host", this.host],
            ["port", this.port],
            ["origin", this.origin],
            ["path", this.path],
            ["hash", this.hash],
            ["searchParams", this.searchParams],
            ["fullUrl", this.fullUrl],
            ["method", this.method],
            ["body", this.body],
            ["headers", this.headers]
          ]
        );
      }
      toString() {
        const options = { betweenKeyValueSeparator: "->", betweenPairSeparator: "|" };
        let result = "";
        this.toMap().forEach((value, key) => {
          if (typeof value === "string" || value === void 0 || value === null) {
            result = `${result}${key}${options.betweenKeyValueSeparator}${value}${options.betweenPairSeparator}`;
          }
          if (typeof value === "object" && value !== null || Array.isArray(value)) {
            result = `${result}${key}${options.betweenKeyValueSeparator}${JSON.stringify(value)}${options.betweenPairSeparator}`;
          }
        });
        return result.slice(0, -1);
      }
    };
    var MockCallHistory = class {
      logs = [];
      calls() {
        return this.logs;
      }
      firstCall() {
        return this.logs.at(0);
      }
      lastCall() {
        return this.logs.at(-1);
      }
      nthCall(number5) {
        if (typeof number5 !== "number") {
          throw new InvalidArgumentError("nthCall must be called with a number");
        }
        if (!Number.isInteger(number5)) {
          throw new InvalidArgumentError("nthCall must be called with an integer");
        }
        if (Math.sign(number5) !== 1) {
          throw new InvalidArgumentError("nthCall must be called with a positive value. use firstCall or lastCall instead");
        }
        return this.logs.at(number5 - 1);
      }
      filterCalls(criteria, options) {
        if (this.logs.length === 0) {
          return this.logs;
        }
        if (typeof criteria === "function") {
          return this.logs.filter(criteria);
        }
        if (criteria instanceof RegExp) {
          return this.logs.filter((log5) => {
            return criteria.test(log5.toString());
          });
        }
        if (typeof criteria === "object" && criteria !== null) {
          if (Object.keys(criteria).length === 0) {
            return this.logs;
          }
          const finalOptions = { operator: "OR", ...buildAndValidateFilterCallsOptions(options) };
          let maybeDuplicatedLogsFiltered = [];
          if ("protocol" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.protocol, finalOptions, this.filterCallsByProtocol, maybeDuplicatedLogsFiltered);
          }
          if ("host" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.host, finalOptions, this.filterCallsByHost, maybeDuplicatedLogsFiltered);
          }
          if ("port" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.port, finalOptions, this.filterCallsByPort, maybeDuplicatedLogsFiltered);
          }
          if ("origin" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.origin, finalOptions, this.filterCallsByOrigin, maybeDuplicatedLogsFiltered);
          }
          if ("path" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.path, finalOptions, this.filterCallsByPath, maybeDuplicatedLogsFiltered);
          }
          if ("hash" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.hash, finalOptions, this.filterCallsByHash, maybeDuplicatedLogsFiltered);
          }
          if ("fullUrl" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.fullUrl, finalOptions, this.filterCallsByFullUrl, maybeDuplicatedLogsFiltered);
          }
          if ("method" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.method, finalOptions, this.filterCallsByMethod, maybeDuplicatedLogsFiltered);
          }
          const uniqLogsFiltered = [...new Set(maybeDuplicatedLogsFiltered)];
          return uniqLogsFiltered;
        }
        throw new InvalidArgumentError("criteria parameter should be one of function, regexp, or object");
      }
      filterCallsByProtocol = makeFilterCalls.call(this, "protocol");
      filterCallsByHost = makeFilterCalls.call(this, "host");
      filterCallsByPort = makeFilterCalls.call(this, "port");
      filterCallsByOrigin = makeFilterCalls.call(this, "origin");
      filterCallsByPath = makeFilterCalls.call(this, "path");
      filterCallsByHash = makeFilterCalls.call(this, "hash");
      filterCallsByFullUrl = makeFilterCalls.call(this, "fullUrl");
      filterCallsByMethod = makeFilterCalls.call(this, "method");
      clear() {
        this.logs = [];
      }
      [kMockCallHistoryAddLog](requestInit) {
        const log5 = new MockCallHistoryLog(requestInit);
        this.logs.push(log5);
        return log5;
      }
      *[Symbol.iterator]() {
        for (const log5 of this.calls()) {
          yield log5;
        }
      }
    };
    module.exports.MockCallHistory = MockCallHistory;
    module.exports.MockCallHistoryLog = MockCallHistoryLog;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/mock-pool.js"(exports, module) {
    var { promisify: promisify2 } = __require("util");
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected,
      kIgnoreTrailingSlash
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        super(origin, opts);
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(
          opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts },
          this[kDispatches]
        );
      }
      async [kClose]() {
        await promisify2(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module.exports = MockPool;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports, module) {
    var { Transform } = __require("stream");
    var { Console: Console2 } = __require("console");
    var PERSISTENT = process.versions.icu ? "\u2705" : "Y ";
    var NOT_PERSISTENT = process.versions.icu ? "\u274C" : "N ";
    module.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk5, _enc, cb) {
            cb(null, chunk5);
          }
        });
        this.logger = new Console2({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI
          }
        });
      }
      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({ method, path: path3, data: { statusCode }, persist, times: times2, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path3,
            "Status code": statusCode,
            Persistent: persist ? PERSISTENT : NOT_PERSISTENT,
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times2 - timesInvoked
          })
        );
        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/mock/mock-agent.js"(exports, module) {
    var { kClients } = require_symbols();
    var Agent = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory,
      kMockAgentRegisterCallHistory,
      kMockAgentIsCallHistoryEnabled,
      kMockAgentAddCallHistoryLog,
      kMockAgentMockCallHistoryInstance,
      kMockCallHistoryAddLog
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, buildAndValidateMockOptions } = require_mock_utils();
    var { InvalidArgumentError, UndiciError } = require_errors();
    var Dispatcher = require_dispatcher();
    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
    var { MockCallHistory } = require_mock_call_history();
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        const mockOptions = buildAndValidateMockOptions(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        this[kMockAgentIsCallHistoryEnabled] = mockOptions?.enableCallHistory ?? false;
        if (opts?.agent && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        const agent = opts?.agent ? opts.agent : new Agent(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = mockOptions;
        if (this[kMockAgentIsCallHistoryEnabled]) {
          this[kMockAgentRegisterCallHistory]();
        }
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        this[kMockAgentAddCallHistoryLog](opts);
        return this[kAgent].dispatch(opts, handler);
      }
      async close() {
        this.clearCallHistory();
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      enableCallHistory() {
        this[kMockAgentIsCallHistoryEnabled] = true;
        return this;
      }
      disableCallHistory() {
        this[kMockAgentIsCallHistoryEnabled] = false;
        return this;
      }
      getCallHistory() {
        return this[kMockAgentMockCallHistoryInstance];
      }
      clearCallHistory() {
        if (this[kMockAgentMockCallHistoryInstance] !== void 0) {
          this[kMockAgentMockCallHistoryInstance].clear();
        }
      }
      // This is required to bypass issues caused by using global symbols - see:
      // https://github.com/nodejs/undici/issues/1447
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentRegisterCallHistory]() {
        if (this[kMockAgentMockCallHistoryInstance] === void 0) {
          this[kMockAgentMockCallHistoryInstance] = new MockCallHistory();
        }
      }
      [kMockAgentAddCallHistoryLog](opts) {
        if (this[kMockAgentIsCallHistoryEnabled]) {
          this[kMockAgentRegisterCallHistory]();
          this[kMockAgentMockCallHistoryInstance][kMockCallHistoryAddLog](opts);
        }
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, dispatcher);
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const client = this[kClients].get(origin);
        if (client) {
          return client;
        }
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, nonExplicitDispatcher] of Array.from(this[kClients])) {
          if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        const mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope5]) => scope5[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending: pending3 }) => pending3);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        const pending3 = this.pendingInterceptors();
        if (pending3.length === 0) {
          return;
        }
        throw new UndiciError(
          pending3.length === 1 ? `1 interceptor is pending:

${pendingInterceptorsFormatter.format(pending3)}`.trim() : `${pending3.length} interceptors are pending:

${pendingInterceptorsFormatter.format(pending3)}`.trim()
        );
      }
    };
    module.exports = MockAgent;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/global.js
var require_global2 = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/global.js"(exports, module) {
    var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
    var { InvalidArgumentError } = require_errors();
    var Agent = require_agent();
    if (getGlobalDispatcher() === void 0) {
      setGlobalDispatcher(new Agent());
    }
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/handler/decorator-handler.js
var require_decorator_handler = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/handler/decorator-handler.js"(exports, module) {
    var assert3 = __require("assert");
    var WrapHandler = require_wrap_handler();
    module.exports = class DecoratorHandler {
      #handler;
      #onCompleteCalled = false;
      #onErrorCalled = false;
      #onResponseStartCalled = false;
      constructor(handler) {
        if (typeof handler !== "object" || handler === null) {
          throw new TypeError("handler must be an object");
        }
        this.#handler = WrapHandler.wrap(handler);
      }
      onRequestStart(...args2) {
        this.#handler.onRequestStart?.(...args2);
      }
      onRequestUpgrade(...args2) {
        assert3(!this.#onCompleteCalled);
        assert3(!this.#onErrorCalled);
        return this.#handler.onRequestUpgrade?.(...args2);
      }
      onResponseStart(...args2) {
        assert3(!this.#onCompleteCalled);
        assert3(!this.#onErrorCalled);
        assert3(!this.#onResponseStartCalled);
        this.#onResponseStartCalled = true;
        return this.#handler.onResponseStart?.(...args2);
      }
      onResponseData(...args2) {
        assert3(!this.#onCompleteCalled);
        assert3(!this.#onErrorCalled);
        return this.#handler.onResponseData?.(...args2);
      }
      onResponseEnd(...args2) {
        assert3(!this.#onCompleteCalled);
        assert3(!this.#onErrorCalled);
        this.#onCompleteCalled = true;
        return this.#handler.onResponseEnd?.(...args2);
      }
      onResponseError(...args2) {
        this.#onErrorCalled = true;
        return this.#handler.onResponseError?.(...args2);
      }
      /**
       * @deprecated
       */
      onBodySent() {
      }
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/handler/redirect-handler.js
var require_redirect_handler = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/handler/redirect-handler.js"(exports, module) {
    var util = require_util();
    var { kBodyUsed } = require_symbols();
    var assert3 = __require("assert");
    var { InvalidArgumentError } = require_errors();
    var EE = __require("events");
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = Symbol("body");
    var noop2 = () => {
    };
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert3(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class _RedirectHandler {
      static buildDispatch(dispatcher, maxRedirections) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        const dispatch = dispatcher.dispatch.bind(dispatcher);
        return (opts, originalHandler) => dispatch(opts, new _RedirectHandler(dispatch, maxRedirections, opts, originalHandler));
      }
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        this.dispatch = dispatch;
        this.location = null;
        this.opts = { ...opts, maxRedirections: 0 };
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        if (util.isStream(this.opts.body)) {
          if (util.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function() {
              assert3(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function() {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body) && !util.isFormDataLike(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onRequestStart(controller, context8) {
        this.handler.onRequestStart?.(controller, { ...context8, history: this.history });
      }
      onRequestUpgrade(controller, statusCode, headers, socket) {
        this.handler.onRequestUpgrade?.(controller, statusCode, headers, socket);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
          throw new Error("max redirects");
        }
        if ((statusCode === 301 || statusCode === 302) && this.opts.method === "POST") {
          this.opts.method = "GET";
          if (util.isStream(this.opts.body)) {
            util.destroy(this.opts.body.on("error", noop2));
          }
          this.opts.body = null;
        }
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          if (util.isStream(this.opts.body)) {
            util.destroy(this.opts.body.on("error", noop2));
          }
          this.opts.body = null;
        }
        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) || redirectableStatusCodes.indexOf(statusCode) === -1 ? null : headers.location;
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage);
          return;
        }
        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
        const path3 = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path3;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        this.opts.query = null;
      }
      onResponseData(controller, chunk5) {
        if (this.location) ; else {
          this.handler.onResponseData?.(controller, chunk5);
        }
      }
      onResponseEnd(controller, trailers) {
        if (this.location) {
          this.dispatch(this.opts, this);
        } else {
          this.handler.onResponseEnd(controller, trailers);
        }
      }
      onResponseError(controller, error4) {
        this.handler.onResponseError?.(controller, error4);
      }
    };
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      if (header.length === 4) {
        return util.headerNameToString(header) === "host";
      }
      if (removeContent && util.headerNameToString(header).startsWith("content-")) {
        return true;
      }
      if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
        const name = util.headerNameToString(header);
        return name === "authorization" || name === "cookie" || name === "proxy-authorization";
      }
      return false;
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
            ret.push(headers[i], headers[i + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        const entries2 = typeof headers[Symbol.iterator] === "function" ? headers : Object.entries(headers);
        for (const [key, value] of entries2) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, value);
          }
        }
      } else {
        assert3(headers == null, "headers must be an object or an array");
      }
      return ret;
    }
    module.exports = RedirectHandler;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/interceptor/redirect.js
var require_redirect = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/interceptor/redirect.js"(exports, module) {
    var RedirectHandler = require_redirect_handler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections } = {}) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections, ...rest } = opts;
          if (maxRedirections == null || maxRedirections === 0) {
            return dispatch(opts, handler);
          }
          const dispatchOpts = { ...rest, maxRedirections: 0 };
          const redirectHandler = new RedirectHandler(dispatch, maxRedirections, dispatchOpts, handler);
          return dispatch(dispatchOpts, redirectHandler);
        };
      };
    }
    module.exports = createRedirectInterceptor;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/interceptor/response-error.js
var require_response_error = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/interceptor/response-error.js"(exports, module) {
    var DecoratorHandler = require_decorator_handler();
    var { ResponseError } = require_errors();
    var ResponseErrorHandler = class extends DecoratorHandler {
      #statusCode;
      #contentType;
      #decoder;
      #headers;
      #body;
      constructor(_opts, { handler }) {
        super(handler);
      }
      #checkContentType(contentType) {
        return (this.#contentType ?? "").indexOf(contentType) === 0;
      }
      onRequestStart(controller, context8) {
        this.#statusCode = 0;
        this.#contentType = null;
        this.#decoder = null;
        this.#headers = null;
        this.#body = "";
        return super.onRequestStart(controller, context8);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        this.#statusCode = statusCode;
        this.#headers = headers;
        this.#contentType = headers["content-type"];
        if (this.#statusCode < 400) {
          return super.onResponseStart(controller, statusCode, headers, statusMessage);
        }
        if (this.#checkContentType("application/json") || this.#checkContentType("text/plain")) {
          this.#decoder = new TextDecoder("utf-8");
        }
      }
      onResponseData(controller, chunk5) {
        if (this.#statusCode < 400) {
          return super.onResponseData(controller, chunk5);
        }
        this.#body += this.#decoder?.decode(chunk5, { stream: true }) ?? "";
      }
      onResponseEnd(controller, trailers) {
        if (this.#statusCode >= 400) {
          this.#body += this.#decoder?.decode(void 0, { stream: false }) ?? "";
          if (this.#checkContentType("application/json")) {
            try {
              this.#body = JSON.parse(this.#body);
            } catch {
            }
          }
          let err;
          const stackTraceLimit = Error.stackTraceLimit;
          Error.stackTraceLimit = 0;
          try {
            err = new ResponseError("Response Error", this.#statusCode, {
              body: this.#body,
              headers: this.#headers
            });
          } finally {
            Error.stackTraceLimit = stackTraceLimit;
          }
          super.onResponseError(controller, err);
        } else {
          super.onResponseEnd(controller, trailers);
        }
      }
      onResponseError(controller, err) {
        super.onResponseError(controller, err);
      }
    };
    module.exports = () => {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          return dispatch(opts, new ResponseErrorHandler(opts, { handler }));
        };
      };
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/interceptor/retry.js
var require_retry = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/interceptor/retry.js"(exports, module) {
    var RetryHandler = require_retry_handler();
    module.exports = (globalOpts) => {
      return (dispatch) => {
        return function retryInterceptor(opts, handler) {
          return dispatch(
            opts,
            new RetryHandler(
              { ...opts, retryOptions: { ...globalOpts, ...opts.retryOptions } },
              {
                handler,
                dispatch
              }
            )
          );
        };
      };
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/interceptor/dump.js
var require_dump = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/interceptor/dump.js"(exports, module) {
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var DecoratorHandler = require_decorator_handler();
    var DumpHandler = class extends DecoratorHandler {
      #maxSize = 1024 * 1024;
      #dumped = false;
      #size = 0;
      #controller = null;
      aborted = false;
      reason = false;
      constructor({ maxSize, signal }, handler) {
        if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {
          throw new InvalidArgumentError("maxSize must be a number greater than 0");
        }
        super(handler);
        this.#maxSize = maxSize ?? this.#maxSize;
      }
      #abort(reason) {
        this.aborted = true;
        this.reason = reason;
      }
      onRequestStart(controller, context8) {
        controller.abort = this.#abort.bind(this);
        this.#controller = controller;
        return super.onRequestStart(controller, context8);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        const contentLength = headers["content-length"];
        if (contentLength != null && contentLength > this.#maxSize) {
          throw new RequestAbortedError(
            `Response size (${contentLength}) larger than maxSize (${this.#maxSize})`
          );
        }
        if (this.aborted === true) {
          return true;
        }
        return super.onResponseStart(controller, statusCode, headers, statusMessage);
      }
      onResponseError(controller, err) {
        if (this.#dumped) {
          return;
        }
        err = this.#controller.reason ?? err;
        super.onResponseError(controller, err);
      }
      onResponseData(controller, chunk5) {
        this.#size = this.#size + chunk5.length;
        if (this.#size >= this.#maxSize) {
          this.#dumped = true;
          if (this.aborted === true) {
            super.onResponseError(controller, this.reason);
          } else {
            super.onResponseEnd(controller, {});
          }
        }
        return true;
      }
      onResponseEnd(controller, trailers) {
        if (this.#dumped) {
          return;
        }
        if (this.#controller.aborted === true) {
          super.onResponseError(controller, this.reason);
          return;
        }
        super.onResponseEnd(controller, trailers);
      }
    };
    function createDumpInterceptor({ maxSize: defaultMaxSize } = {
      maxSize: 1024 * 1024
    }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { dumpMaxSize = defaultMaxSize } = opts;
          const dumpHandler = new DumpHandler({ maxSize: dumpMaxSize, signal: opts.signal }, handler);
          return dispatch(opts, dumpHandler);
        };
      };
    }
    module.exports = createDumpInterceptor;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/interceptor/dns.js
var require_dns = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/interceptor/dns.js"(exports, module) {
    var { isIP } = __require("net");
    var { lookup } = __require("dns");
    var DecoratorHandler = require_decorator_handler();
    var { InvalidArgumentError, InformationalError } = require_errors();
    var maxInt = Math.pow(2, 31) - 1;
    var DNSInstance = class {
      #maxTTL = 0;
      #maxItems = 0;
      #records = /* @__PURE__ */ new Map();
      dualStack = true;
      affinity = null;
      lookup = null;
      pick = null;
      constructor(opts) {
        this.#maxTTL = opts.maxTTL;
        this.#maxItems = opts.maxItems;
        this.dualStack = opts.dualStack;
        this.affinity = opts.affinity;
        this.lookup = opts.lookup ?? this.#defaultLookup;
        this.pick = opts.pick ?? this.#defaultPick;
      }
      get full() {
        return this.#records.size === this.#maxItems;
      }
      runLookup(origin, opts, cb) {
        const ips = this.#records.get(origin.hostname);
        if (ips == null && this.full) {
          cb(null, origin);
          return;
        }
        const newOpts = {
          affinity: this.affinity,
          dualStack: this.dualStack,
          lookup: this.lookup,
          pick: this.pick,
          ...opts.dns,
          maxTTL: this.#maxTTL,
          maxItems: this.#maxItems
        };
        if (ips == null) {
          this.lookup(origin, newOpts, (err, addresses) => {
            if (err || addresses == null || addresses.length === 0) {
              cb(err ?? new InformationalError("No DNS entries found"));
              return;
            }
            this.setRecords(origin, addresses);
            const records = this.#records.get(origin.hostname);
            const ip = this.pick(
              origin,
              records,
              newOpts.affinity
            );
            let port;
            if (typeof ip.port === "number") {
              port = `:${ip.port}`;
            } else if (origin.port !== "") {
              port = `:${origin.port}`;
            } else {
              port = "";
            }
            cb(
              null,
              new URL(`${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`)
            );
          });
        } else {
          const ip = this.pick(
            origin,
            ips,
            newOpts.affinity
          );
          if (ip == null) {
            this.#records.delete(origin.hostname);
            this.runLookup(origin, opts, cb);
            return;
          }
          let port;
          if (typeof ip.port === "number") {
            port = `:${ip.port}`;
          } else if (origin.port !== "") {
            port = `:${origin.port}`;
          } else {
            port = "";
          }
          cb(
            null,
            new URL(`${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`)
          );
        }
      }
      #defaultLookup(origin, opts, cb) {
        lookup(
          origin.hostname,
          {
            all: true,
            family: this.dualStack === false ? this.affinity : 0,
            order: "ipv4first"
          },
          (err, addresses) => {
            if (err) {
              return cb(err);
            }
            const results = /* @__PURE__ */ new Map();
            for (const addr of addresses) {
              results.set(`${addr.address}:${addr.family}`, addr);
            }
            cb(null, results.values());
          }
        );
      }
      #defaultPick(origin, hostnameRecords, affinity) {
        let ip = null;
        const { records, offset } = hostnameRecords;
        let family;
        if (this.dualStack) {
          if (affinity == null) {
            if (offset == null || offset === maxInt) {
              hostnameRecords.offset = 0;
              affinity = 4;
            } else {
              hostnameRecords.offset++;
              affinity = (hostnameRecords.offset & 1) === 1 ? 6 : 4;
            }
          }
          if (records[affinity] != null && records[affinity].ips.length > 0) {
            family = records[affinity];
          } else {
            family = records[affinity === 4 ? 6 : 4];
          }
        } else {
          family = records[affinity];
        }
        if (family == null || family.ips.length === 0) {
          return ip;
        }
        if (family.offset == null || family.offset === maxInt) {
          family.offset = 0;
        } else {
          family.offset++;
        }
        const position = family.offset % family.ips.length;
        ip = family.ips[position] ?? null;
        if (ip == null) {
          return ip;
        }
        if (Date.now() - ip.timestamp > ip.ttl) {
          family.ips.splice(position, 1);
          return this.pick(origin, hostnameRecords, affinity);
        }
        return ip;
      }
      pickFamily(origin, ipFamily) {
        const records = this.#records.get(origin.hostname)?.records;
        if (!records) {
          return null;
        }
        const family = records[ipFamily];
        if (!family) {
          return null;
        }
        if (family.offset == null || family.offset === maxInt) {
          family.offset = 0;
        } else {
          family.offset++;
        }
        const position = family.offset % family.ips.length;
        const ip = family.ips[position] ?? null;
        if (ip == null) {
          return ip;
        }
        if (Date.now() - ip.timestamp > ip.ttl) {
          family.ips.splice(position, 1);
        }
        return ip;
      }
      setRecords(origin, addresses) {
        const timestamp = Date.now();
        const records = { records: { 4: null, 6: null } };
        for (const record of addresses) {
          record.timestamp = timestamp;
          if (typeof record.ttl === "number") {
            record.ttl = Math.min(record.ttl, this.#maxTTL);
          } else {
            record.ttl = this.#maxTTL;
          }
          const familyRecords = records.records[record.family] ?? { ips: [] };
          familyRecords.ips.push(record);
          records.records[record.family] = familyRecords;
        }
        this.#records.set(origin.hostname, records);
      }
      deleteRecords(origin) {
        this.#records.delete(origin.hostname);
      }
      getHandler(meta, opts) {
        return new DNSDispatchHandler(this, meta, opts);
      }
    };
    var DNSDispatchHandler = class extends DecoratorHandler {
      #state = null;
      #opts = null;
      #dispatch = null;
      #origin = null;
      #controller = null;
      #newOrigin = null;
      #firstTry = true;
      constructor(state, { origin, handler, dispatch, newOrigin }, opts) {
        super(handler);
        this.#origin = origin;
        this.#newOrigin = newOrigin;
        this.#opts = { ...opts };
        this.#state = state;
        this.#dispatch = dispatch;
      }
      onResponseError(controller, err) {
        switch (err.code) {
          case "ETIMEDOUT":
          case "ECONNREFUSED": {
            if (this.#state.dualStack) {
              if (!this.#firstTry) {
                super.onResponseError(controller, err);
                return;
              }
              this.#firstTry = false;
              const otherFamily = this.#newOrigin.hostname[0] === "[" ? 4 : 6;
              const ip = this.#state.pickFamily(this.#origin, otherFamily);
              if (ip == null) {
                super.onResponseError(controller, err);
                return;
              }
              let port;
              if (typeof ip.port === "number") {
                port = `:${ip.port}`;
              } else if (this.#origin.port !== "") {
                port = `:${this.#origin.port}`;
              } else {
                port = "";
              }
              const dispatchOpts = {
                ...this.#opts,
                origin: `${this.#origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`
              };
              this.#dispatch(dispatchOpts, this);
              return;
            }
            super.onResponseError(controller, err);
            break;
          }
          case "ENOTFOUND":
            this.#state.deleteRecords(this.#origin);
            super.onResponseError(controller, err);
            break;
          default:
            super.onResponseError(controller, err);
            break;
        }
      }
    };
    module.exports = (interceptorOpts) => {
      if (interceptorOpts?.maxTTL != null && (typeof interceptorOpts?.maxTTL !== "number" || interceptorOpts?.maxTTL < 0)) {
        throw new InvalidArgumentError("Invalid maxTTL. Must be a positive number");
      }
      if (interceptorOpts?.maxItems != null && (typeof interceptorOpts?.maxItems !== "number" || interceptorOpts?.maxItems < 1)) {
        throw new InvalidArgumentError(
          "Invalid maxItems. Must be a positive number and greater than zero"
        );
      }
      if (interceptorOpts?.affinity != null && interceptorOpts?.affinity !== 4 && interceptorOpts?.affinity !== 6) {
        throw new InvalidArgumentError("Invalid affinity. Must be either 4 or 6");
      }
      if (interceptorOpts?.dualStack != null && typeof interceptorOpts?.dualStack !== "boolean") {
        throw new InvalidArgumentError("Invalid dualStack. Must be a boolean");
      }
      if (interceptorOpts?.lookup != null && typeof interceptorOpts?.lookup !== "function") {
        throw new InvalidArgumentError("Invalid lookup. Must be a function");
      }
      if (interceptorOpts?.pick != null && typeof interceptorOpts?.pick !== "function") {
        throw new InvalidArgumentError("Invalid pick. Must be a function");
      }
      const dualStack = interceptorOpts?.dualStack ?? true;
      let affinity;
      if (dualStack) {
        affinity = interceptorOpts?.affinity ?? null;
      } else {
        affinity = interceptorOpts?.affinity ?? 4;
      }
      const opts = {
        maxTTL: interceptorOpts?.maxTTL ?? 1e4,
        // Expressed in ms
        lookup: interceptorOpts?.lookup ?? null,
        pick: interceptorOpts?.pick ?? null,
        dualStack,
        affinity,
        maxItems: interceptorOpts?.maxItems ?? Infinity
      };
      const instance = new DNSInstance(opts);
      return (dispatch) => {
        return function dnsInterceptor(origDispatchOpts, handler) {
          const origin = origDispatchOpts.origin.constructor === URL ? origDispatchOpts.origin : new URL(origDispatchOpts.origin);
          if (isIP(origin.hostname) !== 0) {
            return dispatch(origDispatchOpts, handler);
          }
          instance.runLookup(origin, origDispatchOpts, (err, newOrigin) => {
            if (err) {
              return handler.onResponseError(null, err);
            }
            const dispatchOpts = {
              ...origDispatchOpts,
              servername: origin.hostname,
              // For SNI on TLS
              origin: newOrigin.origin,
              headers: {
                host: origin.host,
                ...origDispatchOpts.headers
              }
            };
            dispatch(
              dispatchOpts,
              instance.getHandler(
                { origin, dispatch, handler, newOrigin },
                origDispatchOpts
              )
            );
          });
          return true;
        };
      };
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/util/cache.js
var require_cache = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/util/cache.js"(exports, module) {
    var {
      safeHTTPMethods
    } = require_util();
    function makeCacheKey(opts) {
      if (!opts.origin) {
        throw new Error("opts.origin is undefined");
      }
      const headers = normaliseHeaders(opts);
      return {
        origin: opts.origin.toString(),
        method: opts.method,
        path: opts.path,
        headers
      };
    }
    function normaliseHeaders(opts) {
      let headers;
      if (opts.headers == null) {
        headers = {};
      } else if (typeof opts.headers[Symbol.iterator] === "function") {
        headers = {};
        for (const x2 of opts.headers) {
          if (!Array.isArray(x2)) {
            throw new Error("opts.headers is not a valid header map");
          }
          const [key, val] = x2;
          if (typeof key !== "string" || typeof val !== "string") {
            throw new Error("opts.headers is not a valid header map");
          }
          headers[key.toLowerCase()] = val;
        }
      } else if (typeof opts.headers === "object") {
        headers = {};
        for (const key of Object.keys(opts.headers)) {
          headers[key.toLowerCase()] = opts.headers[key];
        }
      } else {
        throw new Error("opts.headers is not an object");
      }
      return headers;
    }
    function assertCacheKey(key) {
      if (typeof key !== "object") {
        throw new TypeError(`expected key to be object, got ${typeof key}`);
      }
      for (const property3 of ["origin", "method", "path"]) {
        if (typeof key[property3] !== "string") {
          throw new TypeError(`expected key.${property3} to be string, got ${typeof key[property3]}`);
        }
      }
      if (key.headers !== void 0 && typeof key.headers !== "object") {
        throw new TypeError(`expected headers to be object, got ${typeof key}`);
      }
    }
    function assertCacheValue(value) {
      if (typeof value !== "object") {
        throw new TypeError(`expected value to be object, got ${typeof value}`);
      }
      for (const property3 of ["statusCode", "cachedAt", "staleAt", "deleteAt"]) {
        if (typeof value[property3] !== "number") {
          throw new TypeError(`expected value.${property3} to be number, got ${typeof value[property3]}`);
        }
      }
      if (typeof value.statusMessage !== "string") {
        throw new TypeError(`expected value.statusMessage to be string, got ${typeof value.statusMessage}`);
      }
      if (value.headers != null && typeof value.headers !== "object") {
        throw new TypeError(`expected value.rawHeaders to be object, got ${typeof value.headers}`);
      }
      if (value.vary !== void 0 && typeof value.vary !== "object") {
        throw new TypeError(`expected value.vary to be object, got ${typeof value.vary}`);
      }
      if (value.etag !== void 0 && typeof value.etag !== "string") {
        throw new TypeError(`expected value.etag to be string, got ${typeof value.etag}`);
      }
    }
    function parseCacheControlHeader(header) {
      const output = {};
      let directives2;
      if (Array.isArray(header)) {
        directives2 = [];
        for (const directive3 of header) {
          directives2.push(...directive3.split(","));
        }
      } else {
        directives2 = header.split(",");
      }
      for (let i = 0; i < directives2.length; i++) {
        const directive3 = directives2[i].toLowerCase();
        const keyValueDelimiter = directive3.indexOf("=");
        let key;
        let value;
        if (keyValueDelimiter !== -1) {
          key = directive3.substring(0, keyValueDelimiter).trimStart();
          value = directive3.substring(keyValueDelimiter + 1);
        } else {
          key = directive3.trim();
        }
        switch (key) {
          case "min-fresh":
          case "max-stale":
          case "max-age":
          case "s-maxage":
          case "stale-while-revalidate":
          case "stale-if-error": {
            if (value === void 0 || value[0] === " ") {
              continue;
            }
            if (value.length >= 2 && value[0] === '"' && value[value.length - 1] === '"') {
              value = value.substring(1, value.length - 1);
            }
            const parsedValue = parseInt(value, 10);
            if (parsedValue !== parsedValue) {
              continue;
            }
            if (key === "max-age" && key in output && output[key] >= parsedValue) {
              continue;
            }
            output[key] = parsedValue;
            break;
          }
          case "private":
          case "no-cache": {
            if (value) {
              if (value[0] === '"') {
                const headers = [value.substring(1)];
                let foundEndingQuote = value[value.length - 1] === '"';
                if (!foundEndingQuote) {
                  for (let j = i + 1; j < directives2.length; j++) {
                    const nextPart = directives2[j];
                    const nextPartLength = nextPart.length;
                    headers.push(nextPart.trim());
                    if (nextPartLength !== 0 && nextPart[nextPartLength - 1] === '"') {
                      foundEndingQuote = true;
                      break;
                    }
                  }
                }
                if (foundEndingQuote) {
                  let lastHeader = headers[headers.length - 1];
                  if (lastHeader[lastHeader.length - 1] === '"') {
                    lastHeader = lastHeader.substring(0, lastHeader.length - 1);
                    headers[headers.length - 1] = lastHeader;
                  }
                  if (key in output) {
                    output[key] = output[key].concat(headers);
                  } else {
                    output[key] = headers;
                  }
                }
              } else {
                if (key in output) {
                  output[key] = output[key].concat(value);
                } else {
                  output[key] = [value];
                }
              }
              break;
            }
          }
          // eslint-disable-next-line no-fallthrough
          case "public":
          case "no-store":
          case "must-revalidate":
          case "proxy-revalidate":
          case "immutable":
          case "no-transform":
          case "must-understand":
          case "only-if-cached":
            if (value) {
              continue;
            }
            output[key] = true;
            break;
          default:
            continue;
        }
      }
      return output;
    }
    function parseVaryHeader(varyHeader, headers) {
      if (typeof varyHeader === "string" && varyHeader.includes("*")) {
        return headers;
      }
      const output = (
        /** @type {Record<string, string | string[] | null>} */
        {}
      );
      const varyingHeaders = typeof varyHeader === "string" ? varyHeader.split(",") : varyHeader;
      for (const header of varyingHeaders) {
        const trimmedHeader = header.trim().toLowerCase();
        output[trimmedHeader] = headers[trimmedHeader] ?? null;
      }
      return output;
    }
    function isEtagUsable(etag) {
      if (etag.length <= 2) {
        return false;
      }
      if (etag[0] === '"' && etag[etag.length - 1] === '"') {
        return !(etag[1] === '"' || etag.startsWith('"W/'));
      }
      if (etag.startsWith('W/"') && etag[etag.length - 1] === '"') {
        return etag.length !== 4;
      }
      return false;
    }
    function assertCacheStore(store, name = "CacheStore") {
      if (typeof store !== "object" || store === null) {
        throw new TypeError(`expected type of ${name} to be a CacheStore, got ${store === null ? "null" : typeof store}`);
      }
      for (const fn2 of ["get", "createWriteStream", "delete"]) {
        if (typeof store[fn2] !== "function") {
          throw new TypeError(`${name} needs to have a \`${fn2}()\` function`);
        }
      }
    }
    function assertCacheMethods(methods, name = "CacheMethods") {
      if (!Array.isArray(methods)) {
        throw new TypeError(`expected type of ${name} needs to be an array, got ${methods === null ? "null" : typeof methods}`);
      }
      if (methods.length === 0) {
        throw new TypeError(`${name} needs to have at least one method`);
      }
      for (const method of methods) {
        if (!safeHTTPMethods.includes(method)) {
          throw new TypeError(`element of ${name}-array needs to be one of following values: ${safeHTTPMethods.join(", ")}, got ${method}`);
        }
      }
    }
    module.exports = {
      makeCacheKey,
      normaliseHeaders,
      assertCacheKey,
      assertCacheValue,
      parseCacheControlHeader,
      parseVaryHeader,
      isEtagUsable,
      assertCacheMethods,
      assertCacheStore
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/util/date.js
var require_date = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/util/date.js"(exports, module) {
    var IMF_DAYS = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"];
    var IMF_SPACES = [4, 7, 11, 16, 25];
    var IMF_MONTHS = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
    var IMF_COLONS = [19, 22];
    var ASCTIME_SPACES = [3, 7, 10, 19];
    var RFC850_DAYS = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"];
    function parseHttpDate(date3, now) {
      date3 = date3.toLowerCase();
      switch (date3[3]) {
        case ",":
          return parseImfDate(date3);
        case " ":
          return parseAscTimeDate(date3);
        default:
          return parseRfc850Date(date3, now);
      }
    }
    function parseImfDate(date3) {
      if (date3.length !== 29) {
        return void 0;
      }
      if (!date3.endsWith("gmt")) {
        return void 0;
      }
      for (const spaceInx of IMF_SPACES) {
        if (date3[spaceInx] !== " ") {
          return void 0;
        }
      }
      for (const colonIdx of IMF_COLONS) {
        if (date3[colonIdx] !== ":") {
          return void 0;
        }
      }
      const dayName = date3.substring(0, 3);
      if (!IMF_DAYS.includes(dayName)) {
        return void 0;
      }
      const dayString = date3.substring(5, 7);
      const day = Number.parseInt(dayString);
      if (isNaN(day) || day < 10 && dayString[0] !== "0") {
        return void 0;
      }
      const month = date3.substring(8, 11);
      const monthIdx = IMF_MONTHS.indexOf(month);
      if (monthIdx === -1) {
        return void 0;
      }
      const year = Number.parseInt(date3.substring(12, 16));
      if (isNaN(year)) {
        return void 0;
      }
      const hourString = date3.substring(17, 19);
      const hour = Number.parseInt(hourString);
      if (isNaN(hour) || hour < 10 && hourString[0] !== "0") {
        return void 0;
      }
      const minuteString = date3.substring(20, 22);
      const minute = Number.parseInt(minuteString);
      if (isNaN(minute) || minute < 10 && minuteString[0] !== "0") {
        return void 0;
      }
      const secondString = date3.substring(23, 25);
      const second = Number.parseInt(secondString);
      if (isNaN(second) || second < 10 && secondString[0] !== "0") {
        return void 0;
      }
      return new Date(Date.UTC(year, monthIdx, day, hour, minute, second));
    }
    function parseAscTimeDate(date3) {
      if (date3.length !== 24) {
        return void 0;
      }
      for (const spaceIdx of ASCTIME_SPACES) {
        if (date3[spaceIdx] !== " ") {
          return void 0;
        }
      }
      const dayName = date3.substring(0, 3);
      if (!IMF_DAYS.includes(dayName)) {
        return void 0;
      }
      const month = date3.substring(4, 7);
      const monthIdx = IMF_MONTHS.indexOf(month);
      if (monthIdx === -1) {
        return void 0;
      }
      const dayString = date3.substring(8, 10);
      const day = Number.parseInt(dayString);
      if (isNaN(day) || day < 10 && dayString[0] !== " ") {
        return void 0;
      }
      const hourString = date3.substring(11, 13);
      const hour = Number.parseInt(hourString);
      if (isNaN(hour) || hour < 10 && hourString[0] !== "0") {
        return void 0;
      }
      const minuteString = date3.substring(14, 16);
      const minute = Number.parseInt(minuteString);
      if (isNaN(minute) || minute < 10 && minuteString[0] !== "0") {
        return void 0;
      }
      const secondString = date3.substring(17, 19);
      const second = Number.parseInt(secondString);
      if (isNaN(second) || second < 10 && secondString[0] !== "0") {
        return void 0;
      }
      const year = Number.parseInt(date3.substring(20, 24));
      if (isNaN(year)) {
        return void 0;
      }
      return new Date(Date.UTC(year, monthIdx, day, hour, minute, second));
    }
    function parseRfc850Date(date3, now = /* @__PURE__ */ new Date()) {
      if (!date3.endsWith("gmt")) {
        return void 0;
      }
      const commaIndex = date3.indexOf(",");
      if (commaIndex === -1) {
        return void 0;
      }
      if (date3.length - commaIndex - 1 !== 23) {
        return void 0;
      }
      const dayName = date3.substring(0, commaIndex);
      if (!RFC850_DAYS.includes(dayName)) {
        return void 0;
      }
      if (date3[commaIndex + 1] !== " " || date3[commaIndex + 4] !== "-" || date3[commaIndex + 8] !== "-" || date3[commaIndex + 11] !== " " || date3[commaIndex + 14] !== ":" || date3[commaIndex + 17] !== ":" || date3[commaIndex + 20] !== " ") {
        return void 0;
      }
      const dayString = date3.substring(commaIndex + 2, commaIndex + 4);
      const day = Number.parseInt(dayString);
      if (isNaN(day) || day < 10 && dayString[0] !== "0") {
        return void 0;
      }
      const month = date3.substring(commaIndex + 5, commaIndex + 8);
      const monthIdx = IMF_MONTHS.indexOf(month);
      if (monthIdx === -1) {
        return void 0;
      }
      let year = Number.parseInt(date3.substring(commaIndex + 9, commaIndex + 11));
      if (isNaN(year)) {
        return void 0;
      }
      const currentYear = now.getUTCFullYear();
      const currentDecade = currentYear % 100;
      const currentCentury = Math.floor(currentYear / 100);
      if (year > currentDecade && year - currentDecade >= 50) {
        year += (currentCentury - 1) * 100;
      } else {
        year += currentCentury * 100;
      }
      const hourString = date3.substring(commaIndex + 12, commaIndex + 14);
      const hour = Number.parseInt(hourString);
      if (isNaN(hour) || hour < 10 && hourString[0] !== "0") {
        return void 0;
      }
      const minuteString = date3.substring(commaIndex + 15, commaIndex + 17);
      const minute = Number.parseInt(minuteString);
      if (isNaN(minute) || minute < 10 && minuteString[0] !== "0") {
        return void 0;
      }
      const secondString = date3.substring(commaIndex + 18, commaIndex + 20);
      const second = Number.parseInt(secondString);
      if (isNaN(second) || second < 10 && secondString[0] !== "0") {
        return void 0;
      }
      return new Date(Date.UTC(year, monthIdx, day, hour, minute, second));
    }
    module.exports = {
      parseHttpDate
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/handler/cache-handler.js
var require_cache_handler = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/handler/cache-handler.js"(exports, module) {
    var util = require_util();
    var {
      parseCacheControlHeader,
      parseVaryHeader,
      isEtagUsable
    } = require_cache();
    var { parseHttpDate } = require_date();
    function noop2() {
    }
    var HEURISTICALLY_CACHEABLE_STATUS_CODES = [
      200,
      203,
      204,
      206,
      300,
      301,
      308,
      404,
      405,
      410,
      414,
      501
    ];
    var MAX_RESPONSE_AGE = 2147483647e3;
    var CacheHandler = class {
      /**
       * @type {import('../../types/cache-interceptor.d.ts').default.CacheKey}
       */
      #cacheKey;
      /**
       * @type {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions['type']}
       */
      #cacheType;
      /**
       * @type {number | undefined}
       */
      #cacheByDefault;
      /**
       * @type {import('../../types/cache-interceptor.d.ts').default.CacheStore}
       */
      #store;
      /**
       * @type {import('../../types/dispatcher.d.ts').default.DispatchHandler}
       */
      #handler;
      /**
       * @type {import('node:stream').Writable | undefined}
       */
      #writeStream;
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions} opts
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} cacheKey
       * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler
       */
      constructor({ store, type, cacheByDefault }, cacheKey, handler) {
        this.#store = store;
        this.#cacheType = type;
        this.#cacheByDefault = cacheByDefault;
        this.#cacheKey = cacheKey;
        this.#handler = handler;
      }
      onRequestStart(controller, context8) {
        this.#writeStream?.destroy();
        this.#writeStream = void 0;
        this.#handler.onRequestStart?.(controller, context8);
      }
      onRequestUpgrade(controller, statusCode, headers, socket) {
        this.#handler.onRequestUpgrade?.(controller, statusCode, headers, socket);
      }
      /**
       * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller
       * @param {number} statusCode
       * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders
       * @param {string} statusMessage
       */
      onResponseStart(controller, statusCode, resHeaders, statusMessage) {
        const downstreamOnHeaders = () => this.#handler.onResponseStart?.(
          controller,
          statusCode,
          resHeaders,
          statusMessage
        );
        if (!util.safeHTTPMethods.includes(this.#cacheKey.method) && statusCode >= 200 && statusCode <= 399) {
          try {
            this.#store.delete(this.#cacheKey)?.catch?.(noop2);
          } catch {
          }
          return downstreamOnHeaders();
        }
        const cacheControlHeader = resHeaders["cache-control"];
        const heuristicallyCacheable = resHeaders["last-modified"] && HEURISTICALLY_CACHEABLE_STATUS_CODES.includes(statusCode);
        if (!cacheControlHeader && !resHeaders["expires"] && !heuristicallyCacheable && !this.#cacheByDefault) {
          return downstreamOnHeaders();
        }
        const cacheControlDirectives = cacheControlHeader ? parseCacheControlHeader(cacheControlHeader) : {};
        if (!canCacheResponse(this.#cacheType, statusCode, resHeaders, cacheControlDirectives)) {
          return downstreamOnHeaders();
        }
        const now = Date.now();
        const resAge = resHeaders.age ? getAge(resHeaders.age) : void 0;
        if (resAge && resAge >= MAX_RESPONSE_AGE) {
          return downstreamOnHeaders();
        }
        const resDate = typeof resHeaders.date === "string" ? parseHttpDate(resHeaders.date) : void 0;
        const staleAt = determineStaleAt(this.#cacheType, now, resAge, resHeaders, resDate, cacheControlDirectives) ?? this.#cacheByDefault;
        if (staleAt === void 0 || resAge && resAge > staleAt) {
          return downstreamOnHeaders();
        }
        const baseTime = resDate ? resDate.getTime() : now;
        const absoluteStaleAt = staleAt + baseTime;
        if (now >= absoluteStaleAt) {
          return downstreamOnHeaders();
        }
        let varyDirectives;
        if (this.#cacheKey.headers && resHeaders.vary) {
          varyDirectives = parseVaryHeader(resHeaders.vary, this.#cacheKey.headers);
          if (!varyDirectives) {
            return downstreamOnHeaders();
          }
        }
        const deleteAt = determineDeleteAt(baseTime, cacheControlDirectives, absoluteStaleAt);
        const strippedHeaders = stripNecessaryHeaders(resHeaders, cacheControlDirectives);
        const value = {
          statusCode,
          statusMessage,
          headers: strippedHeaders,
          vary: varyDirectives,
          cacheControlDirectives,
          cachedAt: resAge ? now - resAge : now,
          staleAt: absoluteStaleAt,
          deleteAt
        };
        if (typeof resHeaders.etag === "string" && isEtagUsable(resHeaders.etag)) {
          value.etag = resHeaders.etag;
        }
        this.#writeStream = this.#store.createWriteStream(this.#cacheKey, value);
        if (!this.#writeStream) {
          return downstreamOnHeaders();
        }
        const handler = this;
        this.#writeStream.on("drain", () => controller.resume()).on("error", function() {
          handler.#writeStream = void 0;
          handler.#store.delete(handler.#cacheKey);
        }).on("close", function() {
          if (handler.#writeStream === this) {
            handler.#writeStream = void 0;
          }
          controller.resume();
        });
        return downstreamOnHeaders();
      }
      onResponseData(controller, chunk5) {
        if (this.#writeStream?.write(chunk5) === false) {
          controller.pause();
        }
        this.#handler.onResponseData?.(controller, chunk5);
      }
      onResponseEnd(controller, trailers) {
        this.#writeStream?.end();
        this.#handler.onResponseEnd?.(controller, trailers);
      }
      onResponseError(controller, err) {
        this.#writeStream?.destroy(err);
        this.#writeStream = void 0;
        this.#handler.onResponseError?.(controller, err);
      }
    };
    function canCacheResponse(cacheType, statusCode, resHeaders, cacheControlDirectives) {
      if (statusCode !== 200 && statusCode !== 307) {
        return false;
      }
      if (cacheControlDirectives["no-store"]) {
        return false;
      }
      if (cacheType === "shared" && cacheControlDirectives.private === true) {
        return false;
      }
      if (resHeaders.vary?.includes("*")) {
        return false;
      }
      if (resHeaders.authorization) {
        if (!cacheControlDirectives.public || typeof resHeaders.authorization !== "string") {
          return false;
        }
        if (Array.isArray(cacheControlDirectives["no-cache"]) && cacheControlDirectives["no-cache"].includes("authorization")) {
          return false;
        }
        if (Array.isArray(cacheControlDirectives["private"]) && cacheControlDirectives["private"].includes("authorization")) {
          return false;
        }
      }
      return true;
    }
    function getAge(ageHeader) {
      const age = parseInt(Array.isArray(ageHeader) ? ageHeader[0] : ageHeader);
      return isNaN(age) ? void 0 : age * 1e3;
    }
    function determineStaleAt(cacheType, now, age, resHeaders, responseDate, cacheControlDirectives) {
      if (cacheType === "shared") {
        const sMaxAge = cacheControlDirectives["s-maxage"];
        if (sMaxAge !== void 0) {
          return sMaxAge > 0 ? sMaxAge * 1e3 : void 0;
        }
      }
      const maxAge = cacheControlDirectives["max-age"];
      if (maxAge !== void 0) {
        return maxAge > 0 ? maxAge * 1e3 : void 0;
      }
      if (typeof resHeaders.expires === "string") {
        const expiresDate = parseHttpDate(resHeaders.expires);
        if (expiresDate) {
          if (now >= expiresDate.getTime()) {
            return void 0;
          }
          if (responseDate) {
            if (responseDate >= expiresDate) {
              return void 0;
            }
            if (age !== void 0 && age > expiresDate - responseDate) {
              return void 0;
            }
          }
          return expiresDate.getTime() - now;
        }
      }
      if (typeof resHeaders["last-modified"] === "string") {
        const lastModified = new Date(resHeaders["last-modified"]);
        if (isValidDate(lastModified)) {
          if (lastModified.getTime() >= now) {
            return void 0;
          }
          const responseAge = now - lastModified.getTime();
          return responseAge * 0.1;
        }
      }
      if (cacheControlDirectives.immutable) {
        return 31536e3;
      }
      return void 0;
    }
    function determineDeleteAt(now, cacheControlDirectives, staleAt) {
      let staleWhileRevalidate = -Infinity;
      let staleIfError = -Infinity;
      let immutable = -Infinity;
      if (cacheControlDirectives["stale-while-revalidate"]) {
        staleWhileRevalidate = staleAt + cacheControlDirectives["stale-while-revalidate"] * 1e3;
      }
      if (cacheControlDirectives["stale-if-error"]) {
        staleIfError = staleAt + cacheControlDirectives["stale-if-error"] * 1e3;
      }
      if (staleWhileRevalidate === -Infinity && staleIfError === -Infinity) {
        immutable = now + 31536e6;
      }
      return Math.max(staleAt, staleWhileRevalidate, staleIfError, immutable);
    }
    function stripNecessaryHeaders(resHeaders, cacheControlDirectives) {
      const headersToRemove = [
        "connection",
        "proxy-authenticate",
        "proxy-authentication-info",
        "proxy-authorization",
        "proxy-connection",
        "te",
        "transfer-encoding",
        "upgrade",
        // We'll add age back when serving it
        "age"
      ];
      if (resHeaders["connection"]) {
        if (Array.isArray(resHeaders["connection"])) {
          headersToRemove.push(...resHeaders["connection"].map((header) => header.trim()));
        } else {
          headersToRemove.push(...resHeaders["connection"].split(",").map((header) => header.trim()));
        }
      }
      if (Array.isArray(cacheControlDirectives["no-cache"])) {
        headersToRemove.push(...cacheControlDirectives["no-cache"]);
      }
      if (Array.isArray(cacheControlDirectives["private"])) {
        headersToRemove.push(...cacheControlDirectives["private"]);
      }
      let strippedHeaders;
      for (const headerName of headersToRemove) {
        if (resHeaders[headerName]) {
          strippedHeaders ??= { ...resHeaders };
          delete strippedHeaders[headerName];
        }
      }
      return strippedHeaders ?? resHeaders;
    }
    function isValidDate(date3) {
      return date3 instanceof Date && Number.isFinite(date3.valueOf());
    }
    module.exports = CacheHandler;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/cache/memory-cache-store.js
var require_memory_cache_store = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/cache/memory-cache-store.js"(exports, module) {
    var { Writable } = __require("stream");
    var { assertCacheKey, assertCacheValue } = require_cache();
    var MemoryCacheStore = class {
      #maxCount = Infinity;
      #maxSize = Infinity;
      #maxEntrySize = Infinity;
      #size = 0;
      #count = 0;
      #entries = /* @__PURE__ */ new Map();
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.MemoryCacheStoreOpts | undefined} [opts]
       */
      constructor(opts) {
        if (opts) {
          if (typeof opts !== "object") {
            throw new TypeError("MemoryCacheStore options must be an object");
          }
          if (opts.maxCount !== void 0) {
            if (typeof opts.maxCount !== "number" || !Number.isInteger(opts.maxCount) || opts.maxCount < 0) {
              throw new TypeError("MemoryCacheStore options.maxCount must be a non-negative integer");
            }
            this.#maxCount = opts.maxCount;
          }
          if (opts.maxSize !== void 0) {
            if (typeof opts.maxSize !== "number" || !Number.isInteger(opts.maxSize) || opts.maxSize < 0) {
              throw new TypeError("MemoryCacheStore options.maxSize must be a non-negative integer");
            }
            this.#maxSize = opts.maxSize;
          }
          if (opts.maxEntrySize !== void 0) {
            if (typeof opts.maxEntrySize !== "number" || !Number.isInteger(opts.maxEntrySize) || opts.maxEntrySize < 0) {
              throw new TypeError("MemoryCacheStore options.maxEntrySize must be a non-negative integer");
            }
            this.#maxEntrySize = opts.maxEntrySize;
          }
        }
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} req
       * @returns {import('../../types/cache-interceptor.d.ts').default.GetResult | undefined}
       */
      get(key) {
        assertCacheKey(key);
        const topLevelKey = `${key.origin}:${key.path}`;
        const now = Date.now();
        const entry = this.#entries.get(topLevelKey)?.find((entry2) => entry2.deleteAt > now && entry2.method === key.method && (entry2.vary == null || Object.keys(entry2.vary).every((headerName) => {
          if (entry2.vary[headerName] === null) {
            return key.headers[headerName] === void 0;
          }
          return entry2.vary[headerName] === key.headers[headerName];
        })));
        return entry == null ? void 0 : {
          statusMessage: entry.statusMessage,
          statusCode: entry.statusCode,
          headers: entry.headers,
          body: entry.body,
          vary: entry.vary ? entry.vary : void 0,
          etag: entry.etag,
          cacheControlDirectives: entry.cacheControlDirectives,
          cachedAt: entry.cachedAt,
          staleAt: entry.staleAt,
          deleteAt: entry.deleteAt
        };
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue} val
       * @returns {Writable | undefined}
       */
      createWriteStream(key, val) {
        assertCacheKey(key);
        assertCacheValue(val);
        const topLevelKey = `${key.origin}:${key.path}`;
        const store = this;
        const entry = { ...key, ...val, body: [], size: 0 };
        return new Writable({
          write(chunk5, encoding, callback) {
            if (typeof chunk5 === "string") {
              chunk5 = Buffer.from(chunk5, encoding);
            }
            entry.size += chunk5.byteLength;
            if (entry.size >= store.#maxEntrySize) {
              this.destroy();
            } else {
              entry.body.push(chunk5);
            }
            callback(null);
          },
          final(callback) {
            let entries2 = store.#entries.get(topLevelKey);
            if (!entries2) {
              entries2 = [];
              store.#entries.set(topLevelKey, entries2);
            }
            entries2.push(entry);
            store.#size += entry.size;
            store.#count += 1;
            if (store.#size > store.#maxSize || store.#count > store.#maxCount) {
              for (const [key2, entries3] of store.#entries) {
                for (const entry2 of entries3.splice(0, entries3.length / 2)) {
                  store.#size -= entry2.size;
                  store.#count -= 1;
                }
                if (entries3.length === 0) {
                  store.#entries.delete(key2);
                }
              }
            }
            callback(null);
          }
        });
      }
      /**
       * @param {CacheKey} key
       */
      delete(key) {
        if (typeof key !== "object") {
          throw new TypeError(`expected key to be object, got ${typeof key}`);
        }
        const topLevelKey = `${key.origin}:${key.path}`;
        for (const entry of this.#entries.get(topLevelKey) ?? []) {
          this.#size -= entry.size;
          this.#count -= 1;
        }
        this.#entries.delete(topLevelKey);
      }
    };
    module.exports = MemoryCacheStore;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/handler/cache-revalidation-handler.js
var require_cache_revalidation_handler = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/handler/cache-revalidation-handler.js"(exports, module) {
    var assert3 = __require("assert");
    var CacheRevalidationHandler = class {
      #successful = false;
      /**
       * @type {((boolean, any) => void) | null}
       */
      #callback;
      /**
       * @type {(import('../../types/dispatcher.d.ts').default.DispatchHandler)}
       */
      #handler;
      #context;
      /**
       * @type {boolean}
       */
      #allowErrorStatusCodes;
      /**
       * @param {(boolean) => void} callback Function to call if the cached value is valid
       * @param {import('../../types/dispatcher.d.ts').default.DispatchHandlers} handler
       * @param {boolean} allowErrorStatusCodes
       */
      constructor(callback, handler, allowErrorStatusCodes) {
        if (typeof callback !== "function") {
          throw new TypeError("callback must be a function");
        }
        this.#callback = callback;
        this.#handler = handler;
        this.#allowErrorStatusCodes = allowErrorStatusCodes;
      }
      onRequestStart(_2, context8) {
        this.#successful = false;
        this.#context = context8;
      }
      onRequestUpgrade(controller, statusCode, headers, socket) {
        this.#handler.onRequestUpgrade?.(controller, statusCode, headers, socket);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        assert3(this.#callback != null);
        this.#successful = statusCode === 304 || this.#allowErrorStatusCodes && statusCode >= 500 && statusCode <= 504;
        this.#callback(this.#successful, this.#context);
        this.#callback = null;
        if (this.#successful) {
          return true;
        }
        this.#handler.onRequestStart?.(controller, this.#context);
        this.#handler.onResponseStart?.(
          controller,
          statusCode,
          headers,
          statusMessage
        );
      }
      onResponseData(controller, chunk5) {
        if (this.#successful) {
          return;
        }
        return this.#handler.onResponseData?.(controller, chunk5);
      }
      onResponseEnd(controller, trailers) {
        if (this.#successful) {
          return;
        }
        this.#handler.onResponseEnd?.(controller, trailers);
      }
      onResponseError(controller, err) {
        if (this.#successful) {
          return;
        }
        if (this.#callback) {
          this.#callback(false);
          this.#callback = null;
        }
        if (typeof this.#handler.onResponseError === "function") {
          this.#handler.onResponseError(controller, err);
        } else {
          throw err;
        }
      }
    };
    module.exports = CacheRevalidationHandler;
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/interceptor/cache.js
var require_cache2 = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/interceptor/cache.js"(exports, module) {
    var assert3 = __require("assert");
    var { Readable: Readable2 } = __require("stream");
    var util = require_util();
    var CacheHandler = require_cache_handler();
    var MemoryCacheStore = require_memory_cache_store();
    var CacheRevalidationHandler = require_cache_revalidation_handler();
    var { assertCacheStore, assertCacheMethods, makeCacheKey, normaliseHeaders, parseCacheControlHeader } = require_cache();
    var { AbortError } = require_errors();
    function needsRevalidation(result, cacheControlDirectives) {
      if (cacheControlDirectives?.["no-cache"]) {
        return true;
      }
      const now = Date.now();
      if (now > result.staleAt) {
        if (cacheControlDirectives?.["max-stale"]) {
          const gracePeriod = result.staleAt + cacheControlDirectives["max-stale"] * 1e3;
          return now > gracePeriod;
        }
        return true;
      }
      if (cacheControlDirectives?.["min-fresh"]) {
        const timeLeftTillStale = result.staleAt - now;
        const threshold = cacheControlDirectives["min-fresh"] * 1e3;
        return timeLeftTillStale <= threshold;
      }
      return false;
    }
    function handleUncachedResponse(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl) {
      if (reqCacheControl?.["only-if-cached"]) {
        let aborted = false;
        try {
          if (typeof handler.onConnect === "function") {
            handler.onConnect(() => {
              aborted = true;
            });
            if (aborted) {
              return;
            }
          }
          if (typeof handler.onHeaders === "function") {
            handler.onHeaders(504, [], () => {
            }, "Gateway Timeout");
            if (aborted) {
              return;
            }
          }
          if (typeof handler.onComplete === "function") {
            handler.onComplete([]);
          }
        } catch (err) {
          if (typeof handler.onError === "function") {
            handler.onError(err);
          }
        }
        return true;
      }
      return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
    }
    function sendCachedValue(handler, opts, result, age, context8, isStale) {
      const stream = util.isStream(result.body) ? result.body : Readable2.from(result.body ?? []);
      assert3(!stream.destroyed, "stream should not be destroyed");
      assert3(!stream.readableDidRead, "stream should not be readableDidRead");
      const controller = {
        resume() {
          stream.resume();
        },
        pause() {
          stream.pause();
        },
        get paused() {
          return stream.isPaused();
        },
        get aborted() {
          return stream.destroyed;
        },
        get reason() {
          return stream.errored;
        },
        abort(reason) {
          stream.destroy(reason ?? new AbortError());
        }
      };
      stream.on("error", function(err) {
        if (!this.readableEnded) {
          if (typeof handler.onResponseError === "function") {
            handler.onResponseError(controller, err);
          } else {
            throw err;
          }
        }
      }).on("close", function() {
        if (!this.errored) {
          handler.onResponseEnd?.(controller, {});
        }
      });
      handler.onRequestStart?.(controller, context8);
      if (stream.destroyed) {
        return;
      }
      const headers = { ...result.headers, age: String(age) };
      if (isStale) {
        headers.warning = '110 - "response is stale"';
      }
      handler.onResponseStart?.(controller, result.statusCode, headers, result.statusMessage);
      if (opts.method === "HEAD") {
        stream.destroy();
      } else {
        stream.on("data", function(chunk5) {
          handler.onResponseData?.(controller, chunk5);
        });
      }
    }
    function handleResult(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl, result) {
      if (!result) {
        return handleUncachedResponse(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl);
      }
      const now = Date.now();
      if (now > result.deleteAt) {
        return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
      }
      const age = Math.round((now - result.cachedAt) / 1e3);
      if (reqCacheControl?.["max-age"] && age >= reqCacheControl["max-age"]) {
        return dispatch(opts, handler);
      }
      if (needsRevalidation(result, reqCacheControl)) {
        if (util.isStream(opts.body) && util.bodyLength(opts.body) !== 0) {
          return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
        }
        let withinStaleIfErrorThreshold = false;
        const staleIfErrorExpiry = result.cacheControlDirectives["stale-if-error"] ?? reqCacheControl?.["stale-if-error"];
        if (staleIfErrorExpiry) {
          withinStaleIfErrorThreshold = now < result.staleAt + staleIfErrorExpiry * 1e3;
        }
        let headers = {
          ...normaliseHeaders(opts),
          "if-modified-since": new Date(result.cachedAt).toUTCString()
        };
        if (result.etag) {
          headers["if-none-match"] = result.etag;
        }
        if (result.vary) {
          headers = {
            ...headers,
            ...result.vary
          };
        }
        return dispatch(
          {
            ...opts,
            headers
          },
          new CacheRevalidationHandler(
            (success, context8) => {
              if (success) {
                sendCachedValue(handler, opts, result, age, context8, true);
              } else if (util.isStream(result.body)) {
                result.body.on("error", () => {
                }).destroy();
              }
            },
            new CacheHandler(globalOpts, cacheKey, handler),
            withinStaleIfErrorThreshold
          )
        );
      }
      if (util.isStream(opts.body)) {
        opts.body.on("error", () => {
        }).destroy();
      }
      sendCachedValue(handler, opts, result, age, null, false);
    }
    module.exports = (opts = {}) => {
      const {
        store = new MemoryCacheStore(),
        methods = ["GET"],
        cacheByDefault = void 0,
        type = "shared"
      } = opts;
      if (typeof opts !== "object" || opts === null) {
        throw new TypeError(`expected type of opts to be an Object, got ${opts === null ? "null" : typeof opts}`);
      }
      assertCacheStore(store, "opts.store");
      assertCacheMethods(methods, "opts.methods");
      if (typeof cacheByDefault !== "undefined" && typeof cacheByDefault !== "number") {
        throw new TypeError(`exepcted opts.cacheByDefault to be number or undefined, got ${typeof cacheByDefault}`);
      }
      if (typeof type !== "undefined" && type !== "shared" && type !== "private") {
        throw new TypeError(`exepcted opts.type to be shared, private, or undefined, got ${typeof type}`);
      }
      const globalOpts = {
        store,
        methods,
        cacheByDefault,
        type
      };
      const safeMethodsToNotCache = util.safeHTTPMethods.filter((method) => methods.includes(method) === false);
      return (dispatch) => {
        return (opts2, handler) => {
          if (!opts2.origin || safeMethodsToNotCache.includes(opts2.method)) {
            return dispatch(opts2, handler);
          }
          const reqCacheControl = opts2.headers?.["cache-control"] ? parseCacheControlHeader(opts2.headers["cache-control"]) : void 0;
          if (reqCacheControl?.["no-store"]) {
            return dispatch(opts2, handler);
          }
          const cacheKey = makeCacheKey(opts2);
          const result = store.get(cacheKey);
          if (result && typeof result.then === "function") {
            result.then((result2) => {
              handleResult(
                dispatch,
                globalOpts,
                cacheKey,
                handler,
                opts2,
                reqCacheControl,
                result2
              );
            });
          } else {
            handleResult(
              dispatch,
              globalOpts,
              cacheKey,
              handler,
              opts2,
              reqCacheControl,
              result
            );
          }
          return true;
        };
      };
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/cache/sqlite-cache-store.js
var require_sqlite_cache_store = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/cache/sqlite-cache-store.js"(exports, module) {
    var { Writable } = __require("stream");
    var { assertCacheKey, assertCacheValue } = require_cache();
    var DatabaseSync;
    var VERSION = 3;
    var MAX_ENTRY_SIZE = 2 * 1e3 * 1e3 * 1e3;
    module.exports = class SqliteCacheStore {
      #maxEntrySize = MAX_ENTRY_SIZE;
      #maxCount = Infinity;
      /**
       * @type {import('node:sqlite').DatabaseSync}
       */
      #db;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #getValuesQuery;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #updateValueQuery;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #insertValueQuery;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #deleteExpiredValuesQuery;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #deleteByUrlQuery;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #countEntriesQuery;
      /**
       * @type {import('node:sqlite').StatementSync | null}
       */
      #deleteOldValuesQuery;
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.SqliteCacheStoreOpts | undefined} opts
       */
      constructor(opts) {
        if (opts) {
          if (typeof opts !== "object") {
            throw new TypeError("SqliteCacheStore options must be an object");
          }
          if (opts.maxEntrySize !== void 0) {
            if (typeof opts.maxEntrySize !== "number" || !Number.isInteger(opts.maxEntrySize) || opts.maxEntrySize < 0) {
              throw new TypeError("SqliteCacheStore options.maxEntrySize must be a non-negative integer");
            }
            if (opts.maxEntrySize > MAX_ENTRY_SIZE) {
              throw new TypeError("SqliteCacheStore options.maxEntrySize must be less than 2gb");
            }
            this.#maxEntrySize = opts.maxEntrySize;
          }
          if (opts.maxCount !== void 0) {
            if (typeof opts.maxCount !== "number" || !Number.isInteger(opts.maxCount) || opts.maxCount < 0) {
              throw new TypeError("SqliteCacheStore options.maxCount must be a non-negative integer");
            }
            this.#maxCount = opts.maxCount;
          }
        }
        if (!DatabaseSync) {
          DatabaseSync = __require("sqlite").DatabaseSync;
        }
        this.#db = new DatabaseSync(opts?.location ?? ":memory:");
        this.#db.exec(`
      CREATE TABLE IF NOT EXISTS cacheInterceptorV${VERSION} (
        -- Data specific to us
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        url TEXT NOT NULL,
        method TEXT NOT NULL,

        -- Data returned to the interceptor
        body BUF NULL,
        deleteAt INTEGER NOT NULL,
        statusCode INTEGER NOT NULL,
        statusMessage TEXT NOT NULL,
        headers TEXT NULL,
        cacheControlDirectives TEXT NULL,
        etag TEXT NULL,
        vary TEXT NULL,
        cachedAt INTEGER NOT NULL,
        staleAt INTEGER NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION}_url ON cacheInterceptorV${VERSION}(url);
      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION}_method ON cacheInterceptorV${VERSION}(method);
      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION}_deleteAt ON cacheInterceptorV${VERSION}(deleteAt);
    `);
        this.#getValuesQuery = this.#db.prepare(`
      SELECT
        id,
        body,
        deleteAt,
        statusCode,
        statusMessage,
        headers,
        etag,
        cacheControlDirectives,
        vary,
        cachedAt,
        staleAt
      FROM cacheInterceptorV${VERSION}
      WHERE
        url = ?
        AND method = ?
      ORDER BY
        deleteAt ASC
    `);
        this.#updateValueQuery = this.#db.prepare(`
      UPDATE cacheInterceptorV${VERSION} SET
        body = ?,
        deleteAt = ?,
        statusCode = ?,
        statusMessage = ?,
        headers = ?,
        etag = ?,
        cacheControlDirectives = ?,
        cachedAt = ?,
        staleAt = ?
      WHERE
        id = ?
    `);
        this.#insertValueQuery = this.#db.prepare(`
      INSERT INTO cacheInterceptorV${VERSION} (
        url,
        method,
        body,
        deleteAt,
        statusCode,
        statusMessage,
        headers,
        etag,
        cacheControlDirectives,
        vary,
        cachedAt,
        staleAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
        this.#deleteByUrlQuery = this.#db.prepare(
          `DELETE FROM cacheInterceptorV${VERSION} WHERE url = ?`
        );
        this.#countEntriesQuery = this.#db.prepare(
          `SELECT COUNT(*) AS total FROM cacheInterceptorV${VERSION}`
        );
        this.#deleteExpiredValuesQuery = this.#db.prepare(
          `DELETE FROM cacheInterceptorV${VERSION} WHERE deleteAt <= ?`
        );
        this.#deleteOldValuesQuery = this.#maxCount === Infinity ? null : this.#db.prepare(`
        DELETE FROM cacheInterceptorV${VERSION}
        WHERE id IN (
          SELECT
            id
          FROM cacheInterceptorV${VERSION}
          ORDER BY cachedAt DESC
          LIMIT ?
        )
      `);
      }
      close() {
        this.#db.close();
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @returns {(import('../../types/cache-interceptor.d.ts').default.GetResult & { body?: Buffer }) | undefined}
       */
      get(key) {
        assertCacheKey(key);
        const value = this.#findValue(key);
        return value ? {
          body: value.body ? Buffer.from(value.body.buffer, value.body.byteOffset, value.body.byteLength) : void 0,
          statusCode: value.statusCode,
          statusMessage: value.statusMessage,
          headers: value.headers ? JSON.parse(value.headers) : void 0,
          etag: value.etag ? value.etag : void 0,
          vary: value.vary ? JSON.parse(value.vary) : void 0,
          cacheControlDirectives: value.cacheControlDirectives ? JSON.parse(value.cacheControlDirectives) : void 0,
          cachedAt: value.cachedAt,
          staleAt: value.staleAt,
          deleteAt: value.deleteAt
        } : void 0;
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue & { body: null | Buffer | Array<Buffer>}} value
       */
      set(key, value) {
        assertCacheKey(key);
        const url3 = this.#makeValueUrl(key);
        const body = Array.isArray(value.body) ? Buffer.concat(value.body) : value.body;
        const size16 = body?.byteLength;
        if (size16 && size16 > this.#maxEntrySize) {
          return;
        }
        const existingValue = this.#findValue(key, true);
        if (existingValue) {
          this.#updateValueQuery.run(
            body,
            value.deleteAt,
            value.statusCode,
            value.statusMessage,
            value.headers ? JSON.stringify(value.headers) : null,
            value.etag ? value.etag : null,
            value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null,
            value.cachedAt,
            value.staleAt,
            existingValue.id
          );
        } else {
          this.#prune();
          this.#insertValueQuery.run(
            url3,
            key.method,
            body,
            value.deleteAt,
            value.statusCode,
            value.statusMessage,
            value.headers ? JSON.stringify(value.headers) : null,
            value.etag ? value.etag : null,
            value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null,
            value.vary ? JSON.stringify(value.vary) : null,
            value.cachedAt,
            value.staleAt
          );
        }
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue} value
       * @returns {Writable | undefined}
       */
      createWriteStream(key, value) {
        assertCacheKey(key);
        assertCacheValue(value);
        let size16 = 0;
        const body = [];
        const store = this;
        return new Writable({
          decodeStrings: true,
          write(chunk5, encoding, callback) {
            size16 += chunk5.byteLength;
            if (size16 < store.#maxEntrySize) {
              body.push(chunk5);
            } else {
              this.destroy();
            }
            callback();
          },
          final(callback) {
            store.set(key, { ...value, body });
            callback();
          }
        });
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       */
      delete(key) {
        if (typeof key !== "object") {
          throw new TypeError(`expected key to be object, got ${typeof key}`);
        }
        this.#deleteByUrlQuery.run(this.#makeValueUrl(key));
      }
      #prune() {
        if (this.size <= this.#maxCount) {
          return 0;
        }
        {
          const removed = this.#deleteExpiredValuesQuery.run(Date.now()).changes;
          if (removed) {
            return removed;
          }
        }
        {
          const removed = this.#deleteOldValuesQuery?.run(Math.max(Math.floor(this.#maxCount * 0.1), 1)).changes;
          if (removed) {
            return removed;
          }
        }
        return 0;
      }
      /**
       * Counts the number of rows in the cache
       * @returns {Number}
       */
      get size() {
        const { total } = this.#countEntriesQuery.get();
        return total;
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @returns {string}
       */
      #makeValueUrl(key) {
        return `${key.origin}/${key.path}`;
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @param {boolean} [canBeExpired=false]
       * @returns {SqliteStoreValue | undefined}
       */
      #findValue(key, canBeExpired = false) {
        const url3 = this.#makeValueUrl(key);
        const { headers, method } = key;
        const values3 = this.#getValuesQuery.all(url3, method);
        if (values3.length === 0) {
          return void 0;
        }
        const now = Date.now();
        for (const value of values3) {
          if (now >= value.deleteAt && !canBeExpired) {
            return void 0;
          }
          let matches = true;
          if (value.vary) {
            const vary = JSON.parse(value.vary);
            for (const header in vary) {
              if (!headerValueEquals(headers[header], vary[header])) {
                matches = false;
                break;
              }
            }
          }
          if (matches) {
            return value;
          }
        }
        return void 0;
      }
    };
    function headerValueEquals(lhs, rhs) {
      if (lhs == null && rhs == null) {
        return true;
      }
      if (lhs == null && rhs != null || lhs != null && rhs == null) {
        return false;
      }
      if (Array.isArray(lhs) && Array.isArray(rhs)) {
        if (lhs.length !== rhs.length) {
          return false;
        }
        return lhs.every((x2, i) => x2 === rhs[i]);
      }
      return lhs === rhs;
    }
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/headers.js
var require_headers = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/headers.js"(exports, module) {
    var { kConstruct } = require_symbols();
    var { kEnumerableProperty } = require_util();
    var {
      iteratorMixin,
      isValidHeaderName,
      isValidHeaderValue
    } = require_util2();
    var { webidl } = require_webidl();
    var assert3 = __require("assert");
    var util = __require("util");
    function isHTTPWhiteSpaceCharCode(code) {
      return code === 10 || code === 13 || code === 9 || code === 32;
    }
    function headerValueNormalize(potentialValue) {
      let i = 0;
      let j = potentialValue.length;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;
      return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
    }
    function fill(headers, object) {
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; ++i) {
          const header = object[i];
          if (header.length !== 2) {
            throw webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`
            });
          }
          appendHeader(headers, header[0], header[1]);
        }
      } else if (typeof object === "object" && object !== null) {
        const keys5 = Object.keys(object);
        for (let i = 0; i < keys5.length; ++i) {
          appendHeader(headers, keys5[i], object[keys5[i]]);
        }
      } else {
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
      }
    }
    function appendHeader(headers, name, value) {
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value,
          type: "header value"
        });
      }
      if (getHeadersGuard(headers) === "immutable") {
        throw new TypeError("immutable");
      }
      return getHeadersList(headers).append(name, value, false);
    }
    function headersListSortAndCombine(target) {
      const headersList = getHeadersList(target);
      if (!headersList) {
        return [];
      }
      if (headersList.sortedMap) {
        return headersList.sortedMap;
      }
      const headers = [];
      const names = headersList.toSortedArray();
      const cookies = headersList.cookies;
      if (cookies === null || cookies.length === 1) {
        return headersList.sortedMap = names;
      }
      for (let i = 0; i < names.length; ++i) {
        const { 0: name, 1: value } = names[i];
        if (name === "set-cookie") {
          for (let j = 0; j < cookies.length; ++j) {
            headers.push([name, cookies[j]]);
          }
        } else {
          headers.push([name, value]);
        }
      }
      return headersList.sortedMap = headers;
    }
    function compareHeaderName(a2, b) {
      return a2[0] < b[0] ? -1 : 1;
    }
    var HeadersList = class _HeadersList {
      /** @type {[string, string][]|null} */
      cookies = null;
      sortedMap;
      headersMap;
      constructor(init2) {
        if (init2 instanceof _HeadersList) {
          this.headersMap = new Map(init2.headersMap);
          this.sortedMap = init2.sortedMap;
          this.cookies = init2.cookies === null ? null : [...init2.cookies];
        } else {
          this.headersMap = new Map(init2);
          this.sortedMap = null;
        }
      }
      /**
       * @see https://fetch.spec.whatwg.org/#header-list-contains
       * @param {string} name
       * @param {boolean} isLowerCase
       */
      contains(name, isLowerCase) {
        return this.headersMap.has(isLowerCase ? name : name.toLowerCase());
      }
      clear() {
        this.headersMap.clear();
        this.sortedMap = null;
        this.cookies = null;
      }
      /**
       * @see https://fetch.spec.whatwg.org/#concept-header-list-append
       * @param {string} name
       * @param {string} value
       * @param {boolean} isLowerCase
       */
      append(name, value, isLowerCase) {
        this.sortedMap = null;
        const lowercaseName = isLowerCase ? name : name.toLowerCase();
        const exists4 = this.headersMap.get(lowercaseName);
        if (exists4) {
          const delimiter = lowercaseName === "cookie" ? "; " : ", ";
          this.headersMap.set(lowercaseName, {
            name: exists4.name,
            value: `${exists4.value}${delimiter}${value}`
          });
        } else {
          this.headersMap.set(lowercaseName, { name, value });
        }
        if (lowercaseName === "set-cookie") {
          (this.cookies ??= []).push(value);
        }
      }
      /**
       * @see https://fetch.spec.whatwg.org/#concept-header-list-set
       * @param {string} name
       * @param {string} value
       * @param {boolean} isLowerCase
       */
      set(name, value, isLowerCase) {
        this.sortedMap = null;
        const lowercaseName = isLowerCase ? name : name.toLowerCase();
        if (lowercaseName === "set-cookie") {
          this.cookies = [value];
        }
        this.headersMap.set(lowercaseName, { name, value });
      }
      /**
       * @see https://fetch.spec.whatwg.org/#concept-header-list-delete
       * @param {string} name
       * @param {boolean} isLowerCase
       */
      delete(name, isLowerCase) {
        this.sortedMap = null;
        if (!isLowerCase) name = name.toLowerCase();
        if (name === "set-cookie") {
          this.cookies = null;
        }
        this.headersMap.delete(name);
      }
      /**
       * @see https://fetch.spec.whatwg.org/#concept-header-list-get
       * @param {string} name
       * @param {boolean} isLowerCase
       * @returns {string | null}
       */
      get(name, isLowerCase) {
        return this.headersMap.get(isLowerCase ? name : name.toLowerCase())?.value ?? null;
      }
      *[Symbol.iterator]() {
        for (const { 0: name, 1: { value } } of this.headersMap) {
          yield [name, value];
        }
      }
      get entries() {
        const headers = {};
        if (this.headersMap.size !== 0) {
          for (const { name, value } of this.headersMap.values()) {
            headers[name] = value;
          }
        }
        return headers;
      }
      rawValues() {
        return this.headersMap.values();
      }
      get entriesList() {
        const headers = [];
        if (this.headersMap.size !== 0) {
          for (const { 0: lowerName, 1: { name, value } } of this.headersMap) {
            if (lowerName === "set-cookie") {
              for (const cookie of this.cookies) {
                headers.push([name, cookie]);
              }
            } else {
              headers.push([name, value]);
            }
          }
        }
        return headers;
      }
      // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set
      toSortedArray() {
        const size16 = this.headersMap.size;
        const array6 = new Array(size16);
        if (size16 <= 32) {
          if (size16 === 0) {
            return array6;
          }
          const iterator = this.headersMap[Symbol.iterator]();
          const firstValue = iterator.next().value;
          array6[0] = [firstValue[0], firstValue[1].value];
          assert3(firstValue[1].value !== null);
          for (let i = 1, j = 0, right3 = 0, left3 = 0, pivot = 0, x2, value; i < size16; ++i) {
            value = iterator.next().value;
            x2 = array6[i] = [value[0], value[1].value];
            assert3(x2[1] !== null);
            left3 = 0;
            right3 = i;
            while (left3 < right3) {
              pivot = left3 + (right3 - left3 >> 1);
              if (array6[pivot][0] <= x2[0]) {
                left3 = pivot + 1;
              } else {
                right3 = pivot;
              }
            }
            if (i !== pivot) {
              j = i;
              while (j > left3) {
                array6[j] = array6[--j];
              }
              array6[left3] = x2;
            }
          }
          if (!iterator.next().done) {
            throw new TypeError("Unreachable");
          }
          return array6;
        } else {
          let i = 0;
          for (const { 0: name, 1: { value } } of this.headersMap) {
            array6[i++] = [name, value];
            assert3(value !== null);
          }
          return array6.sort(compareHeaderName);
        }
      }
    };
    var Headers = class _Headers {
      #guard;
      /**
       * @type {HeadersList}
       */
      #headersList;
      /**
       * @param {HeadersInit|Symbol} [init]
       * @returns
       */
      constructor(init2 = void 0) {
        webidl.util.markAsUncloneable(this);
        if (init2 === kConstruct) {
          return;
        }
        this.#headersList = new HeadersList();
        this.#guard = "none";
        if (init2 !== void 0) {
          init2 = webidl.converters.HeadersInit(init2, "Headers constructor", "init");
          fill(this, init2);
        }
      }
      // https://fetch.spec.whatwg.org/#dom-headers-append
      append(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, "Headers.append");
        const prefix = "Headers.append";
        name = webidl.converters.ByteString(name, prefix, "name");
        value = webidl.converters.ByteString(value, prefix, "value");
        return appendHeader(this, name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-delete
      delete(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, "Headers.delete");
        const prefix = "Headers.delete";
        name = webidl.converters.ByteString(name, prefix, "name");
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name,
            type: "header name"
          });
        }
        if (this.#guard === "immutable") {
          throw new TypeError("immutable");
        }
        if (!this.#headersList.contains(name, false)) {
          return;
        }
        this.#headersList.delete(name, false);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-get
      get(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, "Headers.get");
        const prefix = "Headers.get";
        name = webidl.converters.ByteString(name, prefix, "name");
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix,
            value: name,
            type: "header name"
          });
        }
        return this.#headersList.get(name, false);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-has
      has(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, "Headers.has");
        const prefix = "Headers.has";
        name = webidl.converters.ByteString(name, prefix, "name");
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix,
            value: name,
            type: "header name"
          });
        }
        return this.#headersList.contains(name, false);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-set
      set(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, "Headers.set");
        const prefix = "Headers.set";
        name = webidl.converters.ByteString(name, prefix, "name");
        value = webidl.converters.ByteString(value, prefix, "value");
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix,
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix,
            value,
            type: "header value"
          });
        }
        if (this.#guard === "immutable") {
          throw new TypeError("immutable");
        }
        this.#headersList.set(name, value, false);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
      getSetCookie() {
        webidl.brandCheck(this, _Headers);
        const list = this.#headersList.cookies;
        if (list) {
          return [...list];
        }
        return [];
      }
      [util.inspect.custom](depth, options) {
        options.depth ??= depth;
        return `Headers ${util.formatWithOptions(options, this.#headersList.entries)}`;
      }
      static getHeadersGuard(o2) {
        return o2.#guard;
      }
      static setHeadersGuard(o2, guard) {
        o2.#guard = guard;
      }
      /**
       * @param {Headers} o
       */
      static getHeadersList(o2) {
        return o2.#headersList;
      }
      /**
       * @param {Headers} target
       * @param {HeadersList} list
       */
      static setHeadersList(target, list) {
        target.#headersList = list;
      }
    };
    var { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers;
    Reflect.deleteProperty(Headers, "getHeadersGuard");
    Reflect.deleteProperty(Headers, "setHeadersGuard");
    Reflect.deleteProperty(Headers, "getHeadersList");
    Reflect.deleteProperty(Headers, "setHeadersList");
    iteratorMixin("Headers", Headers, headersListSortAndCombine, 0, 1);
    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      getSetCookie: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Headers",
        configurable: true
      },
      [util.inspect.custom]: {
        enumerable: false
      }
    });
    webidl.converters.HeadersInit = function(V2, prefix, argument) {
      if (webidl.util.Type(V2) === webidl.util.Types.OBJECT) {
        const iterator = Reflect.get(V2, Symbol.iterator);
        if (!util.types.isProxy(V2) && iterator === Headers.prototype.entries) {
          try {
            return getHeadersList(V2).entriesList;
          } catch {
          }
        }
        if (typeof iterator === "function") {
          return webidl.converters["sequence<sequence<ByteString>>"](V2, prefix, argument, iterator.bind(V2));
        }
        return webidl.converters["record<ByteString, ByteString>"](V2, prefix, argument);
      }
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    };
    module.exports = {
      fill,
      // for test.
      compareHeaderName,
      Headers,
      HeadersList,
      getHeadersGuard,
      setHeadersGuard,
      setHeadersList,
      getHeadersList
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/response.js
var require_response = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/response.js"(exports, module) {
    var { Headers, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = require_headers();
    var { extractBody, cloneBody, mixinBody, hasFinalizationRegistry, streamRegistry, bodyUnusable } = require_body();
    var util = require_util();
    var nodeUtil = __require("util");
    var { kEnumerableProperty } = util;
    var {
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      serializeJavascriptValueToJSONString,
      isErrorLike,
      isomorphicEncode,
      environmentSettingsObject: relevantRealm
    } = require_util2();
    var {
      redirectStatusSet,
      nullBodyStatus
    } = require_constants3();
    var { webidl } = require_webidl();
    var { URLSerializer } = require_data_url();
    var { kConstruct } = require_symbols();
    var assert3 = __require("assert");
    var { types } = __require("util");
    var textEncoder2 = new TextEncoder("utf-8");
    var Response = class _Response {
      /** @type {Headers} */
      #headers;
      #state;
      // Creates network error Response.
      static error() {
        const responseObject = fromInnerResponse(makeNetworkError(), "immutable");
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response-json
      static json(data, init2 = void 0) {
        webidl.argumentLengthCheck(arguments, 1, "Response.json");
        if (init2 !== null) {
          init2 = webidl.converters.ResponseInit(init2);
        }
        const bytes = textEncoder2.encode(
          serializeJavascriptValueToJSONString(data)
        );
        const body = extractBody(bytes);
        const responseObject = fromInnerResponse(makeResponse({}), "response");
        initializeResponse(responseObject, init2, { body: body[0], type: "application/json" });
        return responseObject;
      }
      // Creates a redirect Response that redirects to url with status status.
      static redirect(url3, status2 = 302) {
        webidl.argumentLengthCheck(arguments, 1, "Response.redirect");
        url3 = webidl.converters.USVString(url3);
        status2 = webidl.converters["unsigned short"](status2);
        let parsedURL;
        try {
          parsedURL = new URL(url3, relevantRealm.settingsObject.baseUrl);
        } catch (err) {
          throw new TypeError(`Failed to parse URL from ${url3}`, { cause: err });
        }
        if (!redirectStatusSet.has(status2)) {
          throw new RangeError(`Invalid status code ${status2}`);
        }
        const responseObject = fromInnerResponse(makeResponse({}), "immutable");
        responseObject.#state.status = status2;
        const value = isomorphicEncode(URLSerializer(parsedURL));
        responseObject.#state.headersList.append("location", value, true);
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response
      constructor(body = null, init2 = void 0) {
        webidl.util.markAsUncloneable(this);
        if (body === kConstruct) {
          return;
        }
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }
        init2 = webidl.converters.ResponseInit(init2);
        this.#state = makeResponse({});
        this.#headers = new Headers(kConstruct);
        setHeadersGuard(this.#headers, "response");
        setHeadersList(this.#headers, this.#state.headersList);
        let bodyWithType = null;
        if (body != null) {
          const [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }
        initializeResponse(this, init2, bodyWithType);
      }
      // Returns response’s type, e.g., "cors".
      get type() {
        webidl.brandCheck(this, _Response);
        return this.#state.type;
      }
      // Returns response’s URL, if it has one; otherwise the empty string.
      get url() {
        webidl.brandCheck(this, _Response);
        const urlList = this.#state.urlList;
        const url3 = urlList[urlList.length - 1] ?? null;
        if (url3 === null) {
          return "";
        }
        return URLSerializer(url3, true);
      }
      // Returns whether response was obtained through a redirect.
      get redirected() {
        webidl.brandCheck(this, _Response);
        return this.#state.urlList.length > 1;
      }
      // Returns response’s status.
      get status() {
        webidl.brandCheck(this, _Response);
        return this.#state.status;
      }
      // Returns whether response’s status is an ok status.
      get ok() {
        webidl.brandCheck(this, _Response);
        return this.#state.status >= 200 && this.#state.status <= 299;
      }
      // Returns response’s status message.
      get statusText() {
        webidl.brandCheck(this, _Response);
        return this.#state.statusText;
      }
      // Returns response’s headers as Headers.
      get headers() {
        webidl.brandCheck(this, _Response);
        return this.#headers;
      }
      get body() {
        webidl.brandCheck(this, _Response);
        return this.#state.body ? this.#state.body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Response);
        return !!this.#state.body && util.isDisturbed(this.#state.body.stream);
      }
      // Returns a clone of response.
      clone() {
        webidl.brandCheck(this, _Response);
        if (bodyUnusable(this.#state)) {
          throw webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed."
          });
        }
        const clonedResponse = cloneResponse(this.#state);
        return fromInnerResponse(clonedResponse, getHeadersGuard(this.#headers));
      }
      [nodeUtil.inspect.custom](depth, options) {
        if (options.depth === null) {
          options.depth = 2;
        }
        options.colors ??= true;
        const properties = {
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          body: this.body,
          bodyUsed: this.bodyUsed,
          ok: this.ok,
          redirected: this.redirected,
          type: this.type,
          url: this.url
        };
        return `Response ${nodeUtil.formatWithOptions(options, properties)}`;
      }
      /**
       * @param {Response} response
       */
      static getResponseHeaders(response) {
        return response.#headers;
      }
      /**
       * @param {Response} response
       * @param {Headers} newHeaders
       */
      static setResponseHeaders(response, newHeaders) {
        response.#headers = newHeaders;
      }
      /**
       * @param {Response} response
       */
      static getResponseState(response) {
        return response.#state;
      }
      /**
       * @param {Response} response
       * @param {any} newState
       */
      static setResponseState(response, newState) {
        response.#state = newState;
      }
    };
    var { getResponseHeaders, setResponseHeaders, getResponseState, setResponseState } = Response;
    Reflect.deleteProperty(Response, "getResponseHeaders");
    Reflect.deleteProperty(Response, "setResponseHeaders");
    Reflect.deleteProperty(Response, "getResponseState");
    Reflect.deleteProperty(Response, "setResponseState");
    mixinBody(Response, getResponseState);
    Object.defineProperties(Response.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Response",
        configurable: true
      }
    });
    Object.defineProperties(Response, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty
    });
    function cloneResponse(response) {
      if (response.internalResponse) {
        return filterResponse(
          cloneResponse(response.internalResponse),
          response.type
        );
      }
      const newResponse = makeResponse({ ...response, body: null });
      if (response.body != null) {
        newResponse.body = cloneBody(newResponse, response.body);
      }
      return newResponse;
    }
    function makeResponse(init2) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init2,
        headersList: init2?.headersList ? new HeadersList(init2?.headersList) : new HeadersList(),
        urlList: init2?.urlList ? [...init2.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      const isError = isErrorLike(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError ? reason : new Error(reason ? String(reason) : reason),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function isNetworkError(response) {
      return (
        // A network error is a response whose type is "error",
        response.type === "error" && // status is 0
        response.status === 0
      );
    }
    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state
      };
      return new Proxy(response, {
        get(target, p3) {
          return p3 in state ? state[p3] : target[p3];
        },
        set(target, p3, value) {
          assert3(!(p3 in state));
          target[p3] = value;
          return true;
        }
      });
    }
    function filterResponse(response, type) {
      if (type === "basic") {
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList
        });
      } else if (type === "cors") {
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList
        });
      } else if (type === "opaque") {
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      } else if (type === "opaqueredirect") {
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null
        });
      } else {
        assert3(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams, err = null) {
      assert3(isCancelled(fetchParams));
      return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException("Request was cancelled."), { cause: err }));
    }
    function initializeResponse(response, init2, body) {
      if (init2.status !== null && (init2.status < 200 || init2.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ("statusText" in init2 && init2.statusText != null) {
        if (!isValidReasonPhrase(String(init2.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }
      if ("status" in init2 && init2.status != null) {
        getResponseState(response).status = init2.status;
      }
      if ("statusText" in init2 && init2.statusText != null) {
        getResponseState(response).statusText = init2.statusText;
      }
      if ("headers" in init2 && init2.headers != null) {
        fill(getResponseHeaders(response), init2.headers);
      }
      if (body) {
        if (nullBodyStatus.includes(response.status)) {
          throw webidl.errors.exception({
            header: "Response constructor",
            message: `Invalid response status code ${response.status}`
          });
        }
        getResponseState(response).body = body.body;
        if (body.type != null && !getResponseState(response).headersList.contains("content-type", true)) {
          getResponseState(response).headersList.append("content-type", body.type, true);
        }
      }
    }
    function fromInnerResponse(innerResponse, guard) {
      const response = new Response(kConstruct);
      setResponseState(response, innerResponse);
      const headers = new Headers(kConstruct);
      setResponseHeaders(response, headers);
      setHeadersList(headers, innerResponse.headersList);
      setHeadersGuard(headers, guard);
      if (hasFinalizationRegistry && innerResponse.body?.stream) {
        streamRegistry.register(response, new WeakRef(innerResponse.body.stream));
      }
      return response;
    }
    webidl.converters.XMLHttpRequestBodyInit = function(V2, prefix, name) {
      if (typeof V2 === "string") {
        return webidl.converters.USVString(V2, prefix, name);
      }
      if (webidl.is.Blob(V2)) {
        return V2;
      }
      if (ArrayBuffer.isView(V2) || types.isArrayBuffer(V2)) {
        return V2;
      }
      if (webidl.is.FormData(V2)) {
        return V2;
      }
      if (webidl.is.URLSearchParams(V2)) {
        return V2;
      }
      return webidl.converters.DOMString(V2, prefix, name);
    };
    webidl.converters.BodyInit = function(V2, prefix, argument) {
      if (webidl.is.ReadableStream(V2)) {
        return V2;
      }
      if (V2?.[Symbol.asyncIterator]) {
        return V2;
      }
      return webidl.converters.XMLHttpRequestBodyInit(V2, prefix, argument);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: () => 200
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: () => ""
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      }
    ]);
    webidl.is.Response = webidl.util.MakeTypeAssertion(Response);
    module.exports = {
      isNetworkError,
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response,
      cloneResponse,
      fromInnerResponse,
      getResponseState
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/dispatcher-weakref.js"(exports, module) {
    var { kConnected, kSize } = require_symbols();
    var CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    };
    var CompatFinalizer = class {
      constructor(finalizer3) {
        this.finalizer = finalizer3;
      }
      register(dispatcher, key) {
        if (dispatcher.on) {
          dispatcher.on("disconnect", () => {
            if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
              this.finalizer(key);
            }
          });
        }
      }
      unregister(key) {
      }
    };
    module.exports = function() {
      if (process.env.NODE_V8_COVERAGE && process.version.startsWith("v18")) {
        process._rawDebug("Using compatibility WeakRef and FinalizationRegistry");
        return {
          WeakRef: CompatWeakRef,
          FinalizationRegistry: CompatFinalizer
        };
      }
      return { WeakRef, FinalizationRegistry };
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/request.js
var require_request2 = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/request.js"(exports, module) {
    var { extractBody, mixinBody, cloneBody, bodyUnusable } = require_body();
    var { Headers, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = require_headers();
    var { FinalizationRegistry: FinalizationRegistry2 } = require_dispatcher_weakref()();
    var util = require_util();
    var nodeUtil = __require("util");
    var {
      isValidHTTPToken,
      sameOrigin,
      environmentSettingsObject
    } = require_util2();
    var {
      forbiddenMethodsSet,
      corsSafeListedMethodsSet,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex
    } = require_constants3();
    var { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util;
    var { webidl } = require_webidl();
    var { URLSerializer } = require_data_url();
    var { kConstruct } = require_symbols();
    var assert3 = __require("assert");
    var { getMaxListeners, setMaxListeners, defaultMaxListeners } = __require("events");
    var kAbortController = Symbol("abortController");
    var requestFinalizer = new FinalizationRegistry2(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });
    var dependentControllerMap = /* @__PURE__ */ new WeakMap();
    var abortSignalHasEventHandlerLeakWarning;
    try {
      abortSignalHasEventHandlerLeakWarning = getMaxListeners(new AbortController().signal) > 0;
    } catch {
      abortSignalHasEventHandlerLeakWarning = false;
    }
    function buildAbort(acRef) {
      return abort;
      function abort() {
        const ac = acRef.deref();
        if (ac !== void 0) {
          requestFinalizer.unregister(abort);
          this.removeEventListener("abort", abort);
          ac.abort(this.reason);
          const controllerList = dependentControllerMap.get(ac.signal);
          if (controllerList !== void 0) {
            if (controllerList.size !== 0) {
              for (const ref of controllerList) {
                const ctrl = ref.deref();
                if (ctrl !== void 0) {
                  ctrl.abort(this.reason);
                }
              }
              controllerList.clear();
            }
            dependentControllerMap.delete(ac.signal);
          }
        }
      }
    }
    var patchMethodWarning = false;
    var Request = class _Request {
      /** @type {AbortSignal} */
      #signal;
      /** @type {import('../../dispatcher/dispatcher')} */
      #dispatcher;
      /** @type {Headers} */
      #headers;
      #state;
      // https://fetch.spec.whatwg.org/#dom-request
      constructor(input2, init2 = void 0) {
        webidl.util.markAsUncloneable(this);
        if (input2 === kConstruct) {
          return;
        }
        const prefix = "Request constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        input2 = webidl.converters.RequestInfo(input2, prefix, "input");
        init2 = webidl.converters.RequestInit(init2, prefix, "init");
        let request2 = null;
        let fallbackMode = null;
        const baseUrl = environmentSettingsObject.settingsObject.baseUrl;
        let signal = null;
        if (typeof input2 === "string") {
          this.#dispatcher = init2.dispatcher;
          let parsedURL;
          try {
            parsedURL = new URL(input2, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input2, { cause: err });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " + input2
            );
          }
          request2 = makeRequest({ urlList: [parsedURL] });
          fallbackMode = "cors";
        } else {
          assert3(webidl.is.Request(input2));
          request2 = input2.#state;
          signal = input2.#signal;
          this.#dispatcher = init2.dispatcher || input2.#dispatcher;
        }
        const origin = environmentSettingsObject.settingsObject.origin;
        let window2 = "client";
        if (request2.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request2.window, origin)) {
          window2 = request2.window;
        }
        if (init2.window != null) {
          throw new TypeError(`'window' option '${window2}' must be null`);
        }
        if ("window" in init2) {
          window2 = "no-window";
        }
        request2 = makeRequest({
          // URL request’s URL.
          // undici implementation note: this is set as the first item in request's urlList in makeRequest
          // method request’s method.
          method: request2.method,
          // header list A copy of request’s header list.
          // undici implementation note: headersList is cloned in makeRequest
          headersList: request2.headersList,
          // unsafe-request flag Set.
          unsafeRequest: request2.unsafeRequest,
          // client This’s relevant settings object.
          client: environmentSettingsObject.settingsObject,
          // window window.
          window: window2,
          // priority request’s priority.
          priority: request2.priority,
          // origin request’s origin. The propagation of the origin is only significant for navigation requests
          // being handled by a service worker. In this scenario a request can have an origin that is different
          // from the current client.
          origin: request2.origin,
          // referrer request’s referrer.
          referrer: request2.referrer,
          // referrer policy request’s referrer policy.
          referrerPolicy: request2.referrerPolicy,
          // mode request’s mode.
          mode: request2.mode,
          // credentials mode request’s credentials mode.
          credentials: request2.credentials,
          // cache mode request’s cache mode.
          cache: request2.cache,
          // redirect mode request’s redirect mode.
          redirect: request2.redirect,
          // integrity metadata request’s integrity metadata.
          integrity: request2.integrity,
          // keepalive request’s keepalive.
          keepalive: request2.keepalive,
          // reload-navigation flag request’s reload-navigation flag.
          reloadNavigation: request2.reloadNavigation,
          // history-navigation flag request’s history-navigation flag.
          historyNavigation: request2.historyNavigation,
          // URL list A clone of request’s URL list.
          urlList: [...request2.urlList]
        });
        const initHasKey = Object.keys(init2).length !== 0;
        if (initHasKey) {
          if (request2.mode === "navigate") {
            request2.mode = "same-origin";
          }
          request2.reloadNavigation = false;
          request2.historyNavigation = false;
          request2.origin = "client";
          request2.referrer = "client";
          request2.referrerPolicy = "";
          request2.url = request2.urlList[request2.urlList.length - 1];
          request2.urlList = [request2.url];
        }
        if (init2.referrer !== void 0) {
          const referrer = init2.referrer;
          if (referrer === "") {
            request2.referrer = "no-referrer";
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl)) {
              request2.referrer = "client";
            } else {
              request2.referrer = parsedReferrer;
            }
          }
        }
        if (init2.referrerPolicy !== void 0) {
          request2.referrerPolicy = init2.referrerPolicy;
        }
        let mode;
        if (init2.mode !== void 0) {
          mode = init2.mode;
        } else {
          mode = fallbackMode;
        }
        if (mode === "navigate") {
          throw webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate."
          });
        }
        if (mode != null) {
          request2.mode = mode;
        }
        if (init2.credentials !== void 0) {
          request2.credentials = init2.credentials;
        }
        if (init2.cache !== void 0) {
          request2.cache = init2.cache;
        }
        if (request2.cache === "only-if-cached" && request2.mode !== "same-origin") {
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        }
        if (init2.redirect !== void 0) {
          request2.redirect = init2.redirect;
        }
        if (init2.integrity != null) {
          request2.integrity = String(init2.integrity);
        }
        if (init2.keepalive !== void 0) {
          request2.keepalive = Boolean(init2.keepalive);
        }
        if (init2.method !== void 0) {
          let method = init2.method;
          const mayBeNormalized = normalizedMethodRecords[method];
          if (mayBeNormalized !== void 0) {
            request2.method = mayBeNormalized;
          } else {
            if (!isValidHTTPToken(method)) {
              throw new TypeError(`'${method}' is not a valid HTTP method.`);
            }
            const upperCase4 = method.toUpperCase();
            if (forbiddenMethodsSet.has(upperCase4)) {
              throw new TypeError(`'${method}' HTTP method is unsupported.`);
            }
            method = normalizedMethodRecordsBase[upperCase4] ?? method;
            request2.method = method;
          }
          if (!patchMethodWarning && request2.method === "patch") {
            process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", {
              code: "UNDICI-FETCH-patch"
            });
            patchMethodWarning = true;
          }
        }
        if (init2.signal !== void 0) {
          signal = init2.signal;
        }
        this.#state = request2;
        const ac = new AbortController();
        this.#signal = ac.signal;
        if (signal != null) {
          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            this[kAbortController] = ac;
            const acRef = new WeakRef(ac);
            const abort = buildAbort(acRef);
            if (abortSignalHasEventHandlerLeakWarning && getMaxListeners(signal) === defaultMaxListeners) {
              setMaxListeners(1500, signal);
            }
            util.addAbortListener(signal, abort);
            requestFinalizer.register(ac, { signal, abort }, abort);
          }
        }
        this.#headers = new Headers(kConstruct);
        setHeadersList(this.#headers, request2.headersList);
        setHeadersGuard(this.#headers, "request");
        if (mode === "no-cors") {
          if (!corsSafeListedMethodsSet.has(request2.method)) {
            throw new TypeError(
              `'${request2.method} is unsupported in no-cors mode.`
            );
          }
          setHeadersGuard(this.#headers, "request-no-cors");
        }
        if (initHasKey) {
          const headersList = getHeadersList(this.#headers);
          const headers = init2.headers !== void 0 ? init2.headers : new HeadersList(headersList);
          headersList.clear();
          if (headers instanceof HeadersList) {
            for (const { name, value } of headers.rawValues()) {
              headersList.append(name, value, false);
            }
            headersList.cookies = headers.cookies;
          } else {
            fillHeaders(this.#headers, headers);
          }
        }
        const inputBody = webidl.is.Request(input2) ? input2.#state.body : null;
        if ((init2.body != null || inputBody != null) && (request2.method === "GET" || request2.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let initBody = null;
        if (init2.body != null) {
          const [extractedBody, contentType] = extractBody(
            init2.body,
            request2.keepalive
          );
          initBody = extractedBody;
          if (contentType && !getHeadersList(this.#headers).contains("content-type", true)) {
            this.#headers.append("content-type", contentType, true);
          }
        }
        const inputOrInitBody = initBody ?? inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init2.duplex == null) {
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          }
          if (request2.mode !== "same-origin" && request2.mode !== "cors") {
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          }
          request2.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (bodyUnusable(input2.#state)) {
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          }
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this.#state.body = finalBody;
      }
      // Returns request’s HTTP method, which is "GET" by default.
      get method() {
        webidl.brandCheck(this, _Request);
        return this.#state.method;
      }
      // Returns the URL of request as a string.
      get url() {
        webidl.brandCheck(this, _Request);
        return URLSerializer(this.#state.url);
      }
      // Returns a Headers object consisting of the headers associated with request.
      // Note that headers added in the network layer by the user agent will not
      // be accounted for in this object, e.g., the "Host" header.
      get headers() {
        webidl.brandCheck(this, _Request);
        return this.#headers;
      }
      // Returns the kind of resource requested by request, e.g., "document"
      // or "script".
      get destination() {
        webidl.brandCheck(this, _Request);
        return this.#state.destination;
      }
      // Returns the referrer of request. Its value can be a same-origin URL if
      // explicitly set in init, the empty string to indicate no referrer, and
      // "about:client" when defaulting to the global’s default. This is used
      // during fetching to determine the value of the `Referer` header of the
      // request being made.
      get referrer() {
        webidl.brandCheck(this, _Request);
        if (this.#state.referrer === "no-referrer") {
          return "";
        }
        if (this.#state.referrer === "client") {
          return "about:client";
        }
        return this.#state.referrer.toString();
      }
      // Returns the referrer policy associated with request.
      // This is used during fetching to compute the value of the request’s
      // referrer.
      get referrerPolicy() {
        webidl.brandCheck(this, _Request);
        return this.#state.referrerPolicy;
      }
      // Returns the mode associated with request, which is a string indicating
      // whether the request will use CORS, or will be restricted to same-origin
      // URLs.
      get mode() {
        webidl.brandCheck(this, _Request);
        return this.#state.mode;
      }
      // Returns the credentials mode associated with request,
      // which is a string indicating whether credentials will be sent with the
      // request always, never, or only when sent to a same-origin URL.
      get credentials() {
        webidl.brandCheck(this, _Request);
        return this.#state.credentials;
      }
      // Returns the cache mode associated with request,
      // which is a string indicating how the request will
      // interact with the browser’s cache when fetching.
      get cache() {
        webidl.brandCheck(this, _Request);
        return this.#state.cache;
      }
      // Returns the redirect mode associated with request,
      // which is a string indicating how redirects for the
      // request will be handled during fetching. A request
      // will follow redirects by default.
      get redirect() {
        webidl.brandCheck(this, _Request);
        return this.#state.redirect;
      }
      // Returns request’s subresource integrity metadata, which is a
      // cryptographic hash of the resource being fetched. Its value
      // consists of multiple hashes separated by whitespace. [SRI]
      get integrity() {
        webidl.brandCheck(this, _Request);
        return this.#state.integrity;
      }
      // Returns a boolean indicating whether or not request can outlive the
      // global in which it was created.
      get keepalive() {
        webidl.brandCheck(this, _Request);
        return this.#state.keepalive;
      }
      // Returns a boolean indicating whether or not request is for a reload
      // navigation.
      get isReloadNavigation() {
        webidl.brandCheck(this, _Request);
        return this.#state.reloadNavigation;
      }
      // Returns a boolean indicating whether or not request is for a history
      // navigation (a.k.a. back-forward navigation).
      get isHistoryNavigation() {
        webidl.brandCheck(this, _Request);
        return this.#state.historyNavigation;
      }
      // Returns the signal associated with request, which is an AbortSignal
      // object indicating whether or not request has been aborted, and its
      // abort event handler.
      get signal() {
        webidl.brandCheck(this, _Request);
        return this.#signal;
      }
      get body() {
        webidl.brandCheck(this, _Request);
        return this.#state.body ? this.#state.body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Request);
        return !!this.#state.body && util.isDisturbed(this.#state.body.stream);
      }
      get duplex() {
        webidl.brandCheck(this, _Request);
        return "half";
      }
      // Returns a clone of request.
      clone() {
        webidl.brandCheck(this, _Request);
        if (bodyUnusable(this.#state)) {
          throw new TypeError("unusable");
        }
        const clonedRequest = cloneRequest(this.#state);
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          let list = dependentControllerMap.get(this.signal);
          if (list === void 0) {
            list = /* @__PURE__ */ new Set();
            dependentControllerMap.set(this.signal, list);
          }
          const acRef = new WeakRef(ac);
          list.add(acRef);
          util.addAbortListener(
            ac.signal,
            buildAbort(acRef)
          );
        }
        return fromInnerRequest(clonedRequest, this.#dispatcher, ac.signal, getHeadersGuard(this.#headers));
      }
      [nodeUtil.inspect.custom](depth, options) {
        if (options.depth === null) {
          options.depth = 2;
        }
        options.colors ??= true;
        const properties = {
          method: this.method,
          url: this.url,
          headers: this.headers,
          destination: this.destination,
          referrer: this.referrer,
          referrerPolicy: this.referrerPolicy,
          mode: this.mode,
          credentials: this.credentials,
          cache: this.cache,
          redirect: this.redirect,
          integrity: this.integrity,
          keepalive: this.keepalive,
          isReloadNavigation: this.isReloadNavigation,
          isHistoryNavigation: this.isHistoryNavigation,
          signal: this.signal
        };
        return `Request ${nodeUtil.formatWithOptions(options, properties)}`;
      }
      /**
       * @param {Request} request
       * @param {AbortSignal} newSignal
       */
      static setRequestSignal(request2, newSignal) {
        request2.#signal = newSignal;
        return request2;
      }
      /**
       * @param {Request} request
       */
      static getRequestDispatcher(request2) {
        return request2.#dispatcher;
      }
      /**
       * @param {Request} request
       * @param {import('../../dispatcher/dispatcher')} newDispatcher
       */
      static setRequestDispatcher(request2, newDispatcher) {
        request2.#dispatcher = newDispatcher;
      }
      /**
       * @param {Request} request
       * @param {Headers} newHeaders
       */
      static setRequestHeaders(request2, newHeaders) {
        request2.#headers = newHeaders;
      }
      /**
       * @param {Request} request
       */
      static getRequestState(request2) {
        return request2.#state;
      }
      /**
       * @param {Request} request
       * @param {any} newState
       */
      static setRequestState(request2, newState) {
        request2.#state = newState;
      }
    };
    var { setRequestSignal, getRequestDispatcher, setRequestDispatcher, setRequestHeaders, getRequestState, setRequestState } = Request;
    Reflect.deleteProperty(Request, "setRequestSignal");
    Reflect.deleteProperty(Request, "getRequestDispatcher");
    Reflect.deleteProperty(Request, "setRequestDispatcher");
    Reflect.deleteProperty(Request, "setRequestHeaders");
    Reflect.deleteProperty(Request, "getRequestState");
    Reflect.deleteProperty(Request, "setRequestState");
    mixinBody(Request, getRequestState);
    function makeRequest(init2) {
      return {
        method: init2.method ?? "GET",
        localURLsOnly: init2.localURLsOnly ?? false,
        unsafeRequest: init2.unsafeRequest ?? false,
        body: init2.body ?? null,
        client: init2.client ?? null,
        reservedClient: init2.reservedClient ?? null,
        replacesClientId: init2.replacesClientId ?? "",
        window: init2.window ?? "client",
        keepalive: init2.keepalive ?? false,
        serviceWorkers: init2.serviceWorkers ?? "all",
        initiator: init2.initiator ?? "",
        destination: init2.destination ?? "",
        priority: init2.priority ?? null,
        origin: init2.origin ?? "client",
        policyContainer: init2.policyContainer ?? "client",
        referrer: init2.referrer ?? "client",
        referrerPolicy: init2.referrerPolicy ?? "",
        mode: init2.mode ?? "no-cors",
        useCORSPreflightFlag: init2.useCORSPreflightFlag ?? false,
        credentials: init2.credentials ?? "same-origin",
        useCredentials: init2.useCredentials ?? false,
        cache: init2.cache ?? "default",
        redirect: init2.redirect ?? "follow",
        integrity: init2.integrity ?? "",
        cryptoGraphicsNonceMetadata: init2.cryptoGraphicsNonceMetadata ?? "",
        parserMetadata: init2.parserMetadata ?? "",
        reloadNavigation: init2.reloadNavigation ?? false,
        historyNavigation: init2.historyNavigation ?? false,
        userActivation: init2.userActivation ?? false,
        taintedOrigin: init2.taintedOrigin ?? false,
        redirectCount: init2.redirectCount ?? 0,
        responseTainting: init2.responseTainting ?? "basic",
        preventNoCacheCacheControlHeaderModification: init2.preventNoCacheCacheControlHeaderModification ?? false,
        done: init2.done ?? false,
        timingAllowFailed: init2.timingAllowFailed ?? false,
        urlList: init2.urlList,
        url: init2.urlList[0],
        headersList: init2.headersList ? new HeadersList(init2.headersList) : new HeadersList()
      };
    }
    function cloneRequest(request2) {
      const newRequest = makeRequest({ ...request2, body: null });
      if (request2.body != null) {
        newRequest.body = cloneBody(newRequest, request2.body);
      }
      return newRequest;
    }
    function fromInnerRequest(innerRequest, dispatcher, signal, guard) {
      const request2 = new Request(kConstruct);
      setRequestState(request2, innerRequest);
      setRequestDispatcher(request2, dispatcher);
      setRequestSignal(request2, signal);
      const headers = new Headers(kConstruct);
      setRequestHeaders(request2, headers);
      setHeadersList(headers, innerRequest.headersList);
      setHeadersGuard(headers, guard);
      return request2;
    }
    Object.defineProperties(Request.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Request",
        configurable: true
      }
    });
    webidl.is.Request = webidl.util.MakeTypeAssertion(Request);
    webidl.converters.RequestInfo = function(V2, prefix, argument) {
      if (typeof V2 === "string") {
        return webidl.converters.USVString(V2);
      }
      if (webidl.is.Request(V2)) {
        return V2;
      }
      return webidl.converters.USVString(V2);
    };
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      },
      {
        key: "body",
        converter: webidl.nullableConverter(
          webidl.converters.BodyInit
        )
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
        allowedValues: referrerPolicy
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#concept-request-mode
        allowedValues: requestMode
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcredentials
        allowedValues: requestCredentials
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcache
        allowedValues: requestCache
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestredirect
        allowedValues: requestRedirect
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(
          (signal) => webidl.converters.AbortSignal(
            signal,
            "RequestInit",
            "signal"
          )
        )
      },
      {
        key: "window",
        converter: webidl.converters.any
      },
      {
        key: "duplex",
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex
      },
      {
        key: "dispatcher",
        // undici specific option
        converter: webidl.converters.any
      }
    ]);
    module.exports = {
      Request,
      makeRequest,
      fromInnerRequest,
      cloneRequest,
      getRequestDispatcher,
      getRequestState
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/fetch/index.js"(exports, module) {
    var {
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse,
      fromInnerResponse,
      getResponseState
    } = require_response();
    var { HeadersList } = require_headers();
    var { Request, cloneRequest, getRequestDispatcher, getRequestState } = require_request2();
    var zlib = __require("zlib");
    var {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlIsHttpHttpsScheme,
      urlHasHttpsScheme,
      clampAndCoarsenConnectionTimingInfo,
      simpleRangeHeaderValue,
      buildContentRange,
      createInflate,
      extractMimeType
    } = require_util2();
    var assert3 = __require("assert");
    var { safelyExtractBody, extractBody } = require_body();
    var {
      redirectStatusSet,
      nullBodyStatus,
      safeMethodsSet,
      requestBodyHeader,
      subresourceSet
    } = require_constants3();
    var EE = __require("events");
    var { Readable: Readable2, pipeline, finished, isErrored, isReadable } = __require("stream");
    var { addAbortListener, bufferToLowerCasedHeaderName } = require_util();
    var { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = require_data_url();
    var { getGlobalDispatcher } = require_global2();
    var { webidl } = require_webidl();
    var { STATUS_CODES } = __require("http");
    var GET_OR_HEAD = ["GET", "HEAD"];
    var defaultUserAgent = typeof __UNDICI_IS_NODE__ !== "undefined" || typeof esbuildDetection !== "undefined" ? "node" : "undici";
    var resolveObjectURL;
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
      }
      terminate(reason) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        this.connection?.destroy(reason);
        this.emit("terminated", reason);
      }
      // https://fetch.spec.whatwg.org/#fetch-controller-abort
      abort(error4) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "aborted";
        if (!error4) {
          error4 = new DOMException("The operation was aborted.", "AbortError");
        }
        this.serializedAbortReason = error4;
        this.connection?.destroy(error4);
        this.emit("terminated", error4);
      }
    };
    function handleFetchDone(response) {
      finalizeAndReportTiming(response, "fetch");
    }
    function fetch(input2, init2 = void 0) {
      webidl.argumentLengthCheck(arguments, 1, "globalThis.fetch");
      let p3 = createDeferredPromise();
      let requestObject;
      try {
        requestObject = new Request(input2, init2);
      } catch (e) {
        p3.reject(e);
        return p3.promise;
      }
      const request2 = getRequestState(requestObject);
      if (requestObject.signal.aborted) {
        abortFetch(p3, request2, null, requestObject.signal.reason);
        return p3.promise;
      }
      const globalObject = request2.client.globalObject;
      if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
        request2.serviceWorkers = "none";
      }
      let responseObject = null;
      let locallyAborted = false;
      let controller = null;
      addAbortListener(
        requestObject.signal,
        () => {
          locallyAborted = true;
          assert3(controller != null);
          controller.abort(requestObject.signal.reason);
          const realResponse = responseObject?.deref();
          abortFetch(p3, request2, realResponse, requestObject.signal.reason);
        }
      );
      const processResponse = (response) => {
        if (locallyAborted) {
          return;
        }
        if (response.aborted) {
          abortFetch(p3, request2, responseObject, controller.serializedAbortReason);
          return;
        }
        if (response.type === "error") {
          p3.reject(new TypeError("fetch failed", { cause: response.error }));
          return;
        }
        responseObject = new WeakRef(fromInnerResponse(response, "immutable"));
        p3.resolve(responseObject.deref());
        p3 = null;
      };
      controller = fetching({
        request: request2,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: getRequestDispatcher(requestObject)
        // undici
      });
      return p3.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      if (response.type === "error" && response.aborted) {
        return;
      }
      if (!response.urlList?.length) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!urlIsHttpHttpsScheme(originalURL)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!response.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime
        });
        cacheState = "";
      }
      timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(
        timingInfo,
        originalURL.href,
        initiatorType,
        globalThis,
        cacheState,
        "",
        // bodyType
        response.status
      );
    }
    var markResourceTiming = performance.markResourceTiming;
    function abortFetch(p3, request2, responseObject, error4) {
      if (p3) {
        p3.reject(error4);
      }
      if (request2.body?.stream != null && isReadable(request2.body.stream)) {
        request2.body.stream.cancel(error4).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = getResponseState(responseObject);
      if (response.body?.stream != null && isReadable(response.body.stream)) {
        response.body.stream.cancel(error4).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
    }
    function fetching({
      request: request2,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher = getGlobalDispatcher()
      // undici
    }) {
      assert3(dispatcher);
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request2.client != null) {
        taskDestination = request2.client.globalObject;
        crossOriginIsolatedCapability = request2.client.crossOriginIsolatedCapability;
      }
      const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currentTime
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request: request2,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      assert3(!request2.body || request2.body.stream);
      if (request2.window === "client") {
        request2.window = request2.client?.globalObject?.constructor?.name === "Window" ? request2.client : "no-window";
      }
      if (request2.origin === "client") {
        request2.origin = request2.client.origin;
      }
      if (request2.policyContainer === "client") {
        if (request2.client != null) {
          request2.policyContainer = clonePolicyContainer(
            request2.client.policyContainer
          );
        } else {
          request2.policyContainer = makePolicyContainer();
        }
      }
      if (!request2.headersList.contains("accept", true)) {
        const value = "*/*";
        request2.headersList.append("accept", value, true);
      }
      if (!request2.headersList.contains("accept-language", true)) {
        request2.headersList.append("accept-language", "*", true);
      }
      if (subresourceSet.has(request2.destination)) ;
      mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      });
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = false) {
      const request2 = fetchParams.request;
      let response = null;
      if (request2.localURLsOnly && !urlIsLocal(requestCurrentURL(request2))) {
        response = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request2);
      if (requestBadPort(request2) === "blocked") {
        response = makeNetworkError("bad port");
      }
      if (request2.referrerPolicy === "") {
        request2.referrerPolicy = request2.policyContainer.referrerPolicy;
      }
      if (request2.referrer !== "no-referrer") {
        request2.referrer = determineRequestsReferrer(request2);
      }
      if (response === null) {
        const currentURL = requestCurrentURL(request2);
        if (
          // - request’s current URL’s origin is same origin with request’s origin,
          //   and request’s response tainting is "basic"
          sameOrigin(currentURL, request2.url) && request2.responseTainting === "basic" || // request’s current URL’s scheme is "data"
          currentURL.protocol === "data:" || // - request’s mode is "navigate" or "websocket"
          (request2.mode === "navigate" || request2.mode === "websocket")
        ) {
          request2.responseTainting = "basic";
          response = await schemeFetch(fetchParams);
        } else if (request2.mode === "same-origin") {
          response = makeNetworkError('request mode cannot be "same-origin"');
        } else if (request2.mode === "no-cors") {
          if (request2.redirect !== "follow") {
            response = makeNetworkError(
              'redirect mode cannot be "follow" for "no-cors" request'
            );
          } else {
            request2.responseTainting = "opaque";
            response = await schemeFetch(fetchParams);
          }
        } else if (!urlIsHttpHttpsScheme(requestCurrentURL(request2))) {
          response = makeNetworkError("URL scheme must be a HTTP(S) scheme");
        } else {
          request2.responseTainting = "cors";
          response = await httpFetch(fetchParams);
        }
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request2.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request2.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request2.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert3(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request2.urlList);
      }
      if (!request2.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request2.headers.contains("range", true)) {
        response = internalResponse = makeNetworkError();
      }
      if (response.status !== 0 && (request2.method === "HEAD" || request2.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request2.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request2.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!bytesMatch(bytes, request2.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        await fullyReadBody(response.body, processBody, processBodyError);
      } else {
        fetchFinale(fetchParams, response);
      }
    }
    function schemeFetch(fetchParams) {
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
        return Promise.resolve(makeAppropriateNetworkError(fetchParams));
      }
      const { request: request2 } = fetchParams;
      const { protocol: scheme } = requestCurrentURL(request2);
      switch (scheme) {
        case "about:": {
          return Promise.resolve(makeNetworkError("about scheme is not supported"));
        }
        case "blob:": {
          if (!resolveObjectURL) {
            resolveObjectURL = __require("buffer").resolveObjectURL;
          }
          const blobURLEntry = requestCurrentURL(request2);
          if (blobURLEntry.search.length !== 0) {
            return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
          }
          const blob = resolveObjectURL(blobURLEntry.toString());
          if (request2.method !== "GET" || !webidl.is.Blob(blob)) {
            return Promise.resolve(makeNetworkError("invalid method"));
          }
          const response = makeResponse();
          const fullLength = blob.size;
          const serializedFullLength = isomorphicEncode(`${fullLength}`);
          const type = blob.type;
          if (!request2.headersList.contains("range", true)) {
            const bodyWithType = extractBody(blob);
            response.statusText = "OK";
            response.body = bodyWithType[0];
            response.headersList.set("content-length", serializedFullLength, true);
            response.headersList.set("content-type", type, true);
          } else {
            response.rangeRequested = true;
            const rangeHeader = request2.headersList.get("range", true);
            const rangeValue = simpleRangeHeaderValue(rangeHeader, true);
            if (rangeValue === "failure") {
              return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
            }
            let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue;
            if (rangeStart === null) {
              rangeStart = fullLength - rangeEnd;
              rangeEnd = rangeStart + rangeEnd - 1;
            } else {
              if (rangeStart >= fullLength) {
                return Promise.resolve(makeNetworkError("Range start is greater than the blob's size."));
              }
              if (rangeEnd === null || rangeEnd >= fullLength) {
                rangeEnd = fullLength - 1;
              }
            }
            const slicedBlob = blob.slice(rangeStart, rangeEnd, type);
            const slicedBodyWithType = extractBody(slicedBlob);
            response.body = slicedBodyWithType[0];
            const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`);
            const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);
            response.status = 206;
            response.statusText = "Partial Content";
            response.headersList.set("content-length", serializedSlicedLength, true);
            response.headersList.set("content-type", type, true);
            response.headersList.set("content-range", contentRange, true);
          }
          return Promise.resolve(response);
        }
        case "data:": {
          const currentURL = requestCurrentURL(request2);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return Promise.resolve(makeResponse({
            statusText: "OK",
            headersList: [
              ["content-type", { name: "Content-Type", value: mimeType }]
            ],
            body: safelyExtractBody(dataURLStruct.body)[0]
          }));
        }
        case "file:": {
          return Promise.resolve(makeNetworkError("not implemented... yet..."));
        }
        case "http:":
        case "https:": {
          return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return Promise.resolve(makeNetworkError("unknown scheme"));
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    function fetchFinale(fetchParams, response) {
      let timingInfo = fetchParams.timingInfo;
      const processResponseEndOfBody = () => {
        const unsafeEndTime = Date.now();
        if (fetchParams.request.destination === "document") {
          fetchParams.controller.fullTimingInfo = timingInfo;
        }
        fetchParams.controller.reportTimingSteps = () => {
          if (!urlIsHttpHttpsScheme(fetchParams.request.url)) {
            return;
          }
          timingInfo.endTime = unsafeEndTime;
          let cacheState = response.cacheState;
          const bodyInfo = response.bodyInfo;
          if (!response.timingAllowPassed) {
            timingInfo = createOpaqueTimingInfo(timingInfo);
            cacheState = "";
          }
          let responseStatus = 0;
          if (fetchParams.request.mode !== "navigator" || !response.hasCrossOriginRedirects) {
            responseStatus = response.status;
            const mimeType = extractMimeType(response.headersList);
            if (mimeType !== "failure") {
              bodyInfo.contentType = minimizeSupportedMimeType(mimeType);
            }
          }
          if (fetchParams.request.initiatorType != null) {
            markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);
          }
        };
        const processResponseEndOfBodyTask = () => {
          fetchParams.request.done = true;
          if (fetchParams.processResponseEndOfBody != null) {
            queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
          }
          if (fetchParams.request.initiatorType != null) {
            fetchParams.controller.reportTimingSteps();
          }
        };
        queueMicrotask(() => processResponseEndOfBodyTask());
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => {
          fetchParams.processResponse(response);
          fetchParams.processResponse = null;
        });
      }
      const internalResponse = response.type === "error" ? response : response.internalResponse ?? response;
      if (internalResponse.body == null) {
        processResponseEndOfBody();
      } else {
        finished(internalResponse.body.stream, () => {
          processResponseEndOfBody();
        });
      }
    }
    async function httpFetch(fetchParams) {
      const request2 = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (response === null) {
        if (request2.redirect === "follow") {
          request2.serviceWorkers = "none";
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request2.responseTainting === "cors" && corsCheck(request2, response) === "failure") {
          return makeNetworkError("cors failure");
        }
        if (TAOCheck(request2, response) === "failure") {
          request2.timingAllowFailed = true;
        }
      }
      if ((request2.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
        request2.origin,
        request2.client,
        request2.destination,
        actualResponse
      ) === "blocked") {
        return makeNetworkError("blocked");
      }
      if (redirectStatusSet.has(actualResponse.status)) {
        if (request2.redirect !== "manual") {
          fetchParams.controller.connection.destroy(void 0, false);
        }
        if (request2.redirect === "error") {
          response = makeNetworkError("unexpected redirect");
        } else if (request2.redirect === "manual") {
          response = actualResponse;
        } else if (request2.redirect === "follow") {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert3(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    function httpRedirectFetch(fetchParams, response) {
      const request2 = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request2).hash
        );
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        return Promise.resolve(makeNetworkError(err));
      }
      if (!urlIsHttpHttpsScheme(locationURL)) {
        return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
      }
      if (request2.redirectCount === 20) {
        return Promise.resolve(makeNetworkError("redirect count exceeded"));
      }
      request2.redirectCount += 1;
      if (request2.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request2, locationURL)) {
        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
      }
      if (request2.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
        return Promise.resolve(makeNetworkError(
          'URL cannot contain credentials for request mode "cors"'
        ));
      }
      if (actualResponse.status !== 303 && request2.body != null && request2.body.source == null) {
        return Promise.resolve(makeNetworkError());
      }
      if ([301, 302].includes(actualResponse.status) && request2.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request2.method)) {
        request2.method = "GET";
        request2.body = null;
        for (const headerName of requestBodyHeader) {
          request2.headersList.delete(headerName);
        }
      }
      if (!sameOrigin(requestCurrentURL(request2), locationURL)) {
        request2.headersList.delete("authorization", true);
        request2.headersList.delete("proxy-authorization", true);
        request2.headersList.delete("cookie", true);
        request2.headersList.delete("host", true);
      }
      if (request2.body != null) {
        assert3(request2.body.source != null);
        request2.body = safelyExtractBody(request2.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request2.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request2, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request2 = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      if (request2.window === "no-window" && request2.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request2;
      } else {
        httpRequest = cloneRequest(request2);
        httpFetchParams = { ...fetchParams };
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials = request2.credentials === "include" || request2.credentials === "same-origin" && request2.responseTainting === "basic";
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
        contentLengthHeaderValue = "0";
      }
      if (contentLength != null) {
        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append("content-length", contentLengthHeaderValue, true);
      }
      if (webidl.is.URL(httpRequest.referrer)) {
        httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href), true);
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.contains("user-agent", true)) {
        httpRequest.headersList.append("user-agent", defaultUserAgent, true);
      }
      if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since", true) || httpRequest.headersList.contains("if-none-match", true) || httpRequest.headersList.contains("if-unmodified-since", true) || httpRequest.headersList.contains("if-match", true) || httpRequest.headersList.contains("if-range", true))) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control", true)) {
        httpRequest.headersList.append("cache-control", "max-age=0", true);
      }
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        if (!httpRequest.headersList.contains("pragma", true)) {
          httpRequest.headersList.append("pragma", "no-cache", true);
        }
        if (!httpRequest.headersList.contains("cache-control", true)) {
          httpRequest.headersList.append("cache-control", "no-cache", true);
        }
      }
      if (httpRequest.headersList.contains("range", true)) {
        httpRequest.headersList.append("accept-encoding", "identity", true);
      }
      if (!httpRequest.headersList.contains("accept-encoding", true)) {
        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
          httpRequest.headersList.append("accept-encoding", "br, gzip, deflate", true);
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate", true);
        }
      }
      httpRequest.headersList.delete("host", true);
      {
        httpRequest.cache = "no-store";
      }
      if (response == null) {
        if (httpRequest.cache === "only-if-cached") {
          return makeNetworkError("only if cached");
        }
        const forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );
        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) ;
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.contains("range", true)) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request2.window === "no-window") {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError("proxy authentication required");
      }
      if (
        // response’s status is 421
        response.status === 421 && // isNewConnectionFetch is false
        !isNewConnectionFetch && // request’s body is null, or request’s body is non-null and request’s body’s source is non-null
        (request2.body == null || request2.body.source != null)
      ) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          true
        );
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert3(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err, abort = true) {
          if (!this.destroyed) {
            this.destroyed = true;
            if (abort) {
              this.abort?.(err ?? new DOMException("The operation was aborted.", "AbortError"));
            }
          }
        }
      };
      const request2 = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      {
        request2.cache = "no-store";
      }
      let requestBody = null;
      if (request2.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request2.body != null) {
        const processBodyChunk = async function* (bytes) {
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e);
          }
        };
        requestBody = async function* () {
          try {
            for await (const bytes of request2.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        }();
      }
      try {
        const { body, status: status2, statusText, headersList, socket } = await dispatch({ body: requestBody });
        if (socket) {
          response = makeResponse({ status: status2, statusText, headersList, socket });
        } else {
          const iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next();
          response = makeResponse({ status: status2, statusText, headersList });
        }
      } catch (err) {
        if (err.name === "AbortError") {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams, err);
        }
        return makeNetworkError(err);
      }
      const pullAlgorithm = () => {
        return fetchParams.controller.resume();
      };
      const cancelAlgorithm = (reason) => {
        if (!isCancelled(fetchParams)) {
          fetchParams.controller.abort(reason);
        }
      };
      const stream = new ReadableStream(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm();
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          },
          type: "bytes"
        }
      );
      response.body = { stream, source: null, length: null };
      if (!fetchParams.controller.resume) {
        fetchParams.controller.on("terminated", onAborted);
      }
      fetchParams.controller.resume = async () => {
        while (true) {
          let bytes;
          let isFailure5;
          try {
            const { done: done11, value } = await fetchParams.controller.next();
            if (isAborted(fetchParams)) {
              break;
            }
            bytes = done11 ? void 0 : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err;
              isFailure5 = true;
            }
          }
          if (bytes === void 0) {
            readableStreamClose(fetchParams.controller.controller);
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
          if (isFailure5) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          const buffer4 = new Uint8Array(bytes);
          if (buffer4.byteLength) {
            fetchParams.controller.controller.enqueue(buffer4);
          }
          if (isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }
          if (fetchParams.controller.controller.desiredSize <= 0) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(
              fetchParams.controller.serializedAbortReason
            );
          }
        } else {
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(new TypeError("terminated", {
              cause: isErrorLike(reason) ? reason : void 0
            }));
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      function dispatch({ body }) {
        const url3 = requestCurrentURL(request2);
        const agent = fetchParams.controller.dispatcher;
        return new Promise((resolve9, reject) => agent.dispatch(
          {
            path: url3.pathname + url3.search,
            origin: url3.origin,
            method: request2.method,
            body: agent.isMockActive ? request2.body && (request2.body.source || request2.body.stream) : body,
            headers: request2.headersList.entries,
            maxRedirections: 0,
            upgrade: request2.mode === "websocket" ? "websocket" : void 0
          },
          {
            body: null,
            abort: null,
            onConnect(abort) {
              const { connection } = fetchParams.controller;
              timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(void 0, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability);
              if (connection.destroyed) {
                abort(new DOMException("The operation was aborted.", "AbortError"));
              } else {
                fetchParams.controller.on("terminated", abort);
                this.abort = connection.abort = abort;
              }
              timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
            },
            onResponseStarted() {
              timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
            },
            onHeaders(status2, rawHeaders, resume2, statusText) {
              if (status2 < 200) {
                return;
              }
              let codings = [];
              let location = "";
              const headersList = new HeadersList();
              for (let i = 0; i < rawHeaders.length; i += 2) {
                headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
              }
              const contentEncoding = headersList.get("content-encoding", true);
              if (contentEncoding) {
                codings = contentEncoding.toLowerCase().split(",").map((x2) => x2.trim());
              }
              location = headersList.get("location", true);
              this.body = new Readable2({ read: resume2 });
              const decoders = [];
              const willFollow = location && request2.redirect === "follow" && redirectStatusSet.has(status2);
              if (codings.length !== 0 && request2.method !== "HEAD" && request2.method !== "CONNECT" && !nullBodyStatus.includes(status2) && !willFollow) {
                for (let i = codings.length - 1; i >= 0; --i) {
                  const coding = codings[i];
                  if (coding === "x-gzip" || coding === "gzip") {
                    decoders.push(zlib.createGunzip({
                      // Be less strict when decoding compressed responses, since sometimes
                      // servers send slightly invalid responses that are still accepted
                      // by common browsers.
                      // Always using Z_SYNC_FLUSH is what cURL does.
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "deflate") {
                    decoders.push(createInflate({
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "br") {
                    decoders.push(zlib.createBrotliDecompress({
                      flush: zlib.constants.BROTLI_OPERATION_FLUSH,
                      finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
                    }));
                  } else {
                    decoders.length = 0;
                    break;
                  }
                }
              }
              const onError7 = this.onError.bind(this);
              resolve9({
                status: status2,
                statusText,
                headersList,
                body: decoders.length ? pipeline(this.body, ...decoders, (err) => {
                  if (err) {
                    this.onError(err);
                  }
                }).on("error", onError7) : this.body.on("error", onError7)
              });
              return true;
            },
            onData(chunk5) {
              if (fetchParams.controller.dump) {
                return;
              }
              const bytes = chunk5;
              timingInfo.encodedBodySize += bytes.byteLength;
              return this.body.push(bytes);
            },
            onComplete() {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              fetchParams.controller.ended = true;
              this.body.push(null);
            },
            onError(error4) {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              this.body?.destroy(error4);
              fetchParams.controller.terminate(error4);
              reject(error4);
            },
            onUpgrade(status2, rawHeaders, socket) {
              if (status2 !== 101) {
                return;
              }
              const headersList = new HeadersList();
              for (let i = 0; i < rawHeaders.length; i += 2) {
                headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
              }
              resolve9({
                status: status2,
                statusText: STATUS_CODES[status2],
                headersList,
                socket
              });
              return true;
            }
          }
        ));
      }
    }
    module.exports = {
      fetch,
      Fetch,
      fetching,
      finalizeAndReportTiming
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/cache/util.js
var require_util3 = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/cache/util.js"(exports, module) {
    var assert3 = __require("assert");
    var { URLSerializer } = require_data_url();
    var { isValidHeaderName } = require_util2();
    function urlEquals(A3, B3, excludeFragment = false) {
      const serializedA = URLSerializer(A3, excludeFragment);
      const serializedB = URLSerializer(B3, excludeFragment);
      return serializedA === serializedB;
    }
    function getFieldValues(header) {
      assert3(header !== null);
      const values3 = [];
      for (let value of header.split(",")) {
        value = value.trim();
        if (isValidHeaderName(value)) {
          values3.push(value);
        }
      }
      return values3;
    }
    module.exports = {
      urlEquals,
      getFieldValues
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/cache/cache.js
var require_cache3 = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/cache/cache.js"(exports, module) {
    var { kConstruct } = require_symbols();
    var { urlEquals, getFieldValues } = require_util3();
    var { kEnumerableProperty, isDisturbed } = require_util();
    var { webidl } = require_webidl();
    var { cloneResponse, fromInnerResponse, getResponseState } = require_response();
    var { Request, fromInnerRequest, getRequestState } = require_request2();
    var { fetching } = require_fetch();
    var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
    var assert3 = __require("assert");
    var Cache = class _Cache {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
       * @type {requestResponseList}
       */
      #relevantRequestResponseList;
      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        webidl.util.markAsUncloneable(this);
        this.#relevantRequestResponseList = arguments[1];
      }
      async match(request2, options = {}) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.match";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        request2 = webidl.converters.RequestInfo(request2, prefix, "request");
        options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        const p3 = this.#internalMatchAll(request2, options, 1);
        if (p3.length === 0) {
          return;
        }
        return p3[0];
      }
      async matchAll(request2 = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.matchAll";
        if (request2 !== void 0) request2 = webidl.converters.RequestInfo(request2, prefix, "request");
        options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        return this.#internalMatchAll(request2, options);
      }
      async add(request2) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.add";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        request2 = webidl.converters.RequestInfo(request2, prefix, "request");
        const requests = [request2];
        const responseArrayPromise = this.addAll(requests);
        return await responseArrayPromise;
      }
      async addAll(requests) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.addAll";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        const responsePromises = [];
        const requestList = [];
        for (let request2 of requests) {
          if (request2 === void 0) {
            throw webidl.errors.conversionFailed({
              prefix,
              argument: "Argument 1",
              types: ["undefined is not allowed"]
            });
          }
          request2 = webidl.converters.RequestInfo(request2);
          if (typeof request2 === "string") {
            continue;
          }
          const r = getRequestState(request2);
          if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
            throw webidl.errors.exception({
              header: prefix,
              message: "Expected http/s scheme when method is not GET."
            });
          }
        }
        const fetchControllers = [];
        for (const request2 of requests) {
          const r = getRequestState(new Request(request2));
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: prefix,
              message: "Expected http/s scheme."
            });
          }
          r.initiator = "fetch";
          r.destination = "subresource";
          requestList.push(r);
          const responsePromise = createDeferredPromise();
          fetchControllers.push(fetching({
            request: r,
            processResponse(response) {
              if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
                responsePromise.reject(webidl.errors.exception({
                  header: "Cache.addAll",
                  message: "Received an invalid status code or the request failed."
                }));
              } else if (response.headersList.contains("vary")) {
                const fieldValues = getFieldValues(response.headersList.get("vary"));
                for (const fieldValue of fieldValues) {
                  if (fieldValue === "*") {
                    responsePromise.reject(webidl.errors.exception({
                      header: "Cache.addAll",
                      message: "invalid vary field value"
                    }));
                    for (const controller of fetchControllers) {
                      controller.abort();
                    }
                    return;
                  }
                }
              }
            },
            processResponseEndOfBody(response) {
              if (response.aborted) {
                responsePromise.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              responsePromise.resolve(response);
            }
          }));
          responsePromises.push(responsePromise.promise);
        }
        const p3 = Promise.all(responsePromises);
        const responses = await p3;
        const operations = [];
        let index = 0;
        for (const response of responses) {
          const operation = {
            type: "put",
            // 7.3.2
            request: requestList[index],
            // 7.3.3
            response
            // 7.3.4
          };
          operations.push(operation);
          index++;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(void 0);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async put(request2, response) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.put";
        webidl.argumentLengthCheck(arguments, 2, prefix);
        request2 = webidl.converters.RequestInfo(request2, prefix, "request");
        response = webidl.converters.Response(response, prefix, "response");
        let innerRequest = null;
        if (webidl.is.Request(request2)) {
          innerRequest = getRequestState(request2);
        } else {
          innerRequest = getRequestState(new Request(request2));
        }
        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected an http/s scheme when method is not GET"
          });
        }
        const innerResponse = getResponseState(response);
        if (innerResponse.status === 206) {
          throw webidl.errors.exception({
            header: prefix,
            message: "Got 206 status"
          });
        }
        if (innerResponse.headersList.contains("vary")) {
          const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
          for (const fieldValue of fieldValues) {
            if (fieldValue === "*") {
              throw webidl.errors.exception({
                header: prefix,
                message: "Got * vary field value"
              });
            }
          }
        }
        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
          throw webidl.errors.exception({
            header: prefix,
            message: "Response body is locked or disturbed"
          });
        }
        const clonedResponse = cloneResponse(innerResponse);
        const bodyReadPromise = createDeferredPromise();
        if (innerResponse.body != null) {
          const stream = innerResponse.body.stream;
          const reader = stream.getReader();
          readAllBytes(reader, bodyReadPromise.resolve, bodyReadPromise.reject);
        } else {
          bodyReadPromise.resolve(void 0);
        }
        const operations = [];
        const operation = {
          type: "put",
          // 14.
          request: innerRequest,
          // 15.
          response: clonedResponse
          // 16.
        };
        operations.push(operation);
        const bytes = await bodyReadPromise.promise;
        if (clonedResponse.body != null) {
          clonedResponse.body.source = bytes;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve();
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async delete(request2, options = {}) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.delete";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        request2 = webidl.converters.RequestInfo(request2, prefix, "request");
        options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        let r = null;
        if (webidl.is.Request(request2)) {
          r = getRequestState(request2);
          if (r.method !== "GET" && !options.ignoreMethod) {
            return false;
          }
        } else {
          assert3(typeof request2 === "string");
          r = getRequestState(new Request(request2));
        }
        const operations = [];
        const operation = {
          type: "delete",
          request: r,
          options
        };
        operations.push(operation);
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        let requestResponses;
        try {
          requestResponses = this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(!!requestResponses?.length);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
       * @param {any} request
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @returns {Promise<readonly Request[]>}
       */
      async keys(request2 = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.keys";
        if (request2 !== void 0) request2 = webidl.converters.RequestInfo(request2, prefix, "request");
        options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        let r = null;
        if (request2 !== void 0) {
          if (webidl.is.Request(request2)) {
            r = getRequestState(request2);
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request2 === "string") {
            r = getRequestState(new Request(request2));
          }
        }
        const promise3 = createDeferredPromise();
        const requests = [];
        if (request2 === void 0) {
          for (const requestResponse of this.#relevantRequestResponseList) {
            requests.push(requestResponse[0]);
          }
        } else {
          const requestResponses = this.#queryCache(r, options);
          for (const requestResponse of requestResponses) {
            requests.push(requestResponse[0]);
          }
        }
        queueMicrotask(() => {
          const requestList = [];
          for (const request3 of requests) {
            const requestObject = fromInnerRequest(
              request3,
              void 0,
              new AbortController().signal,
              "immutable"
            );
            requestList.push(requestObject);
          }
          promise3.resolve(Object.freeze(requestList));
        });
        return promise3.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
       * @param {CacheBatchOperation[]} operations
       * @returns {requestResponseList}
       */
      #batchCacheOperations(operations) {
        const cache3 = this.#relevantRequestResponseList;
        const backupCache = [...cache3];
        const addedItems = [];
        const resultList = [];
        try {
          for (const operation of operations) {
            if (operation.type !== "delete" && operation.type !== "put") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: 'operation type does not match "delete" or "put"'
              });
            }
            if (operation.type === "delete" && operation.response != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "delete operation should not have an associated response"
              });
            }
            if (this.#queryCache(operation.request, operation.options, addedItems).length) {
              throw new DOMException("???", "InvalidStateError");
            }
            let requestResponses;
            if (operation.type === "delete") {
              requestResponses = this.#queryCache(operation.request, operation.options);
              if (requestResponses.length === 0) {
                return [];
              }
              for (const requestResponse of requestResponses) {
                const idx = cache3.indexOf(requestResponse);
                assert3(idx !== -1);
                cache3.splice(idx, 1);
              }
            } else if (operation.type === "put") {
              if (operation.response == null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "put operation should have an associated response"
                });
              }
              const r = operation.request;
              if (!urlIsHttpHttpsScheme(r.url)) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "expected http or https scheme"
                });
              }
              if (r.method !== "GET") {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "not get method"
                });
              }
              if (operation.options != null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "options must not be defined"
                });
              }
              requestResponses = this.#queryCache(operation.request);
              for (const requestResponse of requestResponses) {
                const idx = cache3.indexOf(requestResponse);
                assert3(idx !== -1);
                cache3.splice(idx, 1);
              }
              cache3.push([operation.request, operation.response]);
              addedItems.push([operation.request, operation.response]);
            }
            resultList.push([operation.request, operation.response]);
          }
          return resultList;
        } catch (e) {
          this.#relevantRequestResponseList.length = 0;
          this.#relevantRequestResponseList = backupCache;
          throw e;
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#query-cache
       * @param {any} requestQuery
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @param {requestResponseList} targetStorage
       * @returns {requestResponseList}
       */
      #queryCache(requestQuery, options, targetStorage) {
        const resultList = [];
        const storage = targetStorage ?? this.#relevantRequestResponseList;
        for (const requestResponse of storage) {
          const [cachedRequest, cachedResponse] = requestResponse;
          if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
            resultList.push(requestResponse);
          }
        }
        return resultList;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
       * @param {any} requestQuery
       * @param {any} request
       * @param {any | null} response
       * @param {import('../../types/cache').CacheQueryOptions | undefined} options
       * @returns {boolean}
       */
      #requestMatchesCachedItem(requestQuery, request2, response = null, options) {
        const queryURL = new URL(requestQuery.url);
        const cachedURL = new URL(request2.url);
        if (options?.ignoreSearch) {
          cachedURL.search = "";
          queryURL.search = "";
        }
        if (!urlEquals(queryURL, cachedURL, true)) {
          return false;
        }
        if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
          return true;
        }
        const fieldValues = getFieldValues(response.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            return false;
          }
          const requestValue = request2.headersList.get(fieldValue);
          const queryValue = requestQuery.headersList.get(fieldValue);
          if (requestValue !== queryValue) {
            return false;
          }
        }
        return true;
      }
      #internalMatchAll(request2, options, maxResponses = Infinity) {
        let r = null;
        if (request2 !== void 0) {
          if (webidl.is.Request(request2)) {
            r = getRequestState(request2);
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request2 === "string") {
            r = getRequestState(new Request(request2));
          }
        }
        const responses = [];
        if (request2 === void 0) {
          for (const requestResponse of this.#relevantRequestResponseList) {
            responses.push(requestResponse[1]);
          }
        } else {
          const requestResponses = this.#queryCache(r, options);
          for (const requestResponse of requestResponses) {
            responses.push(requestResponse[1]);
          }
        }
        const responseList = [];
        for (const response of responses) {
          const responseObject = fromInnerResponse(response, "immutable");
          responseList.push(responseObject.clone());
          if (responseList.length >= maxResponses) {
            break;
          }
        }
        return Object.freeze(responseList);
      }
    };
    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: {
        value: "Cache",
        configurable: true
      },
      match: kEnumerableProperty,
      matchAll: kEnumerableProperty,
      add: kEnumerableProperty,
      addAll: kEnumerableProperty,
      put: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    var cacheQueryOptionConverters = [
      {
        key: "ignoreSearch",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "ignoreMethod",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "ignoreVary",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      }
    ];
    webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
    webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
      ...cacheQueryOptionConverters,
      {
        key: "cacheName",
        converter: webidl.converters.DOMString
      }
    ]);
    webidl.converters.Response = webidl.interfaceConverter(
      webidl.is.Response,
      "Response"
    );
    webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
      webidl.converters.RequestInfo
    );
    module.exports = {
      Cache
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/cache/cachestorage.js
var require_cachestorage = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/cache/cachestorage.js"(exports, module) {
    var { Cache } = require_cache3();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var { kConstruct } = require_symbols();
    var CacheStorage = class _CacheStorage {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
       * @type {Map<string, import('./cache').requestResponseList}
       */
      #caches = /* @__PURE__ */ new Map();
      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        webidl.util.markAsUncloneable(this);
      }
      async match(request2, options = {}) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, "CacheStorage.match");
        request2 = webidl.converters.RequestInfo(request2);
        options = webidl.converters.MultiCacheQueryOptions(options);
        if (options.cacheName != null) {
          if (this.#caches.has(options.cacheName)) {
            const cacheList = this.#caches.get(options.cacheName);
            const cache3 = new Cache(kConstruct, cacheList);
            return await cache3.match(request2, options);
          }
        } else {
          for (const cacheList of this.#caches.values()) {
            const cache3 = new Cache(kConstruct, cacheList);
            const response = await cache3.match(request2, options);
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async has(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        const prefix = "CacheStorage.has";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
        return this.#caches.has(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
       * @param {string} cacheName
       * @returns {Promise<Cache>}
       */
      async open(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        const prefix = "CacheStorage.open";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
        if (this.#caches.has(cacheName)) {
          const cache4 = this.#caches.get(cacheName);
          return new Cache(kConstruct, cache4);
        }
        const cache3 = [];
        this.#caches.set(cacheName, cache3);
        return new Cache(kConstruct, cache3);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async delete(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        const prefix = "CacheStorage.delete";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
        return this.#caches.delete(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
       * @returns {Promise<string[]>}
       */
      async keys() {
        webidl.brandCheck(this, _CacheStorage);
        const keys5 = this.#caches.keys();
        return [...keys5];
      }
    };
    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: {
        value: "CacheStorage",
        configurable: true
      },
      match: kEnumerableProperty,
      has: kEnumerableProperty,
      open: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    module.exports = {
      CacheStorage
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/cookies/constants.js
var require_constants4 = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/cookies/constants.js"(exports, module) {
    var maxAttributeValueSize = 1024;
    var maxNameValuePairSize = 4096;
    module.exports = {
      maxAttributeValueSize,
      maxNameValuePairSize
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/cookies/util.js
var require_util4 = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/cookies/util.js"(exports, module) {
    function isCTLExcludingHtab(value) {
      for (let i = 0; i < value.length; ++i) {
        const code = value.charCodeAt(i);
        if (code >= 0 && code <= 8 || code >= 10 && code <= 31 || code === 127) {
          return true;
        }
      }
      return false;
    }
    function validateCookieName(name) {
      for (let i = 0; i < name.length; ++i) {
        const code = name.charCodeAt(i);
        if (code < 33 || // exclude CTLs (0-31), SP and HT
        code > 126 || // exclude non-ascii and DEL
        code === 34 || // "
        code === 40 || // (
        code === 41 || // )
        code === 60 || // <
        code === 62 || // >
        code === 64 || // @
        code === 44 || // ,
        code === 59 || // ;
        code === 58 || // :
        code === 92 || // \
        code === 47 || // /
        code === 91 || // [
        code === 93 || // ]
        code === 63 || // ?
        code === 61 || // =
        code === 123 || // {
        code === 125) {
          throw new Error("Invalid cookie name");
        }
      }
    }
    function validateCookieValue(value) {
      let len = value.length;
      let i = 0;
      if (value[0] === '"') {
        if (len === 1 || value[len - 1] !== '"') {
          throw new Error("Invalid cookie value");
        }
        --len;
        ++i;
      }
      while (i < len) {
        const code = value.charCodeAt(i++);
        if (code < 33 || // exclude CTLs (0-31)
        code > 126 || // non-ascii and DEL (127)
        code === 34 || // "
        code === 44 || // ,
        code === 59 || // ;
        code === 92) {
          throw new Error("Invalid cookie value");
        }
      }
    }
    function validateCookiePath(path3) {
      for (let i = 0; i < path3.length; ++i) {
        const code = path3.charCodeAt(i);
        if (code < 32 || // exclude CTLs (0-31)
        code === 127 || // DEL
        code === 59) {
          throw new Error("Invalid cookie path");
        }
      }
    }
    function validateCookieDomain(domain) {
      if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
        throw new Error("Invalid cookie domain");
      }
    }
    var IMFDays = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    var IMFMonths = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var IMFPaddedNumbers = Array(61).fill(0).map((_2, i) => i.toString().padStart(2, "0"));
    function toIMFDate(date3) {
      if (typeof date3 === "number") {
        date3 = new Date(date3);
      }
      return `${IMFDays[date3.getUTCDay()]}, ${IMFPaddedNumbers[date3.getUTCDate()]} ${IMFMonths[date3.getUTCMonth()]} ${date3.getUTCFullYear()} ${IMFPaddedNumbers[date3.getUTCHours()]}:${IMFPaddedNumbers[date3.getUTCMinutes()]}:${IMFPaddedNumbers[date3.getUTCSeconds()]} GMT`;
    }
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0) {
        throw new Error("Invalid cookie max-age");
      }
    }
    function stringify(cookie) {
      if (cookie.name.length === 0) {
        return null;
      }
      validateCookieName(cookie.name);
      validateCookieValue(cookie.value);
      const out = [`${cookie.name}=${cookie.value}`];
      if (cookie.name.startsWith("__Secure-")) {
        cookie.secure = true;
      }
      if (cookie.name.startsWith("__Host-")) {
        cookie.secure = true;
        cookie.domain = null;
        cookie.path = "/";
      }
      if (cookie.secure) {
        out.push("Secure");
      }
      if (cookie.httpOnly) {
        out.push("HttpOnly");
      }
      if (typeof cookie.maxAge === "number") {
        validateCookieMaxAge(cookie.maxAge);
        out.push(`Max-Age=${cookie.maxAge}`);
      }
      if (cookie.domain) {
        validateCookieDomain(cookie.domain);
        out.push(`Domain=${cookie.domain}`);
      }
      if (cookie.path) {
        validateCookiePath(cookie.path);
        out.push(`Path=${cookie.path}`);
      }
      if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
        out.push(`Expires=${toIMFDate(cookie.expires)}`);
      }
      if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
      }
      for (const part of cookie.unparsed) {
        if (!part.includes("=")) {
          throw new Error("Invalid unparsed");
        }
        const [key, ...value] = part.split("=");
        out.push(`${key.trim()}=${value.join("=")}`);
      }
      return out.join("; ");
    }
    module.exports = {
      isCTLExcludingHtab,
      validateCookieName,
      validateCookiePath,
      validateCookieValue,
      toIMFDate,
      stringify
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/cookies/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/cookies/parse.js"(exports, module) {
    var { maxNameValuePairSize, maxAttributeValueSize } = require_constants4();
    var { isCTLExcludingHtab } = require_util4();
    var { collectASequenceOfCodePointsFast } = require_data_url();
    var assert3 = __require("assert");
    var { unescape: unescape2 } = __require("querystring");
    function parseSetCookie(header) {
      if (isCTLExcludingHtab(header)) {
        return null;
      }
      let nameValuePair = "";
      let unparsedAttributes = "";
      let name = "";
      let value = "";
      if (header.includes(";")) {
        const position = { position: 0 };
        nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
        unparsedAttributes = header.slice(position.position);
      } else {
        nameValuePair = header;
      }
      if (!nameValuePair.includes("=")) {
        value = nameValuePair;
      } else {
        const position = { position: 0 };
        name = collectASequenceOfCodePointsFast(
          "=",
          nameValuePair,
          position
        );
        value = nameValuePair.slice(position.position + 1);
      }
      name = name.trim();
      value = value.trim();
      if (name.length + value.length > maxNameValuePairSize) {
        return null;
      }
      return {
        name,
        value: unescape2(value),
        ...parseUnparsedAttributes(unparsedAttributes)
      };
    }
    function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
      if (unparsedAttributes.length === 0) {
        return cookieAttributeList;
      }
      assert3(unparsedAttributes[0] === ";");
      unparsedAttributes = unparsedAttributes.slice(1);
      let cookieAv = "";
      if (unparsedAttributes.includes(";")) {
        cookieAv = collectASequenceOfCodePointsFast(
          ";",
          unparsedAttributes,
          { position: 0 }
        );
        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
      } else {
        cookieAv = unparsedAttributes;
        unparsedAttributes = "";
      }
      let attributeName = "";
      let attributeValue = "";
      if (cookieAv.includes("=")) {
        const position = { position: 0 };
        attributeName = collectASequenceOfCodePointsFast(
          "=",
          cookieAv,
          position
        );
        attributeValue = cookieAv.slice(position.position + 1);
      } else {
        attributeName = cookieAv;
      }
      attributeName = attributeName.trim();
      attributeValue = attributeValue.trim();
      if (attributeValue.length > maxAttributeValueSize) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const attributeNameLowercase = attributeName.toLowerCase();
      if (attributeNameLowercase === "expires") {
        const expiryTime = new Date(attributeValue);
        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === "max-age") {
        const charCode = attributeValue.charCodeAt(0);
        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        if (!/^\d+$/.test(attributeValue)) {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        const deltaSeconds = Number(attributeValue);
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === "domain") {
        let cookieDomain = attributeValue;
        if (cookieDomain[0] === ".") {
          cookieDomain = cookieDomain.slice(1);
        }
        cookieDomain = cookieDomain.toLowerCase();
        cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === "path") {
        let cookiePath = "";
        if (attributeValue.length === 0 || attributeValue[0] !== "/") {
          cookiePath = "/";
        } else {
          cookiePath = attributeValue;
        }
        cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === "secure") {
        cookieAttributeList.secure = true;
      } else if (attributeNameLowercase === "httponly") {
        cookieAttributeList.httpOnly = true;
      } else if (attributeNameLowercase === "samesite") {
        let enforcement = "Default";
        const attributeValueLowercase = attributeValue.toLowerCase();
        if (attributeValueLowercase.includes("none")) {
          enforcement = "None";
        }
        if (attributeValueLowercase.includes("strict")) {
          enforcement = "Strict";
        }
        if (attributeValueLowercase.includes("lax")) {
          enforcement = "Lax";
        }
        cookieAttributeList.sameSite = enforcement;
      } else {
        cookieAttributeList.unparsed ??= [];
        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      }
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    module.exports = {
      parseSetCookie,
      parseUnparsedAttributes
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/cookies/index.js
var require_cookies = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/cookies/index.js"(exports, module) {
    var { parseSetCookie } = require_parse();
    var { stringify } = require_util4();
    var { webidl } = require_webidl();
    var { Headers } = require_headers();
    var brandChecks = webidl.brandCheckMultiple([Headers, globalThis.Headers].filter(Boolean));
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, "getCookies");
      brandChecks(headers);
      const cookie = headers.get("cookie");
      const out = {};
      if (!cookie) {
        return out;
      }
      for (const piece of cookie.split(";")) {
        const [name, ...value] = piece.split("=");
        out[name.trim()] = value.join("=");
      }
      return out;
    }
    function deleteCookie(headers, name, attributes) {
      brandChecks(headers);
      const prefix = "deleteCookie";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      name = webidl.converters.DOMString(name, prefix, "name");
      attributes = webidl.converters.DeleteCookieAttributes(attributes);
      setCookie(headers, {
        name,
        value: "",
        expires: /* @__PURE__ */ new Date(0),
        ...attributes
      });
    }
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, "getSetCookies");
      brandChecks(headers);
      const cookies = headers.getSetCookie();
      if (!cookies) {
        return [];
      }
      return cookies.map((pair) => parseSetCookie(pair));
    }
    function parseCookie(cookie) {
      cookie = webidl.converters.DOMString(cookie);
      return parseSetCookie(cookie);
    }
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, "setCookie");
      brandChecks(headers);
      cookie = webidl.converters.Cookie(cookie);
      const str = stringify(cookie);
      if (str) {
        headers.append("set-cookie", str, true);
      }
    }
    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: () => null
      }
    ]);
    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: "name"
      },
      {
        converter: webidl.converters.DOMString,
        key: "value"
      },
      {
        converter: webidl.nullableConverter((value) => {
          if (typeof value === "number") {
            return webidl.converters["unsigned long long"](value);
          }
          return new Date(value);
        }),
        key: "expires",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters["long long"]),
        key: "maxAge",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "secure",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "httpOnly",
        defaultValue: () => null
      },
      {
        converter: webidl.converters.USVString,
        key: "sameSite",
        allowedValues: ["Strict", "Lax", "None"]
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: "unparsed",
        defaultValue: () => new Array(0)
      }
    ]);
    module.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie,
      parseCookie
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/events.js
var require_events = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/events.js"(exports, module) {
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var { kConstruct } = require_symbols();
    var MessageEvent = class _MessageEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        if (type === kConstruct) {
          super(arguments[1], arguments[2]);
          webidl.util.markAsUncloneable(this);
          return;
        }
        const prefix = "MessageEvent constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        type = webidl.converters.DOMString(type, prefix, "type");
        eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, "eventInitDict");
        super(type, eventInitDict);
        this.#eventInit = eventInitDict;
        webidl.util.markAsUncloneable(this);
      }
      get data() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.data;
      }
      get origin() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.origin;
      }
      get lastEventId() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.lastEventId;
      }
      get source() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.source;
      }
      get ports() {
        webidl.brandCheck(this, _MessageEvent);
        if (!Object.isFrozen(this.#eventInit.ports)) {
          Object.freeze(this.#eventInit.ports);
        }
        return this.#eventInit.ports;
      }
      initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
        webidl.brandCheck(this, _MessageEvent);
        webidl.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent");
        return new _MessageEvent(type, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId,
          source,
          ports
        });
      }
      static createFastMessageEvent(type, init2) {
        const messageEvent = new _MessageEvent(kConstruct, type, init2);
        messageEvent.#eventInit = init2;
        messageEvent.#eventInit.data ??= null;
        messageEvent.#eventInit.origin ??= "";
        messageEvent.#eventInit.lastEventId ??= "";
        messageEvent.#eventInit.source ??= null;
        messageEvent.#eventInit.ports ??= [];
        return messageEvent;
      }
    };
    var { createFastMessageEvent } = MessageEvent;
    delete MessageEvent.createFastMessageEvent;
    var CloseEvent = class _CloseEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        const prefix = "CloseEvent constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        type = webidl.converters.DOMString(type, prefix, "type");
        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
        super(type, eventInitDict);
        this.#eventInit = eventInitDict;
        webidl.util.markAsUncloneable(this);
      }
      get wasClean() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.wasClean;
      }
      get code() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.code;
      }
      get reason() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.reason;
      }
    };
    var ErrorEvent = class _ErrorEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict) {
        const prefix = "ErrorEvent constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        super(type, eventInitDict);
        webidl.util.markAsUncloneable(this);
        type = webidl.converters.DOMString(type, prefix, "type");
        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
        this.#eventInit = eventInitDict;
      }
      get message() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.message;
      }
      get filename() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.filename;
      }
      get lineno() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.lineno;
      }
      get colno() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.colno;
      }
      get error() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.error;
      }
    };
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "MessageEvent",
        configurable: true
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty
    });
    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "CloseEvent",
        configurable: true
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty
    });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "ErrorEvent",
        configurable: true
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty
    });
    webidl.converters.MessagePort = webidl.interfaceConverter(
      webidl.is.MessagePort,
      "MessagePort"
    );
    webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
      webidl.converters.MessagePort
    );
    var eventInit = [
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      }
    ];
    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "data",
        converter: webidl.converters.any,
        defaultValue: () => null
      },
      {
        key: "origin",
        converter: webidl.converters.USVString,
        defaultValue: () => ""
      },
      {
        key: "lastEventId",
        converter: webidl.converters.DOMString,
        defaultValue: () => ""
      },
      {
        key: "source",
        // Node doesn't implement WindowProxy or ServiceWorker, so the only
        // valid value for source is a MessagePort.
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: () => null
      },
      {
        key: "ports",
        converter: webidl.converters["sequence<MessagePort>"],
        defaultValue: () => new Array(0)
      }
    ]);
    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "wasClean",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "code",
        converter: webidl.converters["unsigned short"],
        defaultValue: () => 0
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: () => ""
      }
    ]);
    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "message",
        converter: webidl.converters.DOMString,
        defaultValue: () => ""
      },
      {
        key: "filename",
        converter: webidl.converters.USVString,
        defaultValue: () => ""
      },
      {
        key: "lineno",
        converter: webidl.converters["unsigned long"],
        defaultValue: () => 0
      },
      {
        key: "colno",
        converter: webidl.converters["unsigned long"],
        defaultValue: () => 0
      },
      {
        key: "error",
        converter: webidl.converters.any
      }
    ]);
    module.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent,
      createFastMessageEvent
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/constants.js
var require_constants5 = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/constants.js"(exports, module) {
    var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    var states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    };
    var sentCloseFrameState = {
      SENT: 1,
      RECEIVED: 2
    };
    var opcodes = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      CLOSE: 8,
      PING: 9,
      PONG: 10
    };
    var maxUnsigned16Bit = 65535;
    var parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4
    };
    var emptyBuffer = Buffer.allocUnsafe(0);
    var sendHints = {
      text: 1,
      typedArray: 2,
      arrayBuffer: 3,
      blob: 4
    };
    module.exports = {
      uid,
      sentCloseFrameState,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer,
      sendHints
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/util.js
var require_util5 = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/util.js"(exports, module) {
    var { states, opcodes } = require_constants5();
    var { isUtf8 } = __require("buffer");
    var { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = require_data_url();
    function isConnecting(readyState) {
      return readyState === states.CONNECTING;
    }
    function isEstablished(readyState) {
      return readyState === states.OPEN;
    }
    function isClosing(readyState) {
      return readyState === states.CLOSING;
    }
    function isClosed(readyState) {
      return readyState === states.CLOSED;
    }
    function fireEvent(e, target, eventFactory = (type, init2) => new Event(type, init2), eventInitDict = {}) {
      const event = eventFactory(e, eventInitDict);
      target.dispatchEvent(event);
    }
    function websocketMessageReceived(handler, type, data) {
      handler.onMessage(type, data);
    }
    function toArrayBuffer(buffer4) {
      if (buffer4.byteLength === buffer4.buffer.byteLength) {
        return buffer4.buffer;
      }
      return new Uint8Array(buffer4).buffer;
    }
    function isValidSubprotocol(protocol) {
      if (protocol.length === 0) {
        return false;
      }
      for (let i = 0; i < protocol.length; ++i) {
        const code = protocol.charCodeAt(i);
        if (code < 33 || // CTL, contains SP (0x20) and HT (0x09)
        code > 126 || code === 34 || // "
        code === 40 || // (
        code === 41 || // )
        code === 44 || // ,
        code === 47 || // /
        code === 58 || // :
        code === 59 || // ;
        code === 60 || // <
        code === 61 || // =
        code === 62 || // >
        code === 63 || // ?
        code === 64 || // @
        code === 91 || // [
        code === 92 || // \
        code === 93 || // ]
        code === 123 || // {
        code === 125) {
          return false;
        }
      }
      return true;
    }
    function isValidStatusCode(code) {
      if (code >= 1e3 && code < 1015) {
        return code !== 1004 && // reserved
        code !== 1005 && // "MUST NOT be set as a status code"
        code !== 1006;
      }
      return code >= 3e3 && code <= 4999;
    }
    function isControlFrame(opcode) {
      return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;
    }
    function isContinuationFrame(opcode) {
      return opcode === opcodes.CONTINUATION;
    }
    function isTextBinaryFrame(opcode) {
      return opcode === opcodes.TEXT || opcode === opcodes.BINARY;
    }
    function isValidOpcode(opcode) {
      return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);
    }
    function parseExtensions(extensions) {
      const position = { position: 0 };
      const extensionList = /* @__PURE__ */ new Map();
      while (position.position < extensions.length) {
        const pair = collectASequenceOfCodePointsFast(";", extensions, position);
        const [name, value = ""] = pair.split("=", 2);
        extensionList.set(
          removeHTTPWhitespace(name, true, false),
          removeHTTPWhitespace(value, false, true)
        );
        position.position++;
      }
      return extensionList;
    }
    function isValidClientWindowBits(value) {
      for (let i = 0; i < value.length; i++) {
        const byte = value.charCodeAt(i);
        if (byte < 48 || byte > 57) {
          return false;
        }
      }
      return true;
    }
    function getURLRecord(url3, baseURL) {
      let urlRecord;
      try {
        urlRecord = new URL(url3, baseURL);
      } catch (e) {
        throw new DOMException(e, "SyntaxError");
      }
      if (urlRecord.protocol === "http:") {
        urlRecord.protocol = "ws:";
      } else if (urlRecord.protocol === "https:") {
        urlRecord.protocol = "wss:";
      }
      if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
        throw new DOMException("expected a ws: or wss: url", "SyntaxError");
      }
      if (urlRecord.hash.length || urlRecord.href.endsWith("#")) {
        throw new DOMException("hash", "SyntaxError");
      }
      return urlRecord;
    }
    function validateCloseCodeAndReason(code, reason) {
      if (code !== null) {
        if (code !== 1e3 && (code < 3e3 || code > 4999)) {
          throw new DOMException("invalid code", "InvalidAccessError");
        }
      }
      if (reason !== null) {
        const reasonBytesLength = Buffer.byteLength(reason);
        if (reasonBytesLength > 123) {
          throw new DOMException(`Reason must be less than 123 bytes; received ${reasonBytesLength}`, "SyntaxError");
        }
      }
    }
    var utf8Decode = (() => {
      if (typeof process.versions.icu === "string") {
        const fatalDecoder = new TextDecoder("utf-8", { fatal: true });
        return fatalDecoder.decode.bind(fatalDecoder);
      }
      return function(buffer4) {
        if (isUtf8(buffer4)) {
          return buffer4.toString("utf-8");
        }
        throw new TypeError("Invalid utf-8 received.");
      };
    })();
    module.exports = {
      isConnecting,
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      websocketMessageReceived,
      utf8Decode,
      isControlFrame,
      isContinuationFrame,
      isTextBinaryFrame,
      isValidOpcode,
      parseExtensions,
      isValidClientWindowBits,
      toArrayBuffer,
      getURLRecord,
      validateCloseCodeAndReason
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/frame.js
var require_frame = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/frame.js"(exports, module) {
    var { maxUnsigned16Bit, opcodes } = require_constants5();
    var BUFFER_SIZE = 8 * 1024;
    var crypto;
    var buffer4 = null;
    var bufIdx = BUFFER_SIZE;
    try {
      crypto = __require("crypto");
    } catch {
      crypto = {
        // not full compatibility, but minimum.
        randomFillSync: function randomFillSync(buffer5, _offset, _size) {
          for (let i = 0; i < buffer5.length; ++i) {
            buffer5[i] = Math.random() * 255 | 0;
          }
          return buffer5;
        }
      };
    }
    function generateMask() {
      if (bufIdx === BUFFER_SIZE) {
        bufIdx = 0;
        crypto.randomFillSync(buffer4 ??= Buffer.allocUnsafeSlow(BUFFER_SIZE), 0, BUFFER_SIZE);
      }
      return [buffer4[bufIdx++], buffer4[bufIdx++], buffer4[bufIdx++], buffer4[bufIdx++]];
    }
    var WebsocketFrameSend = class {
      /**
       * @param {Buffer|undefined} data
       */
      constructor(data) {
        this.frameData = data;
      }
      createFrame(opcode) {
        const frameData = this.frameData;
        const maskKey = generateMask();
        const bodyLength = frameData?.byteLength ?? 0;
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const buffer5 = Buffer.allocUnsafe(bodyLength + offset);
        buffer5[0] = buffer5[1] = 0;
        buffer5[0] |= 128;
        buffer5[0] = (buffer5[0] & 240) + opcode;
        buffer5[offset - 4] = maskKey[0];
        buffer5[offset - 3] = maskKey[1];
        buffer5[offset - 2] = maskKey[2];
        buffer5[offset - 1] = maskKey[3];
        buffer5[1] = payloadLength;
        if (payloadLength === 126) {
          buffer5.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          buffer5[2] = buffer5[3] = 0;
          buffer5.writeUIntBE(bodyLength, 4, 6);
        }
        buffer5[1] |= 128;
        for (let i = 0; i < bodyLength; ++i) {
          buffer5[offset + i] = frameData[i] ^ maskKey[i & 3];
        }
        return buffer5;
      }
      /**
       * @param {Uint8Array} buffer
       */
      static createFastTextFrame(buffer5) {
        const maskKey = generateMask();
        const bodyLength = buffer5.length;
        for (let i = 0; i < bodyLength; ++i) {
          buffer5[i] ^= maskKey[i & 3];
        }
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const head6 = Buffer.allocUnsafeSlow(offset);
        head6[0] = 128 | opcodes.TEXT;
        head6[1] = payloadLength | 128;
        head6[offset - 4] = maskKey[0];
        head6[offset - 3] = maskKey[1];
        head6[offset - 2] = maskKey[2];
        head6[offset - 1] = maskKey[3];
        if (payloadLength === 126) {
          head6.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          head6[2] = head6[3] = 0;
          head6.writeUIntBE(bodyLength, 4, 6);
        }
        return [head6, buffer5];
      }
    };
    module.exports = {
      WebsocketFrameSend
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/connection.js
var require_connection = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/connection.js"(exports, module) {
    var { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = require_constants5();
    var { parseExtensions, isClosed, isClosing, isEstablished, validateCloseCodeAndReason } = require_util5();
    var { channels } = require_diagnostics();
    var { makeRequest } = require_request2();
    var { fetching } = require_fetch();
    var { Headers, getHeadersList } = require_headers();
    var { getDecodeSplit } = require_util2();
    var { WebsocketFrameSend } = require_frame();
    var assert3 = __require("assert");
    var crypto;
    try {
      crypto = __require("crypto");
    } catch {
    }
    function establishWebSocketConnection(url3, protocols, client, handler, options) {
      const requestURL = url3;
      requestURL.protocol = url3.protocol === "ws:" ? "http:" : "https:";
      const request2 = makeRequest({
        urlList: [requestURL],
        client,
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error"
      });
      if (options.headers) {
        const headersList = getHeadersList(new Headers(options.headers));
        request2.headersList = headersList;
      }
      const keyValue = crypto.randomBytes(16).toString("base64");
      request2.headersList.append("sec-websocket-key", keyValue, true);
      request2.headersList.append("sec-websocket-version", "13", true);
      for (const protocol of protocols) {
        request2.headersList.append("sec-websocket-protocol", protocol, true);
      }
      const permessageDeflate = "permessage-deflate; client_max_window_bits";
      request2.headersList.append("sec-websocket-extensions", permessageDeflate, true);
      const controller = fetching({
        request: request2,
        useParallelQueue: true,
        dispatcher: options.dispatcher,
        processResponse(response) {
          if (response.type === "error") {
            handler.readyState = states.CLOSED;
          }
          if (response.type === "error" || response.status !== 101) {
            failWebsocketConnection(handler, 1002, "Received network error or non-101 status code.");
            return;
          }
          if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(handler, 1002, "Server did not respond with sent protocols.");
            return;
          }
          if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            failWebsocketConnection(handler, 1002, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            failWebsocketConnection(handler, 1002, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
          const digest = crypto.createHash("sha1").update(keyValue + uid).digest("base64");
          if (secWSAccept !== digest) {
            failWebsocketConnection(handler, 1002, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
          let extensions;
          if (secExtension !== null) {
            extensions = parseExtensions(secExtension);
            if (!extensions.has("permessage-deflate")) {
              failWebsocketConnection(handler, 1002, "Sec-WebSocket-Extensions header does not match.");
              return;
            }
          }
          const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
          if (secProtocol !== null) {
            const requestProtocols = getDecodeSplit("sec-websocket-protocol", request2.headersList);
            if (!requestProtocols.includes(secProtocol)) {
              failWebsocketConnection(handler, 1002, "Protocol was not set in the opening handshake.");
              return;
            }
          }
          response.socket.on("data", handler.onSocketData);
          response.socket.on("close", handler.onSocketClose);
          response.socket.on("error", handler.onSocketError);
          if (channels.open.hasSubscribers) {
            channels.open.publish({
              address: response.socket.address(),
              protocol: secProtocol,
              extensions: secExtension
            });
          }
          handler.wasEverConnected = true;
          handler.onConnectionEstablished(response, extensions);
        }
      });
      return controller;
    }
    function closeWebSocketConnection(object, code, reason, validate5 = false) {
      code ??= null;
      reason ??= "";
      if (validate5) validateCloseCodeAndReason(code, reason);
      if (isClosed(object.readyState) || isClosing(object.readyState)) ; else if (!isEstablished(object.readyState)) {
        failWebsocketConnection(object);
        object.readyState = states.CLOSING;
      } else if (!object.closeState.has(sentCloseFrameState.SENT) && !object.closeState.has(sentCloseFrameState.RECEIVED)) {
        const frame = new WebsocketFrameSend();
        if (reason.length !== 0 && code === null) {
          code = 1e3;
        }
        assert3(code === null || Number.isInteger(code));
        if (code === null && reason.length === 0) {
          frame.frameData = emptyBuffer;
        } else if (code !== null && reason === null) {
          frame.frameData = Buffer.allocUnsafe(2);
          frame.frameData.writeUInt16BE(code, 0);
        } else if (code !== null && reason !== null) {
          frame.frameData = Buffer.allocUnsafe(2 + Buffer.byteLength(reason));
          frame.frameData.writeUInt16BE(code, 0);
          frame.frameData.write(reason, 2, "utf-8");
        } else {
          frame.frameData = emptyBuffer;
        }
        object.socket.write(frame.createFrame(opcodes.CLOSE));
        object.closeState.add(sentCloseFrameState.SENT);
        object.readyState = states.CLOSING;
      } else {
        object.readyState = states.CLOSING;
      }
    }
    function failWebsocketConnection(handler, code, reason) {
      if (isEstablished(handler.readyState)) {
        closeWebSocketConnection(handler, code, reason, false);
      }
      handler.controller.abort();
      if (handler.socket?.destroyed === false) {
        handler.socket.destroy();
      }
      handler.onFail(code, reason);
    }
    module.exports = {
      establishWebSocketConnection,
      failWebsocketConnection,
      closeWebSocketConnection
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/permessage-deflate.js"(exports, module) {
    var { createInflateRaw, Z_DEFAULT_WINDOWBITS } = __require("zlib");
    var { isValidClientWindowBits } = require_util5();
    var tail = Buffer.from([0, 0, 255, 255]);
    var kBuffer = Symbol("kBuffer");
    var kLength = Symbol("kLength");
    var PerMessageDeflate = class {
      /** @type {import('node:zlib').InflateRaw} */
      #inflate;
      #options = {};
      constructor(extensions) {
        this.#options.serverNoContextTakeover = extensions.has("server_no_context_takeover");
        this.#options.serverMaxWindowBits = extensions.get("server_max_window_bits");
      }
      decompress(chunk5, fin, callback) {
        if (!this.#inflate) {
          let windowBits = Z_DEFAULT_WINDOWBITS;
          if (this.#options.serverMaxWindowBits) {
            if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) {
              callback(new Error("Invalid server_max_window_bits"));
              return;
            }
            windowBits = Number.parseInt(this.#options.serverMaxWindowBits);
          }
          this.#inflate = createInflateRaw({ windowBits });
          this.#inflate[kBuffer] = [];
          this.#inflate[kLength] = 0;
          this.#inflate.on("data", (data) => {
            this.#inflate[kBuffer].push(data);
            this.#inflate[kLength] += data.length;
          });
          this.#inflate.on("error", (err) => {
            this.#inflate = null;
            callback(err);
          });
        }
        this.#inflate.write(chunk5);
        if (fin) {
          this.#inflate.write(tail);
        }
        this.#inflate.flush(() => {
          const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength]);
          this.#inflate[kBuffer].length = 0;
          this.#inflate[kLength] = 0;
          callback(null, full);
        });
      }
    };
    module.exports = { PerMessageDeflate };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/receiver.js
var require_receiver = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/receiver.js"(exports, module) {
    var { Writable } = __require("stream");
    var assert3 = __require("assert");
    var { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = require_constants5();
    var { channels } = require_diagnostics();
    var {
      isValidStatusCode,
      isValidOpcode,
      websocketMessageReceived,
      utf8Decode,
      isControlFrame,
      isTextBinaryFrame,
      isContinuationFrame
    } = require_util5();
    var { failWebsocketConnection } = require_connection();
    var { WebsocketFrameSend } = require_frame();
    var { PerMessageDeflate } = require_permessage_deflate();
    var ByteParser = class extends Writable {
      #buffers = [];
      #fragmentsBytes = 0;
      #byteOffset = 0;
      #loop = false;
      #state = parserStates.INFO;
      #info = {};
      #fragments = [];
      /** @type {Map<string, PerMessageDeflate>} */
      #extensions;
      /** @type {import('./websocket').Handler} */
      #handler;
      constructor(handler, extensions) {
        super();
        this.#handler = handler;
        this.#extensions = extensions == null ? /* @__PURE__ */ new Map() : extensions;
        if (this.#extensions.has("permessage-deflate")) {
          this.#extensions.set("permessage-deflate", new PerMessageDeflate(extensions));
        }
      }
      /**
       * @param {Buffer} chunk
       * @param {() => void} callback
       */
      _write(chunk5, _2, callback) {
        this.#buffers.push(chunk5);
        this.#byteOffset += chunk5.length;
        this.#loop = true;
        this.run(callback);
      }
      /**
       * Runs whenever a new chunk is received.
       * Callback is called whenever there are no more chunks buffering,
       * or not enough bytes are buffered to parse.
       */
      run(callback) {
        while (this.#loop) {
          if (this.#state === parserStates.INFO) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer4 = this.consume(2);
            const fin = (buffer4[0] & 128) !== 0;
            const opcode = buffer4[0] & 15;
            const masked = (buffer4[1] & 128) === 128;
            const fragmented = !fin && opcode !== opcodes.CONTINUATION;
            const payloadLength = buffer4[1] & 127;
            const rsv1 = buffer4[0] & 64;
            const rsv2 = buffer4[0] & 32;
            const rsv3 = buffer4[0] & 16;
            if (!isValidOpcode(opcode)) {
              failWebsocketConnection(this.#handler, 1002, "Invalid opcode received");
              return callback();
            }
            if (masked) {
              failWebsocketConnection(this.#handler, 1002, "Frame cannot be masked");
              return callback();
            }
            if (rsv1 !== 0 && !this.#extensions.has("permessage-deflate")) {
              failWebsocketConnection(this.#handler, 1002, "Expected RSV1 to be clear.");
              return;
            }
            if (rsv2 !== 0 || rsv3 !== 0) {
              failWebsocketConnection(this.#handler, 1002, "RSV1, RSV2, RSV3 must be clear");
              return;
            }
            if (fragmented && !isTextBinaryFrame(opcode)) {
              failWebsocketConnection(this.#handler, 1002, "Invalid frame type was fragmented.");
              return;
            }
            if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {
              failWebsocketConnection(this.#handler, 1002, "Expected continuation frame");
              return;
            }
            if (this.#info.fragmented && fragmented) {
              failWebsocketConnection(this.#handler, 1002, "Fragmented frame exceeded 125 bytes.");
              return;
            }
            if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {
              failWebsocketConnection(this.#handler, 1002, "Control frame either too large or fragmented");
              return;
            }
            if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {
              failWebsocketConnection(this.#handler, 1002, "Unexpected continuation frame");
              return;
            }
            if (payloadLength <= 125) {
              this.#info.payloadLength = payloadLength;
              this.#state = parserStates.READ_DATA;
            } else if (payloadLength === 126) {
              this.#state = parserStates.PAYLOADLENGTH_16;
            } else if (payloadLength === 127) {
              this.#state = parserStates.PAYLOADLENGTH_64;
            }
            if (isTextBinaryFrame(opcode)) {
              this.#info.binaryType = opcode;
              this.#info.compressed = rsv1 !== 0;
            }
            this.#info.opcode = opcode;
            this.#info.masked = masked;
            this.#info.fin = fin;
            this.#info.fragmented = fragmented;
          } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer4 = this.consume(2);
            this.#info.payloadLength = buffer4.readUInt16BE(0);
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
            if (this.#byteOffset < 8) {
              return callback();
            }
            const buffer4 = this.consume(8);
            const upper = buffer4.readUInt32BE(0);
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(this.#handler, 1009, "Received payload length > 2^31 bytes.");
              return;
            }
            const lower = buffer4.readUInt32BE(4);
            this.#info.payloadLength = (upper << 8) + lower;
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.READ_DATA) {
            if (this.#byteOffset < this.#info.payloadLength) {
              return callback();
            }
            const body = this.consume(this.#info.payloadLength);
            if (isControlFrame(this.#info.opcode)) {
              this.#loop = this.parseControlFrame(body);
              this.#state = parserStates.INFO;
            } else {
              if (!this.#info.compressed) {
                this.writeFragments(body);
                if (!this.#info.fragmented && this.#info.fin) {
                  websocketMessageReceived(this.#handler, this.#info.binaryType, this.consumeFragments());
                }
                this.#state = parserStates.INFO;
              } else {
                this.#extensions.get("permessage-deflate").decompress(body, this.#info.fin, (error4, data) => {
                  if (error4) {
                    failWebsocketConnection(this.#handler, 1007, error4.message);
                    return;
                  }
                  this.writeFragments(data);
                  if (!this.#info.fin) {
                    this.#state = parserStates.INFO;
                    this.#loop = true;
                    this.run(callback);
                    return;
                  }
                  websocketMessageReceived(this.#handler, this.#info.binaryType, this.consumeFragments());
                  this.#loop = true;
                  this.#state = parserStates.INFO;
                  this.run(callback);
                });
                this.#loop = false;
                break;
              }
            }
          }
        }
      }
      /**
       * Take n bytes from the buffered Buffers
       * @param {number} n
       * @returns {Buffer}
       */
      consume(n2) {
        if (n2 > this.#byteOffset) {
          throw new Error("Called consume() before buffers satiated.");
        } else if (n2 === 0) {
          return emptyBuffer;
        }
        this.#byteOffset -= n2;
        const first3 = this.#buffers[0];
        if (first3.length > n2) {
          this.#buffers[0] = first3.subarray(n2, first3.length);
          return first3.subarray(0, n2);
        } else if (first3.length === n2) {
          return this.#buffers.shift();
        } else {
          let offset = 0;
          const buffer4 = Buffer.allocUnsafeSlow(n2);
          while (offset !== n2) {
            const next = this.#buffers[0];
            const length3 = next.length;
            if (length3 + offset === n2) {
              buffer4.set(this.#buffers.shift(), offset);
              break;
            } else if (length3 + offset > n2) {
              buffer4.set(next.subarray(0, n2 - offset), offset);
              this.#buffers[0] = next.subarray(n2 - offset);
              break;
            } else {
              buffer4.set(this.#buffers.shift(), offset);
              offset += length3;
            }
          }
          return buffer4;
        }
      }
      writeFragments(fragment) {
        this.#fragmentsBytes += fragment.length;
        this.#fragments.push(fragment);
      }
      consumeFragments() {
        const fragments = this.#fragments;
        if (fragments.length === 1) {
          this.#fragmentsBytes = 0;
          return fragments.shift();
        }
        let offset = 0;
        const output = Buffer.allocUnsafeSlow(this.#fragmentsBytes);
        for (let i = 0; i < fragments.length; ++i) {
          const buffer4 = fragments[i];
          output.set(buffer4, offset);
          offset += buffer4.length;
        }
        this.#fragments = [];
        this.#fragmentsBytes = 0;
        return output;
      }
      parseCloseBody(data) {
        assert3(data.length !== 1);
        let code;
        if (data.length >= 2) {
          code = data.readUInt16BE(0);
        }
        if (code !== void 0 && !isValidStatusCode(code)) {
          return { code: 1002, reason: "Invalid status code", error: true };
        }
        let reason = data.subarray(2);
        if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
          reason = reason.subarray(3);
        }
        try {
          reason = utf8Decode(reason);
        } catch {
          return { code: 1007, reason: "Invalid UTF-8", error: true };
        }
        return { code, reason, error: false };
      }
      /**
       * Parses control frames.
       * @param {Buffer} body
       */
      parseControlFrame(body) {
        const { opcode, payloadLength } = this.#info;
        if (opcode === opcodes.CLOSE) {
          if (payloadLength === 1) {
            failWebsocketConnection(this.#handler, 1002, "Received close frame with a 1-byte body.");
            return false;
          }
          this.#info.closeInfo = this.parseCloseBody(body);
          if (this.#info.closeInfo.error) {
            const { code, reason } = this.#info.closeInfo;
            failWebsocketConnection(this.#handler, code, reason);
            return false;
          }
          if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
            let body2 = emptyBuffer;
            if (this.#info.closeInfo.code) {
              body2 = Buffer.allocUnsafe(2);
              body2.writeUInt16BE(this.#info.closeInfo.code, 0);
            }
            const closeFrame = new WebsocketFrameSend(body2);
            this.#handler.socket.write(closeFrame.createFrame(opcodes.CLOSE));
            this.#handler.closeState.add(sentCloseFrameState.SENT);
          }
          this.#handler.readyState = states.CLOSING;
          this.#handler.closeState.add(sentCloseFrameState.RECEIVED);
          return false;
        } else if (opcode === opcodes.PING) {
          if (!this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
            const frame = new WebsocketFrameSend(body);
            this.#handler.socket.write(frame.createFrame(opcodes.PONG));
            if (channels.ping.hasSubscribers) {
              channels.ping.publish({
                payload: body
              });
            }
          }
        } else if (opcode === opcodes.PONG) {
          if (channels.pong.hasSubscribers) {
            channels.pong.publish({
              payload: body
            });
          }
        }
        return true;
      }
      get closingInfo() {
        return this.#info.closeInfo;
      }
    };
    module.exports = {
      ByteParser
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/sender.js
var require_sender = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/sender.js"(exports, module) {
    var { WebsocketFrameSend } = require_frame();
    var { opcodes, sendHints } = require_constants5();
    var FixedQueue = require_fixed_queue();
    var SendQueue = class {
      /**
       * @type {FixedQueue}
       */
      #queue = new FixedQueue();
      /**
       * @type {boolean}
       */
      #running = false;
      /** @type {import('node:net').Socket} */
      #socket;
      constructor(socket) {
        this.#socket = socket;
      }
      add(item, cb, hint) {
        if (hint !== sendHints.blob) {
          if (!this.#running) {
            if (hint === sendHints.text) {
              const { 0: head6, 1: body } = WebsocketFrameSend.createFastTextFrame(item);
              this.#socket.cork();
              this.#socket.write(head6);
              this.#socket.write(body, cb);
              this.#socket.uncork();
            } else {
              this.#socket.write(createFrame(item, hint), cb);
            }
          } else {
            const node2 = {
              promise: null,
              callback: cb,
              frame: createFrame(item, hint)
            };
            this.#queue.push(node2);
          }
          return;
        }
        const node = {
          promise: item.arrayBuffer().then((ab) => {
            node.promise = null;
            node.frame = createFrame(ab, hint);
          }),
          callback: cb,
          frame: null
        };
        this.#queue.push(node);
        if (!this.#running) {
          this.#run();
        }
      }
      async #run() {
        this.#running = true;
        const queue = this.#queue;
        while (!queue.isEmpty()) {
          const node = queue.shift();
          if (node.promise !== null) {
            await node.promise;
          }
          this.#socket.write(node.frame, node.callback);
          node.callback = node.frame = null;
        }
        this.#running = false;
      }
    };
    function createFrame(data, hint) {
      return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.text ? opcodes.TEXT : opcodes.BINARY);
    }
    function toBuffer(data, hint) {
      switch (hint) {
        case sendHints.text:
        case sendHints.typedArray:
          return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        case sendHints.arrayBuffer:
        case sendHints.blob:
          return new Uint8Array(data);
      }
    }
    module.exports = { SendQueue };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/websocket.js
var require_websocket = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/websocket.js"(exports, module) {
    var { webidl } = require_webidl();
    var { URLSerializer } = require_data_url();
    var { environmentSettingsObject } = require_util2();
    var { staticPropertyDescriptors, states, sentCloseFrameState, sendHints, opcodes } = require_constants5();
    var {
      isConnecting,
      isEstablished,
      isClosing,
      isValidSubprotocol,
      fireEvent,
      utf8Decode,
      toArrayBuffer,
      getURLRecord
    } = require_util5();
    var { establishWebSocketConnection, closeWebSocketConnection, failWebsocketConnection } = require_connection();
    var { ByteParser } = require_receiver();
    var { kEnumerableProperty } = require_util();
    var { getGlobalDispatcher } = require_global2();
    var { types } = __require("util");
    var { ErrorEvent, CloseEvent, createFastMessageEvent } = require_events();
    var { SendQueue } = require_sender();
    var { channels } = require_diagnostics();
    var WebSocket = class _WebSocket extends EventTarget {
      #events = {
        open: null,
        error: null,
        close: null,
        message: null
      };
      #bufferedAmount = 0;
      #protocol = "";
      #extensions = "";
      /** @type {SendQueue} */
      #sendQueue;
      /** @type {Handler} */
      #handler = {
        onConnectionEstablished: (response, extensions) => this.#onConnectionEstablished(response, extensions),
        onFail: (code, reason) => this.#onFail(code, reason),
        onMessage: (opcode, data) => this.#onMessage(opcode, data),
        onParserError: (err) => failWebsocketConnection(this.#handler, null, err.message),
        onParserDrain: () => this.#onParserDrain(),
        onSocketData: (chunk5) => {
          if (!this.#parser.write(chunk5)) {
            this.#handler.socket.pause();
          }
        },
        onSocketError: (err) => {
          this.#handler.readyState = states.CLOSING;
          if (channels.socketError.hasSubscribers) {
            channels.socketError.publish(err);
          }
          this.#handler.socket.destroy();
        },
        onSocketClose: () => this.#onSocketClose(),
        readyState: states.CONNECTING,
        socket: null,
        closeState: /* @__PURE__ */ new Set(),
        controller: null,
        wasEverConnected: false
      };
      #url;
      #binaryType;
      /** @type {import('./receiver').ByteParser} */
      #parser;
      /**
       * @param {string} url
       * @param {string|string[]} protocols
       */
      constructor(url3, protocols = []) {
        super();
        webidl.util.markAsUncloneable(this);
        const prefix = "WebSocket constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols, prefix, "options");
        url3 = webidl.converters.USVString(url3);
        protocols = options.protocols;
        const baseURL = environmentSettingsObject.settingsObject.baseUrl;
        const urlRecord = getURLRecord(url3, baseURL);
        if (typeof protocols === "string") {
          protocols = [protocols];
        }
        if (protocols.length !== new Set(protocols.map((p3) => p3.toLowerCase())).size) {
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p3) => isValidSubprotocol(p3))) {
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this.#url = new URL(urlRecord.href);
        const client = environmentSettingsObject.settingsObject;
        this.#handler.controller = establishWebSocketConnection(
          urlRecord,
          protocols,
          client,
          this.#handler,
          options
        );
        this.#handler.readyState = _WebSocket.CONNECTING;
        this.#binaryType = "blob";
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-close
       * @param {number|undefined} code
       * @param {string|undefined} reason
       */
      close(code = void 0, reason = void 0) {
        webidl.brandCheck(this, _WebSocket);
        const prefix = "WebSocket.close";
        if (code !== void 0) {
          code = webidl.converters["unsigned short"](code, prefix, "code", { clamp: true });
        }
        if (reason !== void 0) {
          reason = webidl.converters.USVString(reason);
        }
        code ??= null;
        reason ??= "";
        closeWebSocketConnection(this.#handler, code, reason, true);
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-send
       * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
       */
      send(data) {
        webidl.brandCheck(this, _WebSocket);
        const prefix = "WebSocket.send";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        data = webidl.converters.WebSocketSendData(data, prefix, "data");
        if (isConnecting(this.#handler.readyState)) {
          throw new DOMException("Sent before connected.", "InvalidStateError");
        }
        if (!isEstablished(this.#handler.readyState) || isClosing(this.#handler.readyState)) {
          return;
        }
        if (typeof data === "string") {
          const buffer4 = Buffer.from(data);
          this.#bufferedAmount += buffer4.byteLength;
          this.#sendQueue.add(buffer4, () => {
            this.#bufferedAmount -= buffer4.byteLength;
          }, sendHints.text);
        } else if (types.isArrayBuffer(data)) {
          this.#bufferedAmount += data.byteLength;
          this.#sendQueue.add(data, () => {
            this.#bufferedAmount -= data.byteLength;
          }, sendHints.arrayBuffer);
        } else if (ArrayBuffer.isView(data)) {
          this.#bufferedAmount += data.byteLength;
          this.#sendQueue.add(data, () => {
            this.#bufferedAmount -= data.byteLength;
          }, sendHints.typedArray);
        } else if (webidl.is.Blob(data)) {
          this.#bufferedAmount += data.size;
          this.#sendQueue.add(data, () => {
            this.#bufferedAmount -= data.size;
          }, sendHints.blob);
        }
      }
      get readyState() {
        webidl.brandCheck(this, _WebSocket);
        return this.#handler.readyState;
      }
      get bufferedAmount() {
        webidl.brandCheck(this, _WebSocket);
        return this.#bufferedAmount;
      }
      get url() {
        webidl.brandCheck(this, _WebSocket);
        return URLSerializer(this.#url);
      }
      get extensions() {
        webidl.brandCheck(this, _WebSocket);
        return this.#extensions;
      }
      get protocol() {
        webidl.brandCheck(this, _WebSocket);
        return this.#protocol;
      }
      get onopen() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.open;
      }
      set onopen(fn2) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.open) {
          this.removeEventListener("open", this.#events.open);
        }
        if (typeof fn2 === "function") {
          this.#events.open = fn2;
          this.addEventListener("open", fn2);
        } else {
          this.#events.open = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.error;
      }
      set onerror(fn2) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.error) {
          this.removeEventListener("error", this.#events.error);
        }
        if (typeof fn2 === "function") {
          this.#events.error = fn2;
          this.addEventListener("error", fn2);
        } else {
          this.#events.error = null;
        }
      }
      get onclose() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.close;
      }
      set onclose(fn2) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.close) {
          this.removeEventListener("close", this.#events.close);
        }
        if (typeof fn2 === "function") {
          this.#events.close = fn2;
          this.addEventListener("close", fn2);
        } else {
          this.#events.close = null;
        }
      }
      get onmessage() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.message;
      }
      set onmessage(fn2) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.message) {
          this.removeEventListener("message", this.#events.message);
        }
        if (typeof fn2 === "function") {
          this.#events.message = fn2;
          this.addEventListener("message", fn2);
        } else {
          this.#events.message = null;
        }
      }
      get binaryType() {
        webidl.brandCheck(this, _WebSocket);
        return this.#binaryType;
      }
      set binaryType(type) {
        webidl.brandCheck(this, _WebSocket);
        if (type !== "blob" && type !== "arraybuffer") {
          this.#binaryType = "blob";
        } else {
          this.#binaryType = type;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
       */
      #onConnectionEstablished(response, parsedExtensions) {
        this.#handler.socket = response.socket;
        const parser4 = new ByteParser(this.#handler, parsedExtensions);
        parser4.on("drain", () => this.#handler.onParserDrain());
        parser4.on("error", (err) => this.#handler.onParserError(err));
        this.#parser = parser4;
        this.#sendQueue = new SendQueue(response.socket);
        this.#handler.readyState = states.OPEN;
        const extensions = response.headersList.get("sec-websocket-extensions");
        if (extensions !== null) {
          this.#extensions = extensions;
        }
        const protocol = response.headersList.get("sec-websocket-protocol");
        if (protocol !== null) {
          this.#protocol = protocol;
        }
        fireEvent("open", this);
      }
      #onFail(code, reason) {
        if (reason) {
          fireEvent("error", this, (type, init2) => new ErrorEvent(type, init2), {
            error: new Error(reason),
            message: reason
          });
        }
        if (!this.#handler.wasEverConnected) {
          this.#handler.readyState = states.CLOSED;
          fireEvent("close", this, (type, init2) => new CloseEvent(type, init2), {
            wasClean: false,
            code,
            reason
          });
        }
      }
      #onMessage(type, data) {
        if (this.#handler.readyState !== states.OPEN) {
          return;
        }
        let dataForEvent;
        if (type === opcodes.TEXT) {
          try {
            dataForEvent = utf8Decode(data);
          } catch {
            failWebsocketConnection(this.#handler, 1007, "Received invalid UTF-8 in text frame.");
            return;
          }
        } else if (type === opcodes.BINARY) {
          if (this.#binaryType === "blob") {
            dataForEvent = new Blob([data]);
          } else {
            dataForEvent = toArrayBuffer(data);
          }
        }
        fireEvent("message", this, createFastMessageEvent, {
          origin: this.#url.origin,
          data: dataForEvent
        });
      }
      #onParserDrain() {
        this.#handler.socket.resume();
      }
      /**
       * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
       * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4
       */
      #onSocketClose() {
        const wasClean = this.#handler.closeState.has(sentCloseFrameState.SENT) && this.#handler.closeState.has(sentCloseFrameState.RECEIVED);
        let code = 1005;
        let reason = "";
        const result = this.#parser.closingInfo;
        if (result && !result.error) {
          code = result.code ?? 1005;
          reason = result.reason;
        } else if (!this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
          code = 1006;
        }
        this.#handler.readyState = states.CLOSED;
        fireEvent("close", this, (type, init2) => new CloseEvent(type, init2), {
          wasClean,
          code,
          reason
        });
        if (channels.close.hasSubscribers) {
          channels.close.publish({
            websocket: this,
            code,
            reason
          });
        }
      }
    };
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
    WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocket",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(WebSocket, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors
    });
    webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
      webidl.converters.DOMString
    );
    webidl.converters["DOMString or sequence<DOMString>"] = function(V2, prefix, argument) {
      if (webidl.util.Type(V2) === webidl.util.Types.OBJECT && Symbol.iterator in V2) {
        return webidl.converters["sequence<DOMString>"](V2);
      }
      return webidl.converters.DOMString(V2, prefix, argument);
    };
    webidl.converters.WebSocketInit = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.converters["DOMString or sequence<DOMString>"],
        defaultValue: () => new Array(0)
      },
      {
        key: "dispatcher",
        converter: webidl.converters.any,
        defaultValue: () => getGlobalDispatcher()
      },
      {
        key: "headers",
        converter: webidl.nullableConverter(webidl.converters.HeadersInit)
      }
    ]);
    webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V2) {
      if (webidl.util.Type(V2) === webidl.util.Types.OBJECT && !(Symbol.iterator in V2)) {
        return webidl.converters.WebSocketInit(V2);
      }
      return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V2) };
    };
    webidl.converters.WebSocketSendData = function(V2) {
      if (webidl.util.Type(V2) === webidl.util.Types.OBJECT) {
        if (webidl.is.Blob(V2)) {
          return V2;
        }
        if (ArrayBuffer.isView(V2) || types.isArrayBuffer(V2)) {
          return V2;
        }
      }
      return webidl.converters.USVString(V2);
    };
    module.exports = {
      WebSocket
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/stream/websocketerror.js
var require_websocketerror = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/stream/websocketerror.js"(exports, module) {
    var { webidl } = require_webidl();
    var { validateCloseCodeAndReason } = require_util5();
    var { kConstruct } = require_symbols();
    var { kEnumerableProperty } = require_util();
    var WebSocketError = class _WebSocketError extends DOMException {
      #closeCode;
      #reason;
      constructor(message = "", init2 = void 0) {
        message = webidl.converters.DOMString(message, "WebSocketError", "message");
        super(message, "WebSocketError");
        if (init2 === kConstruct) {
          return;
        } else if (init2 !== null) {
          init2 = webidl.converters.WebSocketCloseInfo(init2);
        }
        let code = init2.closeCode ?? null;
        const reason = init2.reason ?? "";
        validateCloseCodeAndReason(code, reason);
        if (reason.length !== 0 && code === null) {
          code = 1e3;
        }
        this.#closeCode = code;
        this.#reason = reason;
      }
      get closeCode() {
        return this.#closeCode;
      }
      get reason() {
        return this.#reason;
      }
      /**
       * @param {string} message
       * @param {number|null} code
       * @param {string} reason
       */
      static createUnvalidatedWebSocketError(message, code, reason) {
        const error4 = new _WebSocketError(message, kConstruct);
        error4.#closeCode = code;
        error4.#reason = reason;
        return error4;
      }
    };
    var { createUnvalidatedWebSocketError } = WebSocketError;
    delete WebSocketError.createUnvalidatedWebSocketError;
    Object.defineProperties(WebSocketError.prototype, {
      closeCode: kEnumerableProperty,
      reason: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocketError",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    webidl.is.WebSocketError = webidl.util.MakeTypeAssertion(WebSocketError);
    module.exports = { WebSocketError, createUnvalidatedWebSocketError };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/stream/websocketstream.js
var require_websocketstream = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/websocket/stream/websocketstream.js"(exports, module) {
    var { createDeferredPromise, environmentSettingsObject } = require_util2();
    var { states, opcodes, sentCloseFrameState } = require_constants5();
    var { webidl } = require_webidl();
    var { getURLRecord, isValidSubprotocol, isEstablished, utf8Decode } = require_util5();
    var { establishWebSocketConnection, failWebsocketConnection, closeWebSocketConnection } = require_connection();
    var { types } = __require("util");
    var { channels } = require_diagnostics();
    var { WebsocketFrameSend } = require_frame();
    var { ByteParser } = require_receiver();
    var { WebSocketError, createUnvalidatedWebSocketError } = require_websocketerror();
    var { utf8DecodeBytes } = require_util2();
    var { kEnumerableProperty } = require_util();
    var emittedExperimentalWarning = false;
    var WebSocketStream = class {
      // Each WebSocketStream object has an associated url , which is a URL record .
      /** @type {URL} */
      #url;
      // Each WebSocketStream object has an associated opened promise , which is a promise.
      /** @type {ReturnType<typeof createDeferredPromise>} */
      #openedPromise;
      // Each WebSocketStream object has an associated closed promise , which is a promise.
      /** @type {ReturnType<typeof createDeferredPromise>} */
      #closedPromise;
      // Each WebSocketStream object has an associated readable stream , which is a ReadableStream .
      /** @type {ReadableStream} */
      #readableStream;
      /** @type {ReadableStreamDefaultController} */
      #readableStreamController;
      // Each WebSocketStream object has an associated writable stream , which is a WritableStream .
      /** @type {WritableStream} */
      #writableStream;
      // Each WebSocketStream object has an associated boolean handshake aborted , which is initially false.
      #handshakeAborted = false;
      /** @type {import('../websocket').Handler} */
      #handler = {
        // https://whatpr.org/websockets/48/7b748d3...d5570f3.html#feedback-to-websocket-stream-from-the-protocol
        onConnectionEstablished: (response, extensions) => this.#onConnectionEstablished(response, extensions),
        onFail: (_code, _reason) => {
        },
        onMessage: (opcode, data) => this.#onMessage(opcode, data),
        onParserError: (err) => failWebsocketConnection(this.#handler, null, err.message),
        onParserDrain: () => this.#handler.socket.resume(),
        onSocketData: (chunk5) => {
          if (!this.#parser.write(chunk5)) {
            this.#handler.socket.pause();
          }
        },
        onSocketError: (err) => {
          this.#handler.readyState = states.CLOSING;
          if (channels.socketError.hasSubscribers) {
            channels.socketError.publish(err);
          }
          this.#handler.socket.destroy();
        },
        onSocketClose: () => this.#onSocketClose(),
        readyState: states.CONNECTING,
        socket: null,
        closeState: /* @__PURE__ */ new Set(),
        controller: null,
        wasEverConnected: false
      };
      /** @type {import('../receiver').ByteParser} */
      #parser;
      constructor(url3, options = void 0) {
        if (!emittedExperimentalWarning) {
          process.emitWarning("WebSocketStream is experimental! Expect it to change at any time.", {
            code: "UNDICI-WSS"
          });
          emittedExperimentalWarning = true;
        }
        webidl.argumentLengthCheck(arguments, 1, "WebSocket");
        url3 = webidl.converters.USVString(url3);
        if (options !== null) {
          options = webidl.converters.WebSocketStreamOptions(options);
        }
        const baseURL = environmentSettingsObject.settingsObject.baseUrl;
        const urlRecord = getURLRecord(url3, baseURL);
        const protocols = options.protocols;
        if (protocols.length !== new Set(protocols.map((p3) => p3.toLowerCase())).size) {
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p3) => isValidSubprotocol(p3))) {
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this.#url = urlRecord.toString();
        this.#openedPromise = createDeferredPromise();
        this.#closedPromise = createDeferredPromise();
        if (options.signal != null) {
          const signal = options.signal;
          if (signal.aborted) {
            this.#openedPromise.reject(signal.reason);
            this.#closedPromise.reject(signal.reason);
            return;
          }
          signal.addEventListener("abort", () => {
            if (!isEstablished(this.#handler.readyState)) {
              failWebsocketConnection(this.#handler);
              this.#handler.readyState = states.CLOSING;
              this.#openedPromise.reject(signal.reason);
              this.#closedPromise.reject(signal.reason);
              this.#handshakeAborted = true;
            }
          }, { once: true });
        }
        const client = environmentSettingsObject.settingsObject;
        this.#handler.controller = establishWebSocketConnection(
          urlRecord,
          protocols,
          client,
          this.#handler,
          options
        );
      }
      // The url getter steps are to return this 's url , serialized .
      get url() {
        return this.#url.toString();
      }
      // The opened getter steps are to return this 's opened promise .
      get opened() {
        return this.#openedPromise.promise;
      }
      // The closed getter steps are to return this 's closed promise .
      get closed() {
        return this.#closedPromise.promise;
      }
      // The close( closeInfo ) method steps are:
      close(closeInfo = void 0) {
        if (closeInfo !== null) {
          closeInfo = webidl.converters.WebSocketCloseInfo(closeInfo);
        }
        const code = closeInfo.closeCode ?? null;
        const reason = closeInfo.reason;
        closeWebSocketConnection(this.#handler, code, reason, true);
      }
      #write(chunk5) {
        const promise3 = createDeferredPromise();
        let data = null;
        let opcode = null;
        if (ArrayBuffer.isView(chunk5) || types.isArrayBuffer(chunk5)) {
          data = new Uint8Array(ArrayBuffer.isView(chunk5) ? new Uint8Array(chunk5.buffer, chunk5.byteOffset, chunk5.byteLength) : chunk5);
          opcode = opcodes.BINARY;
        } else {
          let string4;
          try {
            string4 = webidl.converters.DOMString(chunk5);
          } catch (e) {
            promise3.reject(e);
            return;
          }
          data = new TextEncoder().encode(string4);
          opcode = opcodes.TEXT;
        }
        if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
          const frame = new WebsocketFrameSend(data);
          this.#handler.socket.write(frame.createFrame(opcode), () => {
            promise3.resolve(void 0);
          });
        }
        return promise3;
      }
      /** @type {import('../websocket').Handler['onConnectionEstablished']} */
      #onConnectionEstablished(response, parsedExtensions) {
        this.#handler.socket = response.socket;
        const parser4 = new ByteParser(this.#handler, parsedExtensions);
        parser4.on("drain", () => this.#handler.onParserDrain());
        parser4.on("error", (err) => this.#handler.onParserError(err));
        this.#parser = parser4;
        this.#handler.readyState = states.OPEN;
        const extensions = parsedExtensions ?? "";
        const protocol = response.headersList.get("sec-websocket-protocol") ?? "";
        const readable = new ReadableStream({
          start: (controller) => {
            this.#readableStreamController = controller;
          },
          pull(controller) {
            let chunk5;
            while (controller.desiredSize > 0 && (chunk5 = response.socket.read()) !== null) {
              controller.enqueue(chunk5);
            }
          },
          cancel: (reason) => this.#cancel(reason)
        });
        const writable = new WritableStream({
          write: (chunk5) => this.#write(chunk5),
          close: () => closeWebSocketConnection(this.#handler, null, null),
          abort: (reason) => this.#closeUsingReason(reason)
        });
        this.#readableStream = readable;
        this.#writableStream = writable;
        this.#openedPromise.resolve({
          extensions,
          protocol,
          readable,
          writable
        });
      }
      /** @type {import('../websocket').Handler['onMessage']} */
      #onMessage(type, data) {
        if (this.#handler.readyState !== states.OPEN) {
          return;
        }
        let chunk5;
        if (type === opcodes.TEXT) {
          try {
            chunk5 = utf8Decode(data);
          } catch {
            failWebsocketConnection(this.#handler, "Received invalid UTF-8 in text frame.");
            return;
          }
        } else if (type === opcodes.BINARY) {
          chunk5 = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        }
        this.#readableStreamController.enqueue(chunk5);
      }
      /** @type {import('../websocket').Handler['onSocketClose']} */
      #onSocketClose() {
        const wasClean = this.#handler.closeState.has(sentCloseFrameState.SENT) && this.#handler.closeState.has(sentCloseFrameState.RECEIVED);
        this.#handler.readyState = states.CLOSED;
        if (this.#handshakeAborted) {
          return;
        }
        if (!this.#handler.wasEverConnected) {
          this.#openedPromise.reject(new WebSocketError("Socket never opened"));
        }
        const result = this.#parser.closingInfo;
        let code = result?.code ?? 1005;
        if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
          code = 1006;
        }
        const reason = result?.reason == null ? "" : utf8DecodeBytes(Buffer.from(result.reason));
        if (wasClean) {
          this.#readableStream.cancel().catch(() => {
          });
          if (!this.#writableStream.locked) {
            this.#writableStream.abort(new DOMException("A closed WebSocketStream cannot be written to", "InvalidStateError"));
          }
          this.#closedPromise.resolve({
            closeCode: code,
            reason
          });
        } else {
          const error4 = createUnvalidatedWebSocketError("unclean close", code, reason);
          this.#readableStreamController.error(error4);
          this.#writableStream.abort(error4);
          this.#closedPromise.reject(error4);
        }
      }
      #closeUsingReason(reason) {
        let code = null;
        let reasonString = "";
        if (webidl.is.WebSocketError(reason)) {
          code = reason.closeCode;
          reasonString = reason.reason;
        }
        closeWebSocketConnection(this.#handler, code, reasonString);
      }
      //  To cancel a WebSocketStream stream given reason , close using reason giving stream and reason .
      #cancel(reason) {
        this.#closeUsingReason(reason);
      }
    };
    Object.defineProperties(WebSocketStream.prototype, {
      url: kEnumerableProperty,
      opened: kEnumerableProperty,
      closed: kEnumerableProperty,
      close: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocketStream",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    webidl.converters.WebSocketStreamOptions = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.sequenceConverter(webidl.converters.USVString),
        defaultValue: () => []
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(webidl.converters.AbortSignal),
        defaultValue: () => null
      }
    ]);
    webidl.converters.WebSocketCloseInfo = webidl.dictionaryConverter([
      {
        key: "closeCode",
        converter: (V2) => webidl.converters["unsigned short"](V2, { enforceRange: true })
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: () => ""
      }
    ]);
    module.exports = { WebSocketStream };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/eventsource/util.js
var require_util6 = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/eventsource/util.js"(exports, module) {
    function isValidLastEventId(value) {
      return value.indexOf("\0") === -1;
    }
    function isASCIINumber(value) {
      if (value.length === 0) return false;
      for (let i = 0; i < value.length; i++) {
        if (value.charCodeAt(i) < 48 || value.charCodeAt(i) > 57) return false;
      }
      return true;
    }
    function delay4(ms) {
      return new Promise((resolve9) => {
        setTimeout(resolve9, ms).unref();
      });
    }
    module.exports = {
      isValidLastEventId,
      isASCIINumber,
      delay: delay4
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/eventsource/eventsource-stream.js
var require_eventsource_stream = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/eventsource/eventsource-stream.js"(exports, module) {
    var { Transform } = __require("stream");
    var { isASCIINumber, isValidLastEventId } = require_util6();
    var BOM = [239, 187, 191];
    var LF = 10;
    var CR = 13;
    var COLON = 58;
    var SPACE = 32;
    var EventSourceStream = class extends Transform {
      /**
       * @type {eventSourceSettings}
       */
      state;
      /**
       * Leading byte-order-mark check.
       * @type {boolean}
       */
      checkBOM = true;
      /**
       * @type {boolean}
       */
      crlfCheck = false;
      /**
       * @type {boolean}
       */
      eventEndCheck = false;
      /**
       * @type {Buffer|null}
       */
      buffer = null;
      pos = 0;
      event = {
        data: void 0,
        event: void 0,
        id: void 0,
        retry: void 0
      };
      /**
       * @param {object} options
       * @param {boolean} [options.readableObjectMode]
       * @param {eventSourceSettings} [options.eventSourceSettings]
       * @param {(chunk: any, encoding?: BufferEncoding | undefined) => boolean} [options.push]
       */
      constructor(options = {}) {
        options.readableObjectMode = true;
        super(options);
        this.state = options.eventSourceSettings || {};
        if (options.push) {
          this.push = options.push;
        }
      }
      /**
       * @param {Buffer} chunk
       * @param {string} _encoding
       * @param {Function} callback
       * @returns {void}
       */
      _transform(chunk5, _encoding, callback) {
        if (chunk5.length === 0) {
          callback();
          return;
        }
        if (this.buffer) {
          this.buffer = Buffer.concat([this.buffer, chunk5]);
        } else {
          this.buffer = chunk5;
        }
        if (this.checkBOM) {
          switch (this.buffer.length) {
            case 1:
              if (this.buffer[0] === BOM[0]) {
                callback();
                return;
              }
              this.checkBOM = false;
              callback();
              return;
            case 2:
              if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) {
                callback();
                return;
              }
              this.checkBOM = false;
              break;
            case 3:
              if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
                this.buffer = Buffer.alloc(0);
                this.checkBOM = false;
                callback();
                return;
              }
              this.checkBOM = false;
              break;
            default:
              if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
                this.buffer = this.buffer.subarray(3);
              }
              this.checkBOM = false;
              break;
          }
        }
        while (this.pos < this.buffer.length) {
          if (this.eventEndCheck) {
            if (this.crlfCheck) {
              if (this.buffer[this.pos] === LF) {
                this.buffer = this.buffer.subarray(this.pos + 1);
                this.pos = 0;
                this.crlfCheck = false;
                continue;
              }
              this.crlfCheck = false;
            }
            if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
              if (this.buffer[this.pos] === CR) {
                this.crlfCheck = true;
              }
              this.buffer = this.buffer.subarray(this.pos + 1);
              this.pos = 0;
              if (this.event.data !== void 0 || this.event.event || this.event.id || this.event.retry) {
                this.processEvent(this.event);
              }
              this.clearEvent();
              continue;
            }
            this.eventEndCheck = false;
            continue;
          }
          if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
            if (this.buffer[this.pos] === CR) {
              this.crlfCheck = true;
            }
            this.parseLine(this.buffer.subarray(0, this.pos), this.event);
            this.buffer = this.buffer.subarray(this.pos + 1);
            this.pos = 0;
            this.eventEndCheck = true;
            continue;
          }
          this.pos++;
        }
        callback();
      }
      /**
       * @param {Buffer} line
       * @param {EventSourceStreamEvent} event
       */
      parseLine(line, event) {
        if (line.length === 0) {
          return;
        }
        const colonPosition = line.indexOf(COLON);
        if (colonPosition === 0) {
          return;
        }
        let field = "";
        let value = "";
        if (colonPosition !== -1) {
          field = line.subarray(0, colonPosition).toString("utf8");
          let valueStart = colonPosition + 1;
          if (line[valueStart] === SPACE) {
            ++valueStart;
          }
          value = line.subarray(valueStart).toString("utf8");
        } else {
          field = line.toString("utf8");
          value = "";
        }
        switch (field) {
          case "data":
            if (event[field] === void 0) {
              event[field] = value;
            } else {
              event[field] += `
${value}`;
            }
            break;
          case "retry":
            if (isASCIINumber(value)) {
              event[field] = value;
            }
            break;
          case "id":
            if (isValidLastEventId(value)) {
              event[field] = value;
            }
            break;
          case "event":
            if (value.length > 0) {
              event[field] = value;
            }
            break;
        }
      }
      /**
       * @param {EventSourceStreamEvent} event
       */
      processEvent(event) {
        if (event.retry && isASCIINumber(event.retry)) {
          this.state.reconnectionTime = parseInt(event.retry, 10);
        }
        if (event.id && isValidLastEventId(event.id)) {
          this.state.lastEventId = event.id;
        }
        if (event.data !== void 0) {
          this.push({
            type: event.event || "message",
            options: {
              data: event.data,
              lastEventId: this.state.lastEventId,
              origin: this.state.origin
            }
          });
        }
      }
      clearEvent() {
        this.event = {
          data: void 0,
          event: void 0,
          id: void 0,
          retry: void 0
        };
      }
    };
    module.exports = {
      EventSourceStream
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/eventsource/eventsource.js
var require_eventsource = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/lib/web/eventsource/eventsource.js"(exports, module) {
    var { pipeline } = __require("stream");
    var { fetching } = require_fetch();
    var { makeRequest } = require_request2();
    var { webidl } = require_webidl();
    var { EventSourceStream } = require_eventsource_stream();
    var { parseMIMEType } = require_data_url();
    var { createFastMessageEvent } = require_events();
    var { isNetworkError } = require_response();
    var { delay: delay4 } = require_util6();
    var { kEnumerableProperty } = require_util();
    var { environmentSettingsObject } = require_util2();
    var experimentalWarned = false;
    var defaultReconnectionTime = 3e3;
    var CONNECTING = 0;
    var OPEN = 1;
    var CLOSED = 2;
    var ANONYMOUS = "anonymous";
    var USE_CREDENTIALS = "use-credentials";
    var EventSource = class _EventSource extends EventTarget {
      #events = {
        open: null,
        error: null,
        message: null
      };
      #url;
      #withCredentials = false;
      /**
       * @type {ReadyState}
       */
      #readyState = CONNECTING;
      #request = null;
      #controller = null;
      #dispatcher;
      /**
       * @type {import('./eventsource-stream').eventSourceSettings}
       */
      #state;
      /**
       * Creates a new EventSource object.
       * @param {string} url
       * @param {EventSourceInit} [eventSourceInitDict={}]
       * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface
       */
      constructor(url3, eventSourceInitDict = {}) {
        super();
        webidl.util.markAsUncloneable(this);
        const prefix = "EventSource constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning("EventSource is experimental, expect them to change at any time.", {
            code: "UNDICI-ES"
          });
        }
        url3 = webidl.converters.USVString(url3);
        eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, "eventSourceInitDict");
        this.#dispatcher = eventSourceInitDict.dispatcher;
        this.#state = {
          lastEventId: "",
          reconnectionTime: defaultReconnectionTime
        };
        const settings = environmentSettingsObject;
        let urlRecord;
        try {
          urlRecord = new URL(url3, settings.settingsObject.baseUrl);
          this.#state.origin = urlRecord.origin;
        } catch (e) {
          throw new DOMException(e, "SyntaxError");
        }
        this.#url = urlRecord.href;
        let corsAttributeState = ANONYMOUS;
        if (eventSourceInitDict.withCredentials === true) {
          corsAttributeState = USE_CREDENTIALS;
          this.#withCredentials = true;
        }
        const initRequest = {
          redirect: "follow",
          keepalive: true,
          // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes
          mode: "cors",
          credentials: corsAttributeState === "anonymous" ? "same-origin" : "omit",
          referrer: "no-referrer"
        };
        initRequest.client = environmentSettingsObject.settingsObject;
        initRequest.headersList = [["accept", { name: "accept", value: "text/event-stream" }]];
        initRequest.cache = "no-store";
        initRequest.initiator = "other";
        initRequest.urlList = [new URL(this.#url)];
        this.#request = makeRequest(initRequest);
        this.#connect();
      }
      /**
       * Returns the state of this EventSource object's connection. It can have the
       * values described below.
       * @returns {ReadyState}
       * @readonly
       */
      get readyState() {
        return this.#readyState;
      }
      /**
       * Returns the URL providing the event stream.
       * @readonly
       * @returns {string}
       */
      get url() {
        return this.#url;
      }
      /**
       * Returns a boolean indicating whether the EventSource object was
       * instantiated with CORS credentials set (true), or not (false, the default).
       */
      get withCredentials() {
        return this.#withCredentials;
      }
      #connect() {
        if (this.#readyState === CLOSED) return;
        this.#readyState = CONNECTING;
        const fetchParams = {
          request: this.#request,
          dispatcher: this.#dispatcher
        };
        const processEventSourceEndOfBody = (response) => {
          if (isNetworkError(response)) {
            this.dispatchEvent(new Event("error"));
            this.close();
          }
          this.#reconnect();
        };
        fetchParams.processResponseEndOfBody = processEventSourceEndOfBody;
        fetchParams.processResponse = (response) => {
          if (isNetworkError(response)) {
            if (response.aborted) {
              this.close();
              this.dispatchEvent(new Event("error"));
              return;
            } else {
              this.#reconnect();
              return;
            }
          }
          const contentType = response.headersList.get("content-type", true);
          const mimeType = contentType !== null ? parseMIMEType(contentType) : "failure";
          const contentTypeValid = mimeType !== "failure" && mimeType.essence === "text/event-stream";
          if (response.status !== 200 || contentTypeValid === false) {
            this.close();
            this.dispatchEvent(new Event("error"));
            return;
          }
          this.#readyState = OPEN;
          this.dispatchEvent(new Event("open"));
          this.#state.origin = response.urlList[response.urlList.length - 1].origin;
          const eventSourceStream = new EventSourceStream({
            eventSourceSettings: this.#state,
            push: (event) => {
              this.dispatchEvent(createFastMessageEvent(
                event.type,
                event.options
              ));
            }
          });
          pipeline(
            response.body.stream,
            eventSourceStream,
            (error4) => {
              if (error4?.aborted === false) {
                this.close();
                this.dispatchEvent(new Event("error"));
              }
            }
          );
        };
        this.#controller = fetching(fetchParams);
      }
      /**
       * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model
       * @returns {Promise<void>}
       */
      async #reconnect() {
        if (this.#readyState === CLOSED) return;
        this.#readyState = CONNECTING;
        this.dispatchEvent(new Event("error"));
        await delay4(this.#state.reconnectionTime);
        if (this.#readyState !== CONNECTING) return;
        if (this.#state.lastEventId.length) {
          this.#request.headersList.set("last-event-id", this.#state.lastEventId, true);
        }
        this.#connect();
      }
      /**
       * Closes the connection, if any, and sets the readyState attribute to
       * CLOSED.
       */
      close() {
        webidl.brandCheck(this, _EventSource);
        if (this.#readyState === CLOSED) return;
        this.#readyState = CLOSED;
        this.#controller.abort();
        this.#request = null;
      }
      get onopen() {
        return this.#events.open;
      }
      set onopen(fn2) {
        if (this.#events.open) {
          this.removeEventListener("open", this.#events.open);
        }
        if (typeof fn2 === "function") {
          this.#events.open = fn2;
          this.addEventListener("open", fn2);
        } else {
          this.#events.open = null;
        }
      }
      get onmessage() {
        return this.#events.message;
      }
      set onmessage(fn2) {
        if (this.#events.message) {
          this.removeEventListener("message", this.#events.message);
        }
        if (typeof fn2 === "function") {
          this.#events.message = fn2;
          this.addEventListener("message", fn2);
        } else {
          this.#events.message = null;
        }
      }
      get onerror() {
        return this.#events.error;
      }
      set onerror(fn2) {
        if (this.#events.error) {
          this.removeEventListener("error", this.#events.error);
        }
        if (typeof fn2 === "function") {
          this.#events.error = fn2;
          this.addEventListener("error", fn2);
        } else {
          this.#events.error = null;
        }
      }
    };
    var constantsPropertyDescriptors = {
      CONNECTING: {
        __proto__: null,
        configurable: false,
        enumerable: true,
        value: CONNECTING,
        writable: false
      },
      OPEN: {
        __proto__: null,
        configurable: false,
        enumerable: true,
        value: OPEN,
        writable: false
      },
      CLOSED: {
        __proto__: null,
        configurable: false,
        enumerable: true,
        value: CLOSED,
        writable: false
      }
    };
    Object.defineProperties(EventSource, constantsPropertyDescriptors);
    Object.defineProperties(EventSource.prototype, constantsPropertyDescriptors);
    Object.defineProperties(EventSource.prototype, {
      close: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      onopen: kEnumerableProperty,
      readyState: kEnumerableProperty,
      url: kEnumerableProperty,
      withCredentials: kEnumerableProperty
    });
    webidl.converters.EventSourceInitDict = webidl.dictionaryConverter([
      {
        key: "withCredentials",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "dispatcher",
        // undici only
        converter: webidl.converters.any
      }
    ]);
    module.exports = {
      EventSource,
      defaultReconnectionTime
    };
  }
});

// node_modules/.pnpm/undici@7.6.0/node_modules/undici/index.js
var require_undici = __commonJS({
  "node_modules/.pnpm/undici@7.6.0/node_modules/undici/index.js"(exports, module) {
    var Client = require_client();
    var Dispatcher = require_dispatcher();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent = require_agent();
    var ProxyAgent = require_proxy_agent();
    var EnvHttpProxyAgent = require_env_http_proxy_agent();
    var RetryAgent = require_retry_agent();
    var errors = require_errors();
    var util = require_util();
    var { InvalidArgumentError } = errors;
    var api = require_api();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var { MockCallHistory, MockCallHistoryLog } = require_mock_call_history();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var mockErrors = require_mock_errors();
    var RetryHandler = require_retry_handler();
    var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
    var DecoratorHandler = require_decorator_handler();
    var RedirectHandler = require_redirect_handler();
    Object.assign(Dispatcher.prototype, api);
    module.exports.Dispatcher = Dispatcher;
    module.exports.Client = Client;
    module.exports.Pool = Pool;
    module.exports.BalancedPool = BalancedPool;
    module.exports.Agent = Agent;
    module.exports.ProxyAgent = ProxyAgent;
    module.exports.EnvHttpProxyAgent = EnvHttpProxyAgent;
    module.exports.RetryAgent = RetryAgent;
    module.exports.RetryHandler = RetryHandler;
    module.exports.DecoratorHandler = DecoratorHandler;
    module.exports.RedirectHandler = RedirectHandler;
    module.exports.interceptors = {
      redirect: require_redirect(),
      responseError: require_response_error(),
      retry: require_retry(),
      dump: require_dump(),
      dns: require_dns(),
      cache: require_cache2()
    };
    module.exports.cacheStores = {
      MemoryCacheStore: require_memory_cache_store()
    };
    var SqliteCacheStore = require_sqlite_cache_store();
    module.exports.cacheStores.SqliteCacheStore = SqliteCacheStore;
    module.exports.buildConnector = buildConnector;
    module.exports.errors = errors;
    module.exports.util = {
      parseHeaders: util.parseHeaders,
      headerNameToString: util.headerNameToString
    };
    function makeDispatcher(fn2) {
      return (url3, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url3 || typeof url3 !== "string" && typeof url3 !== "object" && !(url3 instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          let path3 = opts.path;
          if (!opts.path.startsWith("/")) {
            path3 = `/${path3}`;
          }
          url3 = new URL(util.parseOrigin(url3).origin + path3);
        } else {
          if (!opts) {
            opts = typeof url3 === "object" ? url3 : {};
          }
          url3 = util.parseURL(url3);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn2.call(dispatcher, {
          ...opts,
          origin: url3.origin,
          path: url3.search ? `${url3.pathname}${url3.search}` : url3.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module.exports.setGlobalDispatcher = setGlobalDispatcher;
    module.exports.getGlobalDispatcher = getGlobalDispatcher;
    var fetchImpl = require_fetch().fetch;
    module.exports.fetch = async function fetch(init2, options = void 0) {
      try {
        return await fetchImpl(init2, options);
      } catch (err) {
        if (err && typeof err === "object") {
          Error.captureStackTrace(err);
        }
        throw err;
      }
    };
    module.exports.Headers = require_headers().Headers;
    module.exports.Response = require_response().Response;
    module.exports.Request = require_request2().Request;
    module.exports.FormData = require_formdata().FormData;
    var { setGlobalOrigin, getGlobalOrigin } = require_global();
    module.exports.setGlobalOrigin = setGlobalOrigin;
    module.exports.getGlobalOrigin = getGlobalOrigin;
    var { CacheStorage } = require_cachestorage();
    var { kConstruct } = require_symbols();
    module.exports.caches = new CacheStorage(kConstruct);
    var { deleteCookie, getCookies, getSetCookies, setCookie, parseCookie } = require_cookies();
    module.exports.deleteCookie = deleteCookie;
    module.exports.getCookies = getCookies;
    module.exports.getSetCookies = getSetCookies;
    module.exports.setCookie = setCookie;
    module.exports.parseCookie = parseCookie;
    var { parseMIMEType, serializeAMimeType } = require_data_url();
    module.exports.parseMIMEType = parseMIMEType;
    module.exports.serializeAMimeType = serializeAMimeType;
    var { CloseEvent, ErrorEvent, MessageEvent } = require_events();
    module.exports.WebSocket = require_websocket().WebSocket;
    module.exports.CloseEvent = CloseEvent;
    module.exports.ErrorEvent = ErrorEvent;
    module.exports.MessageEvent = MessageEvent;
    module.exports.WebSocketStream = require_websocketstream().WebSocketStream;
    module.exports.WebSocketError = require_websocketerror().WebSocketError;
    module.exports.request = makeDispatcher(api.request);
    module.exports.stream = makeDispatcher(api.stream);
    module.exports.pipeline = makeDispatcher(api.pipeline);
    module.exports.connect = makeDispatcher(api.connect);
    module.exports.upgrade = makeDispatcher(api.upgrade);
    module.exports.MockClient = MockClient;
    module.exports.MockCallHistory = MockCallHistory;
    module.exports.MockCallHistoryLog = MockCallHistoryLog;
    module.exports.MockPool = MockPool;
    module.exports.MockAgent = MockAgent;
    module.exports.mockErrors = mockErrors;
    var { EventSource } = require_eventsource();
    module.exports.EventSource = EventSource;
  }
});

// node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports, module) {
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h3 = m2 * 60;
    var d2 = h3 * 24;
    var w2 = d2 * 7;
    var y = d2 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse6(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse6(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match18 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match18) {
        return;
      }
      var n2 = parseFloat(match18[1]);
      var type = (match18[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y;
        case "weeks":
        case "week":
        case "w":
          return n2 * w2;
        case "days":
        case "day":
        case "d":
          return n2 * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h3;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return Math.round(ms / d2) + "d";
      }
      if (msAbs >= h3) {
        return Math.round(ms / h3) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms / m2) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return plural(ms, msAbs, d2, "day");
      }
      if (msAbs >= h3) {
        return plural(ms, msAbs, h3, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms, msAbs, m2, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/common.js"(exports, module) {
    function setup(env2) {
      createDebug2.debug = createDebug2;
      createDebug2.default = createDebug2;
      createDebug2.coerce = coerce;
      createDebug2.disable = disable4;
      createDebug2.enable = enable4;
      createDebug2.enabled = enabled2;
      createDebug2.humanize = require_ms();
      createDebug2.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug2[key] = env2[key];
      });
      createDebug2.names = [];
      createDebug2.skips = [];
      createDebug2.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug2.colors[Math.abs(hash2) % createDebug2.colors.length];
      }
      createDebug2.selectColor = selectColor;
      function createDebug2(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug4(...args2) {
          if (!debug4.enabled) {
            return;
          }
          const self2 = debug4;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args2[0] = createDebug2.coerce(args2[0]);
          if (typeof args2[0] !== "string") {
            args2.unshift("%O");
          }
          let index = 0;
          args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match18, format5) => {
            if (match18 === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug2.formatters[format5];
            if (typeof formatter === "function") {
              const val = args2[index];
              match18 = formatter.call(self2, val);
              args2.splice(index, 1);
              index--;
            }
            return match18;
          });
          createDebug2.formatArgs.call(self2, args2);
          const logFn = self2.log || createDebug2.log;
          logFn.apply(self2, args2);
        }
        debug4.namespace = namespace;
        debug4.useColors = createDebug2.useColors();
        debug4.color = createDebug2.selectColor(namespace);
        debug4.extend = extend3;
        debug4.destroy = createDebug2.destroy;
        Object.defineProperty(debug4, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug2.namespaces) {
              namespacesCache = createDebug2.namespaces;
              enabledCache = createDebug2.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug2.init === "function") {
          createDebug2.init(debug4);
        }
        return debug4;
      }
      function extend3(namespace, delimiter) {
        const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable4(namespaces) {
        createDebug2.save(namespaces);
        createDebug2.namespaces = namespaces;
        createDebug2.names = [];
        createDebug2.skips = [];
        const split3 = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split3) {
          if (ns[0] === "-") {
            createDebug2.skips.push(ns.slice(1));
          } else {
            createDebug2.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable4() {
        const namespaces = [
          ...createDebug2.names,
          ...createDebug2.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug2.enable("");
        return namespaces;
      }
      function enabled2(name) {
        for (const skip of createDebug2.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug2.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug2.enable(createDebug2.load());
      return createDebug2;
    }
    module.exports = setup;
  }
});

// node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned2 = false;
      return () => {
        if (!warned2) {
          warned2 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args2) {
      args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args2.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args2[0].replace(/%[a-zA-Z%]/g, (match18) => {
        if (match18 === "%%") {
          return;
        }
        index++;
        if (match18 === "%c") {
          lastC = index;
        }
      });
      args2.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error4) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error4) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error4) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error4) {
        return "[UnexpectedJSONParseError]: " + error4.message;
      }
    };
  }
});

// node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports, module) {
    module.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports, module) {
    var os = __require("os");
    var tty = __require("tty");
    var hasFlag = require_has_flag();
    var { env: env2 } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env2) {
      if (env2.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env2.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min3 = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min3;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min3;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version3 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version3 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min3;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/node.js"(exports, module) {
    var tty = __require("tty");
    var util = __require("util");
    exports.init = init2;
    exports.log = log5;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error4) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args2) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
        args2.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args2[0] = getDate() + name + " " + args2[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log5(...args2) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args2) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug4) {
      debug4.inspectOpts = {};
      const keys5 = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys5.length; i++) {
        debug4.inspectOpts[keys5[i]] = exports.inspectOpts[keys5[i]];
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.o = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v2, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v2, this.inspectOpts);
    };
  }
});

// node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js"(exports, module) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node();
    }
  }
});

// node_modules/.pnpm/@kwsites+file-exists@1.1.1/node_modules/@kwsites/file-exists/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/.pnpm/@kwsites+file-exists@1.1.1/node_modules/@kwsites/file-exists/dist/src/index.js"(exports) {
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs_1 = __require("fs");
    var debug_1 = __importDefault(require_src());
    var log5 = debug_1.default("@kwsites/file-exists");
    function check2(path3, isFile, isDirectory) {
      log5(`checking %s`, path3);
      try {
        const stat2 = fs_1.statSync(path3);
        if (stat2.isFile() && isFile) {
          log5(`[OK] path represents a file`);
          return true;
        }
        if (stat2.isDirectory() && isDirectory) {
          log5(`[OK] path represents a directory`);
          return true;
        }
        log5(`[FAIL] path represents something other than a file or directory`);
        return false;
      } catch (e) {
        if (e.code === "ENOENT") {
          log5(`[FAIL] path is not accessible: %o`, e);
          return false;
        }
        log5(`[FATAL] %o`, e);
        throw e;
      }
    }
    function exists4(path3, type = exports.READABLE) {
      return check2(path3, (type & exports.FILE) > 0, (type & exports.FOLDER) > 0);
    }
    exports.exists = exists4;
    exports.FILE = 1;
    exports.FOLDER = 2;
    exports.READABLE = exports.FILE + exports.FOLDER;
  }
});

// node_modules/.pnpm/@kwsites+file-exists@1.1.1/node_modules/@kwsites/file-exists/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/@kwsites+file-exists@1.1.1/node_modules/@kwsites/file-exists/dist/index.js"(exports) {
    function __export3(m2) {
      for (var p3 in m2) if (!exports.hasOwnProperty(p3)) exports[p3] = m2[p3];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export3(require_src2());
  }
});

// node_modules/.pnpm/@kwsites+promise-deferred@1.1.1/node_modules/@kwsites/promise-deferred/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/.pnpm/@kwsites+promise-deferred@1.1.1/node_modules/@kwsites/promise-deferred/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDeferred = exports.deferred = void 0;
    function deferred2() {
      let done11;
      let fail19;
      let status2 = "pending";
      const promise3 = new Promise((_done, _fail) => {
        done11 = _done;
        fail19 = _fail;
      });
      return {
        promise: promise3,
        done(result) {
          if (status2 === "pending") {
            status2 = "resolved";
            done11(result);
          }
        },
        fail(error4) {
          if (status2 === "pending") {
            status2 = "rejected";
            fail19(error4);
          }
        },
        get fulfilled() {
          return status2 !== "pending";
        },
        get status() {
          return status2;
        }
      };
    }
    exports.deferred = deferred2;
    exports.createDeferred = deferred2;
    exports.default = deferred2;
  }
});

// node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js"(exports, module) {
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol3) {
        return Object.propertyIsEnumerable.call(target, symbol3);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property3) {
      try {
        return property3 in object;
      } catch (_2) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array6, options) {
      if (!Array.isArray(array6)) {
        throw new Error("first argument should be an array");
      }
      return array6.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module.exports = deepmerge_1;
  }
});

// node_modules/.pnpm/is-module@1.0.0/node_modules/is-module/index.js
var require_is_module = __commonJS({
  "node_modules/.pnpm/is-module@1.0.0/node_modules/is-module/index.js"(exports, module) {
    var ES6ImportExportRegExp = /(?:^\s*|[}{\(\);,\n]\s*)(import\s+['"]|(import|module)\s+[^"'\(\)\n;]+\s+from\s+['"]|export\s+(\*|\{|default|function|var|const|let|[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*))/;
    var ES6AliasRegExp = /(?:^\s*|[}{\(\);,\n]\s*)(export\s*\*\s*from\s*(?:'([^']+)'|"([^"]+)"))/;
    module.exports = function(sauce) {
      return ES6ImportExportRegExp.test(sauce) || ES6AliasRegExp.test(sauce);
    };
  }
});

// node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/homedir.js"(exports, module) {
    var os = __require("os");
    module.exports = os.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/caller.js"(exports, module) {
    module.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_2, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// node_modules/.pnpm/path-parse@1.0.7/node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "node_modules/.pnpm/path-parse@1.0.7/node_modules/path-parse/index.js"(exports, module) {
    var isWindows = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win323 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win323.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix3 = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix3.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module.exports = win323.parse;
    else
      module.exports = posix3.parse;
    module.exports.posix = posix3.parse;
    module.exports.win32 = win323.parse;
  }
});

// node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/node-modules-paths.js"(exports, module) {
    var path3 = __require("path");
    var parse6 = path3.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse6(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse6(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path3.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module.exports = function nodeModulesPaths(start3, opts, request2) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request2,
          start3,
          function() {
            return getNodeModulesDirs(start3, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start3, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/normalize-options.js"(exports, module) {
    module.exports = function(x2, opts) {
      return opts || {};
    };
  }
});

// node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports, module) {
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max5 = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a2, b) {
      var arr = [];
      for (var i = 0; i < a2.length; i += 1) {
        arr[i] = a2[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a2.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind6(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args2 = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args2, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args2, arguments)
        );
      };
      var boundLength = max5(0, target.length - args2.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports, module) {
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(exports, module) {
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind6 = require_function_bind();
    module.exports = bind6.call(call, $hasOwn);
  }
});

// node_modules/.pnpm/is-core-module@2.16.1/node_modules/is-core-module/core.json
var require_core = __commonJS({
  "node_modules/.pnpm/is-core-module@2.16.1/node_modules/is-core-module/core.json"(exports, module) {
    module.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      "node:sea": [">= 20.12 && < 21", ">= 21.7"],
      smalloc: ">= 0.11.5 && < 3",
      "node:sqlite": [">= 22.13 && < 23", ">= 23.4"],
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "test/mock_loader": ">= 22.3 && < 22.7",
      "node:test/mock_loader": ">= 22.3 && < 22.7",
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/.pnpm/is-core-module@2.16.1/node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "node_modules/.pnpm/is-core-module@2.16.1/node_modules/is-core-module/index.js"(exports, module) {
    var hasOwn = require_hasown();
    function specifierIncluded(current2, specifier) {
      var nodeParts = current2.split(".");
      var parts2 = specifier.split(" ");
      var op = parts2.length > 1 ? parts2[0] : "=";
      var versionParts = (parts2.length > 1 ? parts2[1] : parts2[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current2, range4) {
      var specifiers = range4.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current2, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current2 = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current2 !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current2, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current2, specifierValue);
    }
    var data = require_core();
    module.exports = function isCore(x2, nodeVersion) {
      return hasOwn(data, x2) && versionIncluded(nodeVersion, data[x2]);
    };
  }
});

// node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/async.js"(exports, module) {
    var fs3 = __require("fs");
    var getHomedir = require_homedir();
    var path3 = __require("path");
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = process.platform !== "win32" && fs3.realpath && typeof fs3.realpath.native === "function" ? fs3.realpath.native : fs3.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path3.join(homedir, ".node_modules"),
        path3.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs3.stat(file, function(err, stat2) {
        if (!err) {
          return cb(null, stat2.isFile() || stat2.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR") return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir3, cb) {
      fs3.stat(dir3, function(err, stat2) {
        if (!err) {
          return cb(null, stat2.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR") return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath3(x2, cb) {
      realpathFS(x2, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT") cb(realpathErr);
        else cb(null, realpathErr ? x2 : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath3, x2, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath3(x2, cb);
      } else {
        cb(null, x2);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile3, pkgfile, cb) {
      readFile3(pkgfile, function(readFileErr, body) {
        if (readFileErr) cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x2, start3, opts) {
      var dirs = nodeModulesPaths(start3, opts, x2);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path3.join(dirs[i], x2);
      }
      return dirs;
    };
    module.exports = function resolve9(x2, options, callback) {
      var cb = callback;
      var opts = options;
      if (typeof options === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x2 !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x2, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile3 = opts.readFile || fs3.readFile;
      var realpath3 = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path3.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path3.resolve(basedir);
      maybeRealpath(
        realpath3,
        absoluteStart,
        opts,
        function(err2, realStart) {
          if (err2) cb(err2);
          else init2(realStart);
        }
      );
      var res;
      function init2(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x2)) {
          res = path3.resolve(basedir2, x2);
          if (x2 === "." || x2 === ".." || x2.slice(-1) === "/") res += "/";
          if (/\/$/.test(x2) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x2)) {
          return cb(null, x2);
        } else loadNodeModules(x2, basedir2, function(err2, n2, pkg) {
          if (err2) cb(err2);
          else if (n2) {
            return maybeRealpath(realpath3, n2, opts, function(err3, realN) {
              if (err3) {
                cb(err3);
              } else {
                cb(null, realN, pkg);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x2 + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
      }
      function onfile(err2, m2, pkg) {
        if (err2) cb(err2);
        else if (m2) cb(null, m2, pkg);
        else loadAsDirectory(res, function(err3, d2, pkg2) {
          if (err3) cb(err3);
          else if (d2) {
            maybeRealpath(realpath3, d2, opts, function(err4, realD) {
              if (err4) {
                cb(err4);
              } else {
                cb(null, realD, pkg2);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x2 + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
      }
      function loadAsFile(x3, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x3, loadAsFilePackage);
        function load(exts2, x4, loadPackage) {
          if (exts2.length === 0) return cb2(null, void 0, loadPackage);
          var file = x4 + exts2[0];
          var pkg = loadPackage;
          if (pkg) onpkg(null, pkg);
          else loadpkg(path3.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir3) {
            pkg = pkg_;
            if (err2) return cb2(err2);
            if (dir3 && pkg && opts.pathFilter) {
              var rfile = path3.relative(dir3, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x4, rel);
              if (r) return load(
                [""].concat(extensions.slice()),
                path3.resolve(dir3, r),
                pkg
              );
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2) return cb2(err2);
            if (ex) return cb2(null, file, pkg);
            load(exts2.slice(1), x4, pkg);
          }
        }
      }
      function loadpkg(dir3, cb2) {
        if (dir3 === "" || dir3 === "/") return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir3)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir3)) return cb2(null);
        maybeRealpath(realpath3, dir3, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr) return loadpkg(path3.dirname(dir3), cb2);
          var pkgfile = path3.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex) return loadpkg(path3.dirname(dir3), cb2);
            readPackage(readFile3, pkgfile, function(err3, pkgParam) {
              if (err3) cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir3);
            });
          });
        });
      }
      function loadAsDirectory(x3, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath3, x3, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr) return cb2(unwrapErr);
          var pkgfile = path3.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2) return cb2(err2);
            if (!ex) return loadAsFile(path3.join(x3, "index"), fpkg, cb2);
            readPackage(readFile3, pkgfile, function(err3, pkgParam) {
              if (err3) return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path3.resolve(x3, pkg.main), pkg, function(err4, m2, pkg2) {
                  if (err4) return cb2(err4);
                  if (m2) return cb2(null, m2, pkg2);
                  if (!pkg2) return loadAsFile(path3.join(x3, "index"), pkg2, cb2);
                  var dir3 = path3.resolve(x3, pkg2.main);
                  loadAsDirectory(dir3, pkg2, function(err5, n2, pkg3) {
                    if (err5) return cb2(err5);
                    if (n2) return cb2(null, n2, pkg3);
                    loadAsFile(path3.join(x3, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path3.join(x3, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0) return cb2(null, void 0);
        var dir3 = dirs[0];
        isDirectory(path3.dirname(dir3), isdir);
        function isdir(err2, isdir2) {
          if (err2) return cb2(err2);
          if (!isdir2) return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir3, opts.package, onfile2);
        }
        function onfile2(err2, m2, pkg) {
          if (err2) return cb2(err2);
          if (m2) return cb2(null, m2, pkg);
          loadAsDirectory(dir3, opts.package, ondir);
        }
        function ondir(err2, n2, pkg) {
          if (err2) return cb2(err2);
          if (n2) return cb2(null, n2, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x3, start3, cb2) {
        var thunk = function() {
          return getPackageCandidates(x3, start3, opts);
        };
        processDirs(
          cb2,
          packageIterator ? packageIterator(x3, start3, thunk, opts) : thunk()
        );
      }
    };
  }
});

// node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/core.json"(exports, module) {
    module.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      "node:sea": [">= 20.12 && < 21", ">= 21.7"],
      smalloc: ">= 0.11.5 && < 3",
      "node:sqlite": ">= 23.4",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "test/mock_loader": ">= 22.3 && < 22.7",
      "node:test/mock_loader": ">= 22.3 && < 22.7",
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/core.js"(exports, module) {
    var isCoreModule = require_is_core_module();
    var data = require_core2();
    var core = {};
    for (mod in data) {
      if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = isCoreModule(mod);
      }
    }
    var mod;
    module.exports = core;
  }
});

// node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/is-core.js"(exports, module) {
    var isCoreModule = require_is_core_module();
    module.exports = function isCore(x2) {
      return isCoreModule(x2);
    };
  }
});

// node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/lib/sync.js"(exports, module) {
    var isCore = require_is_core_module();
    var fs3 = __require("fs");
    var path3 = __require("path");
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = process.platform !== "win32" && fs3.realpathSync && typeof fs3.realpathSync.native === "function" ? fs3.realpathSync.native : fs3.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path3.join(homedir, ".node_modules"),
        path3.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat2 = fs3.statSync(file, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR")) return false;
        throw e;
      }
      return !!stat2 && (stat2.isFile() || stat2.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir3) {
      try {
        var stat2 = fs3.statSync(dir3, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR")) return false;
        throw e;
      }
      return !!stat2 && stat2.isDirectory();
    };
    var defaultRealpathSync = function realpathSync2(x2) {
      try {
        return realpathFS(x2);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x2;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync2, x2, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync2(x2);
      }
      return x2;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
      var body = readFileSync(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x2, start3, opts) {
      var dirs = nodeModulesPaths(start3, opts, x2);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path3.join(dirs[i], x2);
      }
      return dirs;
    };
    module.exports = function resolveSync(x2, options) {
      if (typeof x2 !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x2, options);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync = opts.readFileSync || fs3.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync2 = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path3.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync2, path3.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x2)) {
        var res = path3.resolve(absoluteStart, x2);
        if (x2 === "." || x2 === ".." || x2.slice(-1) === "/") res += "/";
        var m2 = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m2) return maybeRealpathSync(realpathSync2, m2, opts);
      } else if (includeCoreModules && isCore(x2)) {
        return x2;
      } else {
        var n2 = loadNodeModulesSync(x2, absoluteStart);
        if (n2) return maybeRealpathSync(realpathSync2, n2, opts);
      }
      var err = new Error("Cannot find module '" + x2 + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x3) {
        var pkg = loadpkg(path3.dirname(x3));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path3.relative(pkg.dir, x3);
          var r = opts.pathFilter(pkg.pkg, x3, rfile);
          if (r) {
            x3 = path3.resolve(pkg.dir, r);
          }
        }
        if (isFile(x3)) {
          return x3;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x3 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir3) {
        if (dir3 === "" || dir3 === "/") return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir3)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir3)) return;
        var pkgfile = path3.join(maybeRealpathSync(realpathSync2, dir3, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path3.dirname(dir3));
        }
        var pkg = readPackageSync(readFileSync, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(
            pkg,
            /*pkgfile,*/
            dir3
          );
        }
        return { pkg, dir: dir3 };
      }
      function loadAsDirectorySync(x3) {
        var pkgfile = path3.join(maybeRealpathSync(realpathSync2, x3, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(
              pkg,
              /*pkgfile,*/
              x3
            );
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m3 = loadAsFileSync(path3.resolve(x3, pkg.main));
              if (m3) return m3;
              var n3 = loadAsDirectorySync(path3.resolve(x3, pkg.main));
              if (n3) return n3;
            } catch (e) {
            }
          }
        }
        return loadAsFileSync(path3.join(x3, "/index"));
      }
      function loadNodeModulesSync(x3, start3) {
        var thunk = function() {
          return getPackageCandidates(x3, start3, opts);
        };
        var dirs = packageIterator ? packageIterator(x3, start3, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir3 = dirs[i];
          if (isDirectory(path3.dirname(dir3))) {
            var m3 = loadAsFileSync(dir3);
            if (m3) return m3;
            var n3 = loadAsDirectorySync(dir3);
            if (n3) return n3;
          }
        }
      }
    };
  }
});

// node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/index.js
var require_resolve = __commonJS({
  "node_modules/.pnpm/resolve@1.22.10/node_modules/resolve/index.js"(exports, module) {
    var async3 = require_async();
    async3.core = require_core3();
    async3.isCore = require_is_core();
    async3.sync = require_sync();
    module.exports = async3;
  }
});

// node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/constants.js
var require_constants6 = __commonJS({
  "node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/constants.js"(exports, module) {
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var SEP = "/";
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR,
      SEP
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
      SEP: "\\"
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars3) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars3.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win323) {
        return win323 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/utils.js"(exports) {
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants6();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.isWindows = () => {
      if (typeof navigator !== "undefined" && navigator.platform) {
        const platform = navigator.platform.toLowerCase();
        return platform === "win32" || platform === "windows";
      }
      if (typeof process !== "undefined" && process.platform) {
        return process.platform === "win32";
      }
      return false;
    };
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match18) => {
        return match18 === "\\" ? "" : match18;
      });
    };
    exports.escapeLast = (input2, char, lastIdx) => {
      const idx = input2.lastIndexOf(char, lastIdx);
      if (idx === -1) return input2;
      if (input2[idx - 1] === "\\") return exports.escapeLast(input2, char, idx - 1);
      return `${input2.slice(0, idx)}\\${input2.slice(idx)}`;
    };
    exports.removePrefix = (input2, state = {}) => {
      let output = input2;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input2, state = {}, options = {}) => {
      const prepend6 = options.contains ? "" : "^";
      const append6 = options.contains ? "" : "$";
      let output = `${prepend6}(?:${input2})${append6}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
    exports.basename = (path3, { windows } = {}) => {
      const segs = path3.split(windows ? /[\\/]/ : "/");
      const last6 = segs[segs.length - 1];
      if (last6 === "") {
        return segs[segs.length - 2];
      }
      return last6;
    };
  }
});

// node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/scan.js"(exports, module) {
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants6();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan3 = (input2, options) => {
      const opts = options || {};
      const length3 = input2.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts2 = [];
      let str = input2;
      let index = -1;
      let start3 = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length3;
      const peek2 = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length3) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT && index === start3 + 1) {
            start3 += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek2() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start3) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start3) {
          negated = token.negated = true;
          start3++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base2 = str;
      let prefix = "";
      let glob = "";
      if (start3 > 0) {
        prefix = str.slice(0, start3);
        str = str.slice(start3);
        lastIndex -= start3;
      }
      if (base2 && isGlob === true && lastIndex > 0) {
        base2 = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base2 = "";
        glob = str;
      } else {
        base2 = str;
      }
      if (base2 && base2 !== "" && base2 !== "/" && base2 !== str) {
        if (isPathSeparator(base2.charCodeAt(base2.length - 1))) {
          base2 = base2.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob) glob = utils.removeBackslashes(glob);
        if (base2 && backslashes === true) {
          base2 = utils.removeBackslashes(base2);
        }
      }
      const state = {
        prefix,
        input: input2,
        start: start3,
        base: base2,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n2 = prevIndex ? prevIndex + 1 : start3;
          const i = slashes[idx];
          const value = input2.slice(n2, i);
          if (opts.tokens) {
            if (idx === 0 && start3 !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts2.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input2.length) {
          const value = input2.slice(prevIndex + 1);
          parts2.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts2;
      }
      return state;
    };
    module.exports = scan3;
  }
});

// node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/parse.js"(exports, module) {
    var constants = require_constants6();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args2, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args2, options);
      }
      args2.sort();
      const value = `[${args2.join("-")}]`;
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse6 = (input2, options) => {
      if (typeof input2 !== "string") {
        throw new TypeError("Expected a string");
      }
      input2 = REPLACEMENTS[input2] || input2;
      const opts = { ...options };
      const max5 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input2.length;
      if (len > max5) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max5}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture2 = opts.capture ? "" : "?:";
      const PLATFORM_CHARS = constants.globChars(opts.windows);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture2}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input: input2,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input2 = utils.removePrefix(input2, state);
      len = input2.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek2 = state.peek = (n2 = 1) => input2[state.index + n2];
      const advance = state.advance = () => input2[++state.index] || "";
      const remaining = () => input2.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append6 = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate3 = () => {
        let count5 = 1;
        while (peek2() === "!" && (peek2(2) !== "(" || peek2(3) === "?")) {
          advance();
          state.start++;
          count5++;
        }
        if (count5 % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push2 = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append6(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.output = (prev.output || prev.value) + tok.value;
          prev.value += tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push2({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push2({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse6(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push2({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input2)) {
        let backslashes = false;
        let output = input2.replace(REGEX_SPECIAL_CHARS_BACKREF, (m2, esc, chars3, first3, rest, index) => {
          if (first3 === "\\") {
            backslashes = true;
            return m2;
          }
          if (first3 === "?") {
            if (esc) {
              return esc + first3 + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars3.length);
          }
          if (first3 === ".") {
            return DOT_LITERAL.repeat(chars3.length);
          }
          if (first3 === "*") {
            if (esc) {
              return esc + first3 + (rest ? star : "");
            }
            return star;
          }
          return esc ? m2 : `\\${m2}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m2) => {
              return m2.length % 2 === 0 ? "\\\\" : m2 ? "\\" : "";
            });
          }
        }
        if (output === input2 && opts.contains === true) {
          state.output = input2;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek2();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push2({ type: "text", value });
            continue;
          }
          const match18 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match18 && match18[0].length > 2) {
            slashes = match18[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push2({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix3 = POSIX_REGEX_SOURCE[rest2];
                if (posix3) {
                  prev.value = pre + posix3;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek2() !== ":" || value === "-" && peek2() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append6({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append6({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push2({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push2({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push2({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push2({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push2({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push2({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append6({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture2}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push2(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push2({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range4 = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range4.unshift(arr[i].value);
              }
            }
            output = expandRange(range4, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push2({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push2({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push2({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push2({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push2({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push2({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek2();
            let output = value;
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push2({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push2({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push2({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek2() === "(") {
            if (peek2(2) !== "?" || !/[!=<:]/.test(peek2(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate3();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push2({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push2({ type: "plus", value });
            continue;
          }
          push2({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            push2({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push2({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match18 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match18) {
            value += match18[0];
            state.index += match18[0].length;
          }
          push2({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before2 = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before2 && (before2.type === "star" || before2.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push2({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push2({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after3 = input2[state.index + 4];
            if (after3 && after3 !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end6 = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end6})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push2(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push2(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek2() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push2(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse6.fastpaths = (input2, options) => {
      const opts = { ...options };
      const max5 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input2.length;
      if (len > max5) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max5}`);
      }
      input2 = REPLACEMENTS[input2] || input2;
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(opts.windows);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture2 = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star;
        return `(${capture2}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match18 = /^(.*?)\.(\w+)$/.exec(str);
            if (!match18) return;
            const source2 = create(match18[1]);
            if (!source2) return;
            return source2 + DOT_LITERAL + match18[2];
          }
        }
      };
      const output = utils.removePrefix(input2, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module.exports = parse6;
  }
});

// node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/picomatch.js"(exports, module) {
    var scan3 = require_scan();
    var parse6 = require_parse2();
    var utils = require_utils2();
    var constants = require_constants6();
    var isObject4 = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input2) => picomatch(input2, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2) return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject4(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix3 = opts.windows;
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input2, returnObject = false) => {
        const { isMatch, match: match18, output } = picomatch.test(input2, regex, options, { glob, posix: posix3 });
        const result = { glob, state, regex, posix: posix3, input: input2, output, match: match18, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input2)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input2, regex, options, { glob, posix: posix3 } = {}) => {
      if (typeof input2 !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input2 === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format5 = opts.format || (posix3 ? utils.toPosixSlashes : null);
      let match18 = input2 === glob;
      let output = match18 && format5 ? format5(input2) : input2;
      if (match18 === false) {
        output = format5 ? format5(input2) : input2;
        match18 = output === glob;
      }
      if (match18 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match18 = picomatch.matchBase(input2, regex, options, posix3);
        } else {
          match18 = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match18), match: match18, output };
    };
    picomatch.matchBase = (input2, glob, options) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(utils.basename(input2));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern)) return pattern.map((p3) => picomatch.parse(p3, options));
      return parse6(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input2, options) => scan3(input2, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend6 = opts.contains ? "" : "^";
      const append6 = opts.contains ? "" : "$";
      let source = `${prepend6}(?:${state.output})${append6}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input2, options = {}, returnOutput = false, returnState = false) => {
      if (!input2 || typeof input2 !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input2[0] === "." || input2[0] === "*")) {
        parsed.output = parse6.fastpaths(input2, options);
      }
      if (!parsed.output) {
        parsed = parse6(input2, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module.exports = picomatch;
  }
});

// node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/index.js"(exports, module) {
    var pico = require_picomatch();
    var utils = require_utils2();
    function picomatch(glob, options, returnState = false) {
      if (options && (options.windows === null || options.windows === void 0)) {
        options = { ...options, windows: utils.isWindows() };
      }
      return pico(glob, options, returnState);
    }
    Object.assign(picomatch, pico);
    module.exports = picomatch;
  }
});

// node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/index.js
var require_randombytes = __commonJS({
  "node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/index.js"(exports, module) {
    module.exports = __require("crypto").randomBytes;
  }
});

// node_modules/.pnpm/serialize-javascript@6.0.2/node_modules/serialize-javascript/index.js
var require_serialize_javascript = __commonJS({
  "node_modules/.pnpm/serialize-javascript@6.0.2/node_modules/serialize-javascript/index.js"(exports, module) {
    var randomBytes = require_randombytes();
    var UID_LENGTH = 16;
    var UID = generateUID();
    var PLACE_HOLDER_REGEXP = new RegExp('(\\\\)?"@__(F|R|D|M|S|A|U|I|B|L)-' + UID + '-(\\d+)__@"', "g");
    var IS_NATIVE_CODE_REGEXP = /\{\s*\[native code\]\s*\}/g;
    var IS_PURE_FUNCTION = /function.*?\(/;
    var IS_ARROW_FUNCTION = /.*?=>.*?/;
    var UNSAFE_CHARS_REGEXP = /[<>\/\u2028\u2029]/g;
    var RESERVED_SYMBOLS = ["*", "async"];
    var ESCAPED_CHARS = {
      "<": "\\u003C",
      ">": "\\u003E",
      "/": "\\u002F",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    function escapeUnsafeChars(unsafeChar) {
      return ESCAPED_CHARS[unsafeChar];
    }
    function generateUID() {
      var bytes = randomBytes(UID_LENGTH);
      var result = "";
      for (var i = 0; i < UID_LENGTH; ++i) {
        result += bytes[i].toString(16);
      }
      return result;
    }
    function deleteFunctions(obj) {
      var functionKeys = [];
      for (var key in obj) {
        if (typeof obj[key] === "function") {
          functionKeys.push(key);
        }
      }
      for (var i = 0; i < functionKeys.length; i++) {
        delete obj[functionKeys[i]];
      }
    }
    module.exports = function serialize(obj, options) {
      options || (options = {});
      if (typeof options === "number" || typeof options === "string") {
        options = { space: options };
      }
      var functions = [];
      var regexps = [];
      var dates = [];
      var maps = [];
      var sets = [];
      var arrays = [];
      var undefs = [];
      var infinities = [];
      var bigInts = [];
      var urls = [];
      function replacer(key, value) {
        if (options.ignoreFunction) {
          deleteFunctions(value);
        }
        if (!value && value !== void 0 && value !== BigInt(0)) {
          return value;
        }
        var origValue = this[key];
        var type = typeof origValue;
        if (type === "object") {
          if (origValue instanceof RegExp) {
            return "@__R-" + UID + "-" + (regexps.push(origValue) - 1) + "__@";
          }
          if (origValue instanceof Date) {
            return "@__D-" + UID + "-" + (dates.push(origValue) - 1) + "__@";
          }
          if (origValue instanceof Map) {
            return "@__M-" + UID + "-" + (maps.push(origValue) - 1) + "__@";
          }
          if (origValue instanceof Set) {
            return "@__S-" + UID + "-" + (sets.push(origValue) - 1) + "__@";
          }
          if (origValue instanceof Array) {
            var isSparse = origValue.filter(function() {
              return true;
            }).length !== origValue.length;
            if (isSparse) {
              return "@__A-" + UID + "-" + (arrays.push(origValue) - 1) + "__@";
            }
          }
          if (origValue instanceof URL) {
            return "@__L-" + UID + "-" + (urls.push(origValue) - 1) + "__@";
          }
        }
        if (type === "function") {
          return "@__F-" + UID + "-" + (functions.push(origValue) - 1) + "__@";
        }
        if (type === "undefined") {
          return "@__U-" + UID + "-" + (undefs.push(origValue) - 1) + "__@";
        }
        if (type === "number" && !isNaN(origValue) && !isFinite(origValue)) {
          return "@__I-" + UID + "-" + (infinities.push(origValue) - 1) + "__@";
        }
        if (type === "bigint") {
          return "@__B-" + UID + "-" + (bigInts.push(origValue) - 1) + "__@";
        }
        return value;
      }
      function serializeFunc(fn2) {
        var serializedFn = fn2.toString();
        if (IS_NATIVE_CODE_REGEXP.test(serializedFn)) {
          throw new TypeError("Serializing native function: " + fn2.name);
        }
        if (IS_PURE_FUNCTION.test(serializedFn)) {
          return serializedFn;
        }
        if (IS_ARROW_FUNCTION.test(serializedFn)) {
          return serializedFn;
        }
        var argsStartsAt = serializedFn.indexOf("(");
        var def = serializedFn.substr(0, argsStartsAt).trim().split(" ").filter(function(val) {
          return val.length > 0;
        });
        var nonReservedSymbols = def.filter(function(val) {
          return RESERVED_SYMBOLS.indexOf(val) === -1;
        });
        if (nonReservedSymbols.length > 0) {
          return (def.indexOf("async") > -1 ? "async " : "") + "function" + (def.join("").indexOf("*") > -1 ? "*" : "") + serializedFn.substr(argsStartsAt);
        }
        return serializedFn;
      }
      if (options.ignoreFunction && typeof obj === "function") {
        obj = void 0;
      }
      if (obj === void 0) {
        return String(obj);
      }
      var str;
      if (options.isJSON && !options.space) {
        str = JSON.stringify(obj);
      } else {
        str = JSON.stringify(obj, options.isJSON ? null : replacer, options.space);
      }
      if (typeof str !== "string") {
        return String(str);
      }
      if (options.unsafe !== true) {
        str = str.replace(UNSAFE_CHARS_REGEXP, escapeUnsafeChars);
      }
      if (functions.length === 0 && regexps.length === 0 && dates.length === 0 && maps.length === 0 && sets.length === 0 && arrays.length === 0 && undefs.length === 0 && infinities.length === 0 && bigInts.length === 0 && urls.length === 0) {
        return str;
      }
      return str.replace(PLACE_HOLDER_REGEXP, function(match18, backSlash, type, valueIndex) {
        if (backSlash) {
          return match18;
        }
        if (type === "D") {
          return 'new Date("' + dates[valueIndex].toISOString() + '")';
        }
        if (type === "R") {
          return "new RegExp(" + serialize(regexps[valueIndex].source) + ', "' + regexps[valueIndex].flags + '")';
        }
        if (type === "M") {
          return "new Map(" + serialize(Array.from(maps[valueIndex].entries()), options) + ")";
        }
        if (type === "S") {
          return "new Set(" + serialize(Array.from(sets[valueIndex].values()), options) + ")";
        }
        if (type === "A") {
          return "Array.prototype.slice.call(" + serialize(Object.assign({ length: arrays[valueIndex].length }, arrays[valueIndex]), options) + ")";
        }
        if (type === "U") {
          return "undefined";
        }
        if (type === "I") {
          return infinities[valueIndex];
        }
        if (type === "B") {
          return 'BigInt("' + bigInts[valueIndex] + '")';
        }
        if (type === "L") {
          return "new URL(" + serialize(urls[valueIndex].toString(), options) + ")";
        }
        var fn2 = functions[valueIndex];
        return serializeFunc(fn2);
      });
    };
  }
});

// node_modules/.pnpm/@rollup+wasm-node@4.37.0/node_modules/@rollup/wasm-node/dist/wasm-node/bindings_wasm.js
var require_bindings_wasm = __commonJS({
  "node_modules/.pnpm/@rollup+wasm-node@4.37.0/node_modules/@rollup/wasm-node/dist/wasm-node/bindings_wasm.js"(exports, module) {
    var imports = {};
    imports["__wbindgen_placeholder__"] = module.exports;
    var wasm;
    var { TextDecoder: TextDecoder2, TextEncoder: TextEncoder2 } = __require("util");
    var heap = new Array(128).fill(void 0);
    heap.push(void 0, null, true, false);
    function getObject(idx) {
      return heap[idx];
    }
    var heap_next = heap.length;
    function addHeapObject(obj) {
      if (heap_next === heap.length) heap.push(heap.length + 1);
      const idx = heap_next;
      heap_next = heap[idx];
      heap[idx] = obj;
      return idx;
    }
    var cachedTextDecoder = new TextDecoder2("utf-8", { ignoreBOM: true, fatal: true });
    cachedTextDecoder.decode();
    var cachedUint8ArrayMemory0 = null;
    function getUint8ArrayMemory0() {
      if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
      }
      return cachedUint8ArrayMemory0;
    }
    function getStringFromWasm0(ptr, len) {
      ptr = ptr >>> 0;
      return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
    }
    var WASM_VECTOR_LEN = 0;
    var cachedTextEncoder = new TextEncoder2("utf-8");
    var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
      return cachedTextEncoder.encodeInto(arg, view);
    } : function(arg, view) {
      const buf = cachedTextEncoder.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
    function passStringToWasm0(arg, malloc, realloc) {
      if (realloc === void 0) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr2 = malloc(buf.length, 1) >>> 0;
        getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr2;
      }
      let len = arg.length;
      let ptr = malloc(len, 1) >>> 0;
      const mem = getUint8ArrayMemory0();
      let offset = 0;
      for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 127) break;
        mem[ptr + offset] = code;
      }
      if (offset !== len) {
        if (offset !== 0) {
          arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
      }
      WASM_VECTOR_LEN = offset;
      return ptr;
    }
    var cachedDataViewMemory0 = null;
    function getDataViewMemory0() {
      if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
      }
      return cachedDataViewMemory0;
    }
    function dropObject(idx) {
      if (idx < 132) return;
      heap[idx] = heap_next;
      heap_next = idx;
    }
    function takeObject(idx) {
      const ret = getObject(idx);
      dropObject(idx);
      return ret;
    }
    function getArrayU8FromWasm0(ptr, len) {
      ptr = ptr >>> 0;
      return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
    }
    module.exports.parse = function(code, allow_return_outside_function, jsx) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(code, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.parse(retptr, ptr0, len0, allow_return_outside_function, jsx);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var v2 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_0(r0, r1 * 1, 1);
        return v2;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    };
    module.exports.xxhashBase64Url = function(input2) {
      let deferred1_0;
      let deferred1_1;
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.xxhashBase64Url(retptr, addHeapObject(input2));
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        deferred1_0 = r0;
        deferred1_1 = r1;
        return getStringFromWasm0(r0, r1);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_0(deferred1_0, deferred1_1, 1);
      }
    };
    module.exports.xxhashBase36 = function(input2) {
      let deferred1_0;
      let deferred1_1;
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.xxhashBase36(retptr, addHeapObject(input2));
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        deferred1_0 = r0;
        deferred1_1 = r1;
        return getStringFromWasm0(r0, r1);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_0(deferred1_0, deferred1_1, 1);
      }
    };
    module.exports.xxhashBase16 = function(input2) {
      let deferred1_0;
      let deferred1_1;
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.xxhashBase16(retptr, addHeapObject(input2));
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        deferred1_0 = r0;
        deferred1_1 = r1;
        return getStringFromWasm0(r0, r1);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_0(deferred1_0, deferred1_1, 1);
      }
    };
    module.exports.__wbg_buffer_609cc3eee51ed158 = function(arg0) {
      const ret = getObject(arg0).buffer;
      return addHeapObject(ret);
    };
    module.exports.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {
      let deferred0_0;
      let deferred0_1;
      try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        console.error(getStringFromWasm0(arg0, arg1));
      } finally {
        wasm.__wbindgen_export_0(deferred0_0, deferred0_1, 1);
      }
    };
    module.exports.__wbg_length_a446193dc22c12f8 = function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    };
    module.exports.__wbg_new_8a6f238a6ece86ea = function() {
      const ret = new Error();
      return addHeapObject(ret);
    };
    module.exports.__wbg_new_a12002a7f91c75be = function(arg0) {
      const ret = new Uint8Array(getObject(arg0));
      return addHeapObject(ret);
    };
    module.exports.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {
      getObject(arg0).set(getObject(arg1), arg2 >>> 0);
    };
    module.exports.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {
      const ret = getObject(arg1).stack;
      const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
      const len1 = WASM_VECTOR_LEN;
      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    module.exports.__wbindgen_memory = function() {
      const ret = wasm.memory;
      return addHeapObject(ret);
    };
    module.exports.__wbindgen_object_drop_ref = function(arg0) {
      takeObject(arg0);
    };
    module.exports.__wbindgen_throw = function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    };
    var path3 = __require("path").join(__dirname, "bindings_wasm_bg.wasm");
    var bytes = __require("fs").readFileSync(path3);
    var wasmModule = new WebAssembly.Module(bytes);
    var wasmInstance = new WebAssembly.Instance(wasmModule, imports);
    wasm = wasmInstance.exports;
    module.exports.__wasm = wasm;
  }
});

// node_modules/.pnpm/@rollup+wasm-node@4.37.0/node_modules/@rollup/wasm-node/dist/native.js
var require_native = __commonJS({
  "node_modules/.pnpm/@rollup+wasm-node@4.37.0/node_modules/@rollup/wasm-node/dist/native.js"(exports) {
    var {
      parse: parse6,
      xxhashBase64Url: xxhashBase64Url2,
      xxhashBase36: xxhashBase362,
      xxhashBase16: xxhashBase162
    } = require_bindings_wasm();
    exports.parse = parse6;
    exports.parseAsync = async (code, allowReturnOutsideFunction, jsx, _signal) => parse6(code, allowReturnOutsideFunction, jsx);
    exports.xxhashBase64Url = xxhashBase64Url2;
    exports.xxhashBase36 = xxhashBase362;
    exports.xxhashBase16 = xxhashBase162;
  }
});
function rangeContains(range4, index) {
  return range4.start <= index && index < range4.end;
}
function getLocator(source, options = {}) {
  const { offsetLine = 0, offsetColumn = 0 } = options;
  let start3 = 0;
  const ranges = source.split("\n").map((line, i2) => {
    const end6 = start3 + line.length + 1;
    const range4 = { start: start3, end: end6, line: i2 };
    start3 = end6;
    return range4;
  });
  let i = 0;
  function locator(search, index) {
    if (typeof search === "string") {
      search = source.indexOf(search, index ?? 0);
    }
    if (search === -1) return void 0;
    let range4 = ranges[i];
    const d2 = search >= range4.end ? 1 : -1;
    while (range4) {
      if (rangeContains(range4, search)) {
        return {
          line: offsetLine + range4.line,
          column: offsetColumn + search - range4.start,
          character: search
        };
      }
      i += d2;
      range4 = ranges[i];
    }
  }
  return locator;
}
function locate(source, search, options) {
  return getLocator(source, options)(search, options && options.startIndex);
}
function spaces(index) {
  let result = "";
  while (index--)
    result += " ";
  return result;
}
function tabsToSpaces(value) {
  return value.replace(/^\t+/, (match18) => match18.split("	").join("  "));
}
function getCodeFrame(source, line, column) {
  let lines = source.split("\n");
  if (line > lines.length)
    return "";
  const maxLineLength = Math.max(tabsToSpaces(lines[line - 1].slice(0, column)).length + MIN_CHARACTERS_SHOWN_AFTER_LOCATION + ELLIPSIS.length, LINE_TRUNCATE_LENGTH);
  const frameStart = Math.max(0, line - 3);
  let frameEnd = Math.min(line + 2, lines.length);
  lines = lines.slice(frameStart, frameEnd);
  while (!/\S/.test(lines[lines.length - 1])) {
    lines.pop();
    frameEnd -= 1;
  }
  const digits = String(frameEnd).length;
  return lines.map((sourceLine, index) => {
    const isErrorLine = frameStart + index + 1 === line;
    let lineNumber = String(index + frameStart + 1);
    while (lineNumber.length < digits)
      lineNumber = ` ${lineNumber}`;
    let displayedLine = tabsToSpaces(sourceLine);
    if (displayedLine.length > maxLineLength) {
      displayedLine = `${displayedLine.slice(0, maxLineLength - ELLIPSIS.length)}${ELLIPSIS}`;
    }
    if (isErrorLine) {
      const indicator = spaces(digits + 2 + tabsToSpaces(sourceLine.slice(0, column)).length) + "^";
      return `${lineNumber}: ${displayedLine}
${indicator}`;
    }
    return `${lineNumber}: ${displayedLine}`;
  }).join("\n");
}
function isAbsolute2(path3) {
  return ABSOLUTE_PATH_REGEX.test(path3);
}
function isRelative2(path3) {
  return RELATIVE_PATH_REGEX.test(path3);
}
function normalize2(path3) {
  return path3.replace(BACKSLASH_REGEX, "/");
}
function printQuotedStringList(list, verbs) {
  const isSingleItem = list.length <= 1;
  const quotedList = list.map((item) => `"${item}"`);
  let output = isSingleItem ? quotedList[0] : `${quotedList.slice(0, -1).join(", ")} and ${quotedList.slice(-1)[0]}`;
  if (verbs) {
    output += ` ${isSingleItem ? verbs[0] : verbs[1]}`;
  }
  return output;
}
function relative(from, to) {
  const fromParts = from.split(ANY_SLASH_REGEX).filter(Boolean);
  const toParts = to.split(ANY_SLASH_REGEX).filter(Boolean);
  if (fromParts[0] === ".")
    fromParts.shift();
  if (toParts[0] === ".")
    toParts.shift();
  while (fromParts[0] && toParts[0] && fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  while (toParts[0] === ".." && fromParts.length > 0) {
    toParts.shift();
    fromParts.pop();
  }
  while (fromParts.pop()) {
    toParts.unshift("..");
  }
  return toParts.join("/");
}
function getAliasName(id2) {
  const base2 = p2.basename(id2);
  return base2.slice(0, Math.max(0, base2.length - p2.extname(id2).length));
}
function relativeId(id2) {
  if (!isAbsolute2(id2))
    return id2;
  return relative(p2.resolve(), id2);
}
function isPathFragment(name) {
  return name[0] === "/" || name[0] === "." && (name[1] === "/" || name[1] === ".") || isAbsolute2(name);
}
function getImportPath(importerId, targetPath, stripJsExtension, ensureFileName) {
  while (targetPath.startsWith("../")) {
    targetPath = targetPath.slice(3);
    importerId = "_/" + importerId;
  }
  let relativePath = normalize2(relative(p2.dirname(importerId), targetPath));
  if (stripJsExtension && relativePath.endsWith(".js")) {
    relativePath = relativePath.slice(0, -3);
  }
  if (ensureFileName) {
    if (relativePath === "")
      return "../" + p2.basename(targetPath);
    if (UPPER_DIR_REGEX.test(relativePath)) {
      return [...relativePath.split("/"), "..", p2.basename(targetPath)].join("/");
    }
  }
  return relativePath ? relativePath.startsWith("..") ? relativePath : "./" + relativePath : ".";
}
function isValidUrl(url3) {
  try {
    new URL(url3);
  } catch {
    return false;
  }
  return true;
}
function getRollupUrl(snippet) {
  return `https://rollupjs.org/${snippet}`;
}
function addTrailingSlashIfMissed(url3) {
  if (!url3.endsWith("/")) {
    return url3 + "/";
  }
  return url3;
}
function error3(base2) {
  throw base2 instanceof Error ? base2 : getRollupError(base2);
}
function getRollupError(base2) {
  augmentLogMessage(base2);
  const errorInstance = Object.assign(new Error(base2.message), base2);
  Object.defineProperty(errorInstance, "name", {
    value: "RollupError",
    writable: true
  });
  return errorInstance;
}
function augmentCodeLocation(properties, pos, source, id2) {
  if (typeof pos === "object") {
    const { line, column } = pos;
    properties.loc = { column, file: id2, line };
  } else {
    properties.pos = pos;
    const location = locate(source, pos, { offsetLine: 1 });
    if (!location) {
      return;
    }
    const { line, column } = location;
    properties.loc = { column, file: id2, line };
  }
  if (properties.frame === void 0) {
    const { line, column } = properties.loc;
    properties.frame = getCodeFrame(source, line, column);
  }
}
function augmentLogMessage(log5) {
  if (!(log5.plugin || log5.loc) || log5[symbolAugmented]) {
    return;
  }
  log5[symbolAugmented] = true;
  let prefix = "";
  if (log5.plugin) {
    prefix += `[plugin ${log5.plugin}] `;
  }
  const id2 = log5.id || log5.loc?.file;
  if (id2) {
    const position = log5.loc ? ` (${log5.loc.line}:${log5.loc.column})` : "";
    prefix += `${relativeId(id2)}${position}: `;
  }
  const oldMessage = log5.message;
  log5.message = prefix + log5.message;
  tweakStackMessage(log5, oldMessage);
}
function logAddonNotGenerated(message, hook, plugin) {
  return {
    code: ADDON_ERROR,
    message: `Could not retrieve "${hook}". Check configuration of plugin "${plugin}".
	Error Message: ${message}`
  };
}
function logAlreadyClosed() {
  return {
    code: ALREADY_CLOSED,
    message: 'Bundle is already closed, no more calls to "generate" or "write" are allowed.'
  };
}
function logAmbiguousExternalNamespaces(binding, reexportingModule, usedModule, sources) {
  return {
    binding,
    code: AMBIGUOUS_EXTERNAL_NAMESPACES,
    ids: sources,
    message: `Ambiguous external namespace resolution: "${relativeId(reexportingModule)}" re-exports "${binding}" from one of the external modules ${printQuotedStringList(sources.map((module) => relativeId(module)))}, guessing "${relativeId(usedModule)}".`,
    reexporter: reexportingModule
  };
}
function logAnonymousPluginCache() {
  return {
    code: ANONYMOUS_PLUGIN_CACHE,
    message: "A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey."
  };
}
function logAssetNotFinalisedForFileName(name) {
  return {
    code: ASSET_NOT_FINALISED,
    message: `Plugin error - Unable to get file name for asset "${name}". Ensure that the source is set and that generate is called first. If you reference assets via import.meta.ROLLUP_FILE_URL_<referenceId>, you need to either have set their source after "renderStart" or need to provide an explicit "fileName" when emitting them.`
  };
}
function logAssetReferenceIdNotFoundForSetSource(assetReferenceId) {
  return {
    code: ASSET_NOT_FOUND,
    message: `Plugin error - Unable to set the source for unknown asset "${assetReferenceId}".`
  };
}
function logAssetSourceAlreadySet(name) {
  return {
    code: ASSET_SOURCE_ALREADY_SET,
    message: `Unable to set the source for asset "${name}", source already set.`
  };
}
function logNoAssetSourceSet(assetName) {
  return {
    code: ASSET_SOURCE_MISSING,
    message: `Plugin error creating asset "${assetName}" - no asset source set.`
  };
}
function logBadLoader(id2) {
  return {
    code: BAD_LOADER,
    message: `Error loading "${relativeId(id2)}": plugin load hook should return a string, a { code, map } object, or nothing/null.`
  };
}
function logCannotCallNamespace(name) {
  return {
    code: CANNOT_CALL_NAMESPACE,
    message: `Cannot call a namespace ("${name}").`
  };
}
function logCannotEmitFromOptionsHook() {
  return {
    code: CANNOT_EMIT_FROM_OPTIONS_HOOK,
    message: `Cannot emit files or set asset sources in the "outputOptions" hook, use the "renderStart" hook instead.`
  };
}
function logChunkNotGeneratedForFileName(name) {
  return {
    code: CHUNK_NOT_GENERATED,
    message: `Plugin error - Unable to get file name for emitted chunk "${name}". You can only get file names once chunks have been generated after the "renderStart" hook.`
  };
}
function logChunkInvalid({ fileName, code }, { pos, message }) {
  const errorProperties = {
    code: CHUNK_INVALID,
    message: `Chunk "${fileName}" is not valid JavaScript: ${message}.`
  };
  augmentCodeLocation(errorProperties, pos, code, fileName);
  return errorProperties;
}
function logCircularDependency(cyclePath) {
  return {
    code: CIRCULAR_DEPENDENCY,
    ids: cyclePath,
    message: `Circular dependency: ${cyclePath.map(relativeId).join(" -> ")}`
  };
}
function logCircularReexport(exportName, exporter) {
  return {
    code: CIRCULAR_REEXPORT,
    exporter,
    message: `"${exportName}" cannot be exported from "${relativeId(exporter)}" as it is a reexport that references itself.`
  };
}
function logCyclicCrossChunkReexport(exportName, exporter, reexporter, importer, preserveModules) {
  return {
    code: CYCLIC_CROSS_CHUNK_REEXPORT,
    exporter,
    id: importer,
    message: `Export "${exportName}" of module "${relativeId(exporter)}" was reexported through module "${relativeId(reexporter)}" while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.
Either change the import in "${relativeId(importer)}" to point directly to the exporting module or ${preserveModules ? 'do not use "output.preserveModules"' : 'reconfigure "output.manualChunks"'} to ensure these modules end up in the same chunk.`,
    reexporter
  };
}
function logDeprecation(deprecation, urlSnippet, plugin) {
  return {
    code: DEPRECATED_FEATURE,
    message: deprecation,
    url: getRollupUrl(urlSnippet),
    ...{}
  };
}
function logConstVariableReassignError() {
  return {
    code: CONST_REASSIGN,
    message: "Cannot reassign a variable declared with `const`"
  };
}
function logDuplicateArgumentNameError(name) {
  return {
    code: DUPLICATE_ARGUMENT_NAME,
    message: `Duplicate argument name "${name}"`
  };
}
function logDuplicateExportError(name) {
  return { code: DUPLICATE_EXPORT, message: `Duplicate export "${name}"` };
}
function logDuplicatePluginName(plugin) {
  return {
    code: DUPLICATE_PLUGIN_NAME,
    message: `The plugin name ${plugin} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`
  };
}
function logEmptyChunk(chunkName) {
  return {
    code: EMPTY_BUNDLE,
    message: `Generated an empty chunk: "${chunkName}".`,
    names: [chunkName]
  };
}
function logEval(id2) {
  return {
    code: EVAL,
    id: id2,
    message: `Use of eval in "${relativeId(id2)}" is strongly discouraged as it poses security risks and may cause issues with minification.`,
    url: getRollupUrl(URL_AVOIDING_EVAL)
  };
}
function logExternalSyntheticExports(id2, importer) {
  return {
    code: EXTERNAL_SYNTHETIC_EXPORTS,
    exporter: id2,
    message: `External "${id2}" cannot have "syntheticNamedExports" enabled (imported by "${relativeId(importer)}").`
  };
}
function logFileNameConflict(fileName) {
  return {
    code: FILE_NAME_CONFLICT,
    message: `The emitted file "${fileName}" overwrites a previously emitted file of the same name.`
  };
}
function logFileReferenceIdNotFoundForFilename(assetReferenceId) {
  return {
    code: FILE_NOT_FOUND,
    message: `Plugin error - Unable to get file name for unknown file "${assetReferenceId}".`
  };
}
function logFirstSideEffect(source, id2, { line, column }) {
  return {
    code: FIRST_SIDE_EFFECT,
    message: `First side effect in ${relativeId(id2)} is at (${line}:${column})
${getCodeFrame(source, line, column)}`
  };
}
function logIllegalIdentifierAsName(name) {
  return {
    code: ILLEGAL_IDENTIFIER_AS_NAME,
    message: `Given name "${name}" is not a legal JS identifier. If you need this, you can try "output.extend: true".`,
    url: getRollupUrl(URL_OUTPUT_EXTEND)
  };
}
function logIllegalImportReassignment(name, importingId) {
  return {
    code: ILLEGAL_REASSIGNMENT,
    message: `Illegal reassignment of import "${name}" in "${relativeId(importingId)}".`
  };
}
function logInconsistentImportAttributes(existingAttributes, newAttributes, source, importer) {
  return {
    code: INCONSISTENT_IMPORT_ATTRIBUTES,
    message: `Module "${relativeId(importer)}" tried to import "${relativeId(source)}" with ${formatAttributes(newAttributes)} attributes, but it was already imported elsewhere with ${formatAttributes(existingAttributes)} attributes. Please ensure that import attributes for the same module are always consistent.`
  };
}
function logInvalidAnnotation(comment, id2, type) {
  return {
    code: INVALID_ANNOTATION,
    id: id2,
    message: `A comment

"${comment}"

in "${relativeId(id2)}" contains an annotation that Rollup cannot interpret due to the position of the comment. The comment will be removed to avoid issues.`,
    url: getRollupUrl(type === "noSideEffects" ? URL_TREESHAKE_NOSIDEEFFECTS : URL_TREESHAKE_PURE)
  };
}
function logInputHookInOutputPlugin(pluginName, hookName) {
  return {
    code: INPUT_HOOK_IN_OUTPUT_PLUGIN,
    message: `The "${hookName}" hook used by the output plugin ${pluginName} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`
  };
}
function logCannotAssignModuleToChunk(moduleId, assignToAlias, currentAlias) {
  return {
    code: INVALID_CHUNK,
    message: `Cannot assign "${relativeId(moduleId)}" to the "${assignToAlias}" chunk as it is already in the "${currentAlias}" chunk.`
  };
}
function tweakStackMessage(error4, oldMessage) {
  if (!error4.stack) {
    return error4;
  }
  error4.stack = error4.stack.replace(oldMessage, error4.message);
  return error4;
}
function logInvalidExportOptionValue(optionValue) {
  return {
    code: INVALID_EXPORT_OPTION,
    message: `"output.exports" must be "default", "named", "none", "auto", or left unspecified (defaults to "auto"), received "${optionValue}".`,
    url: getRollupUrl(URL_OUTPUT_EXPORTS)
  };
}
function logIncompatibleExportOptionValue(optionValue, keys5, entryModule) {
  return {
    code: INVALID_EXPORT_OPTION,
    message: `"${optionValue}" was specified for "output.exports", but entry module "${relativeId(entryModule)}" has the following exports: ${printQuotedStringList(keys5)}`,
    url: getRollupUrl(URL_OUTPUT_EXPORTS)
  };
}
function logInternalIdCannotBeExternal(source, importer) {
  return {
    code: INVALID_EXTERNAL_ID,
    message: `"${source}" is imported as an external by "${relativeId(importer)}", but is already an existing non-external module id.`
  };
}
function logImportOptionsAreInvalid(importer) {
  return {
    code: INVALID_IMPORT_ATTRIBUTE,
    message: `Rollup could not statically analyze the options argument of a dynamic import in "${relativeId(importer)}". Dynamic import options need to be an object with a nested attributes object.`
  };
}
function logImportAttributeIsInvalid(importer) {
  return {
    code: INVALID_IMPORT_ATTRIBUTE,
    message: `Rollup could not statically analyze an import attribute of a dynamic import in "${relativeId(importer)}". Import attributes need to have string keys and values. The attribute will be removed.`
  };
}
function logInvalidLogPosition(plugin) {
  return {
    code: INVALID_LOG_POSITION,
    message: `Plugin "${plugin}" tried to add a file position to a log or warning. This is only supported in the "transform" hook at the moment and will be ignored.`
  };
}
function logInvalidOption(option5, urlSnippet, explanation, value) {
  return {
    code: INVALID_OPTION,
    message: `Invalid value ${value === void 0 ? "" : `${JSON.stringify(value)} `}for option "${option5}" - ${explanation}.`,
    url: getRollupUrl(urlSnippet)
  };
}
function logInvalidAddonPluginHook(hook, plugin) {
  return {
    code: INVALID_PLUGIN_HOOK,
    hook,
    message: `Error running plugin hook "${hook}" for plugin "${plugin}", expected a string, a function hook or an object with a "handler" string or function.`,
    plugin
  };
}
function logInvalidFunctionPluginHook(hook, plugin) {
  return {
    code: INVALID_PLUGIN_HOOK,
    hook,
    message: `Error running plugin hook "${hook}" for plugin "${plugin}", expected a function hook or an object with a "handler" function.`,
    plugin
  };
}
function logInvalidRollupPhaseForChunkEmission() {
  return {
    code: INVALID_ROLLUP_PHASE,
    message: `Cannot emit chunks after module loading has finished.`
  };
}
function logInvalidSetAssetSourceCall() {
  return {
    code: INVALID_SETASSETSOURCE,
    message: `setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook.`
  };
}
function logInvalidFormatForTopLevelAwait(id2, format5) {
  return {
    code: INVALID_TLA_FORMAT,
    id: id2,
    message: `Module format "${format5}" does not support top-level await. Use the "es" or "system" output formats rather.`
  };
}
function logMissingEntryExport(binding, exporter) {
  return {
    binding,
    code: MISSING_EXPORT,
    exporter,
    message: `Exported variable "${binding}" is not defined in "${relativeId(exporter)}".`,
    url: getRollupUrl(URL_NAME_IS_NOT_EXPORTED)
  };
}
function logMissingExport(binding, importingModule, exporter) {
  const isJson = p2.extname(exporter) === ".json";
  return {
    binding,
    code: MISSING_EXPORT,
    exporter,
    id: importingModule,
    message: `"${binding}" is not exported by "${relativeId(exporter)}", imported by "${relativeId(importingModule)}".${isJson ? " (Note that you need @rollup/plugin-json to import JSON files)" : ""}`,
    url: getRollupUrl(URL_NAME_IS_NOT_EXPORTED)
  };
}
function logMissingGlobalName(externalId, guess) {
  return {
    code: MISSING_GLOBAL_NAME,
    id: externalId,
    message: `No name was provided for external module "${externalId}" in "output.globals" \u2013 guessing "${guess}".`,
    names: [guess],
    url: getRollupUrl(URL_OUTPUT_GLOBALS)
  };
}
function logImplicitDependantCannotBeExternal(unresolvedId, implicitlyLoadedBefore) {
  return {
    code: MISSING_IMPLICIT_DEPENDANT,
    message: `Module "${relativeId(unresolvedId)}" that should be implicitly loaded before "${relativeId(implicitlyLoadedBefore)}" cannot be external.`
  };
}
function logUnresolvedImplicitDependant(unresolvedId, implicitlyLoadedBefore) {
  return {
    code: MISSING_IMPLICIT_DEPENDANT,
    message: `Module "${relativeId(unresolvedId)}" that should be implicitly loaded before "${relativeId(implicitlyLoadedBefore)}" could not be resolved.`
  };
}
function logImplicitDependantIsNotIncluded(module) {
  const implicitDependencies = [...module.implicitlyLoadedBefore].map((dependency) => relativeId(dependency.id)).sort();
  return {
    code: MISSING_IMPLICIT_DEPENDANT,
    message: `Module "${relativeId(module.id)}" that should be implicitly loaded before ${printQuotedStringList(implicitDependencies)} is not included in the module graph. Either it was not imported by an included module or only via a tree-shaken dynamic import, or no imported bindings were used and it had otherwise no side-effects.`
  };
}
function logMissingJsxExport(name, exporter, importer) {
  return {
    code: MISSING_JSX_EXPORT,
    exporter,
    id: importer,
    message: `Export "${name}" is not defined in module "${relativeId(exporter)}" even though it is needed in "${relativeId(importer)}" to provide JSX syntax. Please check your "jsx" option.`,
    names: [name],
    url: getRollupUrl(URL_JSX)
  };
}
function logMissingNameOptionForIifeExport() {
  return {
    code: MISSING_NAME_OPTION_FOR_IIFE_EXPORT,
    message: `If you do not supply "output.name", you may not be able to access the exports of an IIFE bundle.`,
    url: getRollupUrl(URL_OUTPUT_NAME)
  };
}
function logMissingNameOptionForUmdExport() {
  return {
    code: MISSING_NAME_OPTION_FOR_IIFE_EXPORT,
    message: 'You must supply "output.name" for UMD bundles that have exports so that the exports are accessible in environments without a module loader.',
    url: getRollupUrl(URL_OUTPUT_NAME)
  };
}
function logMissingNodeBuiltins(externalBuiltins) {
  return {
    code: MISSING_NODE_BUILTINS,
    ids: externalBuiltins,
    message: `Creating a browser bundle that depends on Node.js built-in modules (${printQuotedStringList(externalBuiltins)}). You might need to include https://github.com/FredKSchott/rollup-plugin-polyfill-node`
  };
}
function logMissingFileOrDirOption() {
  return {
    code: MISSING_OPTION,
    message: 'You must specify "output.file" or "output.dir" for the build.',
    url: getRollupUrl(URL_OUTPUT_DIR)
  };
}
function logMixedExport(facadeModuleId, name) {
  return {
    code: MIXED_EXPORTS,
    id: facadeModuleId,
    message: `Entry module "${relativeId(facadeModuleId)}" is using named and default exports together. Consumers of your bundle will have to use \`${name || "chunk"}.default\` to access the default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning.`,
    url: getRollupUrl(URL_OUTPUT_EXPORTS)
  };
}
function logModuleLevelDirective(directive3, id2) {
  return {
    code: MODULE_LEVEL_DIRECTIVE,
    id: id2,
    message: `Module level directives cause errors when bundled, "${directive3}" in "${relativeId(id2)}" was ignored.`
  };
}
function logNamespaceConflict(binding, reexportingModuleId, sources) {
  return {
    binding,
    code: NAMESPACE_CONFLICT,
    ids: sources,
    message: `Conflicting namespaces: "${relativeId(reexportingModuleId)}" re-exports "${binding}" from one of the modules ${printQuotedStringList(sources.map((moduleId) => relativeId(moduleId)))} (will be ignored).`,
    reexporter: reexportingModuleId
  };
}
function logNoTransformMapOrAstWithoutCode(pluginName) {
  return {
    code: NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE,
    message: `The plugin "${pluginName}" returned a "map" or "ast" without returning a "code". This will be ignored.`
  };
}
function logOptimizeChunkStatus(chunks3, smallChunks, pointInTime) {
  return {
    code: OPTIMIZE_CHUNK_STATUS,
    message: `${pointInTime}, there are
${chunks3} chunks, of which
${smallChunks} are below minChunkSize.`
  };
}
function logParseError(message, pos) {
  return { code: PARSE_ERROR, message, pos };
}
function logRedeclarationError(name) {
  return {
    code: REDECLARATION_ERROR,
    message: `Identifier "${name}" has already been declared`
  };
}
function logReservedNamespace(namespace) {
  return {
    code: RESERVED_NAMESPACE,
    message: `You have overided reserved namespace "${namespace}"`
  };
}
function logModuleParseError(error4, moduleId) {
  let message = error4.message.replace(/ \(\d+:\d+\)$/, "");
  if (moduleId.endsWith(".json")) {
    message += " (Note that you need @rollup/plugin-json to import JSON files)";
  } else if (!moduleId.endsWith(".js")) {
    message += " (Note that you need plugins to import files that are not JavaScript)";
  }
  return tweakStackMessage({
    cause: error4,
    code: PARSE_ERROR,
    id: moduleId,
    message,
    stack: error4.stack
  }, error4.message);
}
function logPluginError(error4, plugin, { hook, id: id2 } = {}) {
  const code = error4.code;
  if (!error4.pluginCode && code != null && (typeof code !== "string" || !code.startsWith("PLUGIN_"))) {
    error4.pluginCode = code;
  }
  error4.code = PLUGIN_ERROR;
  error4.plugin = plugin;
  if (hook) {
    error4.hook = hook;
  }
  if (id2) {
    error4.id = id2;
  }
  return error4;
}
function logShimmedExport(id2, binding) {
  return {
    binding,
    code: SHIMMED_EXPORT,
    exporter: id2,
    message: `Missing export "${binding}" has been shimmed in module "${relativeId(id2)}".`
  };
}
function logSourcemapBroken(plugin) {
  return {
    code: SOURCEMAP_BROKEN,
    message: `Sourcemap is likely to be incorrect: a plugin (${plugin}) was used to transform files, but didn't generate a sourcemap for the transformation. Consult the plugin documentation for help`,
    plugin,
    url: getRollupUrl(URL_SOURCEMAP_IS_LIKELY_TO_BE_INCORRECT)
  };
}
function logConflictingSourcemapSources(filename) {
  return {
    code: SOURCEMAP_BROKEN,
    message: `Multiple conflicting contents for sourcemap source ${filename}`
  };
}
function logInvalidSourcemapForError(error4, id2, column, line, pos) {
  return {
    cause: error4,
    code: SOURCEMAP_ERROR,
    id: id2,
    loc: {
      column,
      file: id2,
      line
    },
    message: `Error when using sourcemap for reporting an error: ${error4.message}`,
    pos
  };
}
function logSyntheticNamedExportsNeedNamespaceExport(id2, syntheticNamedExportsOption) {
  return {
    code: SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT,
    exporter: id2,
    message: `Module "${relativeId(id2)}" that is marked with \`syntheticNamedExports: ${JSON.stringify(syntheticNamedExportsOption)}\` needs ${typeof syntheticNamedExportsOption === "string" && syntheticNamedExportsOption !== "default" ? `an explicit export named "${syntheticNamedExportsOption}"` : "a default export"} that does not reexport an unresolved named export of the same module.`
  };
}
function logThisIsUndefined() {
  return {
    code: THIS_IS_UNDEFINED,
    message: `The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten`,
    url: getRollupUrl(URL_THIS_IS_UNDEFINED)
  };
}
function logUnexpectedNamedImport(id2, imported, isReexport) {
  const importType = isReexport ? "reexport" : "import";
  return {
    code: UNEXPECTED_NAMED_IMPORT,
    exporter: id2,
    message: `The named export "${imported}" was ${importType}ed from the external module "${relativeId(id2)}" even though its interop type is "defaultOnly". Either remove or change this ${importType} or change the value of the "output.interop" option.`,
    url: getRollupUrl(URL_OUTPUT_INTEROP)
  };
}
function logUnexpectedNamespaceReexport(id2) {
  return {
    code: UNEXPECTED_NAMED_IMPORT,
    exporter: id2,
    message: `There was a namespace "*" reexport from the external module "${relativeId(id2)}" even though its interop type is "defaultOnly". This will be ignored as namespace reexports only reexport named exports. If this is not intended, either remove or change this reexport or change the value of the "output.interop" option.`,
    url: getRollupUrl(URL_OUTPUT_INTEROP)
  };
}
function logUnknownOption(optionType, unknownOptions, validOptions) {
  return {
    code: UNKNOWN_OPTION,
    message: `Unknown ${optionType}: ${unknownOptions.join(", ")}. Allowed options: ${validOptions.join(", ")}`
  };
}
function logEntryCannotBeExternal(unresolvedId) {
  return {
    code: UNRESOLVED_ENTRY,
    message: `Entry module "${relativeId(unresolvedId)}" cannot be external.`
  };
}
function logExternalModulesCannotBeIncludedInManualChunks(source) {
  return {
    code: EXTERNAL_MODULES_CANNOT_BE_INCLUDED_IN_MANUAL_CHUNKS,
    message: `"${source}" cannot be included in manualChunks because it is resolved as an external module by the "external" option or plugins.`
  };
}
function logExternalModulesCannotBeTransformedToModules(source) {
  return {
    code: EXTERNAL_MODULES_CANNOT_BE_TRANSFORMED_TO_MODULES,
    message: `${source} is resolved as a module now, but it was an external module before. Please check whether there are conflicts in your Rollup options "external" and "manualChunks", manualChunks cannot include external modules.`
  };
}
function logUnresolvedEntry(unresolvedId) {
  return {
    code: UNRESOLVED_ENTRY,
    message: `Could not resolve entry module "${relativeId(unresolvedId)}".`
  };
}
function logUnresolvedImport(source, importer) {
  return {
    code: UNRESOLVED_IMPORT,
    exporter: source,
    id: importer,
    message: `Could not resolve "${source}" from "${relativeId(importer)}"`
  };
}
function logUnresolvedImportTreatedAsExternal(source, importer) {
  return {
    code: UNRESOLVED_IMPORT,
    exporter: source,
    id: importer,
    message: `"${source}" is imported by "${relativeId(importer)}", but could not be resolved \u2013 treating it as an external dependency.`,
    url: getRollupUrl(URL_TREATING_MODULE_AS_EXTERNAL_DEPENDENCY)
  };
}
function logUnusedExternalImports(externalId, names, importers) {
  return {
    code: UNUSED_EXTERNAL_IMPORT,
    exporter: externalId,
    ids: importers,
    message: `${printQuotedStringList(names, [
      "is",
      "are"
    ])} imported from external module "${externalId}" but never used in ${printQuotedStringList(importers.map((importer) => relativeId(importer)))}.`,
    names
  };
}
function logFailedValidation(message) {
  return {
    code: VALIDATION_ERROR,
    message
  };
}
function warnDeprecation(deprecation, urlSnippet, activeDeprecation, options, plugin) {
  warnDeprecationWithOptions(deprecation, urlSnippet, activeDeprecation, options.onLog, options.strictDeprecations);
}
function warnDeprecationWithOptions(deprecation, urlSnippet, activeDeprecation, log5, strictDeprecations, plugin) {
  if (activeDeprecation || strictDeprecations) {
    const warning = logDeprecation(deprecation, urlSnippet);
    if (strictDeprecations) {
      return error3(warning);
    }
    log5(LOGLEVEL_WARN, warning);
  }
}
function convertProgram(buffer4) {
  const node = convertNode(0, buffer4);
  switch (node.type) {
    case PanicError: {
      return error3(getRollupError(logParseError(node.message)));
    }
    case ParseError: {
      return error3(getRollupError(logParseError(node.message, node.start)));
    }
    default: {
      return node;
    }
  }
}
function convertNode(position, buffer4) {
  const nodeType = buffer4[position];
  const converter = nodeConverters[nodeType];
  if (!converter) {
    console.trace();
    throw new Error(`Unknown node type: ${nodeType}`);
  }
  return converter(position + 1, buffer4);
}
function convertNodeList(position, buffer4) {
  if (position === 0)
    return EMPTY_ARRAY;
  const length3 = buffer4[position++];
  const list = new Array(length3);
  for (let index = 0; index < length3; index++) {
    const nodePosition = buffer4[position++];
    list[index] = nodePosition ? convertNode(nodePosition, buffer4) : null;
  }
  return list;
}
function getAstBuffer(astBuffer) {
  const array6 = new Uint32Array(astBuffer.buffer);
  let convertString;
  if (typeof Buffer !== "undefined" && astBuffer instanceof Buffer) {
    convertString = (position) => {
      const length3 = array6[position++];
      const bytePosition = position << 2;
      return astBuffer.toString("utf8", bytePosition, bytePosition + length3);
    };
  } else {
    const textDecoder = new TextDecoder();
    convertString = (position) => {
      const length3 = array6[position++];
      const bytePosition = position << 2;
      return textDecoder.decode(astBuffer.subarray(bytePosition, bytePosition + length3));
    };
  }
  return Object.assign(array6, { convertString });
}
var import_native, ArrowFunctionExpression, BlockStatement, CallExpression, CatchClause, ExportDefaultDeclaration, ExpressionStatement, Identifier, Literal, ObjectExpression, PanicError, ParseError, Program, Property, RestElement, ReturnStatement, StaticBlock, TemplateLiteral, VariableDeclarator, BLANK, EMPTY_OBJECT, EMPTY_ARRAY, EMPTY_SET, FIXED_STRINGS, ANNOTATION_KEY, INVALID_ANNOTATION_KEY, convertAnnotations, convertAnnotation, LINE_TRUNCATE_LENGTH, MIN_CHARACTERS_SHOWN_AFTER_LOCATION, ELLIPSIS, LOGLEVEL_SILENT, LOGLEVEL_ERROR, LOGLEVEL_WARN, LOGLEVEL_INFO, LOGLEVEL_DEBUG, logLevelPriority, ABSOLUTE_PATH_REGEX, RELATIVE_PATH_REGEX, BACKSLASH_REGEX, ANY_SLASH_REGEX, UPPER_DIR_REGEX, URL_AVOIDING_EVAL, URL_NAME_IS_NOT_EXPORTED, URL_THIS_IS_UNDEFINED, URL_TREATING_MODULE_AS_EXTERNAL_DEPENDENCY, URL_SOURCEMAP_IS_LIKELY_TO_BE_INCORRECT, URL_JSX, URL_OUTPUT_AMD_ID, URL_OUTPUT_AMD_BASEPATH, URL_OUTPUT_DIR, URL_OUTPUT_EXPORTS, URL_OUTPUT_EXTEND, URL_OUTPUT_EXTERNALIMPORTATTRIBUTES, URL_OUTPUT_FORMAT, URL_OUTPUT_GENERATEDCODE, URL_OUTPUT_GLOBALS, URL_OUTPUT_INLINEDYNAMICIMPORTS, URL_OUTPUT_INTEROP, URL_OUTPUT_MANUALCHUNKS, URL_OUTPUT_NAME, URL_OUTPUT_SOURCEMAPBASEURL, URL_OUTPUT_SOURCEMAPFILE, URL_PRESERVEENTRYSIGNATURES, URL_TREESHAKE, URL_TREESHAKE_PURE, URL_TREESHAKE_NOSIDEEFFECTS, URL_TREESHAKE_MODULESIDEEFFECTS, URL_GENERATEBUNDLE, symbolAugmented, ADDON_ERROR, ALREADY_CLOSED, AMBIGUOUS_EXTERNAL_NAMESPACES, ANONYMOUS_PLUGIN_CACHE, ASSET_NOT_FINALISED, ASSET_NOT_FOUND, ASSET_SOURCE_ALREADY_SET, ASSET_SOURCE_MISSING, BAD_LOADER, CANNOT_CALL_NAMESPACE, CANNOT_EMIT_FROM_OPTIONS_HOOK, CHUNK_NOT_GENERATED, CHUNK_INVALID, CIRCULAR_DEPENDENCY, CIRCULAR_REEXPORT, CONST_REASSIGN, CYCLIC_CROSS_CHUNK_REEXPORT, DEPRECATED_FEATURE, DUPLICATE_ARGUMENT_NAME, DUPLICATE_EXPORT, DUPLICATE_PLUGIN_NAME, EMPTY_BUNDLE, EVAL, EXTERNAL_MODULES_CANNOT_BE_INCLUDED_IN_MANUAL_CHUNKS, EXTERNAL_MODULES_CANNOT_BE_TRANSFORMED_TO_MODULES, EXTERNAL_SYNTHETIC_EXPORTS, FILE_NAME_CONFLICT, FILE_NOT_FOUND, FIRST_SIDE_EFFECT, ILLEGAL_IDENTIFIER_AS_NAME, ILLEGAL_REASSIGNMENT, INCONSISTENT_IMPORT_ATTRIBUTES, INVALID_ANNOTATION, INPUT_HOOK_IN_OUTPUT_PLUGIN, INVALID_CHUNK, INVALID_EXPORT_OPTION, INVALID_EXTERNAL_ID, INVALID_IMPORT_ATTRIBUTE, INVALID_LOG_POSITION, INVALID_OPTION, INVALID_PLUGIN_HOOK, INVALID_ROLLUP_PHASE, INVALID_SETASSETSOURCE, INVALID_TLA_FORMAT, MISSING_EXPORT, MISSING_GLOBAL_NAME, MISSING_IMPLICIT_DEPENDANT, MISSING_JSX_EXPORT, MISSING_NAME_OPTION_FOR_IIFE_EXPORT, MISSING_NODE_BUILTINS, MISSING_OPTION, MIXED_EXPORTS, MODULE_LEVEL_DIRECTIVE, NAMESPACE_CONFLICT, NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE, OPTIMIZE_CHUNK_STATUS, PARSE_ERROR, PLUGIN_ERROR, REDECLARATION_ERROR, RESERVED_NAMESPACE, SHIMMED_EXPORT, SOURCEMAP_BROKEN, SOURCEMAP_ERROR, SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT, THIS_IS_UNDEFINED, UNEXPECTED_NAMED_IMPORT, UNKNOWN_OPTION, UNRESOLVED_ENTRY, UNRESOLVED_IMPORT, UNUSED_EXTERNAL_IMPORT, VALIDATION_ERROR, formatAttributes, nodeConverters, parseAst;
var init_parseAst = __esm({
  "node_modules/.pnpm/@rollup+wasm-node@4.37.0/node_modules/@rollup/wasm-node/dist/es/shared/parseAst.js"() {
    import_native = __toESM(require_native());
    ArrowFunctionExpression = "ArrowFunctionExpression";
    BlockStatement = "BlockStatement";
    CallExpression = "CallExpression";
    CatchClause = "CatchClause";
    ExportDefaultDeclaration = "ExportDefaultDeclaration";
    ExpressionStatement = "ExpressionStatement";
    Identifier = "Identifier";
    Literal = "Literal";
    ObjectExpression = "ObjectExpression";
    PanicError = "PanicError";
    ParseError = "ParseError";
    Program = "Program";
    Property = "Property";
    RestElement = "RestElement";
    ReturnStatement = "ReturnStatement";
    StaticBlock = "StaticBlock";
    TemplateLiteral = "TemplateLiteral";
    VariableDeclarator = "VariableDeclarator";
    BLANK = Object.freeze(/* @__PURE__ */ Object.create(null));
    EMPTY_OBJECT = Object.freeze({});
    EMPTY_ARRAY = Object.freeze([]);
    EMPTY_SET = Object.freeze(new class extends Set {
      add() {
        throw new Error("Cannot add to empty set");
      }
    }());
    FIXED_STRINGS = [
      "var",
      "let",
      "const",
      "init",
      "get",
      "set",
      "constructor",
      "method",
      "-",
      "+",
      "!",
      "~",
      "typeof",
      "void",
      "delete",
      "++",
      "--",
      "==",
      "!=",
      "===",
      "!==",
      "<",
      "<=",
      ">",
      ">=",
      "<<",
      ">>",
      ">>>",
      "+",
      "-",
      "*",
      "/",
      "%",
      "|",
      "^",
      "&",
      "||",
      "&&",
      "in",
      "instanceof",
      "**",
      "??",
      "=",
      "+=",
      "-=",
      "*=",
      "/=",
      "%=",
      "<<=",
      ">>=",
      ">>>=",
      "|=",
      "^=",
      "&=",
      "**=",
      "&&=",
      "||=",
      "??=",
      "pure",
      "noSideEffects",
      "sourcemap",
      "using",
      "await using"
    ];
    ANNOTATION_KEY = "_rollupAnnotations";
    INVALID_ANNOTATION_KEY = "_rollupRemoved";
    convertAnnotations = (position, buffer4) => {
      if (position === 0)
        return EMPTY_ARRAY;
      const length3 = buffer4[position++];
      const list = new Array(length3);
      for (let index = 0; index < length3; index++) {
        list[index] = convertAnnotation(buffer4[position++], buffer4);
      }
      return list;
    };
    convertAnnotation = (position, buffer4) => {
      const start3 = buffer4[position++];
      const end6 = buffer4[position++];
      const type = FIXED_STRINGS[buffer4[position]];
      return { end: end6, start: start3, type };
    };
    LINE_TRUNCATE_LENGTH = 120;
    MIN_CHARACTERS_SHOWN_AFTER_LOCATION = 10;
    ELLIPSIS = "...";
    LOGLEVEL_SILENT = "silent";
    LOGLEVEL_ERROR = "error";
    LOGLEVEL_WARN = "warn";
    LOGLEVEL_INFO = "info";
    LOGLEVEL_DEBUG = "debug";
    logLevelPriority = {
      [LOGLEVEL_DEBUG]: 0,
      [LOGLEVEL_INFO]: 1,
      [LOGLEVEL_SILENT]: 3,
      [LOGLEVEL_WARN]: 2
    };
    ABSOLUTE_PATH_REGEX = /^(?:\/|(?:[A-Za-z]:)?[/\\|])/;
    RELATIVE_PATH_REGEX = /^\.?\.(\/|$)/;
    BACKSLASH_REGEX = /\\/g;
    ANY_SLASH_REGEX = /[/\\]/;
    UPPER_DIR_REGEX = /^(\.\.\/)*\.\.$/;
    URL_AVOIDING_EVAL = "troubleshooting/#avoiding-eval";
    URL_NAME_IS_NOT_EXPORTED = "troubleshooting/#error-name-is-not-exported-by-module";
    URL_THIS_IS_UNDEFINED = "troubleshooting/#error-this-is-undefined";
    URL_TREATING_MODULE_AS_EXTERNAL_DEPENDENCY = "troubleshooting/#warning-treating-module-as-external-dependency";
    URL_SOURCEMAP_IS_LIKELY_TO_BE_INCORRECT = "troubleshooting/#warning-sourcemap-is-likely-to-be-incorrect";
    URL_JSX = "configuration-options/#jsx";
    URL_OUTPUT_AMD_ID = "configuration-options/#output-amd-id";
    URL_OUTPUT_AMD_BASEPATH = "configuration-options/#output-amd-basepath";
    URL_OUTPUT_DIR = "configuration-options/#output-dir";
    URL_OUTPUT_EXPORTS = "configuration-options/#output-exports";
    URL_OUTPUT_EXTEND = "configuration-options/#output-extend";
    URL_OUTPUT_EXTERNALIMPORTATTRIBUTES = "configuration-options/#output-externalimportattributes";
    URL_OUTPUT_FORMAT = "configuration-options/#output-format";
    URL_OUTPUT_GENERATEDCODE = "configuration-options/#output-generatedcode";
    URL_OUTPUT_GLOBALS = "configuration-options/#output-globals";
    URL_OUTPUT_INLINEDYNAMICIMPORTS = "configuration-options/#output-inlinedynamicimports";
    URL_OUTPUT_INTEROP = "configuration-options/#output-interop";
    URL_OUTPUT_MANUALCHUNKS = "configuration-options/#output-manualchunks";
    URL_OUTPUT_NAME = "configuration-options/#output-name";
    URL_OUTPUT_SOURCEMAPBASEURL = "configuration-options/#output-sourcemapbaseurl";
    URL_OUTPUT_SOURCEMAPFILE = "configuration-options/#output-sourcemapfile";
    URL_PRESERVEENTRYSIGNATURES = "configuration-options/#preserveentrysignatures";
    URL_TREESHAKE = "configuration-options/#treeshake";
    URL_TREESHAKE_PURE = "configuration-options/#pure";
    URL_TREESHAKE_NOSIDEEFFECTS = "configuration-options/#no-side-effects";
    URL_TREESHAKE_MODULESIDEEFFECTS = "configuration-options/#treeshake-modulesideeffects";
    URL_GENERATEBUNDLE = "plugin-development/#generatebundle";
    symbolAugmented = Symbol("augmented");
    ADDON_ERROR = "ADDON_ERROR";
    ALREADY_CLOSED = "ALREADY_CLOSED";
    AMBIGUOUS_EXTERNAL_NAMESPACES = "AMBIGUOUS_EXTERNAL_NAMESPACES";
    ANONYMOUS_PLUGIN_CACHE = "ANONYMOUS_PLUGIN_CACHE";
    ASSET_NOT_FINALISED = "ASSET_NOT_FINALISED";
    ASSET_NOT_FOUND = "ASSET_NOT_FOUND";
    ASSET_SOURCE_ALREADY_SET = "ASSET_SOURCE_ALREADY_SET";
    ASSET_SOURCE_MISSING = "ASSET_SOURCE_MISSING";
    BAD_LOADER = "BAD_LOADER";
    CANNOT_CALL_NAMESPACE = "CANNOT_CALL_NAMESPACE";
    CANNOT_EMIT_FROM_OPTIONS_HOOK = "CANNOT_EMIT_FROM_OPTIONS_HOOK";
    CHUNK_NOT_GENERATED = "CHUNK_NOT_GENERATED";
    CHUNK_INVALID = "CHUNK_INVALID";
    CIRCULAR_DEPENDENCY = "CIRCULAR_DEPENDENCY";
    CIRCULAR_REEXPORT = "CIRCULAR_REEXPORT";
    CONST_REASSIGN = "CONST_REASSIGN";
    CYCLIC_CROSS_CHUNK_REEXPORT = "CYCLIC_CROSS_CHUNK_REEXPORT";
    DEPRECATED_FEATURE = "DEPRECATED_FEATURE";
    DUPLICATE_ARGUMENT_NAME = "DUPLICATE_ARGUMENT_NAME";
    DUPLICATE_EXPORT = "DUPLICATE_EXPORT";
    DUPLICATE_PLUGIN_NAME = "DUPLICATE_PLUGIN_NAME";
    EMPTY_BUNDLE = "EMPTY_BUNDLE";
    EVAL = "EVAL";
    EXTERNAL_MODULES_CANNOT_BE_INCLUDED_IN_MANUAL_CHUNKS = "EXTERNAL_MODULES_CANNOT_BE_INCLUDED_IN_MANUAL_CHUNKS";
    EXTERNAL_MODULES_CANNOT_BE_TRANSFORMED_TO_MODULES = "EXTERNAL_MODULES_CANNOT_BE_TRANSFORMED_TO_MODULES";
    EXTERNAL_SYNTHETIC_EXPORTS = "EXTERNAL_SYNTHETIC_EXPORTS";
    FILE_NAME_CONFLICT = "FILE_NAME_CONFLICT";
    FILE_NOT_FOUND = "FILE_NOT_FOUND";
    FIRST_SIDE_EFFECT = "FIRST_SIDE_EFFECT";
    ILLEGAL_IDENTIFIER_AS_NAME = "ILLEGAL_IDENTIFIER_AS_NAME";
    ILLEGAL_REASSIGNMENT = "ILLEGAL_REASSIGNMENT";
    INCONSISTENT_IMPORT_ATTRIBUTES = "INCONSISTENT_IMPORT_ATTRIBUTES";
    INVALID_ANNOTATION = "INVALID_ANNOTATION";
    INPUT_HOOK_IN_OUTPUT_PLUGIN = "INPUT_HOOK_IN_OUTPUT_PLUGIN";
    INVALID_CHUNK = "INVALID_CHUNK";
    INVALID_EXPORT_OPTION = "INVALID_EXPORT_OPTION";
    INVALID_EXTERNAL_ID = "INVALID_EXTERNAL_ID";
    INVALID_IMPORT_ATTRIBUTE = "INVALID_IMPORT_ATTRIBUTE";
    INVALID_LOG_POSITION = "INVALID_LOG_POSITION";
    INVALID_OPTION = "INVALID_OPTION";
    INVALID_PLUGIN_HOOK = "INVALID_PLUGIN_HOOK";
    INVALID_ROLLUP_PHASE = "INVALID_ROLLUP_PHASE";
    INVALID_SETASSETSOURCE = "INVALID_SETASSETSOURCE";
    INVALID_TLA_FORMAT = "INVALID_TLA_FORMAT";
    MISSING_EXPORT = "MISSING_EXPORT";
    MISSING_GLOBAL_NAME = "MISSING_GLOBAL_NAME";
    MISSING_IMPLICIT_DEPENDANT = "MISSING_IMPLICIT_DEPENDANT";
    MISSING_JSX_EXPORT = "MISSING_JSX_EXPORT";
    MISSING_NAME_OPTION_FOR_IIFE_EXPORT = "MISSING_NAME_OPTION_FOR_IIFE_EXPORT";
    MISSING_NODE_BUILTINS = "MISSING_NODE_BUILTINS";
    MISSING_OPTION = "MISSING_OPTION";
    MIXED_EXPORTS = "MIXED_EXPORTS";
    MODULE_LEVEL_DIRECTIVE = "MODULE_LEVEL_DIRECTIVE";
    NAMESPACE_CONFLICT = "NAMESPACE_CONFLICT";
    NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE = "NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE";
    OPTIMIZE_CHUNK_STATUS = "OPTIMIZE_CHUNK_STATUS";
    PARSE_ERROR = "PARSE_ERROR";
    PLUGIN_ERROR = "PLUGIN_ERROR";
    REDECLARATION_ERROR = "REDECLARATION_ERROR";
    RESERVED_NAMESPACE = "RESERVED_NAMESPACE";
    SHIMMED_EXPORT = "SHIMMED_EXPORT";
    SOURCEMAP_BROKEN = "SOURCEMAP_BROKEN";
    SOURCEMAP_ERROR = "SOURCEMAP_ERROR";
    SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT = "SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT";
    THIS_IS_UNDEFINED = "THIS_IS_UNDEFINED";
    UNEXPECTED_NAMED_IMPORT = "UNEXPECTED_NAMED_IMPORT";
    UNKNOWN_OPTION = "UNKNOWN_OPTION";
    UNRESOLVED_ENTRY = "UNRESOLVED_ENTRY";
    UNRESOLVED_IMPORT = "UNRESOLVED_IMPORT";
    UNUSED_EXTERNAL_IMPORT = "UNUSED_EXTERNAL_IMPORT";
    VALIDATION_ERROR = "VALIDATION_ERROR";
    formatAttributes = (attributes) => {
      const entries2 = Object.entries(attributes);
      if (entries2.length === 0)
        return "no";
      return entries2.map(([key, value]) => `"${key}": "${value}"`).join(", ");
    };
    nodeConverters = [
      function panicError(position, buffer4) {
        return {
          type: "PanicError",
          start: buffer4[position],
          end: buffer4[position + 1],
          message: buffer4.convertString(buffer4[position + 2])
        };
      },
      function parseError(position, buffer4) {
        return {
          type: "ParseError",
          start: buffer4[position],
          end: buffer4[position + 1],
          message: buffer4.convertString(buffer4[position + 2])
        };
      },
      function arrayExpression(position, buffer4) {
        return {
          type: "ArrayExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          elements: convertNodeList(buffer4[position + 2], buffer4)
        };
      },
      function arrayPattern(position, buffer4) {
        return {
          type: "ArrayPattern",
          start: buffer4[position],
          end: buffer4[position + 1],
          elements: convertNodeList(buffer4[position + 2], buffer4)
        };
      },
      function arrowFunctionExpression(position, buffer4) {
        const flags = buffer4[position + 2];
        const annotations = convertAnnotations(buffer4[position + 3], buffer4);
        return {
          type: "ArrowFunctionExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          async: (flags & 1) === 1,
          expression: (flags & 2) === 2,
          generator: (flags & 4) === 4,
          ...annotations.length > 0 ? { [ANNOTATION_KEY]: annotations } : {},
          params: convertNodeList(buffer4[position + 4], buffer4),
          body: convertNode(buffer4[position + 5], buffer4),
          id: null
        };
      },
      function assignmentExpression(position, buffer4) {
        return {
          type: "AssignmentExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          operator: FIXED_STRINGS[buffer4[position + 2]],
          left: convertNode(buffer4[position + 3], buffer4),
          right: convertNode(buffer4[position + 4], buffer4)
        };
      },
      function assignmentPattern(position, buffer4) {
        return {
          type: "AssignmentPattern",
          start: buffer4[position],
          end: buffer4[position + 1],
          left: convertNode(buffer4[position + 2], buffer4),
          right: convertNode(buffer4[position + 3], buffer4)
        };
      },
      function awaitExpression(position, buffer4) {
        return {
          type: "AwaitExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          argument: convertNode(buffer4[position + 2], buffer4)
        };
      },
      function binaryExpression(position, buffer4) {
        return {
          type: "BinaryExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          operator: FIXED_STRINGS[buffer4[position + 2]],
          left: convertNode(buffer4[position + 3], buffer4),
          right: convertNode(buffer4[position + 4], buffer4)
        };
      },
      function blockStatement(position, buffer4) {
        return {
          type: "BlockStatement",
          start: buffer4[position],
          end: buffer4[position + 1],
          body: convertNodeList(buffer4[position + 2], buffer4)
        };
      },
      function breakStatement(position, buffer4) {
        const labelPosition = buffer4[position + 2];
        return {
          type: "BreakStatement",
          start: buffer4[position],
          end: buffer4[position + 1],
          label: labelPosition === 0 ? null : convertNode(labelPosition, buffer4)
        };
      },
      function callExpression(position, buffer4) {
        const flags = buffer4[position + 2];
        const annotations = convertAnnotations(buffer4[position + 3], buffer4);
        return {
          type: "CallExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          optional: (flags & 1) === 1,
          ...annotations.length > 0 ? { [ANNOTATION_KEY]: annotations } : {},
          callee: convertNode(buffer4[position + 4], buffer4),
          arguments: convertNodeList(buffer4[position + 5], buffer4)
        };
      },
      function catchClause(position, buffer4) {
        const parameterPosition = buffer4[position + 2];
        return {
          type: "CatchClause",
          start: buffer4[position],
          end: buffer4[position + 1],
          param: parameterPosition === 0 ? null : convertNode(parameterPosition, buffer4),
          body: convertNode(buffer4[position + 3], buffer4)
        };
      },
      function chainExpression(position, buffer4) {
        return {
          type: "ChainExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          expression: convertNode(buffer4[position + 2], buffer4)
        };
      },
      function classBody(position, buffer4) {
        return {
          type: "ClassBody",
          start: buffer4[position],
          end: buffer4[position + 1],
          body: convertNodeList(buffer4[position + 2], buffer4)
        };
      },
      function classDeclaration(position, buffer4) {
        const idPosition = buffer4[position + 3];
        const superClassPosition = buffer4[position + 4];
        return {
          type: "ClassDeclaration",
          start: buffer4[position],
          end: buffer4[position + 1],
          decorators: convertNodeList(buffer4[position + 2], buffer4),
          id: idPosition === 0 ? null : convertNode(idPosition, buffer4),
          superClass: superClassPosition === 0 ? null : convertNode(superClassPosition, buffer4),
          body: convertNode(buffer4[position + 5], buffer4)
        };
      },
      function classExpression(position, buffer4) {
        const idPosition = buffer4[position + 3];
        const superClassPosition = buffer4[position + 4];
        return {
          type: "ClassExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          decorators: convertNodeList(buffer4[position + 2], buffer4),
          id: idPosition === 0 ? null : convertNode(idPosition, buffer4),
          superClass: superClassPosition === 0 ? null : convertNode(superClassPosition, buffer4),
          body: convertNode(buffer4[position + 5], buffer4)
        };
      },
      function conditionalExpression(position, buffer4) {
        return {
          type: "ConditionalExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          test: convertNode(buffer4[position + 2], buffer4),
          consequent: convertNode(buffer4[position + 3], buffer4),
          alternate: convertNode(buffer4[position + 4], buffer4)
        };
      },
      function continueStatement(position, buffer4) {
        const labelPosition = buffer4[position + 2];
        return {
          type: "ContinueStatement",
          start: buffer4[position],
          end: buffer4[position + 1],
          label: labelPosition === 0 ? null : convertNode(labelPosition, buffer4)
        };
      },
      function debuggerStatement(position, buffer4) {
        return {
          type: "DebuggerStatement",
          start: buffer4[position],
          end: buffer4[position + 1]
        };
      },
      function decorator(position, buffer4) {
        return {
          type: "Decorator",
          start: buffer4[position],
          end: buffer4[position + 1],
          expression: convertNode(buffer4[position + 2], buffer4)
        };
      },
      function directive(position, buffer4) {
        return {
          type: "ExpressionStatement",
          start: buffer4[position],
          end: buffer4[position + 1],
          directive: buffer4.convertString(buffer4[position + 2]),
          expression: convertNode(buffer4[position + 3], buffer4)
        };
      },
      function doWhileStatement(position, buffer4) {
        return {
          type: "DoWhileStatement",
          start: buffer4[position],
          end: buffer4[position + 1],
          body: convertNode(buffer4[position + 2], buffer4),
          test: convertNode(buffer4[position + 3], buffer4)
        };
      },
      function emptyStatement(position, buffer4) {
        return {
          type: "EmptyStatement",
          start: buffer4[position],
          end: buffer4[position + 1]
        };
      },
      function exportAllDeclaration(position, buffer4) {
        const exportedPosition = buffer4[position + 2];
        return {
          type: "ExportAllDeclaration",
          start: buffer4[position],
          end: buffer4[position + 1],
          exported: exportedPosition === 0 ? null : convertNode(exportedPosition, buffer4),
          source: convertNode(buffer4[position + 3], buffer4),
          attributes: convertNodeList(buffer4[position + 4], buffer4)
        };
      },
      function exportDefaultDeclaration(position, buffer4) {
        return {
          type: "ExportDefaultDeclaration",
          start: buffer4[position],
          end: buffer4[position + 1],
          declaration: convertNode(buffer4[position + 2], buffer4)
        };
      },
      function exportNamedDeclaration(position, buffer4) {
        const sourcePosition = buffer4[position + 3];
        const declarationPosition = buffer4[position + 5];
        return {
          type: "ExportNamedDeclaration",
          start: buffer4[position],
          end: buffer4[position + 1],
          specifiers: convertNodeList(buffer4[position + 2], buffer4),
          source: sourcePosition === 0 ? null : convertNode(sourcePosition, buffer4),
          attributes: convertNodeList(buffer4[position + 4], buffer4),
          declaration: declarationPosition === 0 ? null : convertNode(declarationPosition, buffer4)
        };
      },
      function exportSpecifier(position, buffer4) {
        const local = convertNode(buffer4[position + 2], buffer4);
        const exportedPosition = buffer4[position + 3];
        return {
          type: "ExportSpecifier",
          start: buffer4[position],
          end: buffer4[position + 1],
          local,
          exported: exportedPosition === 0 ? { ...local } : convertNode(exportedPosition, buffer4)
        };
      },
      function expressionStatement(position, buffer4) {
        return {
          type: "ExpressionStatement",
          start: buffer4[position],
          end: buffer4[position + 1],
          expression: convertNode(buffer4[position + 2], buffer4)
        };
      },
      function forInStatement(position, buffer4) {
        return {
          type: "ForInStatement",
          start: buffer4[position],
          end: buffer4[position + 1],
          left: convertNode(buffer4[position + 2], buffer4),
          right: convertNode(buffer4[position + 3], buffer4),
          body: convertNode(buffer4[position + 4], buffer4)
        };
      },
      function forOfStatement(position, buffer4) {
        const flags = buffer4[position + 2];
        return {
          type: "ForOfStatement",
          start: buffer4[position],
          end: buffer4[position + 1],
          await: (flags & 1) === 1,
          left: convertNode(buffer4[position + 3], buffer4),
          right: convertNode(buffer4[position + 4], buffer4),
          body: convertNode(buffer4[position + 5], buffer4)
        };
      },
      function forStatement(position, buffer4) {
        const initPosition = buffer4[position + 2];
        const testPosition = buffer4[position + 3];
        const updatePosition = buffer4[position + 4];
        return {
          type: "ForStatement",
          start: buffer4[position],
          end: buffer4[position + 1],
          init: initPosition === 0 ? null : convertNode(initPosition, buffer4),
          test: testPosition === 0 ? null : convertNode(testPosition, buffer4),
          update: updatePosition === 0 ? null : convertNode(updatePosition, buffer4),
          body: convertNode(buffer4[position + 5], buffer4)
        };
      },
      function functionDeclaration(position, buffer4) {
        const flags = buffer4[position + 2];
        const annotations = convertAnnotations(buffer4[position + 3], buffer4);
        const idPosition = buffer4[position + 4];
        return {
          type: "FunctionDeclaration",
          start: buffer4[position],
          end: buffer4[position + 1],
          async: (flags & 1) === 1,
          generator: (flags & 2) === 2,
          ...annotations.length > 0 ? { [ANNOTATION_KEY]: annotations } : {},
          id: idPosition === 0 ? null : convertNode(idPosition, buffer4),
          params: convertNodeList(buffer4[position + 5], buffer4),
          body: convertNode(buffer4[position + 6], buffer4),
          expression: false
        };
      },
      function functionExpression(position, buffer4) {
        const flags = buffer4[position + 2];
        const annotations = convertAnnotations(buffer4[position + 3], buffer4);
        const idPosition = buffer4[position + 4];
        return {
          type: "FunctionExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          async: (flags & 1) === 1,
          generator: (flags & 2) === 2,
          ...annotations.length > 0 ? { [ANNOTATION_KEY]: annotations } : {},
          id: idPosition === 0 ? null : convertNode(idPosition, buffer4),
          params: convertNodeList(buffer4[position + 5], buffer4),
          body: convertNode(buffer4[position + 6], buffer4),
          expression: false
        };
      },
      function identifier2(position, buffer4) {
        return {
          type: "Identifier",
          start: buffer4[position],
          end: buffer4[position + 1],
          name: buffer4.convertString(buffer4[position + 2])
        };
      },
      function ifStatement(position, buffer4) {
        const alternatePosition = buffer4[position + 4];
        return {
          type: "IfStatement",
          start: buffer4[position],
          end: buffer4[position + 1],
          test: convertNode(buffer4[position + 2], buffer4),
          consequent: convertNode(buffer4[position + 3], buffer4),
          alternate: alternatePosition === 0 ? null : convertNode(alternatePosition, buffer4)
        };
      },
      function importAttribute(position, buffer4) {
        return {
          type: "ImportAttribute",
          start: buffer4[position],
          end: buffer4[position + 1],
          key: convertNode(buffer4[position + 2], buffer4),
          value: convertNode(buffer4[position + 3], buffer4)
        };
      },
      function importDeclaration(position, buffer4) {
        return {
          type: "ImportDeclaration",
          start: buffer4[position],
          end: buffer4[position + 1],
          specifiers: convertNodeList(buffer4[position + 2], buffer4),
          source: convertNode(buffer4[position + 3], buffer4),
          attributes: convertNodeList(buffer4[position + 4], buffer4)
        };
      },
      function importDefaultSpecifier(position, buffer4) {
        return {
          type: "ImportDefaultSpecifier",
          start: buffer4[position],
          end: buffer4[position + 1],
          local: convertNode(buffer4[position + 2], buffer4)
        };
      },
      function importExpression(position, buffer4) {
        const optionsPosition = buffer4[position + 3];
        return {
          type: "ImportExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          source: convertNode(buffer4[position + 2], buffer4),
          options: optionsPosition === 0 ? null : convertNode(optionsPosition, buffer4)
        };
      },
      function importNamespaceSpecifier(position, buffer4) {
        return {
          type: "ImportNamespaceSpecifier",
          start: buffer4[position],
          end: buffer4[position + 1],
          local: convertNode(buffer4[position + 2], buffer4)
        };
      },
      function importSpecifier(position, buffer4) {
        const importedPosition = buffer4[position + 2];
        const local = convertNode(buffer4[position + 3], buffer4);
        return {
          type: "ImportSpecifier",
          start: buffer4[position],
          end: buffer4[position + 1],
          imported: importedPosition === 0 ? { ...local } : convertNode(importedPosition, buffer4),
          local
        };
      },
      function jsxAttribute(position, buffer4) {
        const valuePosition = buffer4[position + 3];
        return {
          type: "JSXAttribute",
          start: buffer4[position],
          end: buffer4[position + 1],
          name: convertNode(buffer4[position + 2], buffer4),
          value: valuePosition === 0 ? null : convertNode(valuePosition, buffer4)
        };
      },
      function jsxClosingElement(position, buffer4) {
        return {
          type: "JSXClosingElement",
          start: buffer4[position],
          end: buffer4[position + 1],
          name: convertNode(buffer4[position + 2], buffer4)
        };
      },
      function jsxClosingFragment(position, buffer4) {
        return {
          type: "JSXClosingFragment",
          start: buffer4[position],
          end: buffer4[position + 1]
        };
      },
      function jsxElement(position, buffer4) {
        const closingElementPosition = buffer4[position + 4];
        return {
          type: "JSXElement",
          start: buffer4[position],
          end: buffer4[position + 1],
          openingElement: convertNode(buffer4[position + 2], buffer4),
          children: convertNodeList(buffer4[position + 3], buffer4),
          closingElement: closingElementPosition === 0 ? null : convertNode(closingElementPosition, buffer4)
        };
      },
      function jsxEmptyExpression(position, buffer4) {
        return {
          type: "JSXEmptyExpression",
          start: buffer4[position],
          end: buffer4[position + 1]
        };
      },
      function jsxExpressionContainer(position, buffer4) {
        return {
          type: "JSXExpressionContainer",
          start: buffer4[position],
          end: buffer4[position + 1],
          expression: convertNode(buffer4[position + 2], buffer4)
        };
      },
      function jsxFragment(position, buffer4) {
        return {
          type: "JSXFragment",
          start: buffer4[position],
          end: buffer4[position + 1],
          openingFragment: convertNode(buffer4[position + 2], buffer4),
          children: convertNodeList(buffer4[position + 3], buffer4),
          closingFragment: convertNode(buffer4[position + 4], buffer4)
        };
      },
      function jsxIdentifier(position, buffer4) {
        return {
          type: "JSXIdentifier",
          start: buffer4[position],
          end: buffer4[position + 1],
          name: buffer4.convertString(buffer4[position + 2])
        };
      },
      function jsxMemberExpression(position, buffer4) {
        return {
          type: "JSXMemberExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          object: convertNode(buffer4[position + 2], buffer4),
          property: convertNode(buffer4[position + 3], buffer4)
        };
      },
      function jsxNamespacedName(position, buffer4) {
        return {
          type: "JSXNamespacedName",
          start: buffer4[position],
          end: buffer4[position + 1],
          namespace: convertNode(buffer4[position + 2], buffer4),
          name: convertNode(buffer4[position + 3], buffer4)
        };
      },
      function jsxOpeningElement(position, buffer4) {
        const flags = buffer4[position + 2];
        return {
          type: "JSXOpeningElement",
          start: buffer4[position],
          end: buffer4[position + 1],
          selfClosing: (flags & 1) === 1,
          name: convertNode(buffer4[position + 3], buffer4),
          attributes: convertNodeList(buffer4[position + 4], buffer4)
        };
      },
      function jsxOpeningFragment(position, buffer4) {
        return {
          type: "JSXOpeningFragment",
          start: buffer4[position],
          end: buffer4[position + 1],
          attributes: [],
          selfClosing: false
        };
      },
      function jsxSpreadAttribute(position, buffer4) {
        return {
          type: "JSXSpreadAttribute",
          start: buffer4[position],
          end: buffer4[position + 1],
          argument: convertNode(buffer4[position + 2], buffer4)
        };
      },
      function jsxSpreadChild(position, buffer4) {
        return {
          type: "JSXSpreadChild",
          start: buffer4[position],
          end: buffer4[position + 1],
          expression: convertNode(buffer4[position + 2], buffer4)
        };
      },
      function jsxText(position, buffer4) {
        return {
          type: "JSXText",
          start: buffer4[position],
          end: buffer4[position + 1],
          value: buffer4.convertString(buffer4[position + 2]),
          raw: buffer4.convertString(buffer4[position + 3])
        };
      },
      function labeledStatement(position, buffer4) {
        return {
          type: "LabeledStatement",
          start: buffer4[position],
          end: buffer4[position + 1],
          label: convertNode(buffer4[position + 2], buffer4),
          body: convertNode(buffer4[position + 3], buffer4)
        };
      },
      function literalBigInt(position, buffer4) {
        const bigint = buffer4.convertString(buffer4[position + 2]);
        return {
          type: "Literal",
          start: buffer4[position],
          end: buffer4[position + 1],
          bigint,
          raw: buffer4.convertString(buffer4[position + 3]),
          value: BigInt(bigint)
        };
      },
      function literalBoolean(position, buffer4) {
        const flags = buffer4[position + 2];
        const value = (flags & 1) === 1;
        return {
          type: "Literal",
          start: buffer4[position],
          end: buffer4[position + 1],
          value,
          raw: value ? "true" : "false"
        };
      },
      function literalNull(position, buffer4) {
        return {
          type: "Literal",
          start: buffer4[position],
          end: buffer4[position + 1],
          raw: "null",
          value: null
        };
      },
      function literalNumber(position, buffer4) {
        const rawPosition = buffer4[position + 2];
        return {
          type: "Literal",
          start: buffer4[position],
          end: buffer4[position + 1],
          raw: rawPosition === 0 ? void 0 : buffer4.convertString(rawPosition),
          value: new DataView(buffer4.buffer).getFloat64(position + 3 << 2, true)
        };
      },
      function literalRegExp(position, buffer4) {
        const flags = buffer4.convertString(buffer4[position + 2]);
        const pattern = buffer4.convertString(buffer4[position + 3]);
        return {
          type: "Literal",
          start: buffer4[position],
          end: buffer4[position + 1],
          raw: `/${pattern}/${flags}`,
          regex: { flags, pattern },
          value: new RegExp(pattern, flags)
        };
      },
      function literalString(position, buffer4) {
        const rawPosition = buffer4[position + 3];
        return {
          type: "Literal",
          start: buffer4[position],
          end: buffer4[position + 1],
          value: buffer4.convertString(buffer4[position + 2]),
          raw: rawPosition === 0 ? void 0 : buffer4.convertString(rawPosition)
        };
      },
      function logicalExpression(position, buffer4) {
        return {
          type: "LogicalExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          operator: FIXED_STRINGS[buffer4[position + 2]],
          left: convertNode(buffer4[position + 3], buffer4),
          right: convertNode(buffer4[position + 4], buffer4)
        };
      },
      function memberExpression(position, buffer4) {
        const flags = buffer4[position + 2];
        return {
          type: "MemberExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          computed: (flags & 1) === 1,
          optional: (flags & 2) === 2,
          object: convertNode(buffer4[position + 3], buffer4),
          property: convertNode(buffer4[position + 4], buffer4)
        };
      },
      function metaProperty(position, buffer4) {
        return {
          type: "MetaProperty",
          start: buffer4[position],
          end: buffer4[position + 1],
          meta: convertNode(buffer4[position + 2], buffer4),
          property: convertNode(buffer4[position + 3], buffer4)
        };
      },
      function methodDefinition(position, buffer4) {
        const flags = buffer4[position + 2];
        return {
          type: "MethodDefinition",
          start: buffer4[position],
          end: buffer4[position + 1],
          static: (flags & 1) === 1,
          computed: (flags & 2) === 2,
          decorators: convertNodeList(buffer4[position + 3], buffer4),
          key: convertNode(buffer4[position + 4], buffer4),
          value: convertNode(buffer4[position + 5], buffer4),
          kind: FIXED_STRINGS[buffer4[position + 6]]
        };
      },
      function newExpression(position, buffer4) {
        const annotations = convertAnnotations(buffer4[position + 2], buffer4);
        return {
          type: "NewExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          ...annotations.length > 0 ? { [ANNOTATION_KEY]: annotations } : {},
          callee: convertNode(buffer4[position + 3], buffer4),
          arguments: convertNodeList(buffer4[position + 4], buffer4)
        };
      },
      function objectExpression(position, buffer4) {
        return {
          type: "ObjectExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          properties: convertNodeList(buffer4[position + 2], buffer4)
        };
      },
      function objectPattern(position, buffer4) {
        return {
          type: "ObjectPattern",
          start: buffer4[position],
          end: buffer4[position + 1],
          properties: convertNodeList(buffer4[position + 2], buffer4)
        };
      },
      function privateIdentifier(position, buffer4) {
        return {
          type: "PrivateIdentifier",
          start: buffer4[position],
          end: buffer4[position + 1],
          name: buffer4.convertString(buffer4[position + 2])
        };
      },
      function program(position, buffer4) {
        const invalidAnnotations = convertAnnotations(buffer4[position + 3], buffer4);
        return {
          type: "Program",
          start: buffer4[position],
          end: buffer4[position + 1],
          body: convertNodeList(buffer4[position + 2], buffer4),
          ...invalidAnnotations.length > 0 ? { [INVALID_ANNOTATION_KEY]: invalidAnnotations } : {},
          sourceType: "module"
        };
      },
      function property(position, buffer4) {
        const flags = buffer4[position + 2];
        const keyPosition = buffer4[position + 3];
        const value = convertNode(buffer4[position + 4], buffer4);
        return {
          type: "Property",
          start: buffer4[position],
          end: buffer4[position + 1],
          method: (flags & 1) === 1,
          shorthand: (flags & 2) === 2,
          computed: (flags & 4) === 4,
          key: keyPosition === 0 ? { ...value } : convertNode(keyPosition, buffer4),
          value,
          kind: FIXED_STRINGS[buffer4[position + 5]]
        };
      },
      function propertyDefinition(position, buffer4) {
        const flags = buffer4[position + 2];
        const valuePosition = buffer4[position + 5];
        return {
          type: "PropertyDefinition",
          start: buffer4[position],
          end: buffer4[position + 1],
          static: (flags & 1) === 1,
          computed: (flags & 2) === 2,
          decorators: convertNodeList(buffer4[position + 3], buffer4),
          key: convertNode(buffer4[position + 4], buffer4),
          value: valuePosition === 0 ? null : convertNode(valuePosition, buffer4)
        };
      },
      function restElement(position, buffer4) {
        return {
          type: "RestElement",
          start: buffer4[position],
          end: buffer4[position + 1],
          argument: convertNode(buffer4[position + 2], buffer4)
        };
      },
      function returnStatement(position, buffer4) {
        const argumentPosition = buffer4[position + 2];
        return {
          type: "ReturnStatement",
          start: buffer4[position],
          end: buffer4[position + 1],
          argument: argumentPosition === 0 ? null : convertNode(argumentPosition, buffer4)
        };
      },
      function sequenceExpression(position, buffer4) {
        return {
          type: "SequenceExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          expressions: convertNodeList(buffer4[position + 2], buffer4)
        };
      },
      function spreadElement(position, buffer4) {
        return {
          type: "SpreadElement",
          start: buffer4[position],
          end: buffer4[position + 1],
          argument: convertNode(buffer4[position + 2], buffer4)
        };
      },
      function staticBlock(position, buffer4) {
        return {
          type: "StaticBlock",
          start: buffer4[position],
          end: buffer4[position + 1],
          body: convertNodeList(buffer4[position + 2], buffer4)
        };
      },
      function superElement(position, buffer4) {
        return {
          type: "Super",
          start: buffer4[position],
          end: buffer4[position + 1]
        };
      },
      function switchCase(position, buffer4) {
        const testPosition = buffer4[position + 2];
        return {
          type: "SwitchCase",
          start: buffer4[position],
          end: buffer4[position + 1],
          test: testPosition === 0 ? null : convertNode(testPosition, buffer4),
          consequent: convertNodeList(buffer4[position + 3], buffer4)
        };
      },
      function switchStatement(position, buffer4) {
        return {
          type: "SwitchStatement",
          start: buffer4[position],
          end: buffer4[position + 1],
          discriminant: convertNode(buffer4[position + 2], buffer4),
          cases: convertNodeList(buffer4[position + 3], buffer4)
        };
      },
      function taggedTemplateExpression(position, buffer4) {
        return {
          type: "TaggedTemplateExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          tag: convertNode(buffer4[position + 2], buffer4),
          quasi: convertNode(buffer4[position + 3], buffer4)
        };
      },
      function templateElement(position, buffer4) {
        const flags = buffer4[position + 2];
        const cookedPosition = buffer4[position + 3];
        const cooked = cookedPosition === 0 ? void 0 : buffer4.convertString(cookedPosition);
        const raw = buffer4.convertString(buffer4[position + 4]);
        return {
          type: "TemplateElement",
          start: buffer4[position],
          end: buffer4[position + 1],
          tail: (flags & 1) === 1,
          value: { cooked, raw }
        };
      },
      function templateLiteral(position, buffer4) {
        return {
          type: "TemplateLiteral",
          start: buffer4[position],
          end: buffer4[position + 1],
          quasis: convertNodeList(buffer4[position + 2], buffer4),
          expressions: convertNodeList(buffer4[position + 3], buffer4)
        };
      },
      function thisExpression(position, buffer4) {
        return {
          type: "ThisExpression",
          start: buffer4[position],
          end: buffer4[position + 1]
        };
      },
      function throwStatement(position, buffer4) {
        return {
          type: "ThrowStatement",
          start: buffer4[position],
          end: buffer4[position + 1],
          argument: convertNode(buffer4[position + 2], buffer4)
        };
      },
      function tryStatement(position, buffer4) {
        const handlerPosition = buffer4[position + 3];
        const finalizerPosition = buffer4[position + 4];
        return {
          type: "TryStatement",
          start: buffer4[position],
          end: buffer4[position + 1],
          block: convertNode(buffer4[position + 2], buffer4),
          handler: handlerPosition === 0 ? null : convertNode(handlerPosition, buffer4),
          finalizer: finalizerPosition === 0 ? null : convertNode(finalizerPosition, buffer4)
        };
      },
      function unaryExpression(position, buffer4) {
        return {
          type: "UnaryExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          operator: FIXED_STRINGS[buffer4[position + 2]],
          argument: convertNode(buffer4[position + 3], buffer4),
          prefix: true
        };
      },
      function updateExpression(position, buffer4) {
        const flags = buffer4[position + 2];
        return {
          type: "UpdateExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          prefix: (flags & 1) === 1,
          operator: FIXED_STRINGS[buffer4[position + 3]],
          argument: convertNode(buffer4[position + 4], buffer4)
        };
      },
      function variableDeclaration(position, buffer4) {
        return {
          type: "VariableDeclaration",
          start: buffer4[position],
          end: buffer4[position + 1],
          kind: FIXED_STRINGS[buffer4[position + 2]],
          declarations: convertNodeList(buffer4[position + 3], buffer4)
        };
      },
      function variableDeclarator(position, buffer4) {
        const initPosition = buffer4[position + 3];
        return {
          type: "VariableDeclarator",
          start: buffer4[position],
          end: buffer4[position + 1],
          id: convertNode(buffer4[position + 2], buffer4),
          init: initPosition === 0 ? null : convertNode(initPosition, buffer4)
        };
      },
      function whileStatement(position, buffer4) {
        return {
          type: "WhileStatement",
          start: buffer4[position],
          end: buffer4[position + 1],
          test: convertNode(buffer4[position + 2], buffer4),
          body: convertNode(buffer4[position + 3], buffer4)
        };
      },
      function yieldExpression(position, buffer4) {
        const flags = buffer4[position + 2];
        const argumentPosition = buffer4[position + 3];
        return {
          type: "YieldExpression",
          start: buffer4[position],
          end: buffer4[position + 1],
          delegate: (flags & 1) === 1,
          argument: argumentPosition === 0 ? null : convertNode(argumentPosition, buffer4)
        };
      }
    ];
    parseAst = (input2, { allowReturnOutsideFunction = false, jsx = false } = {}) => convertProgram(getAstBuffer((0, import_native.parse)(input2, allowReturnOutsideFunction, jsx)));
  }
});
function decodeInteger2(reader, relative4) {
  let value = 0;
  let shift2 = 0;
  let integer3 = 0;
  do {
    const c = reader.next();
    integer3 = charToInt2[c];
    value |= (integer3 & 31) << shift2;
    shift2 += 5;
  } while (integer3 & 32);
  const shouldNegate = value & 1;
  value >>>= 1;
  if (shouldNegate) {
    value = -2147483648 | -value;
  }
  return relative4 + value;
}
function encodeInteger2(builder, num, relative4) {
  let delta = num - relative4;
  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
  do {
    let clamped = delta & 31;
    delta >>>= 5;
    if (delta > 0)
      clamped |= 32;
    builder.write(intToChar2[clamped]);
  } while (delta > 0);
  return num;
}
function hasMoreVlq2(reader, max5) {
  if (reader.pos >= max5)
    return false;
  return reader.peek() !== comma2;
}
function decode3(mappings) {
  const { length: length3 } = mappings;
  const reader = new StringReader2(mappings);
  const decoded = [];
  let genColumn = 0;
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  do {
    const semi = reader.indexOf(";");
    const line = [];
    let sorted2 = true;
    let lastCol = 0;
    genColumn = 0;
    while (reader.pos < semi) {
      let seg;
      genColumn = decodeInteger2(reader, genColumn);
      if (genColumn < lastCol)
        sorted2 = false;
      lastCol = genColumn;
      if (hasMoreVlq2(reader, semi)) {
        sourcesIndex = decodeInteger2(reader, sourcesIndex);
        sourceLine = decodeInteger2(reader, sourceLine);
        sourceColumn = decodeInteger2(reader, sourceColumn);
        if (hasMoreVlq2(reader, semi)) {
          namesIndex = decodeInteger2(reader, namesIndex);
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
        } else {
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
        }
      } else {
        seg = [genColumn];
      }
      line.push(seg);
      reader.pos++;
    }
    if (!sorted2)
      sort3(line);
    decoded.push(line);
    reader.pos = semi + 1;
  } while (reader.pos <= length3);
  return decoded;
}
function sort3(line) {
  line.sort(sortComparator3);
}
function sortComparator3(a2, b) {
  return a2[0] - b[0];
}
function encode2(decoded) {
  const writer = new StringWriter2();
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0)
      writer.write(semicolon2);
    if (line.length === 0)
      continue;
    let genColumn = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      if (j > 0)
        writer.write(comma2);
      genColumn = encodeInteger2(writer, segment[0], genColumn);
      if (segment.length === 1)
        continue;
      sourcesIndex = encodeInteger2(writer, segment[1], sourcesIndex);
      sourceLine = encodeInteger2(writer, segment[2], sourceLine);
      sourceColumn = encodeInteger2(writer, segment[3], sourceColumn);
      if (segment.length === 4)
        continue;
      namesIndex = encodeInteger2(writer, segment[4], namesIndex);
    }
  }
  return writer.flush();
}
function getBtoa() {
  if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") {
    return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
  } else if (typeof Buffer === "function") {
    return (str) => Buffer.from(str, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
function guessIndent(code) {
  const lines = code.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced3 = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced3.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced3.length) {
    return "	";
  }
  const min3 = spaced3.reduce((previous2, current2) => {
    const numSpaces = /^ +/.exec(current2)[0].length;
    return Math.min(numSpaces, previous2);
  }, Infinity);
  return new Array(min3 + 1).join(" ");
}
function getRelativePath(from, to) {
  const fromParts = from.split(/[/\\]/);
  const toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--) fromParts[i] = "..";
  }
  return fromParts.concat(toParts).join("/");
}
function isObject3(thing) {
  return toString3.call(thing) === "[object Object]";
}
function getLocator2(source) {
  const originalLines = source.split("\n");
  const lineOffsets = [];
  for (let i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate2(index) {
    let i = 0;
    let j = lineOffsets.length;
    while (i < j) {
      const m2 = i + j >> 1;
      if (index < lineOffsets[m2]) {
        j = m2;
      } else {
        i = m2 + 1;
      }
    }
    const line = i - 1;
    const column = index - lineOffsets[line];
    return { line, column };
  };
}
function treeshakeNode(node, code, start3, end6) {
  code.remove(start3, end6);
  node.removeAnnotations(code);
}
function findFirstOccurrenceOutsideComment(code, searchString, start3 = 0) {
  let searchPos, charCodeAfterSlash;
  searchPos = code.indexOf(searchString, start3);
  while (true) {
    start3 = code.indexOf("/", start3);
    if (start3 === -1 || start3 >= searchPos)
      return searchPos;
    charCodeAfterSlash = code.charCodeAt(++start3);
    ++start3;
    start3 = charCodeAfterSlash === 47 ? code.indexOf("\n", start3) + 1 : code.indexOf("*/", start3) + 2;
    if (start3 > searchPos) {
      searchPos = code.indexOf(searchString, start3);
    }
  }
}
function findNonWhiteSpace(code, index) {
  NON_WHITESPACE.lastIndex = index;
  const result = NON_WHITESPACE.exec(code);
  return result.index;
}
function findLastWhiteSpaceReverse(code, start3, end6) {
  while (true) {
    if (start3 >= end6) {
      return end6;
    }
    if (WHITESPACE.test(code[end6 - 1])) {
      end6--;
    } else {
      return end6;
    }
  }
}
function findFirstLineBreakOutsideComment(code) {
  let lineBreakPos, charCodeAfterSlash, start3 = 0;
  lineBreakPos = code.indexOf("\n", start3);
  while (true) {
    start3 = code.indexOf("/", start3);
    if (start3 === -1 || start3 > lineBreakPos)
      return [lineBreakPos, lineBreakPos + 1];
    charCodeAfterSlash = code.charCodeAt(start3 + 1);
    if (charCodeAfterSlash === 47)
      return [start3, lineBreakPos + 1];
    start3 = code.indexOf("*/", start3 + 2) + 2;
    if (start3 > lineBreakPos) {
      lineBreakPos = code.indexOf("\n", start3);
    }
  }
}
function renderStatementList(statements, code, start3, end6, options) {
  let currentNode, currentNodeStart, currentNodeNeedsBoundaries, nextNodeStart;
  let nextNode = statements[0];
  let nextNodeNeedsBoundaries = !nextNode.included || nextNode.needsBoundaries;
  if (nextNodeNeedsBoundaries) {
    nextNodeStart = start3 + findFirstLineBreakOutsideComment(code.original.slice(start3, nextNode.start))[1];
  }
  for (let nextIndex = 1; nextIndex <= statements.length; nextIndex++) {
    currentNode = nextNode;
    currentNodeStart = nextNodeStart;
    currentNodeNeedsBoundaries = nextNodeNeedsBoundaries;
    nextNode = statements[nextIndex];
    nextNodeNeedsBoundaries = nextNode === void 0 ? false : !nextNode.included || nextNode.needsBoundaries;
    if (currentNodeNeedsBoundaries || nextNodeNeedsBoundaries) {
      nextNodeStart = currentNode.end + findFirstLineBreakOutsideComment(code.original.slice(currentNode.end, nextNode === void 0 ? end6 : nextNode.start))[1];
      if (currentNode.included) {
        if (currentNodeNeedsBoundaries) {
          currentNode.render(code, options, {
            end: nextNodeStart,
            start: currentNodeStart
          });
        } else {
          currentNode.render(code, options);
        }
      } else {
        treeshakeNode(currentNode, code, currentNodeStart, nextNodeStart);
      }
    } else {
      currentNode.render(code, options);
    }
  }
}
function getCommaSeparatedNodesWithBoundaries(nodes, code, start3, end6) {
  const splitUpNodes = [];
  let node, nextNodeStart, contentEnd, char;
  let separator = start3 - 1;
  for (const nextNode of nodes) {
    if (node !== void 0) {
      separator = node.end + findFirstOccurrenceOutsideComment(code.original.slice(node.end, nextNode.start), ",");
    }
    nextNodeStart = contentEnd = separator + 1 + findFirstLineBreakOutsideComment(code.original.slice(separator + 1, nextNode.start))[1];
    while (char = code.original.charCodeAt(nextNodeStart), char === 32 || char === 9 || char === 10 || char === 13)
      nextNodeStart++;
    if (node !== void 0) {
      splitUpNodes.push({
        contentEnd,
        end: nextNodeStart,
        node,
        separator,
        start: start3
      });
    }
    node = nextNode;
    start3 = nextNodeStart;
  }
  splitUpNodes.push({
    contentEnd: end6,
    end: end6,
    node,
    separator: null,
    start: start3
  });
  return splitUpNodes;
}
function removeLineBreaks(code, start3, end6) {
  while (true) {
    const [removeStart, removeEnd] = findFirstLineBreakOutsideComment(code.original.slice(start3, end6));
    if (removeStart === -1) {
      break;
    }
    code.remove(start3 + removeStart, start3 += removeEnd);
  }
}
function getSystemExportStatement(exportedVariables, { exportNamesByVariable, snippets: { _: _2, getObject, getPropertyAccess } }, modifier = "") {
  if (exportedVariables.length === 1 && exportNamesByVariable.get(exportedVariables[0]).length === 1) {
    const variable = exportedVariables[0];
    return `exports(${JSON.stringify(exportNamesByVariable.get(variable)[0])},${_2}${variable.getName(getPropertyAccess)}${modifier})`;
  } else {
    const fields = [];
    for (const variable of exportedVariables) {
      for (const exportName of exportNamesByVariable.get(variable)) {
        fields.push([exportName, variable.getName(getPropertyAccess) + modifier]);
      }
    }
    return `exports(${getObject(fields, { lineBreakIndent: null })})`;
  }
}
function renderSystemExportExpression(exportedVariable, expressionStart, expressionEnd, code, { exportNamesByVariable, snippets: { _: _2 } }) {
  code.prependRight(expressionStart, `exports(${JSON.stringify(exportNamesByVariable.get(exportedVariable)[0])},${_2}`);
  code.appendLeft(expressionEnd, ")");
}
function renderSystemExportFunction(exportedVariables, expressionStart, expressionEnd, needsParens, code, options) {
  const { _: _2, getDirectReturnIifeLeft } = options.snippets;
  code.prependRight(expressionStart, getDirectReturnIifeLeft(["v"], `${getSystemExportStatement(exportedVariables, options)},${_2}v`, { needsArrowReturnParens: true, needsWrappedFunction: needsParens }));
  code.appendLeft(expressionEnd, ")");
}
function renderSystemExportSequenceAfterExpression(exportedVariable, expressionStart, expressionEnd, needsParens, code, options) {
  const { _: _2, getPropertyAccess } = options.snippets;
  code.appendLeft(expressionEnd, `,${_2}${getSystemExportStatement([exportedVariable], options)},${_2}${exportedVariable.getName(getPropertyAccess)}`);
  if (needsParens) {
    code.prependRight(expressionStart, "(");
    code.appendLeft(expressionEnd, ")");
  }
}
function renderSystemExportSequenceBeforeExpression(exportedVariable, expressionStart, expressionEnd, needsParens, code, options, modifier) {
  const { _: _2 } = options.snippets;
  code.prependRight(expressionStart, `${getSystemExportStatement([exportedVariable], options, modifier)},${_2}`);
  if (needsParens) {
    code.prependRight(expressionStart, "(");
    code.appendLeft(expressionEnd, ")");
  }
}
function getOrCreate(map26, key, init2) {
  const existing = map26.get(key);
  if (existing !== void 0) {
    return existing;
  }
  const value = init2();
  map26.set(key, value);
  return value;
}
function getNewSet() {
  return /* @__PURE__ */ new Set();
}
function getNewArray() {
  return [];
}
function is_reference(node, parent) {
  if (node.type === "MemberExpression") {
    return !node.computed && is_reference(node.object, node);
  }
  if (node.type !== "Identifier") return false;
  switch (parent?.type) {
    // disregard `bar` in `foo.bar`
    case "MemberExpression":
      return parent.computed || node === parent.object;
    // disregard the `foo` in `class {foo(){}}` but keep it in `class {[foo](){}}`
    case "MethodDefinition":
      return parent.computed;
    // disregard the `meta` in `import.meta`
    case "MetaProperty":
      return parent.meta === node;
    // disregard the `foo` in `class {foo=bar}` but keep it in `class {[foo]=bar}` and `class {bar=foo}`
    case "PropertyDefinition":
      return parent.computed || node === parent.value;
    // disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
    case "Property":
      return parent.computed || node === parent.value;
    // disregard the `bar` in `export { foo as bar }` or
    // the foo in `import { foo as bar }`
    case "ExportSpecifier":
    case "ImportSpecifier":
      return node === parent.local;
    // disregard the `foo` in `foo: while (...) { ... break foo; ... continue foo;}`
    case "LabeledStatement":
    case "BreakStatement":
    case "ContinueStatement":
      return false;
    default:
      return true;
  }
}
function createInclusionContext() {
  return {
    brokenFlow: false,
    hasBreak: false,
    hasContinue: false,
    includedCallArguments: /* @__PURE__ */ new Set(),
    includedLabels: /* @__PURE__ */ new Set()
  };
}
function createHasEffectsContext() {
  return {
    accessed: new EntityPathTracker(),
    assigned: new EntityPathTracker(),
    brokenFlow: false,
    called: new DiscriminatedPathTracker(),
    hasBreak: false,
    hasContinue: false,
    ignore: {
      breaks: false,
      continues: false,
      labels: /* @__PURE__ */ new Set(),
      returnYield: false,
      this: false
    },
    includedLabels: /* @__PURE__ */ new Set(),
    instantiated: new DiscriminatedPathTracker(),
    replacedVariableInits: /* @__PURE__ */ new Map()
  };
}
function isFlagSet(flags, flag) {
  return (flags & flag) !== 0;
}
function setFlag(flags, flag, value) {
  return flags & ~flag | -value & flag;
}
function cacheObjectGetters(object, getterProperties) {
  for (const property3 of getterProperties) {
    const propertyGetter = Object.getOwnPropertyDescriptor(object, property3).get;
    Object.defineProperty(object, property3, {
      get() {
        const value = propertyGetter.call(object);
        Object.defineProperty(object, property3, { value });
        return value;
      }
    });
  }
}
function isLegal(value) {
  if (needsEscape(value)) {
    return false;
  }
  return !illegalCharacters.test(value);
}
function makeLegal(value) {
  value = value.replace(/-(\w)/g, (_2, letter) => letter.toUpperCase()).replace(illegalCharacters, "_");
  if (needsEscape(value))
    value = `_${value}`;
  return value || "_";
}
function stringifyObjectKeyIfNeeded(key) {
  if (VALID_IDENTIFIER_REGEXP.test(key)) {
    return key === "__proto__" ? '["__proto__"]' : key;
  }
  if (NUMBER_REGEXP.test(key) && +key <= Number.MAX_SAFE_INTEGER) {
    return key;
  }
  return JSON.stringify(key);
}
function stringifyIdentifierIfNeeded(key) {
  if (VALID_IDENTIFIER_REGEXP.test(key)) {
    return key;
  }
  return JSON.stringify(key);
}
function markModuleAndImpureDependenciesAsExecuted(baseModule) {
  baseModule.isExecuted = true;
  const modules = [baseModule];
  const visitedModules = /* @__PURE__ */ new Set();
  for (const module of modules) {
    for (const dependency of [...module.dependencies, ...module.implicitlyLoadedBefore]) {
      if (!(dependency instanceof ExternalModule) && !dependency.isExecuted && (dependency.info.moduleSideEffects || module.implicitlyLoadedBefore.has(dependency)) && !visitedModules.has(dependency.id)) {
        dependency.isExecuted = true;
        visitedModules.add(dependency.id);
        modules.push(dependency);
      }
    }
  }
}
function createChildNodeKeysForNode(esTreeNode) {
  return Object.keys(esTreeNode).filter(
    (key) => typeof esTreeNode[key] === "object" && key.charCodeAt(0) !== 95
    /* _ */
  );
}
function onlyIncludeSelf() {
  this.included = true;
  if (!this.deoptimized)
    this.applyDeoptimizations();
}
function onlyIncludeSelfNoDeoptimize() {
  this.included = true;
}
function doNotDeoptimize() {
  this.deoptimized = true;
}
function isObjectExpressionNode(node) {
  return node instanceof NodeBase && node.type === ObjectExpression;
}
function isPropertyNode(node) {
  return node.type === Property;
}
function assembleMemberDescriptions(memberDescriptions, inheritedDescriptions = null) {
  return Object.create(inheritedDescriptions, memberDescriptions);
}
function getLiteralMembersForValue(value) {
  if (value instanceof RegExp) {
    return literalRegExpMembers;
  }
  switch (typeof value) {
    case "boolean": {
      return literalBooleanMembers;
    }
    case "number": {
      return literalNumberMembers;
    }
    case "string": {
      return literalStringMembers;
    }
  }
  return /* @__PURE__ */ Object.create(null);
}
function hasMemberEffectWhenCalled(members, memberName, interaction, context8) {
  if (typeof memberName !== "string" || !members[memberName]) {
    return true;
  }
  return members[memberName].hasEffectsWhenCalled?.(interaction, context8) || false;
}
function getMemberReturnExpressionWhenCalled(members, memberName) {
  if (typeof memberName !== "string" || !members[memberName])
    return UNKNOWN_RETURN_EXPRESSION;
  return [members[memberName].returns, false];
}
function getGlobalAtPath(path3) {
  let currentGlobal = knownGlobals;
  for (const pathSegment of path3) {
    if (typeof pathSegment !== "string") {
      return null;
    }
    currentGlobal = currentGlobal[pathSegment];
    if (!currentGlobal) {
      return null;
    }
  }
  return currentGlobal[ValueProperties];
}
function closestParentFunctionOrProgram(node) {
  while (node && !/^Program|Function/.test(node.type)) {
    node = node.parent;
  }
  return node;
}
function toBase64(value) {
  let outString = "";
  do {
    const currentDigit = value % base;
    value = value / base | 0;
    outString = chars2[currentDigit] + outString;
  } while (value !== 0);
  return outString;
}
function getSafeName(baseName, usedNames, forbiddenNames) {
  let safeName = baseName;
  let count5 = 1;
  while (usedNames.has(safeName) || RESERVED_NAMES.has(safeName) || forbiddenNames?.has(safeName)) {
    safeName = `${baseName}$${toBase64(count5++)}`;
  }
  usedNames.add(safeName);
  return safeName;
}
function checkEffectForNodes(nodes, context8) {
  for (const node of nodes) {
    if (node.hasEffects(context8)) {
      return true;
    }
  }
  return false;
}
function isStaticBlock(statement) {
  return statement.type === StaticBlock;
}
function addArgumentToBeDeoptimized(argument) {
  if (this.included) {
    argument.deoptimizePath(UNKNOWN_PATH);
  } else {
    this.deoptimizedArguments?.push(argument);
  }
}
function getDeclarationStart(code, start3) {
  return findNonWhiteSpace(code, findFirstOccurrenceOutsideComment(code, "default", start3) + 7);
}
function getFunctionIdInsertPosition(code, start3) {
  const declarationEnd = findFirstOccurrenceOutsideComment(code, "function", start3) + "function".length;
  code = code.slice(declarationEnd, findFirstOccurrenceOutsideComment(code, "(", declarationEnd));
  const generatorStarPos = findFirstOccurrenceOutsideComment(code, "*");
  if (generatorStarPos === -1) {
    return declarationEnd;
  }
  return declarationEnd + generatorStarPos + 1;
}
function escapeId(id2) {
  if (!needsEscapeRegEx.test(id2))
    return id2;
  return id2.replace(backSlashRegEx, "\\\\").replace(quoteNewlineRegEx, "\\$1");
}
function getToStringTagValue(getObject) {
  return getObject([["value", "'Module'"]], {
    lineBreakIndent: null
  });
}
function getChainElementLiteralValueAtPath(element, object, path3, recursionTracker, origin) {
  if ("getLiteralValueAtPathAsChainElement" in object) {
    const calleeValue = object.getLiteralValueAtPathAsChainElement(EMPTY_PATH, SHARED_RECURSION_TRACKER, origin);
    if (calleeValue === IS_SKIPPED_CHAIN || element.optional && calleeValue == null) {
      return IS_SKIPPED_CHAIN;
    }
  } else if (element.optional && object.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, origin) == null) {
    return IS_SKIPPED_CHAIN;
  }
  return element.getLiteralValueAtPath(path3, recursionTracker, origin);
}
function getResolvablePropertyKey(memberExpression3) {
  return memberExpression3.computed ? getResolvableComputedPropertyKey(memberExpression3.property) : memberExpression3.property.name;
}
function getResolvableComputedPropertyKey(propertyKey) {
  if (propertyKey instanceof Literal2) {
    return String(propertyKey.value);
  }
  return null;
}
function getPathIfNotComputed(memberExpression3) {
  const nextPathKey = memberExpression3.propertyKey;
  const object = memberExpression3.object;
  if (typeof nextPathKey === "string") {
    if (object instanceof Identifier2) {
      return [
        { key: object.name, pos: object.start },
        { key: nextPathKey, pos: memberExpression3.property.start }
      ];
    }
    if (object instanceof MemberExpression) {
      const parentPath = getPathIfNotComputed(object);
      return parentPath && [...parentPath, { key: nextPathKey, pos: memberExpression3.property.start }];
    }
  }
  return null;
}
function getStringFromPath(path3) {
  let pathString = path3[0].key;
  for (let index = 1; index < path3.length; index++) {
    pathString += "." + path3[index].key;
  }
  return pathString;
}
function resolveNamespaceVariables(baseVariable, path3, astContext) {
  if (path3.length === 0)
    return baseVariable;
  if (!baseVariable.isNamespace || baseVariable instanceof ExternalVariable)
    return null;
  const exportName = path3[0].key;
  const variable = baseVariable.context.traceExport(exportName);
  if (!variable) {
    if (path3.length === 1) {
      const fileName = baseVariable.context.fileName;
      astContext.log(LOGLEVEL_WARN, logMissingExport(exportName, astContext.module.id, fileName), path3[0].pos);
      return "undefined";
    }
    return null;
  }
  return resolveNamespaceVariables(variable, path3.slice(1), astContext);
}
function formatAttributes2(attributes, { getObject }) {
  if (!attributes) {
    return null;
  }
  const assertionEntries = Object.entries(attributes).map(([key, value]) => [key, `'${value}'`]);
  if (assertionEntries.length > 0) {
    return getObject(assertionEntries, { lineBreakIndent: null });
  }
  return null;
}
function removeJsExtension(name) {
  return name.endsWith(".js") ? name.slice(0, -3) : name;
}
function getCompleteAmdId(options, chunkId) {
  if (options.autoId) {
    return `${options.basePath ? options.basePath + "/" : ""}${removeJsExtension(chunkId)}`;
  }
  return options.id ?? "";
}
function getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, reexportProtoFromExternal, mechanism = "return ") {
  const { _: _2, getDirectReturnFunction, getFunctionIntro, getPropertyAccess, n: n2, s: s2 } = snippets;
  if (!namedExportsMode) {
    return `${n2}${n2}${mechanism}${getSingleDefaultExport(exports, dependencies, interop, externalLiveBindings, getPropertyAccess)};`;
  }
  let exportBlock = "";
  if (namedExportsMode) {
    for (const { defaultVariableName, importPath, isChunk: isChunk2, name, namedExportsMode: depNamedExportsMode, namespaceVariableName, reexports } of dependencies) {
      if (!reexports) {
        continue;
      }
      for (const specifier of reexports) {
        if (specifier.reexported !== "*") {
          const importName = getReexportedImportName(name, specifier.imported, depNamedExportsMode, isChunk2, defaultVariableName, namespaceVariableName, interop, importPath, externalLiveBindings, getPropertyAccess);
          if (exportBlock)
            exportBlock += n2;
          if (specifier.imported !== "*" && specifier.needsLiveBinding) {
            const [left3, right3] = getDirectReturnFunction([], {
              functionReturn: true,
              lineBreakIndent: null,
              name: null
            });
            exportBlock += `Object.defineProperty(exports,${_2}${JSON.stringify(specifier.reexported)},${_2}{${n2}${t}enumerable:${_2}true,${n2}${t}get:${_2}${left3}${importName}${right3}${n2}});`;
          } else if (specifier.reexported === "__proto__") {
            exportBlock += `Object.defineProperty(exports,${_2}"__proto__",${_2}{${n2}${t}enumerable:${_2}true,${n2}${t}value:${_2}${importName}${n2}});`;
          } else {
            exportBlock += `exports${getPropertyAccess(specifier.reexported)}${_2}=${_2}${importName};`;
          }
        }
      }
    }
  }
  for (const { exported, local } of exports) {
    const lhs = `exports${getPropertyAccess(exported)}`;
    const rhs = local;
    if (lhs !== rhs) {
      if (exportBlock)
        exportBlock += n2;
      exportBlock += exported === "__proto__" ? `Object.defineProperty(exports,${_2}"__proto__",${_2}{${n2}${t}enumerable:${_2}true,${n2}${t}value:${_2}${rhs}${n2}});` : `${lhs}${_2}=${_2}${rhs};`;
    }
  }
  if (namedExportsMode) {
    for (const { name, reexports } of dependencies) {
      if (!reexports) {
        continue;
      }
      for (const specifier of reexports) {
        if (specifier.reexported === "*") {
          if (exportBlock)
            exportBlock += n2;
          if (!specifier.needsLiveBinding && reexportProtoFromExternal) {
            const protoString = "'__proto__'";
            exportBlock += `Object.prototype.hasOwnProperty.call(${name},${_2}${protoString})${_2}&&${n2}${t}!Object.prototype.hasOwnProperty.call(exports,${_2}${protoString})${_2}&&${n2}${t}Object.defineProperty(exports,${_2}${protoString},${_2}{${n2}${t}${t}enumerable:${_2}true,${n2}${t}${t}value:${_2}${name}[${protoString}]${n2}${t}});${n2}${n2}`;
          }
          const copyPropertyIfNecessary = `{${n2}${t}if${_2}(k${_2}!==${_2}'default'${_2}&&${_2}!Object.prototype.hasOwnProperty.call(exports,${_2}k))${_2}${getDefineProperty(name, specifier.needsLiveBinding, t, snippets)}${s2}${n2}}`;
          exportBlock += `Object.keys(${name}).forEach(${getFunctionIntro(["k"], {
            isAsync: false,
            name: null
          })}${copyPropertyIfNecessary});`;
        }
      }
    }
  }
  if (exportBlock) {
    return `${n2}${n2}${exportBlock}`;
  }
  return "";
}
function getSingleDefaultExport(exports, dependencies, interop, externalLiveBindings, getPropertyAccess) {
  if (exports.length > 0) {
    return exports[0].local;
  } else {
    for (const { defaultVariableName, importPath, isChunk: isChunk2, name, namedExportsMode: depNamedExportsMode, namespaceVariableName, reexports } of dependencies) {
      if (reexports) {
        return getReexportedImportName(name, reexports[0].imported, depNamedExportsMode, isChunk2, defaultVariableName, namespaceVariableName, interop, importPath, externalLiveBindings, getPropertyAccess);
      }
    }
  }
}
function getReexportedImportName(moduleVariableName, imported, depNamedExportsMode, isChunk2, defaultVariableName, namespaceVariableName, interop, moduleId, externalLiveBindings, getPropertyAccess) {
  if (imported === "default") {
    if (!isChunk2) {
      const moduleInterop = interop(moduleId);
      const variableName = defaultInteropHelpersByInteropType[moduleInterop] ? defaultVariableName : moduleVariableName;
      return isDefaultAProperty(moduleInterop, externalLiveBindings) ? `${variableName}${getPropertyAccess("default")}` : variableName;
    }
    return depNamedExportsMode ? `${moduleVariableName}${getPropertyAccess("default")}` : moduleVariableName;
  }
  if (imported === "*") {
    return (isChunk2 ? !depNamedExportsMode : namespaceInteropHelpersByInteropType[interop(moduleId)]) ? namespaceVariableName : moduleVariableName;
  }
  return `${moduleVariableName}${getPropertyAccess(imported)}`;
}
function getEsModuleValue(getObject) {
  return getObject([["value", "true"]], {
    lineBreakIndent: null
  });
}
function getNamespaceMarkers(hasNamedExports, addEsModule, addNamespaceToStringTag, { _: _2, getObject }) {
  if (hasNamedExports) {
    if (addEsModule) {
      if (addNamespaceToStringTag) {
        return `Object.defineProperties(exports,${_2}${getObject([
          ["__esModule", getEsModuleValue(getObject)],
          [null, `[Symbol.toStringTag]:${_2}${getToStringTagValue(getObject)}`]
        ], {
          lineBreakIndent: null
        })});`;
      }
      return `Object.defineProperty(exports,${_2}'__esModule',${_2}${getEsModuleValue(getObject)});`;
    }
    if (addNamespaceToStringTag) {
      return `Object.defineProperty(exports,${_2}Symbol.toStringTag,${_2}${getToStringTagValue(getObject)});`;
    }
  }
  return "";
}
function getInteropBlock(dependencies, interop, externalLiveBindings, freeze, symbols, accessedGlobals, indent, snippets) {
  const { _: _2, cnst, n: n2 } = snippets;
  const neededInteropHelpers = /* @__PURE__ */ new Set();
  const interopStatements = [];
  const addInteropStatement = (helperVariableName, helper, dependencyVariableName) => {
    neededInteropHelpers.add(helper);
    interopStatements.push(`${cnst} ${helperVariableName}${_2}=${_2}/*#__PURE__*/${helper}(${dependencyVariableName});`);
  };
  for (const { defaultVariableName, imports, importPath, isChunk: isChunk2, name, namedExportsMode, namespaceVariableName, reexports } of dependencies) {
    if (isChunk2) {
      for (const { imported, reexported } of [
        ...imports || [],
        ...reexports || []
      ]) {
        if (imported === "*" && reexported !== "*") {
          if (!namedExportsMode) {
            addInteropStatement(namespaceVariableName, INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE, name);
          }
          break;
        }
      }
    } else {
      const moduleInterop = interop(importPath);
      let hasDefault = false;
      let hasNamespace = false;
      for (const { imported, reexported } of [
        ...imports || [],
        ...reexports || []
      ]) {
        let helper;
        let variableName;
        if (imported === "default") {
          if (!hasDefault) {
            hasDefault = true;
            if (defaultVariableName !== namespaceVariableName) {
              variableName = defaultVariableName;
              helper = defaultInteropHelpersByInteropType[moduleInterop];
            }
          }
        } else if (imported === "*" && reexported !== "*" && !hasNamespace) {
          hasNamespace = true;
          helper = namespaceInteropHelpersByInteropType[moduleInterop];
          variableName = namespaceVariableName;
        }
        if (helper) {
          addInteropStatement(variableName, helper, name);
        }
      }
    }
  }
  return `${getHelpersBlock(neededInteropHelpers, accessedGlobals, indent, snippets, externalLiveBindings, freeze, symbols)}${interopStatements.length > 0 ? `${interopStatements.join(n2)}${n2}${n2}` : ""}`;
}
function addJsExtension(name) {
  return name.endsWith(".js") ? name : name + ".js";
}
function updateExtensionForRelativeAmdId(id2, forceJsExtensionForImports) {
  if (id2[0] !== ".") {
    return id2;
  }
  return forceJsExtensionForImports ? addJsExtension(id2) : removeJsExtension(id2);
}
function warnOnBuiltins(log5, dependencies) {
  const externalBuiltins = dependencies.map(({ importPath }) => importPath).filter((importPath) => nodeBuiltins.has(importPath) || importPath.startsWith("node:"));
  if (externalBuiltins.length === 0)
    return;
  log5(LOGLEVEL_WARN, logMissingNodeBuiltins(externalBuiltins));
}
function amd(magicString, { accessedGlobals, dependencies, exports, hasDefaultExport, hasExports, id: id2, indent: t, intro, isEntryFacade, isModuleFacade, namedExportsMode, log: log5, outro, snippets }, { amd: amd2, esModule, externalLiveBindings, freeze, generatedCode: { symbols }, interop, reexportProtoFromExternal, strict }) {
  warnOnBuiltins(log5, dependencies);
  const deps = dependencies.map((m2) => `'${updateExtensionForRelativeAmdId(m2.importPath, amd2.forceJsExtensionForImports)}'`);
  const parameters = dependencies.map((m2) => m2.name);
  const { n: n2, getNonArrowFunctionIntro, _: _2 } = snippets;
  if (namedExportsMode && hasExports) {
    parameters.unshift(`exports`);
    deps.unshift(`'exports'`);
  }
  if (accessedGlobals.has("require")) {
    parameters.unshift("require");
    deps.unshift(`'require'`);
  }
  if (accessedGlobals.has("module")) {
    parameters.unshift("module");
    deps.unshift(`'module'`);
  }
  const completeAmdId = getCompleteAmdId(amd2, id2);
  const defineParameters = (completeAmdId ? `'${completeAmdId}',${_2}` : ``) + (deps.length > 0 ? `[${deps.join(`,${_2}`)}],${_2}` : ``);
  const useStrict = strict ? `${_2}'use strict';` : "";
  magicString.prepend(`${intro}${getInteropBlock(dependencies, interop, externalLiveBindings, freeze, symbols, accessedGlobals, t, snippets)}`);
  const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, reexportProtoFromExternal);
  let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, isEntryFacade && (esModule === true || esModule === "if-default-prop" && hasDefaultExport), isModuleFacade && symbols, snippets);
  if (namespaceMarkers) {
    namespaceMarkers = n2 + n2 + namespaceMarkers;
  }
  magicString.append(`${exportBlock}${namespaceMarkers}${outro}`).indent(t).prepend(`${amd2.define}(${defineParameters}(${getNonArrowFunctionIntro(parameters, {
    isAsync: false,
    name: null
  })}{${useStrict}${n2}${n2}`).append(`${n2}${n2}}));`);
}
function cjs(magicString, { accessedGlobals, dependencies, exports, hasDefaultExport, hasExports, indent: t, intro, isEntryFacade, isModuleFacade, namedExportsMode, outro, snippets }, { compact: compact2, esModule, externalLiveBindings, freeze, interop, generatedCode: { symbols }, reexportProtoFromExternal, strict }) {
  const { _: _2, n: n2 } = snippets;
  const useStrict = strict ? `'use strict';${n2}${n2}` : "";
  let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, isEntryFacade && (esModule === true || esModule === "if-default-prop" && hasDefaultExport), isModuleFacade && symbols, snippets);
  if (namespaceMarkers) {
    namespaceMarkers += n2 + n2;
  }
  const importBlock = getImportBlock$1(dependencies, snippets, compact2);
  const interopBlock = getInteropBlock(dependencies, interop, externalLiveBindings, freeze, symbols, accessedGlobals, t, snippets);
  magicString.prepend(`${useStrict}${intro}${namespaceMarkers}${importBlock}${interopBlock}`);
  const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, reexportProtoFromExternal, `module.exports${_2}=${_2}`);
  magicString.append(`${exportBlock}${outro}`);
}
function getImportBlock$1(dependencies, { _: _2, cnst, n: n2 }, compact2) {
  let importBlock = "";
  let definingVariable = false;
  for (const { importPath, name, reexports, imports } of dependencies) {
    if (!reexports && !imports) {
      if (importBlock) {
        importBlock += compact2 && !definingVariable ? "," : `;${n2}`;
      }
      definingVariable = false;
      importBlock += `require('${importPath}')`;
    } else {
      importBlock += compact2 && definingVariable ? "," : `${importBlock ? `;${n2}` : ""}${cnst} `;
      definingVariable = true;
      importBlock += `${name}${_2}=${_2}require('${importPath}')`;
    }
  }
  if (importBlock) {
    return `${importBlock};${n2}${n2}`;
  }
  return "";
}
function es(magicString, { accessedGlobals, indent: t, intro, outro, dependencies, exports, snippets }, { externalLiveBindings, freeze, generatedCode: { symbols }, importAttributesKey }) {
  const { n: n2 } = snippets;
  const importBlock = getImportBlock(dependencies, importAttributesKey, snippets);
  if (importBlock.length > 0)
    intro += importBlock.join(n2) + n2 + n2;
  intro += getHelpersBlock(null, accessedGlobals, t, snippets, externalLiveBindings, freeze, symbols);
  if (intro)
    magicString.prepend(intro);
  const exportBlock = getExportBlock(exports, snippets);
  if (exportBlock.length > 0)
    magicString.append(n2 + n2 + exportBlock.join(n2).trim());
  if (outro)
    magicString.append(outro);
  magicString.trim();
}
function getImportBlock(dependencies, importAttributesKey, { _: _2 }) {
  const importBlock = [];
  for (const { importPath, reexports, imports, name, attributes } of dependencies) {
    const assertion = attributes ? `${_2}${importAttributesKey}${_2}${attributes}` : "";
    const pathWithAssertion = `'${importPath}'${assertion};`;
    if (!reexports && !imports) {
      importBlock.push(`import${_2}${pathWithAssertion}`);
      continue;
    }
    if (imports) {
      let defaultImport = null;
      let starImport = null;
      const importedNames = [];
      for (const specifier of imports) {
        if (specifier.imported === "default") {
          defaultImport = specifier;
        } else if (specifier.imported === "*") {
          starImport = specifier;
        } else {
          importedNames.push(specifier);
        }
      }
      if (starImport) {
        importBlock.push(`import${_2}*${_2}as ${starImport.local} from${_2}${pathWithAssertion}`);
      }
      if (defaultImport && importedNames.length === 0) {
        importBlock.push(`import ${defaultImport.local} from${_2}${pathWithAssertion}`);
      } else if (importedNames.length > 0) {
        importBlock.push(`import ${defaultImport ? `${defaultImport.local},${_2}` : ""}{${_2}${importedNames.map((specifier) => specifier.imported === specifier.local ? specifier.imported : `${stringifyIdentifierIfNeeded(specifier.imported)} as ${specifier.local}`).join(`,${_2}`)}${_2}}${_2}from${_2}${pathWithAssertion}`);
      }
    }
    if (reexports) {
      let starExport = null;
      const namespaceReexports = [];
      const namedReexports = [];
      for (const specifier of reexports) {
        if (specifier.reexported === "*") {
          starExport = specifier;
        } else if (specifier.imported === "*") {
          namespaceReexports.push(specifier);
        } else {
          namedReexports.push(specifier);
        }
      }
      if (starExport) {
        importBlock.push(`export${_2}*${_2}from${_2}${pathWithAssertion}`);
      }
      if (namespaceReexports.length > 0) {
        if (!imports || !imports.some((specifier) => specifier.imported === "*" && specifier.local === name)) {
          importBlock.push(`import${_2}*${_2}as ${name} from${_2}${pathWithAssertion}`);
        }
        for (const specifier of namespaceReexports) {
          importBlock.push(`export${_2}{${_2}${name === specifier.reexported ? name : `${name} as ${stringifyIdentifierIfNeeded(specifier.reexported)}`} };`);
        }
      }
      if (namedReexports.length > 0) {
        importBlock.push(`export${_2}{${_2}${namedReexports.map((specifier) => specifier.imported === specifier.reexported ? stringifyIdentifierIfNeeded(specifier.imported) : `${stringifyIdentifierIfNeeded(specifier.imported)} as ${stringifyIdentifierIfNeeded(specifier.reexported)}`).join(`,${_2}`)}${_2}}${_2}from${_2}${pathWithAssertion}`);
      }
    }
  }
  return importBlock;
}
function getExportBlock(exports, { _: _2, cnst }) {
  const exportBlock = [];
  const exportDeclaration = new Array(exports.length);
  let index = 0;
  for (const specifier of exports) {
    if (specifier.expression) {
      exportBlock.push(`${cnst} ${specifier.local}${_2}=${_2}${specifier.expression};`);
    }
    exportDeclaration[index++] = specifier.exported === specifier.local ? specifier.local : `${specifier.local} as ${stringifyIdentifierIfNeeded(specifier.exported)}`;
  }
  if (exportDeclaration.length > 0) {
    exportBlock.push(`export${_2}{${_2}${exportDeclaration.join(`,${_2}`)}${_2}};`);
  }
  return exportBlock;
}
function setupNamespace(name, root, globals, { _: _2, getPropertyAccess, s: s2 }, compact2, log5) {
  const parts2 = name.split(".");
  const isReserved = parts2[0] in Object.prototype;
  if (log5 && isReserved) {
    log5(LOGLEVEL_WARN, logReservedNamespace(parts2[0]));
  }
  parts2[0] = (typeof globals === "function" ? globals(parts2[0]) : isReserved ? parts2[0] : globals[parts2[0]]) || parts2[0];
  parts2.pop();
  let propertyPath = root;
  return parts2.map((part) => {
    propertyPath += getPropertyAccess(part);
    return `${propertyPath}${_2}=${_2}${propertyPath}${_2}||${_2}{}${s2}`;
  }).join(compact2 ? "," : "\n") + (compact2 && parts2.length > 0 ? ";" : "\n");
}
function assignToDeepVariable(deepName, root, globals, assignment, { _: _2, getPropertyAccess }, log5) {
  const parts2 = deepName.split(".");
  const isReserved = parts2[0] in Object.prototype;
  if (log5 && isReserved) {
    log5(LOGLEVEL_WARN, logReservedNamespace(parts2[0]));
  }
  parts2[0] = (typeof globals === "function" ? globals(parts2[0]) : isReserved ? parts2[0] : globals[parts2[0]]) || parts2[0];
  const last6 = parts2.pop();
  let propertyPath = root;
  let deepAssignment = [
    ...parts2.map((part) => {
      propertyPath += getPropertyAccess(part);
      return `${propertyPath}${_2}=${_2}${propertyPath}${_2}||${_2}{}`;
    }),
    `${propertyPath}${getPropertyAccess(last6)}`
  ].join(`,${_2}`) + `${_2}=${_2}${assignment}`;
  if (parts2.length > 0) {
    deepAssignment = `(${deepAssignment})`;
  }
  return deepAssignment;
}
function trimEmptyImports(dependencies) {
  let index = dependencies.length;
  while (index--) {
    const { imports, reexports } = dependencies[index];
    if (imports || reexports) {
      return dependencies.slice(0, index + 1);
    }
  }
  return [];
}
function iife(magicString, { accessedGlobals, dependencies, exports, hasDefaultExport, hasExports, indent: t, intro, namedExportsMode, log: log5, outro, snippets }, { compact: compact2, esModule, extend: extend3, freeze, externalLiveBindings, reexportProtoFromExternal, globals, interop, name, generatedCode: { symbols }, strict }) {
  const { _: _2, getNonArrowFunctionIntro, getPropertyAccess, n: n2 } = snippets;
  const isNamespaced = name && name.includes(".");
  const useVariableAssignment = !extend3 && !isNamespaced;
  if (name && useVariableAssignment && !isLegal(name)) {
    return error3(logIllegalIdentifierAsName(name));
  }
  warnOnBuiltins(log5, dependencies);
  const external = trimEmptyImports(dependencies);
  const deps = external.map((dep) => dep.globalName || "null");
  const parameters = external.map((m2) => m2.name);
  if (hasExports && !name) {
    log5(LOGLEVEL_WARN, logMissingNameOptionForIifeExport());
  }
  if (namedExportsMode && hasExports) {
    if (extend3) {
      deps.unshift(`this${keypath(name, getPropertyAccess)}${_2}=${_2}this${keypath(name, getPropertyAccess)}${_2}||${_2}{}`);
      parameters.unshift("exports");
    } else {
      deps.unshift("{}");
      parameters.unshift("exports");
    }
  }
  const useStrict = strict ? `${t}'use strict';${n2}` : "";
  const interopBlock = getInteropBlock(dependencies, interop, externalLiveBindings, freeze, symbols, accessedGlobals, t, snippets);
  magicString.prepend(`${intro}${interopBlock}`);
  let wrapperIntro = `(${getNonArrowFunctionIntro(parameters, {
    isAsync: false,
    name: null
  })}{${n2}${useStrict}${n2}`;
  if (hasExports) {
    if (name && !(extend3 && namedExportsMode)) {
      wrapperIntro = (useVariableAssignment ? `var ${name}` : `this${keypath(name, getPropertyAccess)}`) + `${_2}=${_2}${wrapperIntro}`;
    }
    if (isNamespaced) {
      wrapperIntro = setupNamespace(name, "this", globals, snippets, compact2, log5) + wrapperIntro;
    }
  }
  let wrapperOutro = `${n2}${n2}})(${deps.join(`,${_2}`)});`;
  if (hasExports && !extend3 && namedExportsMode) {
    wrapperOutro = `${n2}${n2}${t}return exports;${wrapperOutro}`;
  }
  const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, reexportProtoFromExternal);
  let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, esModule === true || esModule === "if-default-prop" && hasDefaultExport, symbols, snippets);
  if (namespaceMarkers) {
    namespaceMarkers = n2 + n2 + namespaceMarkers;
  }
  magicString.append(`${exportBlock}${namespaceMarkers}${outro}`).indent(t).prepend(wrapperIntro).append(wrapperOutro);
}
function system(magicString, { accessedGlobals, dependencies, exports, hasExports, indent: t, intro, snippets, outro, usesTopLevelAwait }, { externalLiveBindings, freeze, name, generatedCode: { symbols }, strict, systemNullSetters }) {
  const { _: _2, getFunctionIntro, getNonArrowFunctionIntro, n: n2, s: s2 } = snippets;
  const { importBindings, setters, starExcludes } = analyzeDependencies(dependencies, exports, t, snippets);
  const registeredName = name ? `'${name}',${_2}` : "";
  const wrapperParameters = accessedGlobals.has("module") ? ["exports", "module"] : hasExports ? ["exports"] : [];
  let wrapperStart = `System.register(${registeredName}[` + dependencies.map(({ importPath }) => `'${importPath}'`).join(`,${_2}`) + `],${_2}(${getNonArrowFunctionIntro(wrapperParameters, {
    isAsync: false,
    name: null
  })}{${n2}${t}${strict ? "'use strict';" : ""}` + getStarExcludesBlock(starExcludes, t, snippets) + getImportBindingsBlock(importBindings, t, snippets) + `${n2}${t}return${_2}{${setters.length > 0 ? `${n2}${t}${t}setters:${_2}[${setters.map((setter) => setter ? `${getFunctionIntro(["module"], {
    isAsync: false,
    name: null
  })}{${n2}${t}${t}${t}${setter}${n2}${t}${t}}` : systemNullSetters ? `null` : `${getFunctionIntro([], { isAsync: false, name: null })}{}`).join(`,${_2}`)}],` : ""}${n2}`;
  wrapperStart += `${t}${t}execute:${_2}(${getNonArrowFunctionIntro([], {
    isAsync: usesTopLevelAwait,
    name: null
  })}{${n2}${n2}`;
  const wrapperEnd = `${t}${t}})${n2}${t}}${s2}${n2}}));`;
  magicString.prepend(intro + getHelpersBlock(null, accessedGlobals, t, snippets, externalLiveBindings, freeze, symbols) + getHoistedExportsBlock(exports, t, snippets)).append(`${outro}${n2}${n2}` + getSyntheticExportsBlock(exports, t, snippets) + getMissingExportsBlock(exports, t, snippets)).indent(`${t}${t}${t}`).append(wrapperEnd).prepend(wrapperStart);
}
function analyzeDependencies(dependencies, exports, t, { _: _2, cnst, getObject, getPropertyAccess, n: n2 }) {
  const importBindings = [];
  const setters = [];
  let starExcludes = null;
  for (const { imports, reexports } of dependencies) {
    const setter = [];
    if (imports) {
      for (const specifier of imports) {
        importBindings.push(specifier.local);
        if (specifier.imported === "*") {
          setter.push(`${specifier.local}${_2}=${_2}module;`);
        } else {
          setter.push(`${specifier.local}${_2}=${_2}module${getPropertyAccess(specifier.imported)};`);
        }
      }
    }
    if (reexports) {
      const reexportedNames = [];
      let hasStarReexport = false;
      for (const { imported, reexported } of reexports) {
        if (reexported === "*") {
          hasStarReexport = true;
        } else {
          reexportedNames.push([
            reexported,
            imported === "*" ? "module" : `module${getPropertyAccess(imported)}`
          ]);
        }
      }
      if (reexportedNames.length > 1 || hasStarReexport) {
        if (hasStarReexport) {
          if (!starExcludes) {
            starExcludes = getStarExcludes({ dependencies, exports });
          }
          reexportedNames.unshift([null, `__proto__:${_2}null`]);
          const exportMapping = getObject(reexportedNames, { lineBreakIndent: null });
          setter.push(`${cnst} setter${_2}=${_2}${exportMapping};`, `for${_2}(${cnst} name in module)${_2}{`, `${t}if${_2}(!_starExcludes[name])${_2}setter[name]${_2}=${_2}module[name];`, "}", "exports(setter);");
        } else {
          const exportMapping = getObject(reexportedNames, { lineBreakIndent: null });
          setter.push(`exports(${exportMapping});`);
        }
      } else {
        const [key, value] = reexportedNames[0];
        setter.push(`exports(${JSON.stringify(key)},${_2}${value});`);
      }
    }
    setters.push(setter.join(`${n2}${t}${t}${t}`));
  }
  return { importBindings, setters, starExcludes };
}
function getExportsBlock(exports, t, { _: _2, n: n2 }) {
  if (exports.length === 0) {
    return "";
  }
  if (exports.length === 1) {
    return `exports(${JSON.stringify(exports[0].name)},${_2}${exports[0].value});${n2}${n2}`;
  }
  return `exports({${n2}` + exports.map(({ name, value }) => `${t}${stringifyObjectKeyIfNeeded(name)}:${_2}${value}`).join(`,${n2}`) + `${n2}});${n2}${n2}`;
}
function globalProperty(name, globalVariable, getPropertyAccess) {
  if (!name)
    return "null";
  return `${globalVariable}${keypath(name, getPropertyAccess)}`;
}
function safeAccess(name, globalVariable, { _: _2, getPropertyAccess }) {
  let propertyPath = globalVariable;
  return name.split(".").map((part) => propertyPath += getPropertyAccess(part)).join(`${_2}&&${_2}`);
}
function umd(magicString, { accessedGlobals, dependencies, exports, hasDefaultExport, hasExports, id: id2, indent: t, intro, namedExportsMode, log: log5, outro, snippets }, { amd: amd2, compact: compact2, esModule, extend: extend3, externalLiveBindings, freeze, interop, name, generatedCode: { symbols }, globals, noConflict, reexportProtoFromExternal, strict }) {
  const { _: _2, cnst, getFunctionIntro, getNonArrowFunctionIntro, getPropertyAccess, n: n2, s: s2 } = snippets;
  const factoryVariable = compact2 ? "f" : "factory";
  const globalVariable = compact2 ? "g" : "global";
  if (hasExports && !name) {
    return error3(logMissingNameOptionForUmdExport());
  }
  warnOnBuiltins(log5, dependencies);
  const amdDeps = dependencies.map((m2) => `'${updateExtensionForRelativeAmdId(m2.importPath, amd2.forceJsExtensionForImports)}'`);
  const cjsDeps = dependencies.map((m2) => `require('${m2.importPath}')`);
  const trimmedImports = trimEmptyImports(dependencies);
  const globalDeps = trimmedImports.map((module) => globalProperty(module.globalName, globalVariable, getPropertyAccess));
  const factoryParameters = trimmedImports.map((m2) => m2.name);
  if (namedExportsMode && (hasExports || noConflict)) {
    amdDeps.unshift(`'exports'`);
    cjsDeps.unshift(`exports`);
    globalDeps.unshift(assignToDeepVariable(name, globalVariable, globals, `${extend3 ? `${globalProperty(name, globalVariable, getPropertyAccess)}${_2}||${_2}` : ""}{}`, snippets, log5));
    factoryParameters.unshift("exports");
  }
  const completeAmdId = getCompleteAmdId(amd2, id2);
  const amdParameters = (completeAmdId ? `'${completeAmdId}',${_2}` : ``) + (amdDeps.length > 0 ? `[${amdDeps.join(`,${_2}`)}],${_2}` : ``);
  const define = amd2.define;
  const cjsExport = !namedExportsMode && hasExports ? `module.exports${_2}=${_2}` : ``;
  const useStrict = strict ? `${_2}'use strict';${n2}` : ``;
  let iifeExport;
  if (noConflict) {
    const noConflictExportsVariable = compact2 ? "e" : "exports";
    let factory;
    if (!namedExportsMode && hasExports) {
      factory = `${cnst} ${noConflictExportsVariable}${_2}=${_2}${assignToDeepVariable(name, globalVariable, globals, `${factoryVariable}(${globalDeps.join(`,${_2}`)})`, snippets, log5)};`;
    } else {
      const module = globalDeps.shift();
      factory = `${cnst} ${noConflictExportsVariable}${_2}=${_2}${module};${n2}${t}${t}${factoryVariable}(${[noConflictExportsVariable, ...globalDeps].join(`,${_2}`)});`;
    }
    iifeExport = `(${getFunctionIntro([], { isAsync: false, name: null })}{${n2}${t}${t}${cnst} current${_2}=${_2}${safeAccess(name, globalVariable, snippets)};${n2}${t}${t}${factory}${n2}${t}${t}${noConflictExportsVariable}.noConflict${_2}=${_2}${getFunctionIntro([], {
      isAsync: false,
      name: null
    })}{${_2}${globalProperty(name, globalVariable, getPropertyAccess)}${_2}=${_2}current;${_2}return ${noConflictExportsVariable}${s2}${_2}};${n2}${t}})()`;
  } else {
    iifeExport = `${factoryVariable}(${globalDeps.join(`,${_2}`)})`;
    if (!namedExportsMode && hasExports) {
      iifeExport = assignToDeepVariable(name, globalVariable, globals, iifeExport, snippets, log5);
    }
  }
  const iifeNeedsGlobal = hasExports || noConflict && namedExportsMode || globalDeps.length > 0;
  const wrapperParameters = [factoryVariable];
  if (iifeNeedsGlobal) {
    wrapperParameters.unshift(globalVariable);
  }
  const globalArgument = iifeNeedsGlobal ? `this,${_2}` : "";
  const iifeStart = iifeNeedsGlobal ? `(${globalVariable}${_2}=${_2}typeof globalThis${_2}!==${_2}'undefined'${_2}?${_2}globalThis${_2}:${_2}${globalVariable}${_2}||${_2}self,${_2}` : "";
  const iifeEnd = iifeNeedsGlobal ? ")" : "";
  const cjsIntro = iifeNeedsGlobal ? `${t}typeof exports${_2}===${_2}'object'${_2}&&${_2}typeof module${_2}!==${_2}'undefined'${_2}?${_2}${cjsExport}${factoryVariable}(${cjsDeps.join(`,${_2}`)})${_2}:${n2}` : "";
  const wrapperIntro = `(${getNonArrowFunctionIntro(wrapperParameters, { isAsync: false, name: null })}{${n2}` + cjsIntro + `${t}typeof ${define}${_2}===${_2}'function'${_2}&&${_2}${define}.amd${_2}?${_2}${define}(${amdParameters}${factoryVariable})${_2}:${n2}${t}${iifeStart}${iifeExport}${iifeEnd};${n2}})(${globalArgument}(${getNonArrowFunctionIntro(factoryParameters, {
    isAsync: false,
    name: null
  })}{${useStrict}${n2}`;
  const wrapperOutro = n2 + n2 + "}));";
  magicString.prepend(`${intro}${getInteropBlock(dependencies, interop, externalLiveBindings, freeze, symbols, accessedGlobals, t, snippets)}`);
  const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, reexportProtoFromExternal);
  let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, esModule === true || esModule === "if-default-prop" && hasDefaultExport, symbols, snippets);
  if (namespaceMarkers) {
    namespaceMarkers = n2 + n2 + namespaceMarkers;
  }
  magicString.append(`${exportBlock}${namespaceMarkers}${outro}`).trim().indent(t).append(wrapperOutro).prepend(wrapperIntro);
}
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function renderCallArguments(code, options, node) {
  if (node.arguments.length > 0) {
    if (node.arguments[node.arguments.length - 1].included) {
      for (const argument of node.arguments) {
        argument.render(code, options);
      }
    } else {
      let lastIncludedIndex = node.arguments.length - 2;
      while (lastIncludedIndex >= 0 && !node.arguments[lastIncludedIndex].included) {
        lastIncludedIndex--;
      }
      if (lastIncludedIndex >= 0) {
        for (let index = 0; index <= lastIncludedIndex; index++) {
          node.arguments[index].render(code, options);
        }
        code.remove(findFirstOccurrenceOutsideComment(code.original, ",", node.arguments[lastIncludedIndex].end), node.end - 1);
      } else {
        code.remove(findFirstOccurrenceOutsideComment(code.original, "(", node.callee.end) + 1, node.end - 1);
      }
    }
  }
}
function tryCastLiteralValueToBoolean(literalValue) {
  if (typeof literalValue === "symbol") {
    if (literalValue === UnknownFalsyValue) {
      return false;
    }
    if (literalValue === UnknownTruthyValue) {
      return true;
    }
    return UnknownValue;
  }
  return !!literalValue;
}
function hasLoopBodyEffects(context8, body) {
  const { brokenFlow, hasBreak, hasContinue, ignore: ignore3 } = context8;
  const { breaks, continues } = ignore3;
  ignore3.breaks = true;
  ignore3.continues = true;
  context8.hasBreak = false;
  context8.hasContinue = false;
  if (body.hasEffects(context8))
    return true;
  ignore3.breaks = breaks;
  ignore3.continues = continues;
  context8.hasBreak = hasBreak;
  context8.hasContinue = hasContinue;
  context8.brokenFlow = brokenFlow;
  return false;
}
function includeLoopBody(context8, body, includeChildrenRecursively) {
  const { brokenFlow, hasBreak, hasContinue } = context8;
  context8.hasBreak = false;
  context8.hasContinue = false;
  body.include(context8, includeChildrenRecursively, { asSingleStatement: true });
  context8.hasBreak = hasBreak;
  context8.hasContinue = hasContinue;
  context8.brokenFlow = brokenFlow;
}
function isReassignedExportsMember(variable, exportNamesByVariable) {
  return variable.renderBaseName !== null && exportNamesByVariable.has(variable) && variable.isReassigned;
}
function getChunkInfoWithPath(chunk5) {
  return { fileName: chunk5.getFileName(), ...chunk5.getPreRenderedChunkInfo() };
}
function getInteropHelper(resolution, exportMode, interop) {
  return exportMode === "external" ? namespaceInteropHelpersByInteropType[interop(resolution instanceof ExternalModule ? resolution.id : null)] : exportMode === "default" ? INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE : null;
}
function getDeterministicObjectDestructure(objectPattern3) {
  const variables = [];
  for (const property3 of objectPattern3.properties) {
    if (property3.type === "RestElement" || property3.computed || property3.key.type !== "Identifier")
      return;
    variables.push(property3.key.name);
  }
  return variables;
}
function getRenderedJsxChildren(children2) {
  let renderedChildren = 0;
  for (const child of children2) {
    if (!(child instanceof JSXExpressionContainer && child.expression instanceof JSXEmptyExpression)) {
      renderedChildren++;
    }
  }
  return renderedChildren;
}
function getAndIncludeFactoryVariable(factory, preserve, importSource, node, context8) {
  const [baseName, nestedName] = factory.split(".");
  let factoryVariable;
  if (importSource) {
    factoryVariable = node.scope.context.getImportedJsxFactoryVariable(nestedName ? "default" : baseName, node.start, importSource);
    if (preserve) {
      const globalVariable = node.scope.findGlobal(baseName);
      globalVariable.includePath(UNKNOWN_PATH, context8);
      factoryVariable.globalName = baseName;
    }
  } else {
    factoryVariable = node.scope.findGlobal(baseName);
  }
  node.scope.context.includeVariableInModule(factoryVariable, UNKNOWN_PATH, context8);
  if (factoryVariable instanceof LocalVariable) {
    factoryVariable.consolidateInitializers();
    factoryVariable.addUsedPlace(node);
    node.scope.context.requestTreeshakingPass();
  }
  return factoryVariable;
}
function findFunctionScope(scope5, thisVariable) {
  while (!(scope5 instanceof FunctionScope && scope5.thisVariable === thisVariable)) {
    if (!(scope5 instanceof ChildScope)) {
      return null;
    }
    scope5 = scope5.parent;
  }
  return scope5;
}
function getRenderedLiteralValue(value) {
  if (value === void 0) {
    return "void 0";
  }
  if (typeof value === "boolean") {
    return String(value);
  }
  if (typeof value === "string") {
    return JSON.stringify(value);
  }
  if (typeof value === "number") {
    return getSimplifiedNumber(value);
  }
  return UnknownValue;
}
function getSimplifiedNumber(value) {
  if (Object.is(-0, value)) {
    return "-0";
  }
  const exp = value.toExponential();
  const [base2, exponent] = exp.split("e");
  const floatLength = base2.split(".")[1]?.length || 0;
  const finalizedExp = `${base2.replace(".", "")}e${parseInt(exponent) - floatLength}`;
  const stringifiedValue = String(value).replace("+", "");
  return finalizedExp.length < stringifiedValue.length ? finalizedExp : stringifiedValue;
}
function areAllDeclarationsIncludedAndNotExported(declarations, exportNamesByVariable) {
  for (const declarator of declarations) {
    if (!declarator.id.included)
      return false;
    if (declarator.id.type === Identifier) {
      if (exportNamesByVariable.has(declarator.id.variable))
        return false;
    } else {
      const exportedVariables = [];
      declarator.id.addExportedVariables(exportedVariables, exportNamesByVariable);
      if (exportedVariables.length > 0)
        return false;
    }
  }
  return true;
}
function gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports) {
  let singleSystemExport = null;
  if (options.format === "system") {
    for (const { node } of separatedNodes) {
      if (node.id instanceof Identifier2 && node.init && aggregatedSystemExports.length === 0 && options.exportNamesByVariable.get(node.id.variable)?.length === 1) {
        singleSystemExport = node.id.variable;
        aggregatedSystemExports.push(singleSystemExport);
      } else {
        node.id.addExportedVariables(aggregatedSystemExports, options.exportNamesByVariable);
      }
    }
    if (aggregatedSystemExports.length > 1) {
      singleSystemExport = null;
    } else if (singleSystemExport) {
      aggregatedSystemExports.length = 0;
    }
  }
  return singleSystemExport;
}
function convertProgram2(buffer4, parent, parentScope) {
  return convertNode2(parent, parentScope, 0, getAstBuffer(buffer4));
}
function convertNode2(parent, parentScope, position, buffer4) {
  const nodeType = buffer4[position];
  const NodeConstructor = nodeConstructors$1[nodeType];
  if (!NodeConstructor) {
    console.trace();
    throw new Error(`Unknown node type: ${nodeType}`);
  }
  const node = new NodeConstructor(parent, parentScope);
  node.type = nodeTypeStrings[nodeType];
  node.start = buffer4[position + 1];
  node.end = buffer4[position + 2];
  bufferParsers[nodeType](node, position + 3, buffer4);
  node.initialise();
  return node;
}
function convertNodeList2(parent, parentScope, position, buffer4) {
  if (position === 0)
    return EMPTY_ARRAY;
  const length3 = buffer4[position++];
  const list = new Array(length3);
  for (let index = 0; index < length3; index++) {
    const nodePosition = buffer4[position++];
    list[index] = nodePosition ? convertNode2(parent, parentScope, nodePosition, buffer4) : null;
  }
  return list;
}
function resetCacheToEncoded(cache3) {
  if (cache3.encodedMappings === void 0 && cache3.decodedMappings) {
    cache3.encodedMappings = encode2(cache3.decodedMappings);
  }
  cache3.decodedMappings = void 0;
}
function resetSourcemapCache(map26, sourcemapChain) {
  if (map26) {
    const cache3 = sourceMapCache.get(map26);
    if (cache3) {
      resetCacheToEncoded(cache3);
    }
  }
  if (!sourcemapChain) {
    return;
  }
  for (const map27 of sourcemapChain) {
    if (map27.missing)
      continue;
    resetSourcemapCache(map27);
  }
}
function decodedSourcemap(map26) {
  if (!map26)
    return null;
  if (typeof map26 === "string") {
    map26 = JSON.parse(map26);
  }
  if (!map26.mappings) {
    return {
      mappings: [],
      names: [],
      sources: [],
      version: 3
    };
  }
  const originalMappings = map26.mappings;
  const isAlreadyDecoded = Array.isArray(originalMappings);
  const cache3 = {
    decodedMappings: isAlreadyDecoded ? originalMappings : void 0,
    encodedMappings: isAlreadyDecoded ? void 0 : originalMappings
  };
  const decodedMap = {
    ...map26,
    // By moving mappings behind an accessor, we can avoid unneeded computation for cases
    // where the mappings field is never actually accessed. This appears to greatly reduce
    // the overhead of sourcemap decoding in terms of both compute time and memory usage.
    get mappings() {
      if (cache3.decodedMappings) {
        return cache3.decodedMappings;
      }
      cache3.decodedMappings = cache3.encodedMappings ? decode3(cache3.encodedMappings) : [];
      cache3.encodedMappings = void 0;
      return cache3.decodedMappings;
    }
  };
  sourceMapCache.set(decodedMap, cache3);
  return decodedMap;
}
function getId(m2) {
  return m2.id;
}
function getOriginalLocation(sourcemapChain, location) {
  const filteredSourcemapChain = sourcemapChain.filter((sourcemap) => !sourcemap.missing);
  traceSourcemap: while (filteredSourcemapChain.length > 0) {
    const sourcemap = filteredSourcemapChain.pop();
    const line = sourcemap.mappings[location.line - 1];
    if (line) {
      const filteredLine = line.filter((segment) => segment.length > 1);
      const lastSegment = filteredLine[filteredLine.length - 1];
      for (const segment of filteredLine) {
        if (segment[0] >= location.column || segment === lastSegment) {
          location = {
            column: segment[3],
            line: segment[2] + 1
          };
          continue traceSourcemap;
        }
      }
    }
    throw new Error("Can't resolve original location of error.");
  }
  return location;
}
function getAttributesFromImportExpression(node) {
  const { scope: { context: context8 }, options, start: start3 } = node;
  if (!(options instanceof ObjectExpression2)) {
    if (options) {
      context8.module.log(LOGLEVEL_WARN, logImportAttributeIsInvalid(context8.module.id), start3);
    }
    return EMPTY_OBJECT;
  }
  const assertProperty = options.properties.find((property3) => ATTRIBUTE_KEYWORDS.has(getPropertyKey(property3)))?.value;
  if (!assertProperty) {
    return EMPTY_OBJECT;
  }
  if (!(assertProperty instanceof ObjectExpression2)) {
    context8.module.log(LOGLEVEL_WARN, logImportOptionsAreInvalid(context8.module.id), start3);
    return EMPTY_OBJECT;
  }
  const assertFields = assertProperty.properties.map((property3) => {
    const key = getPropertyKey(property3);
    if (typeof key === "string" && typeof property3.value.value === "string") {
      return [key, property3.value.value];
    }
    context8.module.log(LOGLEVEL_WARN, logImportAttributeIsInvalid(context8.module.id), property3.start);
    return null;
  }).filter((property3) => !!property3);
  if (assertFields.length > 0) {
    return Object.fromEntries(assertFields);
  }
  return EMPTY_OBJECT;
}
function getAttributesFromImportExportDeclaration(attributes) {
  return attributes?.length ? Object.fromEntries(attributes.map((assertion) => [getPropertyKey(assertion), assertion.value.value])) : EMPTY_OBJECT;
}
function doAttributesDiffer(assertionA, assertionB) {
  const keysA = Object.keys(assertionA);
  return keysA.length !== Object.keys(assertionB).length || keysA.some((key) => assertionA[key] !== assertionB[key]);
}
function getPersistedLabel(label, level) {
  switch (level) {
    case 1: {
      return `# ${label}`;
    }
    case 2: {
      return `## ${label}`;
    }
    case 3: {
      return label;
    }
    default: {
      return `- ${label}`;
    }
  }
}
function timeStartImpl(label, level = 3) {
  label = getPersistedLabel(label, level);
  const startMemory = process$1__default.default.memoryUsage().heapUsed;
  const startTime = perf_hooks.performance.now();
  const timer = timers.get(label);
  if (timer === void 0) {
    timers.set(label, {
      memory: 0,
      startMemory,
      startTime,
      time: 0,
      totalMemory: 0
    });
  } else {
    timer.startMemory = startMemory;
    timer.startTime = startTime;
  }
}
function timeEndImpl(label, level = 3) {
  label = getPersistedLabel(label, level);
  const timer = timers.get(label);
  if (timer !== void 0) {
    const currentMemory = process$1__default.default.memoryUsage().heapUsed;
    timer.memory += currentMemory - timer.startMemory;
    timer.time += perf_hooks.performance.now() - timer.startTime;
    timer.totalMemory = Math.max(timer.totalMemory, currentMemory);
  }
}
function getTimings() {
  const newTimings = {};
  for (const [label, { memory, time: time3, totalMemory }] of timers) {
    newTimings[label] = [time3, memory, totalMemory];
  }
  return newTimings;
}
function getPluginWithTimers(plugin, index) {
  if (plugin._hasTimer)
    return plugin;
  plugin._hasTimer = true;
  for (const hook of TIMED_PLUGIN_HOOKS) {
    if (hook in plugin) {
      let timerLabel = `plugin ${index}`;
      if (plugin.name) {
        timerLabel += ` (${plugin.name})`;
      }
      timerLabel += ` - ${hook}`;
      const handler = function(...parameters) {
        timeStart(timerLabel, 4);
        const result = hookFunction.apply(this, parameters);
        timeEnd(timerLabel, 4);
        return result;
      };
      let hookFunction;
      if (typeof plugin[hook].handler === "function") {
        hookFunction = plugin[hook].handler;
        plugin[hook].handler = handler;
      } else {
        hookFunction = plugin[hook];
        plugin[hook] = handler;
      }
    }
  }
  return plugin;
}
function initialiseTimers(inputOptions) {
  if (inputOptions.perf) {
    timers = /* @__PURE__ */ new Map();
    timeStart = timeStartImpl;
    timeEnd = timeEndImpl;
    inputOptions.plugins = inputOptions.plugins.map(getPluginWithTimers);
  } else {
    timeStart = doNothing;
    timeEnd = doNothing;
  }
}
function getVariableForExportNameRecursive(target, name, importerForSideEffects, isExportAllSearch, searchedNamesAndModules = /* @__PURE__ */ new Map()) {
  const searchedModules = searchedNamesAndModules.get(name);
  if (searchedModules) {
    if (searchedModules.has(target)) {
      return isExportAllSearch ? [null] : error3(logCircularReexport(name, target.id));
    }
    searchedModules.add(target);
  } else {
    searchedNamesAndModules.set(name, /* @__PURE__ */ new Set([target]));
  }
  return target.getVariableForExportName(name, {
    importerForSideEffects,
    isExportAllSearch,
    searchedNamesAndModules
  });
}
function getAndExtendSideEffectModules(variable, module) {
  const sideEffectModules = getOrCreate(module.sideEffectDependenciesByVariable, variable, getNewSet);
  let currentVariable = variable;
  const referencedVariables = /* @__PURE__ */ new Set([currentVariable]);
  while (true) {
    const importingModule = currentVariable.module;
    currentVariable = currentVariable instanceof ExportDefaultVariable ? currentVariable.getDirectOriginalVariable() : currentVariable instanceof SyntheticNamedExportVariable ? currentVariable.syntheticNamespace : null;
    if (!currentVariable || referencedVariables.has(currentVariable)) {
      break;
    }
    referencedVariables.add(currentVariable);
    sideEffectModules.add(importingModule);
    const originalSideEffects = importingModule.sideEffectDependenciesByVariable.get(currentVariable);
    if (originalSideEffects) {
      for (const module2 of originalSideEffects) {
        sideEffectModules.add(module2);
      }
    }
  }
  return sideEffectModules;
}
function setAlternativeExporterIfCyclic(variable, importer, reexporter) {
  if (variable.module instanceof Module && variable.module !== reexporter) {
    const exporterCycles = variable.module.cycles;
    if (exporterCycles.size > 0) {
      const importerCycles = reexporter.cycles;
      for (const cycleSymbol of importerCycles) {
        if (exporterCycles.has(cycleSymbol)) {
          importer.alternativeReexportModules.set(variable, reexporter);
          break;
        }
      }
    }
  }
}
async function createAddons(options, outputPluginDriver, chunk5) {
  try {
    let [banner, footer, intro, outro] = await Promise.all([
      outputPluginDriver.hookReduceValue("banner", options.banner(chunk5), [chunk5], concatSeparator),
      outputPluginDriver.hookReduceValue("footer", options.footer(chunk5), [chunk5], concatSeparator),
      outputPluginDriver.hookReduceValue("intro", options.intro(chunk5), [chunk5], concatDblSeparator),
      outputPluginDriver.hookReduceValue("outro", options.outro(chunk5), [chunk5], concatDblSeparator)
    ]);
    if (intro)
      intro += "\n\n";
    if (outro)
      outro = `

${outro}`;
    if (banner)
      banner += "\n";
    if (footer)
      footer = "\n" + footer;
    return { banner, footer, intro, outro };
  } catch (error_) {
    return error3(logAddonNotGenerated(error_.message, error_.hook, error_.plugin));
  }
}
function deconflictChunk(modules, dependenciesToBeDeconflicted, imports, usedNames, format5, interop, preserveModules, externalLiveBindings, chunkByModule, externalChunkByModule, syntheticExports, exportNamesByVariable, accessedGlobalsByScope, includedNamespaces) {
  const reversedModules = [...modules].reverse();
  for (const module of reversedModules) {
    module.scope.addUsedOutsideNames(usedNames, format5, exportNamesByVariable, accessedGlobalsByScope);
  }
  deconflictTopLevelVariables(usedNames, reversedModules, includedNamespaces);
  DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT[format5](usedNames, imports, dependenciesToBeDeconflicted, interop, preserveModules, externalLiveBindings, chunkByModule, externalChunkByModule, syntheticExports);
  for (const module of reversedModules) {
    module.scope.deconflict(format5, exportNamesByVariable, accessedGlobalsByScope);
  }
}
function deconflictImportsEsmOrSystem(usedNames, imports, dependenciesToBeDeconflicted, _interop, preserveModules, _externalLiveBindings, chunkByModule, externalChunkByModule, syntheticExports) {
  for (const dependency of dependenciesToBeDeconflicted.dependencies) {
    if (preserveModules || dependency instanceof ExternalChunk) {
      dependency.variableName = getSafeName(dependency.suggestedVariableName, usedNames, null);
    }
  }
  for (const variable of imports) {
    const module = variable.module;
    const name = variable.name;
    if (variable.isNamespace && (preserveModules || module instanceof ExternalModule)) {
      variable.setRenderNames(null, (module instanceof ExternalModule ? externalChunkByModule.get(module) : chunkByModule.get(module)).variableName);
    } else if (module instanceof ExternalModule && name === "default") {
      variable.setRenderNames(null, getSafeName([...module.exportedVariables].some(([exportedVariable, exportedName]) => exportedName === "*" && exportedVariable.included) ? module.suggestedVariableName + "__default" : module.suggestedVariableName, usedNames, variable.forbiddenNames));
    } else {
      variable.setRenderNames(null, getSafeName(makeLegal(name), usedNames, variable.forbiddenNames));
    }
  }
  for (const variable of syntheticExports) {
    variable.setRenderNames(null, getSafeName(variable.name, usedNames, variable.forbiddenNames));
  }
}
function deconflictImportsOther(usedNames, imports, { deconflictedDefault, deconflictedNamespace, dependencies }, interop, preserveModules, externalLiveBindings, chunkByModule, externalChunkByModule) {
  for (const chunk5 of dependencies) {
    chunk5.variableName = getSafeName(chunk5.suggestedVariableName, usedNames, null);
  }
  for (const chunk5 of deconflictedNamespace) {
    chunk5.namespaceVariableName = getSafeName(`${chunk5.suggestedVariableName}__namespace`, usedNames, null);
  }
  for (const externalModule of deconflictedDefault) {
    externalModule.defaultVariableName = deconflictedNamespace.has(externalModule) && canDefaultBeTakenFromNamespace(interop(externalModule.id), externalLiveBindings) ? externalModule.namespaceVariableName : getSafeName(`${externalModule.suggestedVariableName}__default`, usedNames, null);
  }
  for (const variable of imports) {
    const module = variable.module;
    if (module instanceof ExternalModule) {
      const chunk5 = externalChunkByModule.get(module);
      const name = variable.name;
      if (name === "default") {
        const moduleInterop = interop(module.id);
        const variableName = defaultInteropHelpersByInteropType[moduleInterop] ? chunk5.defaultVariableName : chunk5.variableName;
        if (isDefaultAProperty(moduleInterop, externalLiveBindings)) {
          variable.setRenderNames(variableName, "default");
        } else {
          variable.setRenderNames(null, variableName);
        }
      } else if (name === "*") {
        variable.setRenderNames(null, namespaceInteropHelpersByInteropType[interop(module.id)] ? chunk5.namespaceVariableName : chunk5.variableName);
      } else {
        variable.setRenderNames(chunk5.variableName, null);
      }
    } else {
      const chunk5 = chunkByModule.get(module);
      if (preserveModules && variable.isNamespace) {
        variable.setRenderNames(null, chunk5.exportMode === "default" ? chunk5.namespaceVariableName : chunk5.variableName);
      } else if (chunk5.exportMode === "default") {
        variable.setRenderNames(null, chunk5.variableName);
      } else {
        variable.setRenderNames(chunk5.variableName, chunk5.getVariableExportName(variable));
      }
    }
  }
}
function deconflictTopLevelVariables(usedNames, modules, includedNamespaces) {
  for (const module of modules) {
    for (const variable of module.scope.variables.values()) {
      if (variable.included && // this will only happen for exports in some formats
      !(variable.renderBaseName || variable instanceof ExportDefaultVariable && variable.getOriginalVariable() !== variable)) {
        variable.setRenderNames(null, getSafeName(variable.name, usedNames, variable.forbiddenNames));
      }
    }
    if (includedNamespaces.has(module)) {
      const namespace = module.namespace;
      namespace.setRenderNames(null, getSafeName(namespace.name, usedNames, namespace.forbiddenNames));
    }
  }
}
function assignExportsToMangledNames(exports, exportsByName, exportNamesByVariable) {
  let nameIndex = 0;
  for (const variable of exports) {
    let [exportName] = variable.name;
    if (exportsByName.has(exportName)) {
      do {
        exportName = toBase64(++nameIndex);
        if (exportName.charCodeAt(0) === 49) {
          nameIndex += 9 * 64 ** (exportName.length - 1);
          exportName = toBase64(nameIndex);
        }
      } while (RESERVED_NAMES.has(exportName) || exportsByName.has(exportName));
    }
    exportsByName.set(exportName, variable);
    exportNamesByVariable.set(variable, [exportName]);
  }
}
function assignExportsToNames(exports, exportsByName, exportNamesByVariable) {
  for (const variable of exports) {
    let nameIndex = 0;
    let exportName = variable.name;
    while (exportsByName.has(exportName)) {
      exportName = variable.name + "$" + ++nameIndex;
    }
    exportsByName.set(exportName, variable);
    exportNamesByVariable.set(variable, [exportName]);
  }
}
function getExportMode(chunk5, { exports: exportMode, name, format: format5 }, facadeModuleId, log5) {
  const exportKeys = chunk5.getExportNames();
  if (exportMode === "default") {
    if (exportKeys.length !== 1 || exportKeys[0] !== "default") {
      return error3(logIncompatibleExportOptionValue("default", exportKeys, facadeModuleId));
    }
  } else if (exportMode === "none" && exportKeys.length > 0) {
    return error3(logIncompatibleExportOptionValue("none", exportKeys, facadeModuleId));
  }
  if (exportMode === "auto") {
    if (exportKeys.length === 0) {
      exportMode = "none";
    } else if (exportKeys.length === 1 && exportKeys[0] === "default") {
      exportMode = "default";
    } else {
      if (format5 !== "es" && format5 !== "system" && exportKeys.includes("default")) {
        log5(LOGLEVEL_WARN, logMixedExport(facadeModuleId, name));
      }
      exportMode = "named";
    }
  }
  return exportMode;
}
function guessIndentString(code) {
  const lines = code.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced3 = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced3.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced3.length) {
    return "	";
  }
  const min3 = spaced3.reduce((previous2, current2) => {
    const numberSpaces = /^ +/.exec(current2)[0].length;
    return Math.min(numberSpaces, previous2);
  }, Infinity);
  return " ".repeat(min3);
}
function getIndentString(modules, options) {
  if (options.indent !== true)
    return options.indent;
  for (const module of modules) {
    const indent = guessIndentString(module.originalCode);
    if (indent !== null)
      return indent;
  }
  return "	";
}
function getStaticDependencies(chunk5, orderedModules, chunkByModule, externalChunkByModule) {
  const staticDependencyBlocks = [];
  const handledDependencies = /* @__PURE__ */ new Set();
  for (let modulePos = orderedModules.length - 1; modulePos >= 0; modulePos--) {
    const module = orderedModules[modulePos];
    if (!handledDependencies.has(module)) {
      const staticDependencies = [];
      addStaticDependencies(module, staticDependencies, handledDependencies, chunk5, chunkByModule, externalChunkByModule);
      staticDependencyBlocks.unshift(staticDependencies);
    }
  }
  const dependencies = /* @__PURE__ */ new Set();
  for (const block of staticDependencyBlocks) {
    for (const dependency of block) {
      dependencies.add(dependency);
    }
  }
  return dependencies;
}
function addStaticDependencies(module, staticDependencies, handledModules, chunk5, chunkByModule, externalChunkByModule) {
  const dependencies = module.getDependenciesToBeIncluded();
  for (const dependency of dependencies) {
    if (dependency instanceof ExternalModule) {
      staticDependencies.push(externalChunkByModule.get(dependency));
      continue;
    }
    const dependencyChunk = chunkByModule.get(dependency);
    if (dependencyChunk !== chunk5) {
      staticDependencies.push(dependencyChunk);
      continue;
    }
    if (!handledModules.has(dependency)) {
      handledModules.add(dependency);
      addStaticDependencies(dependency, staticDependencies, handledModules, chunk5, chunkByModule, externalChunkByModule);
    }
  }
}
function renderNamePattern(pattern, patternName, replacements) {
  if (isPathFragment(pattern))
    return error3(logFailedValidation(`Invalid pattern "${pattern}" for "${patternName}", patterns can be neither absolute nor relative paths. If you want your files to be stored in a subdirectory, write its name without a leading slash like this: subdirectory/pattern.`));
  return pattern.replace(/\[(\w+)(:\d+)?]/g, (_match, type, size16) => {
    if (!replacements.hasOwnProperty(type) || size16 && type !== "hash") {
      return error3(logFailedValidation(`"[${type}${size16 || ""}]" is not a valid placeholder in the "${patternName}" pattern.`));
    }
    const replacement = replacements[type](size16 && Number.parseInt(size16.slice(1)));
    if (isPathFragment(replacement))
      return error3(logFailedValidation(`Invalid substitution "${replacement}" for placeholder "[${type}]" in "${patternName}" pattern, can be neither absolute nor relative path.`));
    return replacement;
  });
}
function makeUnique(name, { [lowercaseBundleKeys]: reservedLowercaseBundleKeys }) {
  if (!reservedLowercaseBundleKeys.has(name.toLowerCase()))
    return name;
  const extension = p2.extname(name);
  name = name.slice(0, Math.max(0, name.length - extension.length));
  let uniqueName, uniqueIndex = 1;
  while (reservedLowercaseBundleKeys.has((uniqueName = name + ++uniqueIndex + extension).toLowerCase()))
    ;
  return uniqueName;
}
function getGlobalName(chunk5, globals, hasExports, log5) {
  const globalName = typeof globals === "function" ? globals(chunk5.id) : globals[chunk5.id];
  if (globalName) {
    return globalName;
  }
  if (hasExports) {
    log5(LOGLEVEL_WARN, logMissingGlobalName(chunk5.id, chunk5.variableName));
    return chunk5.variableName;
  }
}
function getChunkNameFromModule(module) {
  return getPredefinedChunkNameFromModule(module) ?? getAliasName(module.id);
}
function getPredefinedChunkNameFromModule(module) {
  return module.chunkNames.find(({ isUserDefined }) => isUserDefined)?.name ?? module.chunkNames[0]?.name;
}
function getImportedBindingsPerDependency(renderedDependencies, resolveFileName2) {
  const importedBindingsPerDependency = {};
  for (const [dependency, declaration] of renderedDependencies) {
    const specifiers = /* @__PURE__ */ new Set();
    if (declaration.imports) {
      for (const { imported } of declaration.imports) {
        specifiers.add(imported);
      }
    }
    if (declaration.reexports) {
      for (const { imported } of declaration.reexports) {
        specifiers.add(imported);
      }
    }
    importedBindingsPerDependency[resolveFileName2(dependency)] = [...specifiers];
  }
  return importedBindingsPerDependency;
}
function* concatLazy(iterables) {
  for (const iterable of iterables) {
    yield* iterable;
  }
}
function getChunkAssignments(entries2, manualChunkAliasByEntry, minChunkSize, log5) {
  const { chunkDefinitions, modulesInManualChunks } = getChunkDefinitionsFromManualChunks(manualChunkAliasByEntry);
  const { allEntries, dependentEntriesByModule, dynamicallyDependentEntriesByDynamicEntry, dynamicImportsByEntry, dynamicallyDependentEntriesByAwaitedDynamicEntry, awaitedDynamicImportsByEntry } = analyzeModuleGraph(entries2);
  const chunkAtoms = getChunksWithSameDependentEntries(getModulesWithDependentEntries(dependentEntriesByModule, modulesInManualChunks));
  const staticDependencyAtomsByEntry = getStaticDependencyAtomsByEntry(allEntries, chunkAtoms);
  const alreadyLoadedAtomsByEntry = getAlreadyLoadedAtomsByEntry(staticDependencyAtomsByEntry, dynamicallyDependentEntriesByDynamicEntry, dynamicImportsByEntry, allEntries);
  const awaitedAlreadyLoadedAtomsByEntry = getAlreadyLoadedAtomsByEntry(staticDependencyAtomsByEntry, dynamicallyDependentEntriesByAwaitedDynamicEntry, awaitedDynamicImportsByEntry, allEntries);
  removeUnnecessaryDependentEntries(chunkAtoms, alreadyLoadedAtomsByEntry, awaitedAlreadyLoadedAtomsByEntry);
  const { chunks: chunks3, sideEffectAtoms, sizeByAtom } = getChunksWithSameDependentEntriesAndCorrelatedAtoms(chunkAtoms, staticDependencyAtomsByEntry, alreadyLoadedAtomsByEntry, minChunkSize);
  chunkDefinitions.push(...getOptimizedChunks(chunks3, minChunkSize, sideEffectAtoms, sizeByAtom, log5).map(({ modules }) => ({
    alias: null,
    modules
  })));
  return chunkDefinitions;
}
function getChunkDefinitionsFromManualChunks(manualChunkAliasByEntry) {
  const modulesInManualChunks = new Set(manualChunkAliasByEntry.keys());
  const manualChunkModulesByAlias = /* @__PURE__ */ Object.create(null);
  for (const [entry, alias] of manualChunkAliasByEntry) {
    addStaticDependenciesToManualChunk(entry, manualChunkModulesByAlias[alias] ||= [], modulesInManualChunks);
  }
  const manualChunks = Object.entries(manualChunkModulesByAlias);
  const chunkDefinitions = new Array(manualChunks.length);
  let index = 0;
  for (const [alias, modules] of manualChunks) {
    chunkDefinitions[index++] = { alias, modules };
  }
  return { chunkDefinitions, modulesInManualChunks };
}
function addStaticDependenciesToManualChunk(entry, manualChunkModules, modulesInManualChunks) {
  const modulesToHandle = /* @__PURE__ */ new Set([entry]);
  for (const module of modulesToHandle) {
    modulesInManualChunks.add(module);
    manualChunkModules.push(module);
    for (const dependency of module.dependencies) {
      if (!(dependency instanceof ExternalModule || modulesInManualChunks.has(dependency))) {
        modulesToHandle.add(dependency);
      }
    }
  }
}
function analyzeModuleGraph(entries2) {
  const dynamicEntryModules = /* @__PURE__ */ new Set();
  const awaitedDynamicEntryModules = /* @__PURE__ */ new Set();
  const dependentEntriesByModule = /* @__PURE__ */ new Map();
  const allEntriesSet = new Set(entries2);
  const dynamicImportModulesByEntry = new Array(allEntriesSet.size);
  const awaitedDynamicImportModulesByEntry = new Array(allEntriesSet.size);
  let entryIndex = 0;
  for (const currentEntry of allEntriesSet) {
    const dynamicImportsForCurrentEntry = /* @__PURE__ */ new Set();
    const awaitedDynamicImportsForCurrentEntry = /* @__PURE__ */ new Set();
    dynamicImportModulesByEntry[entryIndex] = dynamicImportsForCurrentEntry;
    awaitedDynamicImportModulesByEntry[entryIndex] = awaitedDynamicImportsForCurrentEntry;
    const modulesToHandle = /* @__PURE__ */ new Set([currentEntry]);
    for (const module of modulesToHandle) {
      getOrCreate(dependentEntriesByModule, module, getNewSet).add(entryIndex);
      for (const dependency of module.getDependenciesToBeIncluded()) {
        if (!(dependency instanceof ExternalModule)) {
          modulesToHandle.add(dependency);
        }
      }
      for (const { resolution } of module.dynamicImports) {
        if (resolution instanceof Module && resolution.includedDynamicImporters.length > 0 && !allEntriesSet.has(resolution)) {
          dynamicEntryModules.add(resolution);
          allEntriesSet.add(resolution);
          dynamicImportsForCurrentEntry.add(resolution);
          if (resolution.includedDirectTopLevelAwaitingDynamicImporters.has(currentEntry)) {
            awaitedDynamicEntryModules.add(resolution);
            awaitedDynamicImportsForCurrentEntry.add(resolution);
          }
        }
      }
      for (const dependency of module.implicitlyLoadedBefore) {
        if (!allEntriesSet.has(dependency)) {
          dynamicEntryModules.add(dependency);
          allEntriesSet.add(dependency);
        }
      }
    }
    entryIndex++;
  }
  const allEntries = [...allEntriesSet];
  const { awaitedDynamicEntries, awaitedDynamicImportsByEntry, dynamicEntries, dynamicImportsByEntry } = getDynamicEntries(allEntries, dynamicEntryModules, dynamicImportModulesByEntry, awaitedDynamicEntryModules, awaitedDynamicImportModulesByEntry);
  return {
    allEntries,
    awaitedDynamicImportsByEntry,
    dependentEntriesByModule,
    dynamicallyDependentEntriesByAwaitedDynamicEntry: getDynamicallyDependentEntriesByDynamicEntry(dependentEntriesByModule, awaitedDynamicEntries, allEntries, (dynamicEntry) => dynamicEntry.includedDirectTopLevelAwaitingDynamicImporters),
    dynamicallyDependentEntriesByDynamicEntry: getDynamicallyDependentEntriesByDynamicEntry(dependentEntriesByModule, dynamicEntries, allEntries, (dynamicEntry) => dynamicEntry.includedDynamicImporters),
    dynamicImportsByEntry
  };
}
function getDynamicEntries(allEntries, dynamicEntryModules, dynamicImportModulesByEntry, awaitedDynamicEntryModules, awaitedDynamicImportModulesByEntry) {
  const entryIndexByModule = /* @__PURE__ */ new Map();
  const dynamicEntries = /* @__PURE__ */ new Set();
  const awaitedDynamicEntries = /* @__PURE__ */ new Set();
  for (const [entryIndex, entry] of allEntries.entries()) {
    entryIndexByModule.set(entry, entryIndex);
    if (dynamicEntryModules.has(entry)) {
      dynamicEntries.add(entryIndex);
    }
    if (awaitedDynamicEntryModules.has(entry)) {
      awaitedDynamicEntries.add(entryIndex);
    }
  }
  const dynamicImportsByEntry = getDynamicImportsByEntry(dynamicImportModulesByEntry, entryIndexByModule);
  const awaitedDynamicImportsByEntry = getDynamicImportsByEntry(awaitedDynamicImportModulesByEntry, entryIndexByModule);
  return {
    awaitedDynamicEntries,
    awaitedDynamicImportsByEntry,
    dynamicEntries,
    dynamicImportsByEntry
  };
}
function getDynamicImportsByEntry(dynamicImportModulesByEntry, entryIndexByModule) {
  const dynamicImportsByEntry = new Array(dynamicImportModulesByEntry.length);
  let index = 0;
  for (const dynamicImportModules of dynamicImportModulesByEntry) {
    const dynamicImports = /* @__PURE__ */ new Set();
    for (const dynamicEntry of dynamicImportModules) {
      dynamicImports.add(entryIndexByModule.get(dynamicEntry));
    }
    dynamicImportsByEntry[index++] = dynamicImports;
  }
  return dynamicImportsByEntry;
}
function getDynamicallyDependentEntriesByDynamicEntry(dependentEntriesByModule, dynamicEntries, allEntries, getDynamicImporters) {
  const dynamicallyDependentEntriesByDynamicEntry = /* @__PURE__ */ new Map();
  for (const dynamicEntryIndex of dynamicEntries) {
    const dynamicallyDependentEntries = getOrCreate(dynamicallyDependentEntriesByDynamicEntry, dynamicEntryIndex, getNewSet);
    const dynamicEntry = allEntries[dynamicEntryIndex];
    for (const importer of concatLazy([
      getDynamicImporters(dynamicEntry),
      dynamicEntry.implicitlyLoadedAfter
    ])) {
      for (const entry of dependentEntriesByModule.get(importer)) {
        dynamicallyDependentEntries.add(entry);
      }
    }
  }
  return dynamicallyDependentEntriesByDynamicEntry;
}
function getChunksWithSameDependentEntries(modulesWithDependentEntries) {
  const chunkModules = /* @__PURE__ */ Object.create(null);
  for (const { dependentEntries, modules } of modulesWithDependentEntries) {
    let chunkSignature = 0n;
    for (const entryIndex of dependentEntries) {
      chunkSignature |= 1n << BigInt(entryIndex);
    }
    (chunkModules[String(chunkSignature)] ||= {
      dependentEntries: new Set(dependentEntries),
      modules: []
    }).modules.push(...modules);
  }
  return Object.values(chunkModules);
}
function* getModulesWithDependentEntries(dependentEntriesByModule, modulesInManualChunks) {
  for (const [module, dependentEntries] of dependentEntriesByModule) {
    if (!modulesInManualChunks.has(module)) {
      yield { dependentEntries, modules: [module] };
    }
  }
}
function getStaticDependencyAtomsByEntry(allEntries, chunkAtoms) {
  const staticDependencyAtomsByEntry = allEntries.map(() => 0n);
  let atomMask = 1n;
  for (const { dependentEntries } of chunkAtoms) {
    for (const entryIndex of dependentEntries) {
      staticDependencyAtomsByEntry[entryIndex] |= atomMask;
    }
    atomMask <<= 1n;
  }
  return staticDependencyAtomsByEntry;
}
function getAlreadyLoadedAtomsByEntry(staticDependencyAtomsByEntry, dynamicallyDependentEntriesByDynamicEntry, dynamicImportsByEntry, allEntries) {
  const alreadyLoadedAtomsByEntry = allEntries.map((_entry, entryIndex) => dynamicallyDependentEntriesByDynamicEntry.has(entryIndex) ? -1n : 0n);
  for (const [dynamicEntryIndex, dynamicallyDependentEntries] of dynamicallyDependentEntriesByDynamicEntry) {
    dynamicallyDependentEntriesByDynamicEntry.delete(dynamicEntryIndex);
    const knownLoadedAtoms = alreadyLoadedAtomsByEntry[dynamicEntryIndex];
    let updatedLoadedAtoms = knownLoadedAtoms;
    for (const entryIndex of dynamicallyDependentEntries) {
      updatedLoadedAtoms &= staticDependencyAtomsByEntry[entryIndex] | alreadyLoadedAtomsByEntry[entryIndex];
    }
    if (updatedLoadedAtoms !== knownLoadedAtoms) {
      alreadyLoadedAtomsByEntry[dynamicEntryIndex] = updatedLoadedAtoms;
      for (const dynamicImport of dynamicImportsByEntry[dynamicEntryIndex]) {
        getOrCreate(dynamicallyDependentEntriesByDynamicEntry, dynamicImport, getNewSet).add(dynamicEntryIndex);
      }
    }
  }
  return alreadyLoadedAtomsByEntry;
}
function removeUnnecessaryDependentEntries(chunkAtoms, alreadyLoadedAtomsByEntry, awaitedAlreadyLoadedAtomsByEntry) {
  let chunkMask = 1n;
  for (const { dependentEntries } of chunkAtoms) {
    for (const entryIndex of dependentEntries) {
      if ((alreadyLoadedAtomsByEntry[entryIndex] & chunkMask) === chunkMask && (awaitedAlreadyLoadedAtomsByEntry[entryIndex] & chunkMask) === 0n) {
        dependentEntries.delete(entryIndex);
      }
    }
    chunkMask <<= 1n;
  }
}
function getChunksWithSameDependentEntriesAndCorrelatedAtoms(chunkAtoms, staticDependencyAtomsByEntry, alreadyLoadedAtomsByEntry, minChunkSize) {
  const chunksBySignature = /* @__PURE__ */ Object.create(null);
  const chunkByModule = /* @__PURE__ */ new Map();
  const sizeByAtom = new Array(chunkAtoms.length);
  let sideEffectAtoms = 0n;
  let atomMask = 1n;
  let index = 0;
  for (const { dependentEntries, modules } of chunkAtoms) {
    let chunkSignature = 0n;
    let correlatedAtoms = -1n;
    for (const entryIndex of dependentEntries) {
      chunkSignature |= 1n << BigInt(entryIndex);
      correlatedAtoms &= staticDependencyAtomsByEntry[entryIndex] | alreadyLoadedAtomsByEntry[entryIndex];
    }
    const chunk5 = chunksBySignature[String(chunkSignature)] ||= {
      containedAtoms: 0n,
      correlatedAtoms,
      dependencies: /* @__PURE__ */ new Set(),
      dependentChunks: /* @__PURE__ */ new Set(),
      dependentEntries: new Set(dependentEntries),
      modules: [],
      pure: true,
      size: 0
    };
    let atomSize = 0;
    let pure = true;
    for (const module of modules) {
      chunkByModule.set(module, chunk5);
      if (module.isIncluded()) {
        pure &&= !module.hasEffects();
        atomSize += minChunkSize > 1 ? module.estimateSize() : 1;
      }
    }
    if (!pure) {
      sideEffectAtoms |= atomMask;
    }
    sizeByAtom[index++] = atomSize;
    chunk5.containedAtoms |= atomMask;
    chunk5.modules.push(...modules);
    chunk5.pure &&= pure;
    chunk5.size += atomSize;
    atomMask <<= 1n;
  }
  const chunks3 = Object.values(chunksBySignature);
  sideEffectAtoms |= addChunkDependenciesAndGetExternalSideEffectAtoms(chunks3, chunkByModule, atomMask);
  return { chunks: chunks3, sideEffectAtoms, sizeByAtom };
}
function addChunkDependenciesAndGetExternalSideEffectAtoms(chunks3, chunkByModule, nextAvailableAtomMask) {
  const signatureByExternalModule = /* @__PURE__ */ new Map();
  let externalSideEffectAtoms = 0n;
  for (const chunk5 of chunks3) {
    const { dependencies, modules } = chunk5;
    for (const module of modules) {
      for (const dependency of module.getDependenciesToBeIncluded()) {
        if (dependency instanceof ExternalModule) {
          if (dependency.info.moduleSideEffects) {
            const signature = getOrCreate(signatureByExternalModule, dependency, () => {
              const signature2 = nextAvailableAtomMask;
              nextAvailableAtomMask <<= 1n;
              externalSideEffectAtoms |= signature2;
              return signature2;
            });
            chunk5.containedAtoms |= signature;
            chunk5.correlatedAtoms |= signature;
          }
        } else {
          const dependencyChunk = chunkByModule.get(dependency);
          if (dependencyChunk && dependencyChunk !== chunk5) {
            dependencies.add(dependencyChunk);
            dependencyChunk.dependentChunks.add(chunk5);
          }
        }
      }
    }
  }
  return externalSideEffectAtoms;
}
function getOptimizedChunks(chunks3, minChunkSize, sideEffectAtoms, sizeByAtom, log5) {
  timeStart("optimize chunks", 3);
  const chunkPartition = getPartitionedChunks(chunks3, minChunkSize);
  if (!chunkPartition) {
    timeEnd("optimize chunks", 3);
    return chunks3;
  }
  if (minChunkSize > 1) {
    log5("info", logOptimizeChunkStatus(chunks3.length, chunkPartition.small.size, "Initially"));
  }
  mergeChunks(chunkPartition, minChunkSize, sideEffectAtoms, sizeByAtom);
  if (minChunkSize > 1) {
    log5("info", logOptimizeChunkStatus(chunkPartition.small.size + chunkPartition.big.size, chunkPartition.small.size, "After merging chunks"));
  }
  timeEnd("optimize chunks", 3);
  return [...chunkPartition.small, ...chunkPartition.big];
}
function getPartitionedChunks(chunks3, minChunkSize) {
  const smallChunks = [];
  const bigChunks = [];
  for (const chunk5 of chunks3) {
    (chunk5.size < minChunkSize ? smallChunks : bigChunks).push(chunk5);
  }
  if (smallChunks.length === 0) {
    return null;
  }
  smallChunks.sort(compareChunkSize);
  bigChunks.sort(compareChunkSize);
  return {
    big: new Set(bigChunks),
    small: new Set(smallChunks)
  };
}
function compareChunkSize({ size: sizeA }, { size: sizeB }) {
  return sizeA - sizeB;
}
function mergeChunks(chunkPartition, minChunkSize, sideEffectAtoms, sizeByAtom) {
  const { small } = chunkPartition;
  for (const mergedChunk of small) {
    const bestTargetChunk = findBestMergeTarget(
      mergedChunk,
      chunkPartition,
      sideEffectAtoms,
      sizeByAtom,
      // In the default case, we do not accept size increases
      minChunkSize <= 1 ? 1 : Infinity
    );
    if (bestTargetChunk) {
      const { containedAtoms, correlatedAtoms, modules, pure, size: size16 } = mergedChunk;
      small.delete(mergedChunk);
      getChunksInPartition(bestTargetChunk, minChunkSize, chunkPartition).delete(bestTargetChunk);
      bestTargetChunk.modules.push(...modules);
      bestTargetChunk.size += size16;
      bestTargetChunk.pure &&= pure;
      const { dependencies, dependentChunks, dependentEntries } = bestTargetChunk;
      bestTargetChunk.correlatedAtoms &= correlatedAtoms;
      bestTargetChunk.containedAtoms |= containedAtoms;
      for (const entry of mergedChunk.dependentEntries) {
        dependentEntries.add(entry);
      }
      for (const dependency of mergedChunk.dependencies) {
        dependencies.add(dependency);
        dependency.dependentChunks.delete(mergedChunk);
        dependency.dependentChunks.add(bestTargetChunk);
      }
      for (const dependentChunk of mergedChunk.dependentChunks) {
        dependentChunks.add(dependentChunk);
        dependentChunk.dependencies.delete(mergedChunk);
        dependentChunk.dependencies.add(bestTargetChunk);
      }
      dependencies.delete(bestTargetChunk);
      dependentChunks.delete(bestTargetChunk);
      getChunksInPartition(bestTargetChunk, minChunkSize, chunkPartition).add(bestTargetChunk);
    }
  }
}
function findBestMergeTarget(mergedChunk, { big, small }, sideEffectAtoms, sizeByAtom, smallestAdditionalSize) {
  let bestTargetChunk = null;
  for (const targetChunk of concatLazy([small, big])) {
    if (mergedChunk === targetChunk)
      continue;
    const additionalSizeAfterMerge = getAdditionalSizeAfterMerge(mergedChunk, targetChunk, smallestAdditionalSize, sideEffectAtoms, sizeByAtom);
    if (additionalSizeAfterMerge < smallestAdditionalSize) {
      bestTargetChunk = targetChunk;
      if (additionalSizeAfterMerge === 0)
        break;
      smallestAdditionalSize = additionalSizeAfterMerge;
    }
  }
  return bestTargetChunk;
}
function getAdditionalSizeAfterMerge(mergedChunk, targetChunk, currentAdditionalSize, sideEffectAtoms, sizeByAtom) {
  const firstSize = getAdditionalSizeIfNoTransitiveDependencyOrNonCorrelatedSideEffect(mergedChunk, targetChunk, currentAdditionalSize, sideEffectAtoms, sizeByAtom);
  return firstSize < currentAdditionalSize ? firstSize + getAdditionalSizeIfNoTransitiveDependencyOrNonCorrelatedSideEffect(targetChunk, mergedChunk, currentAdditionalSize - firstSize, sideEffectAtoms, sizeByAtom) : Infinity;
}
function getAdditionalSizeIfNoTransitiveDependencyOrNonCorrelatedSideEffect(dependentChunk, dependencyChunk, currentAdditionalSize, sideEffectAtoms, sizeByAtom) {
  const { correlatedAtoms } = dependencyChunk;
  let dependencyAtoms = dependentChunk.containedAtoms;
  const dependentContainedSideEffects = dependencyAtoms & sideEffectAtoms;
  if ((correlatedAtoms & dependentContainedSideEffects) !== dependentContainedSideEffects) {
    return Infinity;
  }
  const chunksToCheck = new Set(dependentChunk.dependencies);
  for (const { dependencies, containedAtoms } of chunksToCheck) {
    dependencyAtoms |= containedAtoms;
    const containedSideEffects = containedAtoms & sideEffectAtoms;
    if ((correlatedAtoms & containedSideEffects) !== containedSideEffects) {
      return Infinity;
    }
    for (const dependency of dependencies) {
      if (dependency === dependencyChunk) {
        return Infinity;
      }
      chunksToCheck.add(dependency);
    }
  }
  return getAtomsSizeIfBelowLimit(dependencyAtoms & ~correlatedAtoms, currentAdditionalSize, sizeByAtom);
}
function getAtomsSizeIfBelowLimit(atoms, currentAdditionalSize, sizeByAtom) {
  let size16 = 0;
  let atomIndex = 0;
  let atomSignature = 1n;
  const { length: length3 } = sizeByAtom;
  for (; atomIndex < length3; atomIndex++) {
    if ((atoms & atomSignature) === atomSignature) {
      size16 += sizeByAtom[atomIndex];
    }
    atomSignature <<= 1n;
    if (size16 >= currentAdditionalSize) {
      return Infinity;
    }
  }
  return size16;
}
function getChunksInPartition(chunk5, minChunkSize, chunkPartition) {
  return chunk5.size < minChunkSize ? chunkPartition.small : chunkPartition.big;
}
function commondir(files) {
  if (files.length === 0)
    return "/";
  if (files.length === 1)
    return p2.dirname(files[0]);
  const commonSegments = files.slice(1).reduce((commonSegments2, file) => {
    const pathSegments = file.split(/\/+|\\+/);
    let index;
    for (index = 0; commonSegments2[index] === pathSegments[index] && index < Math.min(commonSegments2.length, pathSegments.length); index++)
      ;
    return commonSegments2.slice(0, index);
  }, files[0].split(/\/+|\\+/));
  return commonSegments.length > 1 ? commonSegments.join("/") : "/";
}
function sortByExecutionOrder(units) {
  units.sort(compareExecIndex);
}
function analyseModuleExecution(entryModules) {
  let nextExecIndex = 0;
  const cyclePaths = [];
  const analysedModules = /* @__PURE__ */ new Set();
  const dynamicImports = /* @__PURE__ */ new Set();
  const parents = /* @__PURE__ */ new Map();
  const orderedModules = [];
  const analyseModule = (module) => {
    if (module instanceof Module) {
      for (const dependency of module.dependencies) {
        if (parents.has(dependency)) {
          if (!analysedModules.has(dependency)) {
            cyclePaths.push(getCyclePath(dependency, module, parents));
          }
          continue;
        }
        parents.set(dependency, module);
        analyseModule(dependency);
      }
      for (const dependency of module.implicitlyLoadedBefore) {
        dynamicImports.add(dependency);
      }
      for (const { resolution } of module.dynamicImports) {
        if (resolution instanceof Module) {
          dynamicImports.add(resolution);
        }
      }
      orderedModules.push(module);
    }
    module.execIndex = nextExecIndex++;
    analysedModules.add(module);
  };
  for (const currentEntry of entryModules) {
    if (!parents.has(currentEntry)) {
      parents.set(currentEntry, null);
      analyseModule(currentEntry);
    }
  }
  for (const currentEntry of dynamicImports) {
    if (!parents.has(currentEntry)) {
      parents.set(currentEntry, null);
      analyseModule(currentEntry);
    }
  }
  return { cyclePaths, orderedModules };
}
function getCyclePath(module, parent, parents) {
  const cycleSymbol = Symbol(module.id);
  const path3 = [module.id];
  let nextModule = parent;
  module.cycles.add(cycleSymbol);
  while (nextModule !== module) {
    nextModule.cycles.add(cycleSymbol);
    path3.push(nextModule.id);
    nextModule = parents.get(nextModule);
  }
  path3.push(path3[0]);
  path3.reverse();
  return path3;
}
function getGenerateCodeSnippets({ compact: compact2, generatedCode: { arrowFunctions, constBindings, objectShorthand, reservedNamesAsProps } }) {
  const { _: _2, n: n2, s: s2 } = compact2 ? { _: "", n: "", s: "" } : { _: " ", n: "\n", s: ";" };
  const cnst = constBindings ? "const" : "var";
  const getNonArrowFunctionIntro = (parameters, { isAsync, name }) => `${isAsync ? `async ` : ""}function${name ? ` ${name}` : ""}${_2}(${parameters.join(`,${_2}`)})${_2}`;
  const getFunctionIntro = arrowFunctions ? (parameters, { isAsync, name }) => {
    const singleParameter = parameters.length === 1;
    const asyncString = isAsync ? `async${singleParameter ? " " : _2}` : "";
    return `${name ? `${cnst} ${name}${_2}=${_2}` : ""}${asyncString}${singleParameter ? parameters[0] : `(${parameters.join(`,${_2}`)})`}${_2}=>${_2}`;
  } : getNonArrowFunctionIntro;
  const getDirectReturnFunction = (parameters, { functionReturn, lineBreakIndent, name }) => [
    `${getFunctionIntro(parameters, {
      isAsync: false,
      name
    })}${arrowFunctions ? lineBreakIndent ? `${n2}${lineBreakIndent.base}${lineBreakIndent.t}` : "" : `{${lineBreakIndent ? `${n2}${lineBreakIndent.base}${lineBreakIndent.t}` : _2}${functionReturn ? "return " : ""}`}`,
    arrowFunctions ? `${name ? ";" : ""}${lineBreakIndent ? `${n2}${lineBreakIndent.base}` : ""}` : `${s2}${lineBreakIndent ? `${n2}${lineBreakIndent.base}` : _2}}`
  ];
  const isValidPropertyName = reservedNamesAsProps ? (name) => VALID_IDENTIFIER_REGEXP.test(name) : (name) => !RESERVED_NAMES.has(name) && VALID_IDENTIFIER_REGEXP.test(name);
  return {
    _: _2,
    cnst,
    getDirectReturnFunction,
    getDirectReturnIifeLeft: (parameters, returned, { needsArrowReturnParens, needsWrappedFunction }) => {
      const [left3, right3] = getDirectReturnFunction(parameters, {
        functionReturn: true,
        lineBreakIndent: null,
        name: null
      });
      return `${wrapIfNeeded(`${left3}${wrapIfNeeded(returned, arrowFunctions && needsArrowReturnParens)}${right3}`, arrowFunctions || needsWrappedFunction)}(`;
    },
    getFunctionIntro,
    getNonArrowFunctionIntro,
    getObject(fields, { lineBreakIndent }) {
      const prefix = lineBreakIndent ? `${n2}${lineBreakIndent.base}${lineBreakIndent.t}` : _2;
      return `{${fields.map(([key, value]) => {
        if (key === null)
          return `${prefix}${value}`;
        const keyInObject = stringifyObjectKeyIfNeeded(key);
        return key === value && objectShorthand && key === keyInObject ? prefix + key : `${prefix}${keyInObject}:${_2}${value}`;
      }).join(`,`)}${fields.length === 0 ? "" : lineBreakIndent ? `${n2}${lineBreakIndent.base}` : _2}}`;
    },
    getPropertyAccess: (name) => isValidPropertyName(name) ? `.${name}` : `[${JSON.stringify(name)}]`,
    n: n2,
    s: s2
  };
}
function getLinkMap(log5) {
  return function linkMap(source, map26) {
    if (!map26.missing) {
      return new Link(map26, [source]);
    }
    log5(LOGLEVEL_WARN, logSourcemapBroken(map26.plugin));
    return new Link({
      mappings: [],
      names: []
    }, [source]);
  };
}
function getCollapsedSourcemap(id2, originalCode, originalSourcemap, sourcemapChain, linkMap) {
  let source;
  if (originalSourcemap) {
    const sources = originalSourcemap.sources;
    const sourcesContent = originalSourcemap.sourcesContent || [];
    const directory = p2.dirname(id2) || ".";
    const sourceRoot = originalSourcemap.sourceRoot || ".";
    const baseSources = sources.map((source2, index) => new Source(p2.resolve(directory, sourceRoot, source2), sourcesContent[index]));
    source = new Link(originalSourcemap, baseSources);
  } else {
    source = new Source(id2, originalCode);
  }
  return sourcemapChain.reduce(linkMap, source);
}
function collapseSourcemaps(file, map26, modules, bundleSourcemapChain, excludeContent, log5) {
  const linkMap = getLinkMap(log5);
  const moduleSources = modules.filter((module) => !module.excludeFromSourcemap).map((module) => getCollapsedSourcemap(module.id, module.originalCode, module.originalSourcemap, module.sourcemapChain, linkMap));
  const link = new Link(map26, moduleSources);
  const source = bundleSourcemapChain.reduce(linkMap, link);
  let { sources, sourcesContent, names, mappings } = source.traceMappings();
  if (file) {
    const directory = p2.dirname(file);
    sources = sources.map((source2) => p2.relative(directory, source2));
    file = p2.basename(file);
  }
  sourcesContent = excludeContent ? null : sourcesContent;
  for (const module of modules) {
    resetSourcemapCache(module.originalSourcemap, module.sourcemapChain);
  }
  return new SourceMap2({ file, mappings, names, sources, sourcesContent });
}
function collapseSourcemap(id2, originalCode, originalSourcemap, sourcemapChain, log5) {
  if (sourcemapChain.length === 0) {
    return originalSourcemap;
  }
  const source = getCollapsedSourcemap(id2, originalCode, originalSourcemap, sourcemapChain, getLinkMap(log5));
  const map26 = source.traceMappings();
  return decodedSourcemap({ version: 3, ...map26 });
}
function ensureBuffer(input2) {
  if (typeof input2 === "string") {
    if (typeof Buffer === "undefined") {
      textEncoder ??= new TextEncoder();
      return textEncoder.encode(input2);
    }
    return Buffer.from(input2);
  }
  return input2;
}
async function renderChunks(chunks3, bundle, pluginDriver, outputOptions, log5) {
  timeStart("render chunks", 2);
  reserveEntryChunksInBundle(chunks3);
  const renderedChunks = await Promise.all(chunks3.map((chunk5) => chunk5.render()));
  timeEnd("render chunks", 2);
  timeStart("transform chunks", 2);
  const getHash2 = hasherByType[outputOptions.hashCharacters];
  const chunkGraph = getChunkGraph(chunks3);
  const { hashDependenciesByPlaceholder, initialHashesByPlaceholder, nonHashedChunksWithPlaceholders, placeholders, renderedChunksByPlaceholder } = await transformChunksAndGenerateContentHashes(renderedChunks, chunkGraph, outputOptions, pluginDriver, getHash2, log5);
  const hashesByPlaceholder = generateFinalHashes(renderedChunksByPlaceholder, hashDependenciesByPlaceholder, initialHashesByPlaceholder, placeholders, bundle, getHash2);
  addChunksToBundle(renderedChunksByPlaceholder, hashesByPlaceholder, bundle, nonHashedChunksWithPlaceholders, pluginDriver, outputOptions);
  timeEnd("transform chunks", 2);
}
function reserveEntryChunksInBundle(chunks3) {
  for (const chunk5 of chunks3) {
    if (chunk5.facadeModule && chunk5.facadeModule.isUserDefinedEntryPoint) {
      chunk5.getPreliminaryFileName();
    }
  }
}
function getChunkGraph(chunks3) {
  return Object.fromEntries(chunks3.map((chunk5) => {
    const renderedChunkInfo = chunk5.getRenderedChunkInfo();
    return [renderedChunkInfo.fileName, renderedChunkInfo];
  }));
}
async function transformChunk(magicString, fileName, usedModules, chunkGraph, options, outputPluginDriver, log5) {
  let map26 = null;
  const sourcemapChain = [];
  let code = await outputPluginDriver.hookReduceArg0("renderChunk", [magicString.toString(), chunkGraph[fileName], options, { chunks: chunkGraph }], (code2, result, plugin) => {
    if (result == null)
      return code2;
    if (typeof result === "string")
      result = {
        code: result,
        map: void 0
      };
    if (result.map !== null) {
      const map27 = decodedSourcemap(result.map);
      sourcemapChain.push(map27 || { missing: true, plugin: plugin.name });
    }
    return result.code;
  });
  const { compact: compact2, dir: dir3, file, sourcemap, sourcemapExcludeSources, sourcemapFile, sourcemapPathTransform, sourcemapIgnoreList } = options;
  if (!compact2 && code[code.length - 1] !== "\n")
    code += "\n";
  if (sourcemap) {
    timeStart("sourcemaps", 3);
    let resultingFile;
    if (file)
      resultingFile = p2.resolve(sourcemapFile || file);
    else if (dir3)
      resultingFile = p2.resolve(dir3, fileName);
    else
      resultingFile = p2.resolve(fileName);
    const decodedMap = magicString.generateDecodedMap({});
    map26 = collapseSourcemaps(resultingFile, decodedMap, usedModules, sourcemapChain, sourcemapExcludeSources, log5);
    for (let sourcesIndex = 0; sourcesIndex < map26.sources.length; ++sourcesIndex) {
      let sourcePath = map26.sources[sourcesIndex];
      const sourcemapPath = `${resultingFile}.map`;
      const ignoreList = sourcemapIgnoreList(sourcePath, sourcemapPath);
      if (typeof ignoreList !== "boolean") {
        error3(logFailedValidation("sourcemapIgnoreList function must return a boolean."));
      }
      if (ignoreList) {
        if (map26.x_google_ignoreList === void 0) {
          map26.x_google_ignoreList = [];
        }
        if (!map26.x_google_ignoreList.includes(sourcesIndex)) {
          map26.x_google_ignoreList.push(sourcesIndex);
        }
      }
      if (sourcemapPathTransform) {
        sourcePath = sourcemapPathTransform(sourcePath, sourcemapPath);
        if (typeof sourcePath !== "string") {
          error3(logFailedValidation(`sourcemapPathTransform function must return a string.`));
        }
      }
      map26.sources[sourcesIndex] = normalize2(sourcePath);
    }
    timeEnd("sourcemaps", 3);
  }
  return {
    code,
    map: map26
  };
}
async function transformChunksAndGenerateContentHashes(renderedChunks, chunkGraph, outputOptions, pluginDriver, getHash2, log5) {
  const nonHashedChunksWithPlaceholders = [];
  const renderedChunksByPlaceholder = /* @__PURE__ */ new Map();
  const hashDependenciesByPlaceholder = /* @__PURE__ */ new Map();
  const initialHashesByPlaceholder = /* @__PURE__ */ new Map();
  const placeholders = /* @__PURE__ */ new Set();
  for (const { preliminaryFileName: { hashPlaceholder } } of renderedChunks) {
    if (hashPlaceholder)
      placeholders.add(hashPlaceholder);
  }
  await Promise.all(renderedChunks.map(async ({ chunk: chunk5, preliminaryFileName: { fileName, hashPlaceholder }, preliminarySourcemapFileName, magicString, usedModules }) => {
    const transformedChunk = {
      chunk: chunk5,
      fileName,
      sourcemapFileName: preliminarySourcemapFileName?.fileName ?? null,
      ...await transformChunk(magicString, fileName, usedModules, chunkGraph, outputOptions, pluginDriver, log5)
    };
    const { code, map: map26 } = transformedChunk;
    if (hashPlaceholder) {
      const { containedPlaceholders, transformedCode } = replacePlaceholdersWithDefaultAndGetContainedPlaceholders(code, placeholders);
      let contentToHash = transformedCode;
      const hashAugmentation = pluginDriver.hookReduceValueSync("augmentChunkHash", "", [chunk5.getRenderedChunkInfo()], (augmentation, pluginHash) => {
        if (pluginHash) {
          augmentation += pluginHash;
        }
        return augmentation;
      });
      if (hashAugmentation) {
        contentToHash += hashAugmentation;
      }
      renderedChunksByPlaceholder.set(hashPlaceholder, transformedChunk);
      hashDependenciesByPlaceholder.set(hashPlaceholder, {
        containedPlaceholders,
        contentHash: getHash2(contentToHash)
      });
    } else {
      nonHashedChunksWithPlaceholders.push(transformedChunk);
    }
    const sourcemapHashPlaceholder = preliminarySourcemapFileName?.hashPlaceholder;
    if (map26 && sourcemapHashPlaceholder) {
      initialHashesByPlaceholder.set(preliminarySourcemapFileName.hashPlaceholder, getHash2(map26.toString()).slice(0, preliminarySourcemapFileName.hashPlaceholder.length));
    }
  }));
  return {
    hashDependenciesByPlaceholder,
    initialHashesByPlaceholder,
    nonHashedChunksWithPlaceholders,
    placeholders,
    renderedChunksByPlaceholder
  };
}
function generateFinalHashes(renderedChunksByPlaceholder, hashDependenciesByPlaceholder, initialHashesByPlaceholder, placeholders, bundle, getHash2) {
  const hashesByPlaceholder = new Map(initialHashesByPlaceholder);
  for (const placeholder of placeholders) {
    const { fileName } = renderedChunksByPlaceholder.get(placeholder);
    let contentToHash = "";
    const hashDependencyPlaceholders = /* @__PURE__ */ new Set([placeholder]);
    for (const dependencyPlaceholder of hashDependencyPlaceholders) {
      const { containedPlaceholders, contentHash } = hashDependenciesByPlaceholder.get(dependencyPlaceholder);
      contentToHash += contentHash;
      for (const containedPlaceholder of containedPlaceholders) {
        hashDependencyPlaceholders.add(containedPlaceholder);
      }
    }
    let finalFileName;
    let finalHash;
    do {
      if (finalHash) {
        contentToHash = finalHash;
      }
      finalHash = getHash2(contentToHash).slice(0, placeholder.length);
      finalFileName = replaceSinglePlaceholder(fileName, placeholder, finalHash);
    } while (bundle[lowercaseBundleKeys].has(finalFileName.toLowerCase()));
    bundle[finalFileName] = FILE_PLACEHOLDER;
    hashesByPlaceholder.set(placeholder, finalHash);
  }
  return hashesByPlaceholder;
}
function addChunksToBundle(renderedChunksByPlaceholder, hashesByPlaceholder, bundle, nonHashedChunksWithPlaceholders, pluginDriver, options) {
  for (const { chunk: chunk5, code, fileName, sourcemapFileName, map: map26 } of renderedChunksByPlaceholder.values()) {
    let updatedCode = replacePlaceholders(code, hashesByPlaceholder);
    const finalFileName = replacePlaceholders(fileName, hashesByPlaceholder);
    let finalSourcemapFileName = null;
    if (map26) {
      if (options.sourcemapDebugIds) {
        updatedCode += calculateDebugIdAndGetComment(updatedCode, map26);
      }
      finalSourcemapFileName = sourcemapFileName ? replacePlaceholders(sourcemapFileName, hashesByPlaceholder) : `${finalFileName}.map`;
      map26.file = replacePlaceholders(map26.file, hashesByPlaceholder);
      updatedCode += emitSourceMapAndGetComment(finalSourcemapFileName, map26, pluginDriver, options);
    }
    bundle[finalFileName] = chunk5.finalizeChunk(updatedCode, map26, finalSourcemapFileName, hashesByPlaceholder);
  }
  for (const { chunk: chunk5, code, fileName, sourcemapFileName, map: map26 } of nonHashedChunksWithPlaceholders) {
    let updatedCode = hashesByPlaceholder.size > 0 ? replacePlaceholders(code, hashesByPlaceholder) : code;
    let finalSourcemapFileName = null;
    if (map26) {
      if (options.sourcemapDebugIds) {
        updatedCode += calculateDebugIdAndGetComment(updatedCode, map26);
      }
      finalSourcemapFileName = sourcemapFileName ? replacePlaceholders(sourcemapFileName, hashesByPlaceholder) : `${fileName}.map`;
      updatedCode += emitSourceMapAndGetComment(finalSourcemapFileName, map26, pluginDriver, options);
    }
    bundle[fileName] = chunk5.finalizeChunk(updatedCode, map26, finalSourcemapFileName, hashesByPlaceholder);
  }
}
function emitSourceMapAndGetComment(fileName, map26, pluginDriver, { sourcemap, sourcemapBaseUrl }) {
  let url3;
  if (sourcemap === "inline") {
    url3 = map26.toUrl();
  } else {
    const sourcemapFileName = p2.basename(fileName);
    url3 = sourcemapBaseUrl ? new URL(sourcemapFileName, sourcemapBaseUrl).toString() : sourcemapFileName;
    pluginDriver.emitFile({
      fileName,
      originalFileName: null,
      source: map26.toString(),
      type: "asset"
    });
  }
  return sourcemap === "hidden" ? "" : `//# ${SOURCEMAPPING_URL}=${url3}
`;
}
function calculateDebugIdAndGetComment(code, map26) {
  const hash2 = hasherByType.hex(code);
  const debugId = [
    hash2.slice(0, 8),
    hash2.slice(8, 12),
    "4" + hash2.slice(12, 15),
    (parseInt(hash2.slice(15, 16), 16) & 3 | 8).toString(16) + hash2.slice(17, 20),
    hash2.slice(20, 32)
  ].join("-");
  map26.debugId = debugId;
  return "//# debugId=" + debugId + "\n";
}
function validateOptionsForMultiChunkOutput(outputOptions, log5) {
  if (outputOptions.format === "umd" || outputOptions.format === "iife")
    return error3(logInvalidOption("output.format", URL_OUTPUT_FORMAT, "UMD and IIFE output formats are not supported for code-splitting builds", outputOptions.format));
  if (typeof outputOptions.file === "string")
    return error3(logInvalidOption("output.file", URL_OUTPUT_DIR, 'when building multiple chunks, the "output.dir" option must be used, not "output.file". To inline dynamic imports, set the "inlineDynamicImports" option'));
  if (outputOptions.sourcemapFile)
    return error3(logInvalidOption("output.sourcemapFile", URL_OUTPUT_SOURCEMAPFILE, '"output.sourcemapFile" is only supported for single-file builds'));
  if (!outputOptions.amd.autoId && outputOptions.amd.id)
    log5(LOGLEVEL_WARN, logInvalidOption("output.amd.id", URL_OUTPUT_AMD_ID, 'this option is only properly supported for single-file builds. Use "output.amd.autoId" and "output.amd.basePath" instead'));
}
function getIncludedModules(modulesById) {
  const includedModules = [];
  for (const module of modulesById.values()) {
    if (module instanceof Module && (module.isIncluded() || module.info.isEntry || module.includedDynamicImporters.length > 0)) {
      includedModules.push(module);
    }
  }
  return includedModules;
}
function getAbsoluteEntryModulePaths(includedModules, preserveModules) {
  const absoluteEntryModulePaths = [];
  for (const module of includedModules) {
    if ((module.info.isEntry || preserveModules) && isAbsolute2(module.id)) {
      absoluteEntryModulePaths.push(module.id);
    }
  }
  return absoluteEntryModulePaths;
}
function getExternalChunkByModule(modulesById, outputOptions, inputBase) {
  const externalChunkByModule = /* @__PURE__ */ new Map();
  for (const module of modulesById.values()) {
    if (module instanceof ExternalModule) {
      externalChunkByModule.set(module, new ExternalChunk(module, outputOptions, inputBase));
    }
  }
  return externalChunkByModule;
}
function addModuleToManualChunk(alias, module, manualChunkAliasByEntry) {
  const existingAlias = manualChunkAliasByEntry.get(module);
  if (typeof existingAlias === "string" && existingAlias !== alias) {
    return error3(logCannotAssignModuleToChunk(module.id, alias, existingAlias));
  }
  manualChunkAliasByEntry.set(module, alias);
}
function flru(max5) {
  var num, curr, prev;
  var limit = max5;
  function keep(key, value) {
    if (++num > limit) {
      prev = curr;
      reset(1);
      ++num;
    }
    curr[key] = value;
  }
  function reset(isPartial) {
    num = 0;
    curr = /* @__PURE__ */ Object.create(null);
    isPartial || (prev = /* @__PURE__ */ Object.create(null));
  }
  reset();
  return {
    clear: reset,
    has: function(key) {
      return curr[key] !== void 0 || prev[key] !== void 0;
    },
    get: function(key) {
      var val = curr[key];
      if (val !== void 0) return val;
      if ((val = prev[key]) !== void 0) {
        keep(key, val);
        return val;
      }
    },
    set: function(key, value) {
      if (curr[key] !== void 0) {
        curr[key] = value;
      } else {
        keep(key, value);
      }
    }
  };
}
function resolveIdViaPlugins(source, importer, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry, attributes) {
  let skipped = null;
  let replaceContext = null;
  if (skip) {
    skipped = /* @__PURE__ */ new Set();
    for (const skippedCall of skip) {
      if (source === skippedCall.source && importer === skippedCall.importer) {
        skipped.add(skippedCall.plugin);
      }
    }
    replaceContext = (pluginContext2, plugin) => ({
      ...pluginContext2,
      resolve: (source2, importer2, { attributes: attributes2, custom: custom3, isEntry: isEntry2, skipSelf } = BLANK) => {
        skipSelf ??= true;
        return moduleLoaderResolveId(source2, importer2, custom3, isEntry2, attributes2 || EMPTY_OBJECT, skipSelf ? [...skip, { importer: importer2, plugin, source: source2 }] : skip);
      }
    });
  }
  return pluginDriver.hookFirstAndGetPlugin("resolveId", [source, importer, { attributes, custom: customOptions, isEntry }], replaceContext, skipped);
}
async function resolveId(source, importer, preserveSymlinks, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry, attributes) {
  const pluginResult = await resolveIdViaPlugins(source, importer, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry, attributes);
  if (pluginResult != null) {
    const [resolveIdResult, plugin] = pluginResult;
    if (typeof resolveIdResult === "object" && !resolveIdResult.resolvedBy) {
      return {
        ...resolveIdResult,
        resolvedBy: plugin.name
      };
    }
    if (typeof resolveIdResult === "string") {
      return {
        id: resolveIdResult,
        resolvedBy: plugin.name
      };
    }
    return resolveIdResult;
  }
  if (importer !== void 0 && !isAbsolute2(source) && source[0] !== ".")
    return null;
  return addJsExtensionIfNecessary(importer ? p2.resolve(p2.dirname(importer), source) : p2.resolve(source), preserveSymlinks);
}
async function addJsExtensionIfNecessary(file, preserveSymlinks) {
  return await findFile(file, preserveSymlinks) ?? await findFile(file + ".mjs", preserveSymlinks) ?? await findFile(file + ".js", preserveSymlinks);
}
async function findFile(file, preserveSymlinks) {
  try {
    const stats = await promises.lstat(file);
    if (!preserveSymlinks && stats.isSymbolicLink())
      return await findFile(await promises.realpath(file), preserveSymlinks);
    if (preserveSymlinks && stats.isSymbolicLink() || stats.isFile()) {
      const name = p2.basename(file);
      const files = await promises.readdir(p2.dirname(file));
      if (files.includes(name))
        return file;
    }
  } catch {
  }
}
function stripBom(content) {
  if (content.charCodeAt(0) === 65279) {
    return stripBom(content.slice(1));
  }
  return content;
}
function createPluginCache(cache3) {
  return {
    delete(id2) {
      return delete cache3[id2];
    },
    get(id2) {
      const item = cache3[id2];
      if (!item)
        return;
      item[0] = 0;
      return item[1];
    },
    has(id2) {
      const item = cache3[id2];
      if (!item)
        return false;
      item[0] = 0;
      return true;
    },
    set(id2, value) {
      cache3[id2] = [0, value];
    }
  };
}
function getTrackedPluginCache(pluginCache, onUse) {
  return {
    delete(id2) {
      onUse();
      return pluginCache.delete(id2);
    },
    get(id2) {
      onUse();
      return pluginCache.get(id2);
    },
    has(id2) {
      onUse();
      return pluginCache.has(id2);
    },
    set(id2, value) {
      onUse();
      return pluginCache.set(id2, value);
    }
  };
}
function uncacheablePluginError(pluginName) {
  if (pluginName.startsWith(ANONYMOUS_PLUGIN_PREFIX) || pluginName.startsWith(ANONYMOUS_OUTPUT_PLUGIN_PREFIX)) {
    return error3(logAnonymousPluginCache());
  }
  return error3(logDuplicatePluginName(pluginName));
}
function getCacheForUncacheablePlugin(pluginName) {
  return {
    delete() {
      return uncacheablePluginError(pluginName);
    },
    get() {
      return uncacheablePluginError(pluginName);
    },
    has() {
      return uncacheablePluginError(pluginName);
    },
    set() {
      return uncacheablePluginError(pluginName);
    }
  };
}
async function asyncFlatten(array6) {
  do {
    array6 = (await Promise.all(array6)).flat(Infinity);
  } while (array6.some((v2) => v2?.then));
  return array6;
}
function warnUnknownOptions(passedOptions, validOptions, optionType, log5, ignoredKeys = /$./) {
  const validOptionSet = new Set(validOptions);
  const unknownOptions = Object.keys(passedOptions).filter((key) => !(validOptionSet.has(key) || ignoredKeys.test(key)));
  if (unknownOptions.length > 0) {
    log5(LOGLEVEL_WARN, logUnknownOption(optionType, unknownOptions, [...validOptionSet].sort()));
  }
}
async function transform2(source, module, pluginDriver, log5) {
  const id2 = module.id;
  const sourcemapChain = [];
  let originalSourcemap = source.map === null ? null : decodedSourcemap(source.map);
  const originalCode = source.code;
  let ast = source.ast;
  const transformDependencies = [];
  const emittedFiles = [];
  let customTransformCache = false;
  const useCustomTransformCache = () => customTransformCache = true;
  let pluginName = "";
  let currentSource = source.code;
  function transformReducer(previousCode, result, plugin) {
    let code2;
    let map26;
    if (typeof result === "string") {
      code2 = result;
    } else if (result && typeof result === "object") {
      module.updateOptions(result);
      if (result.code == null) {
        if (result.map || result.ast) {
          log5(LOGLEVEL_WARN, logNoTransformMapOrAstWithoutCode(plugin.name));
        }
        return previousCode;
      }
      ({ code: code2, map: map26, ast } = result);
    } else {
      return previousCode;
    }
    if (map26 !== null) {
      sourcemapChain.push(decodedSourcemap(typeof map26 === "string" ? JSON.parse(map26) : map26) || {
        missing: true,
        plugin: plugin.name
      });
    }
    currentSource = code2;
    return code2;
  }
  const getLogHandler2 = (handler) => (log6, pos) => {
    log6 = normalizeLog(log6);
    if (pos)
      augmentCodeLocation(log6, pos, currentSource, id2);
    log6.id = id2;
    log6.hook = "transform";
    handler(log6);
  };
  let code;
  try {
    code = await pluginDriver.hookReduceArg0("transform", [currentSource, id2], transformReducer, (pluginContext2, plugin) => {
      pluginName = plugin.name;
      return {
        ...pluginContext2,
        addWatchFile(id3) {
          transformDependencies.push(id3);
          pluginContext2.addWatchFile(id3);
        },
        cache: customTransformCache ? pluginContext2.cache : getTrackedPluginCache(pluginContext2.cache, useCustomTransformCache),
        debug: getLogHandler2(pluginContext2.debug),
        emitFile(emittedFile) {
          emittedFiles.push(emittedFile);
          return pluginDriver.emitFile(emittedFile);
        },
        error(error_, pos) {
          if (typeof error_ === "string")
            error_ = { message: error_ };
          if (pos)
            augmentCodeLocation(error_, pos, currentSource, id2);
          error_.id = id2;
          error_.hook = "transform";
          return pluginContext2.error(error_);
        },
        getCombinedSourcemap() {
          const combinedMap = collapseSourcemap(id2, originalCode, originalSourcemap, sourcemapChain, log5);
          if (!combinedMap) {
            const magicString = new MagicString(originalCode);
            return magicString.generateMap({ hires: true, includeContent: true, source: id2 });
          }
          if (originalSourcemap !== combinedMap) {
            originalSourcemap = combinedMap;
            sourcemapChain.length = 0;
          }
          return new SourceMap2({
            ...combinedMap,
            file: null,
            sourcesContent: combinedMap.sourcesContent
          });
        },
        info: getLogHandler2(pluginContext2.info),
        setAssetSource() {
          return this.error(logInvalidSetAssetSourceCall());
        },
        warn: getLogHandler2(pluginContext2.warn)
      };
    });
  } catch (error_) {
    return error3(logPluginError(error_, pluginName, { hook: "transform", id: id2 }));
  }
  if (!customTransformCache && // files emitted by a transform hook need to be emitted again if the hook is skipped
  emittedFiles.length > 0)
    module.transformFiles = emittedFiles;
  return {
    ast,
    code,
    customTransformCache,
    originalCode,
    originalSourcemap,
    sourcemapChain,
    transformDependencies
  };
}
function normalizeRelativeExternalId(source, importer) {
  return isRelative2(source) ? importer ? p2.resolve(importer, "..", source) : p2.resolve(source) : source;
}
function addChunkNamesToModule(module, { fileName, name }, isUserDefined, priority) {
  if (fileName !== null) {
    module.chunkFileNames.add(fileName);
  } else if (name !== null) {
    let namePosition = 0;
    while (module.chunkNames[namePosition]?.priority < priority)
      namePosition++;
    module.chunkNames.splice(namePosition, 0, { isUserDefined, name, priority });
  }
}
function isNotAbsoluteExternal(id2, source, makeAbsoluteExternalsRelative) {
  return makeAbsoluteExternalsRelative === true || makeAbsoluteExternalsRelative === "ifRelativeSource" && isRelative2(source) || !isAbsolute2(id2);
}
async function waitForDependencyResolution(loadPromise) {
  const [resolveStaticDependencyPromises, resolveDynamicImportPromises] = await loadPromise;
  return Promise.all([...resolveStaticDependencyPromises, ...resolveDynamicImportPromises]);
}
function generateAssetFileName(name, names, source, originalFileName, originalFileNames, sourceHash, outputOptions, bundle, inputOptions) {
  const emittedName = outputOptions.sanitizeFileName(name || "asset");
  return makeUnique(renderNamePattern(typeof outputOptions.assetFileNames === "function" ? outputOptions.assetFileNames({
    // Additionally, this should be non-enumerable in the next major
    get name() {
      warnDeprecation('Accessing the "name" property of emitted assets when generating the file name is deprecated. Use the "names" property instead.', URL_GENERATEBUNDLE, false, inputOptions);
      return name;
    },
    names,
    // Additionally, this should be non-enumerable in the next major
    get originalFileName() {
      warnDeprecation('Accessing the "originalFileName" property of emitted assets when generating the file name is deprecated. Use the "originalFileNames" property instead.', URL_GENERATEBUNDLE, false, inputOptions);
      return originalFileName;
    },
    originalFileNames,
    source,
    type: "asset"
  }) : outputOptions.assetFileNames, "output.assetFileNames", {
    ext: () => p2.extname(emittedName).slice(1),
    extname: () => p2.extname(emittedName),
    hash: (size16) => sourceHash.slice(0, Math.max(0, size16 || DEFAULT_HASH_SIZE)),
    name: () => emittedName.slice(0, Math.max(0, emittedName.length - p2.extname(emittedName).length))
  }), bundle);
}
function reserveFileNameInBundle(fileName, { bundle }, log5) {
  if (bundle[lowercaseBundleKeys].has(fileName.toLowerCase())) {
    log5(LOGLEVEL_WARN, logFileNameConflict(fileName));
  } else {
    bundle[fileName] = FILE_PLACEHOLDER;
  }
}
function hasValidType(emittedFile) {
  return Boolean(emittedFile && emittedFileTypes.has(emittedFile.type));
}
function hasValidName(emittedFile) {
  const validatedName = emittedFile.fileName || emittedFile.name;
  return !validatedName || typeof validatedName === "string" && !isPathFragment(validatedName);
}
function getValidSource(source, emittedFile, fileReferenceId) {
  if (!(typeof source === "string" || source instanceof Uint8Array)) {
    const assetName = emittedFile.fileName || emittedFile.name || fileReferenceId;
    return error3(logFailedValidation(`Could not set source for ${typeof assetName === "string" ? `asset "${assetName}"` : "unnamed asset"}, asset source needs to be a string, Uint8Array or Buffer.`));
  }
  return source;
}
function getAssetFileName(file, referenceId) {
  if (typeof file.fileName !== "string") {
    return error3(logAssetNotFinalisedForFileName(file.name || referenceId));
  }
  return file.fileName;
}
function getChunkFileName(file, facadeChunkByModule) {
  if (file.fileName) {
    return file.fileName;
  }
  if (facadeChunkByModule) {
    return facadeChunkByModule.get(file.module).getFileName();
  }
  return error3(logChunkNotGeneratedForFileName(file.fileName || file.name));
}
function getNamesFromAssets(consumedFiles) {
  const names = [];
  const originalFileNames = [];
  for (const { name, originalFileName } of consumedFiles) {
    if (typeof name === "string") {
      names.push(name);
    }
    if (originalFileName) {
      originalFileNames.push(originalFileName);
    }
  }
  originalFileNames.sort();
  names.sort((a2, b) => a2.length - b.length || (a2 > b ? 1 : a2 === b ? 0 : -1));
  return { names, originalFileNames };
}
function getLogHandler(level, code, logger, pluginName, logLevel3) {
  if (logLevelPriority[level] < logLevelPriority[logLevel3]) {
    return doNothing;
  }
  return (log5, pos) => {
    if (pos != null) {
      logger(LOGLEVEL_WARN, logInvalidLogPosition(pluginName));
    }
    log5 = normalizeLog(log5);
    if (log5.code && !log5.pluginCode) {
      log5.pluginCode = log5.code;
    }
    log5.code = code;
    log5.plugin = pluginName;
    logger(level, log5);
  };
}
function getPluginContext(plugin, pluginCache, graph, options, fileEmitter, existingPluginNames) {
  const { logLevel: logLevel3, onLog } = options;
  let cacheable = true;
  if (typeof plugin.cacheKey !== "string") {
    if (plugin.name.startsWith(ANONYMOUS_PLUGIN_PREFIX) || plugin.name.startsWith(ANONYMOUS_OUTPUT_PLUGIN_PREFIX) || existingPluginNames.has(plugin.name)) {
      cacheable = false;
    } else {
      existingPluginNames.add(plugin.name);
    }
  }
  let cacheInstance;
  if (!pluginCache) {
    cacheInstance = NO_CACHE;
  } else if (cacheable) {
    const cacheKey = plugin.cacheKey || plugin.name;
    cacheInstance = createPluginCache(pluginCache[cacheKey] || (pluginCache[cacheKey] = /* @__PURE__ */ Object.create(null)));
  } else {
    cacheInstance = getCacheForUncacheablePlugin(plugin.name);
  }
  return {
    addWatchFile(id2) {
      graph.watchFiles[id2] = true;
    },
    cache: cacheInstance,
    debug: getLogHandler(LOGLEVEL_DEBUG, "PLUGIN_LOG", onLog, plugin.name, logLevel3),
    emitFile: fileEmitter.emitFile.bind(fileEmitter),
    error(error_) {
      return error3(logPluginError(normalizeLog(error_), plugin.name));
    },
    getFileName: fileEmitter.getFileName,
    getModuleIds: () => graph.modulesById.keys(),
    getModuleInfo: graph.getModuleInfo,
    getWatchFiles: () => Object.keys(graph.watchFiles),
    info: getLogHandler(LOGLEVEL_INFO, "PLUGIN_LOG", onLog, plugin.name, logLevel3),
    load(resolvedId) {
      return graph.moduleLoader.preloadModule(resolvedId);
    },
    meta: {
      rollupVersion: version2,
      watchMode: graph.watchMode
    },
    parse: parseAst,
    resolve(source, importer, { attributes, custom: custom3, isEntry, skipSelf } = BLANK) {
      skipSelf ??= true;
      return graph.moduleLoader.resolveId(source, importer, custom3, isEntry, attributes || EMPTY_OBJECT, skipSelf ? [{ importer, plugin, source }] : null);
    },
    setAssetSource: fileEmitter.setAssetSource,
    warn: getLogHandler(LOGLEVEL_WARN, "PLUGIN_WARNING", onLog, plugin.name, logLevel3)
  };
}
function getSortedValidatedPlugins(hookName, plugins, validateHandler = validateFunctionPluginHandler) {
  const pre = [];
  const normal = [];
  const post = [];
  for (const plugin of plugins) {
    const hook = plugin[hookName];
    if (hook) {
      if (typeof hook === "object") {
        validateHandler(hook.handler, hookName, plugin);
        if (hook.order === "pre") {
          pre.push(plugin);
          continue;
        }
        if (hook.order === "post") {
          post.push(plugin);
          continue;
        }
      } else {
        validateHandler(hook, hookName, plugin);
      }
      normal.push(plugin);
    }
  }
  return [...pre, ...normal, ...post];
}
function validateFunctionPluginHandler(handler, hookName, plugin) {
  if (typeof handler !== "function") {
    error3(logInvalidFunctionPluginHook(hookName, plugin.name));
  }
}
function validateAddonPluginHandler(handler, hookName, plugin) {
  if (typeof handler !== "string" && typeof handler !== "function") {
    return error3(logInvalidAddonPluginHook(hookName, plugin.name));
  }
}
function noReturn() {
}
function normalizeEntryModules(entryModules) {
  if (Array.isArray(entryModules)) {
    return entryModules.map((id2) => ({
      fileName: null,
      id: id2,
      implicitlyLoadedAfter: [],
      importer: void 0,
      name: null
    }));
  }
  return Object.entries(entryModules).map(([name, id2]) => ({
    fileName: null,
    id: id2,
    implicitlyLoadedAfter: [],
    importer: void 0,
    name
  }));
}
function formatAction([pluginName, hookName, parameters]) {
  const action = `(${pluginName}) ${hookName}`;
  const s2 = JSON.stringify;
  switch (hookName) {
    case "resolveId": {
      return `${action} ${s2(parameters[0])} ${s2(parameters[1])}`;
    }
    case "load": {
      return `${action} ${s2(parameters[0])}`;
    }
    case "transform": {
      return `${action} ${s2(parameters[1])}`;
    }
    case "shouldTransformCachedModule": {
      return `${action} ${s2(parameters[0].id)}`;
    }
    case "moduleParsed": {
      return `${action} ${s2(parameters[0].id)}`;
    }
  }
  return action;
}
async function catchUnfinishedHookActions(pluginDriver, callback) {
  const emptyEventLoopPromise = new Promise((_2, reject) => {
    rejectByPluginDriver.set(pluginDriver, reject);
    if (!handleBeforeExit) {
      handleBeforeExit = () => {
        for (const [pluginDriver2, reject2] of rejectByPluginDriver) {
          const unfulfilledActions = pluginDriver2.getUnfulfilledHookActions();
          reject2(new Error(`Unexpected early exit. This happens when Promises returned by plugins cannot resolve. Unfinished hook action(s) on exit:
` + [...unfulfilledActions].map(formatAction).join("\n")));
        }
      };
      process$1__default.default.once("beforeExit", handleBeforeExit);
    }
  });
  try {
    return await Promise.race([callback(), emptyEventLoopPromise]);
  } finally {
    rejectByPluginDriver.delete(pluginDriver);
    if (rejectByPluginDriver.size === 0) {
      process$1__default.default.off("beforeExit", handleBeforeExit);
      handleBeforeExit = null;
    }
  }
}
async function initWasm() {
}
function getLogger(plugins, onLog, watchMode, logLevel3) {
  plugins = getSortedValidatedPlugins("onLog", plugins);
  const minimalPriority = logLevelPriority[logLevel3];
  const logger = (level, log5, skipped = EMPTY_SET) => {
    augmentLogMessage(log5);
    const logPriority = logLevelPriority[level];
    if (logPriority < minimalPriority) {
      return;
    }
    for (const plugin of plugins) {
      if (skipped.has(plugin))
        continue;
      const { onLog: pluginOnLog } = plugin;
      const getLogHandler2 = (level2) => {
        if (logLevelPriority[level2] < minimalPriority) {
          return doNothing;
        }
        return (log6) => logger(level2, normalizeLog(log6), new Set(skipped).add(plugin));
      };
      const handler = "handler" in pluginOnLog ? pluginOnLog.handler : pluginOnLog;
      if (handler.call({
        debug: getLogHandler2(LOGLEVEL_DEBUG),
        error: (log6) => error3(normalizeLog(log6)),
        info: getLogHandler2(LOGLEVEL_INFO),
        meta: { rollupVersion: version2, watchMode },
        warn: getLogHandler2(LOGLEVEL_WARN)
      }, level, log5) === false) {
        return;
      }
    }
    onLog(level, log5);
  };
  return logger;
}
function ensureArray2(items) {
  if (Array.isArray(items)) {
    return items.filter(Boolean);
  }
  if (items) {
    return [items];
  }
  return [];
}
async function normalizeInputOptions(config2, watchMode) {
  const unsetOptions = /* @__PURE__ */ new Set();
  const context8 = config2.context ?? "undefined";
  const plugins = await normalizePluginOption(config2.plugins);
  const logLevel3 = config2.logLevel || LOGLEVEL_INFO;
  const onLog = getLogger(plugins, getOnLog(config2, logLevel3), watchMode, logLevel3);
  const strictDeprecations = config2.strictDeprecations || false;
  const maxParallelFileOps = getMaxParallelFileOps(config2);
  const options = {
    cache: getCache(config2),
    context: context8,
    experimentalCacheExpiry: config2.experimentalCacheExpiry ?? 10,
    experimentalLogSideEffects: config2.experimentalLogSideEffects || false,
    external: getIdMatcher(config2.external),
    input: getInput(config2),
    jsx: getJsx(config2),
    logLevel: logLevel3,
    makeAbsoluteExternalsRelative: config2.makeAbsoluteExternalsRelative ?? "ifRelativeSource",
    maxParallelFileOps,
    moduleContext: getModuleContext(config2, context8),
    onLog,
    perf: config2.perf || false,
    plugins,
    preserveEntrySignatures: config2.preserveEntrySignatures ?? "exports-only",
    preserveSymlinks: config2.preserveSymlinks || false,
    shimMissingExports: config2.shimMissingExports || false,
    strictDeprecations,
    treeshake: getTreeshake(config2)
  };
  warnUnknownOptions(config2, [...Object.keys(options), "onwarn", "watch"], "input options", onLog, /^(output)$/);
  return { options, unsetOptions };
}
function sanitizeFileName(name) {
  const match18 = DRIVE_LETTER_REGEX.exec(name);
  const driveLetter = match18 ? match18[0] : "";
  return driveLetter + name.slice(driveLetter.length).replace(INVALID_CHAR_REGEX, "_");
}
async function normalizeOutputOptions(config2, inputOptions, unsetInputOptions) {
  const unsetOptions = new Set(unsetInputOptions);
  const compact2 = config2.compact || false;
  const format5 = getFormat(config2);
  const inlineDynamicImports = getInlineDynamicImports(config2, inputOptions);
  const preserveModules = getPreserveModules(config2, inlineDynamicImports, inputOptions);
  const file = getFile(config2, preserveModules, inputOptions);
  const generatedCode = getGeneratedCode(config2);
  const externalImportAttributes = getExternalImportAttributes(config2, inputOptions);
  const outputOptions = {
    amd: getAmd(config2),
    assetFileNames: config2.assetFileNames ?? "assets/[name]-[hash][extname]",
    banner: getAddon(config2, "banner"),
    chunkFileNames: config2.chunkFileNames ?? "[name]-[hash].js",
    compact: compact2,
    dir: getDir(config2, file),
    dynamicImportInCjs: config2.dynamicImportInCjs ?? true,
    entryFileNames: getEntryFileNames(config2, unsetOptions),
    esModule: config2.esModule ?? "if-default-prop",
    experimentalMinChunkSize: config2.experimentalMinChunkSize ?? 1,
    exports: getExports(config2, unsetOptions),
    extend: config2.extend || false,
    externalImportAssertions: externalImportAttributes,
    externalImportAttributes,
    externalLiveBindings: config2.externalLiveBindings ?? true,
    file,
    footer: getAddon(config2, "footer"),
    format: format5,
    freeze: config2.freeze ?? true,
    generatedCode,
    globals: config2.globals || {},
    hashCharacters: config2.hashCharacters ?? "base64",
    hoistTransitiveImports: config2.hoistTransitiveImports ?? true,
    importAttributesKey: config2.importAttributesKey ?? "assert",
    indent: getIndent(config2, compact2),
    inlineDynamicImports,
    interop: getInterop(config2),
    intro: getAddon(config2, "intro"),
    manualChunks: getManualChunks(config2, inlineDynamicImports, preserveModules),
    minifyInternalExports: getMinifyInternalExports(config2, format5, compact2),
    name: config2.name,
    noConflict: config2.noConflict || false,
    outro: getAddon(config2, "outro"),
    paths: config2.paths || {},
    plugins: await normalizePluginOption(config2.plugins),
    preserveModules,
    preserveModulesRoot: getPreserveModulesRoot(config2),
    reexportProtoFromExternal: config2.reexportProtoFromExternal ?? true,
    sanitizeFileName: typeof config2.sanitizeFileName === "function" ? config2.sanitizeFileName : config2.sanitizeFileName === false ? (id2) => id2 : sanitizeFileName,
    sourcemap: config2.sourcemap || false,
    sourcemapBaseUrl: getSourcemapBaseUrl(config2),
    sourcemapDebugIds: config2.sourcemapDebugIds || false,
    sourcemapExcludeSources: config2.sourcemapExcludeSources || false,
    sourcemapFile: config2.sourcemapFile,
    sourcemapFileNames: getSourcemapFileNames(config2, unsetOptions),
    sourcemapIgnoreList: typeof config2.sourcemapIgnoreList === "function" ? config2.sourcemapIgnoreList : config2.sourcemapIgnoreList === false ? () => false : (relativeSourcePath) => relativeSourcePath.includes("node_modules"),
    sourcemapPathTransform: config2.sourcemapPathTransform,
    strict: config2.strict ?? true,
    systemNullSetters: config2.systemNullSetters ?? true,
    validate: config2.validate || false,
    virtualDirname: config2.virtualDirname || "_virtual"
  };
  warnUnknownOptions(config2, Object.keys(outputOptions), "output options", inputOptions.onLog);
  return { options: outputOptions, unsetOptions };
}
function getExports(config2, unsetOptions) {
  const configExports = config2.exports;
  if (configExports == null) {
    unsetOptions.add("exports");
  } else if (!["default", "named", "none", "auto"].includes(configExports)) {
    return error3(logInvalidExportOptionValue(configExports));
  }
  return configExports || "auto";
}
function rollup(rawInputOptions) {
  return rollupInternal(rawInputOptions, null);
}
async function rollupInternal(rawInputOptions, watcher) {
  const { options: inputOptions, unsetOptions: unsetInputOptions } = await getInputOptions(rawInputOptions, watcher !== null);
  initialiseTimers(inputOptions);
  await initWasm();
  const graph = new Graph(inputOptions, watcher);
  const useCache = rawInputOptions.cache !== false;
  if (rawInputOptions.cache) {
    inputOptions.cache = void 0;
    rawInputOptions.cache = void 0;
  }
  timeStart("BUILD", 1);
  await catchUnfinishedHookActions(graph.pluginDriver, async () => {
    try {
      timeStart("initialize", 2);
      await graph.pluginDriver.hookParallel("buildStart", [inputOptions]);
      timeEnd("initialize", 2);
      await graph.build();
    } catch (error_) {
      const watchFiles = Object.keys(graph.watchFiles);
      if (watchFiles.length > 0) {
        error_.watchFiles = watchFiles;
      }
      try {
        await graph.pluginDriver.hookParallel("buildEnd", [error_]);
      } catch (buildEndError) {
        const compoundError = getRollupError({
          ...error_,
          message: `There was an error during the build:
  ${error_.message}
Additionally, handling the error in the 'buildEnd' hook caused the following error:
  ${buildEndError.message}`
        });
        await graph.pluginDriver.hookParallel("closeBundle", [compoundError]);
        throw compoundError;
      }
      await graph.pluginDriver.hookParallel("closeBundle", [error_]);
      throw error_;
    }
    try {
      await graph.pluginDriver.hookParallel("buildEnd", []);
    } catch (buildEndError) {
      await graph.pluginDriver.hookParallel("closeBundle", [buildEndError]);
      throw buildEndError;
    }
  });
  timeEnd("BUILD", 1);
  const result = {
    cache: useCache ? graph.getCache() : void 0,
    async close() {
      if (result.closed)
        return;
      result.closed = true;
      await graph.pluginDriver.hookParallel("closeBundle", []);
    },
    closed: false,
    async [Symbol.asyncDispose]() {
      await this.close();
    },
    async generate(rawOutputOptions) {
      if (result.closed)
        return error3(logAlreadyClosed());
      return handleGenerateWrite(false, inputOptions, unsetInputOptions, rawOutputOptions, graph);
    },
    get watchFiles() {
      return Object.keys(graph.watchFiles);
    },
    async write(rawOutputOptions) {
      if (result.closed)
        return error3(logAlreadyClosed());
      return handleGenerateWrite(true, inputOptions, unsetInputOptions, rawOutputOptions, graph);
    }
  };
  if (inputOptions.perf)
    result.getTimings = getTimings;
  return result;
}
async function getInputOptions(initialInputOptions, watchMode) {
  if (!initialInputOptions) {
    throw new Error("You must supply an options object to rollup");
  }
  const processedInputOptions = await getProcessedInputOptions(initialInputOptions, watchMode);
  const { options, unsetOptions } = await normalizeInputOptions(processedInputOptions, watchMode);
  normalizePlugins(options.plugins, ANONYMOUS_PLUGIN_PREFIX);
  return { options, unsetOptions };
}
async function getProcessedInputOptions(inputOptions, watchMode) {
  const plugins = getSortedValidatedPlugins("options", await normalizePluginOption(inputOptions.plugins));
  const logLevel3 = inputOptions.logLevel || LOGLEVEL_INFO;
  const logger = getLogger(plugins, getOnLog(inputOptions, logLevel3), watchMode, logLevel3);
  for (const plugin of plugins) {
    const { name, options } = plugin;
    const handler = "handler" in options ? options.handler : options;
    const processedOptions = await handler.call({
      debug: getLogHandler(LOGLEVEL_DEBUG, "PLUGIN_LOG", logger, name, logLevel3),
      error: (error_) => error3(logPluginError(normalizeLog(error_), name, { hook: "onLog" })),
      info: getLogHandler(LOGLEVEL_INFO, "PLUGIN_LOG", logger, name, logLevel3),
      meta: { rollupVersion: version2, watchMode },
      warn: getLogHandler(LOGLEVEL_WARN, "PLUGIN_WARNING", logger, name, logLevel3)
    }, inputOptions);
    if (processedOptions) {
      inputOptions = processedOptions;
    }
  }
  return inputOptions;
}
function normalizePlugins(plugins, anonymousPrefix) {
  for (const [index, plugin] of plugins.entries()) {
    if (!plugin.name) {
      plugin.name = `${anonymousPrefix}${index + 1}`;
    }
  }
}
async function handleGenerateWrite(isWrite, inputOptions, unsetInputOptions, rawOutputOptions, graph) {
  const { options: outputOptions, outputPluginDriver, unsetOptions } = await getOutputOptionsAndPluginDriver(rawOutputOptions, graph.pluginDriver, inputOptions, unsetInputOptions);
  return catchUnfinishedHookActions(outputPluginDriver, async () => {
    const bundle = new Bundle2(outputOptions, unsetOptions, inputOptions, outputPluginDriver, graph);
    const generated = await bundle.generate(isWrite);
    if (isWrite) {
      timeStart("WRITE", 1);
      if (!outputOptions.dir && !outputOptions.file) {
        return error3(logMissingFileOrDirOption());
      }
      await Promise.all(Object.values(generated).map((chunk5) => graph.fileOperationQueue.run(() => writeOutputFile(chunk5, outputOptions))));
      await outputPluginDriver.hookParallel("writeBundle", [outputOptions, generated]);
      timeEnd("WRITE", 1);
    }
    return createOutput(generated);
  });
}
async function getOutputOptionsAndPluginDriver(rawOutputOptions, inputPluginDriver, inputOptions, unsetInputOptions) {
  if (!rawOutputOptions) {
    throw new Error("You must supply an options object");
  }
  const rawPlugins = await normalizePluginOption(rawOutputOptions.plugins);
  normalizePlugins(rawPlugins, ANONYMOUS_OUTPUT_PLUGIN_PREFIX);
  const outputPluginDriver = inputPluginDriver.createOutputPluginDriver(rawPlugins);
  return {
    ...await getOutputOptions(inputOptions, unsetInputOptions, rawOutputOptions, outputPluginDriver),
    outputPluginDriver
  };
}
function getOutputOptions(inputOptions, unsetInputOptions, rawOutputOptions, outputPluginDriver) {
  return normalizeOutputOptions(outputPluginDriver.hookReduceArg0Sync("outputOptions", [rawOutputOptions], (outputOptions, result) => result || outputOptions, (pluginContext2) => {
    const emitError = () => pluginContext2.error(logCannotEmitFromOptionsHook());
    return {
      ...pluginContext2,
      emitFile: emitError,
      setAssetSource: emitError
    };
  }), inputOptions, unsetInputOptions);
}
function createOutput(outputBundle) {
  return {
    output: Object.values(outputBundle).filter((outputFile) => Object.keys(outputFile).length > 0).sort((outputFileA, outputFileB) => getSortingFileType(outputFileA) - getSortingFileType(outputFileB))
  };
}
function getSortingFileType(file) {
  if (file.type === "asset") {
    return SortingFileType.ASSET;
  }
  if (file.isEntry) {
    return SortingFileType.ENTRY_CHUNK;
  }
  return SortingFileType.SECONDARY_CHUNK;
}
async function writeOutputFile(outputFile, outputOptions) {
  const fileName = p2.resolve(outputOptions.dir || p2.dirname(outputOptions.file), outputFile.fileName);
  await promises.mkdir(p2.dirname(fileName), { recursive: true });
  return promises.writeFile(fileName, outputFile.type === "asset" ? outputFile.source : outputFile.code);
}
function requirePicocolors() {
  if (hasRequiredPicocolors) return picocolors.exports;
  hasRequiredPicocolors = 1;
  let p3 = process || {}, argv = p3.argv || [], env2 = p3.env || {};
  let isColorSupported = !(!!env2.NO_COLOR || argv.includes("--no-color")) && (!!env2.FORCE_COLOR || argv.includes("--color") || p3.platform === "win32" || (p3.stdout || {}).isTTY && env2.TERM !== "dumb" || !!env2.CI);
  let formatter = (open, close2, replace2 = open) => (input2) => {
    let string4 = "" + input2, index = string4.indexOf(close2, open.length);
    return ~index ? open + replaceClose(string4, close2, replace2, index) + close2 : open + string4 + close2;
  };
  let replaceClose = (string4, close2, replace2, index) => {
    let result = "", cursor = 0;
    do {
      result += string4.substring(cursor, index) + replace2;
      cursor = index + close2.length;
      index = string4.indexOf(close2, cursor);
    } while (~index);
    return result + string4.substring(cursor);
  };
  let createColors = (enabled2 = isColorSupported) => {
    let f2 = enabled2 ? formatter : () => String;
    return {
      isColorSupported: enabled2,
      reset: f2("\x1B[0m", "\x1B[0m"),
      bold: f2("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: f2("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: f2("\x1B[3m", "\x1B[23m"),
      underline: f2("\x1B[4m", "\x1B[24m"),
      inverse: f2("\x1B[7m", "\x1B[27m"),
      hidden: f2("\x1B[8m", "\x1B[28m"),
      strikethrough: f2("\x1B[9m", "\x1B[29m"),
      black: f2("\x1B[30m", "\x1B[39m"),
      red: f2("\x1B[31m", "\x1B[39m"),
      green: f2("\x1B[32m", "\x1B[39m"),
      yellow: f2("\x1B[33m", "\x1B[39m"),
      blue: f2("\x1B[34m", "\x1B[39m"),
      magenta: f2("\x1B[35m", "\x1B[39m"),
      cyan: f2("\x1B[36m", "\x1B[39m"),
      white: f2("\x1B[37m", "\x1B[39m"),
      gray: f2("\x1B[90m", "\x1B[39m"),
      bgBlack: f2("\x1B[40m", "\x1B[49m"),
      bgRed: f2("\x1B[41m", "\x1B[49m"),
      bgGreen: f2("\x1B[42m", "\x1B[49m"),
      bgYellow: f2("\x1B[43m", "\x1B[49m"),
      bgBlue: f2("\x1B[44m", "\x1B[49m"),
      bgMagenta: f2("\x1B[45m", "\x1B[49m"),
      bgCyan: f2("\x1B[46m", "\x1B[49m"),
      bgWhite: f2("\x1B[47m", "\x1B[49m"),
      blackBright: f2("\x1B[90m", "\x1B[39m"),
      redBright: f2("\x1B[91m", "\x1B[39m"),
      greenBright: f2("\x1B[92m", "\x1B[39m"),
      yellowBright: f2("\x1B[93m", "\x1B[39m"),
      blueBright: f2("\x1B[94m", "\x1B[39m"),
      magentaBright: f2("\x1B[95m", "\x1B[39m"),
      cyanBright: f2("\x1B[96m", "\x1B[39m"),
      whiteBright: f2("\x1B[97m", "\x1B[39m"),
      bgBlackBright: f2("\x1B[100m", "\x1B[49m"),
      bgRedBright: f2("\x1B[101m", "\x1B[49m"),
      bgGreenBright: f2("\x1B[102m", "\x1B[49m"),
      bgYellowBright: f2("\x1B[103m", "\x1B[49m"),
      bgBlueBright: f2("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: f2("\x1B[105m", "\x1B[49m"),
      bgCyanBright: f2("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: f2("\x1B[107m", "\x1B[49m")
    };
  };
  picocolors.exports = createColors();
  picocolors.exports.createColors = createColors;
  return picocolors.exports;
}
var import_native2, version2, comma2, semicolon2, chars$1, intToChar2, charToInt2, bufLength2, td2, StringWriter2, StringReader2, BitSet, Chunk$1, btoa2, SourceMap2, toString3, wordRegex, Mappings, n, warned, MagicString, hasOwnProp, Bundle$1, NO_SEMICOLON, NON_WHITESPACE, WHITESPACE, UnknownKey, UnknownNonAccessorKey, UnknownInteger, SymbolToStringTag, EMPTY_PATH, UNKNOWN_PATH, UNKNOWN_NON_ACCESSOR_PATH, UNKNOWN_INTEGER_PATH, EntitiesKey, EntityPathTracker, SHARED_RECURSION_TRACKER, DiscriminatedPathTracker, UNKNOWN_INCLUDED_PATH, IncludedFullPathTracker, UNKNOWN_INCLUDED_TOP_LEVEL_PATH, IncludedTopLevelPathTracker, UnknownValue, UnknownTruthyValue, UnknownFalsyValue, ExpressionEntity, UNKNOWN_EXPRESSION, UNKNOWN_RETURN_EXPRESSION, deoptimizeInteraction, includeInteraction, INTERACTION_ACCESSED, INTERACTION_ASSIGNED, INTERACTION_CALLED, NODE_INTERACTION_UNKNOWN_ACCESS, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, NODE_INTERACTION_UNKNOWN_CALL, PureFunctionKey, getPureFunctions, Variable, ExternalVariable, RESERVED_NAMES, illegalCharacters, startsWithDigit, needsEscape, VALID_IDENTIFIER_REGEXP, NUMBER_REGEXP, ExternalModule, doNothing, childNodeKeys, INCLUDE_PARAMETERS, IS_SKIPPED_CHAIN, NodeBase, UNDEFINED_EXPRESSION, returnsUnknown, UNKNOWN_LITERAL_BOOLEAN, returnsBoolean, UNKNOWN_LITERAL_NUMBER, returnsNumber, UNKNOWN_LITERAL_STRING, returnsString, stringReplace, objectMembers, literalBooleanMembers, literalNumberMembers, literalRegExpMembers, literalStringMembers, Method, METHOD_RETURNS_BOOLEAN, METHOD_RETURNS_STRING, METHOD_RETURNS_NUMBER, METHOD_RETURNS_UNKNOWN, INTEGER_REG_EXP, ObjectEntity, isInteger, OBJECT_PROTOTYPE_FALLBACK, OBJECT_PROTOTYPE, NEW_ARRAY_PROPERTIES, METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN, METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER, METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY, METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY, METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY, METHOD_MUTATES_SELF_AND_ARGS_RETURNS_NUMBER, METHOD_MUTATES_SELF_RETURNS_UNKNOWN, METHOD_DEOPTS_SELF_RETURNS_UNKNOWN, METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN, METHOD_MUTATES_SELF_RETURNS_SELF, METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF, ARRAY_PROTOTYPE, SpreadElement, ArrayExpression, ValueProperties, getUnknownValue, returnFalse, returnTrue, PURE, IMPURE, PURE_WITH_ARRAY, GETTER_ACCESS, O, PF, PF_NO_GETTER, MUTATES_ARG_WITHOUT_ACCESSOR, C, PC, PC_WITH_ARRAY, ARRAY_TYPE, INTL_MEMBER, knownGlobals, GlobalVariable, MAX_PATH_DEPTH, limitConcatenatedPathDepth, LocalVariable, tdzVariableKinds, IdentifierBase, ObjectMember, Identifier2, chars2, base, Scope2, ChildScope, MethodBase, MethodDefinition, BlockScope, StaticBlock2, ClassNode, ClassDeclaration, ArgumentsVariable, MAX_TRACKED_INTERACTIONS, NO_INTERACTIONS, UNKNOWN_DEOPTIMIZED_FIELD, EMPTY_PATH_TRACKER, UNKNOWN_DEOPTIMIZED_ENTITY, ParameterVariable, ThisVariable, CatchBodyScope, FunctionBodyScope, ParameterScope, ReturnValueScope, FunctionScope, ExpressionStatement2, BlockStatement2, RestElement2, getIncludedPatternPath$1, FunctionBase, FunctionNode, FunctionDeclaration, ExportDefaultDeclaration2, needsEscapeRegEx, quoteNewlineRegEx, backSlashRegEx, INTEROP_DEFAULT_VARIABLE, INTEROP_DEFAULT_COMPAT_VARIABLE, INTEROP_NAMESPACE_VARIABLE, INTEROP_NAMESPACE_COMPAT_VARIABLE, INTEROP_NAMESPACE_DEFAULT_VARIABLE, INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE, MERGE_NAMESPACES_VARIABLE, DOCUMENT_CURRENT_SCRIPT, defaultInteropHelpersByInteropType, isDefaultAProperty, namespaceInteropHelpersByInteropType, canDefaultBeTakenFromNamespace, getHelpersBlock, HELPER_GENERATORS, getDefaultLiveBinding, getDefaultStatic, getIsCompatNamespace, createNamespaceObject, loopOverKeys, loopOverNamespaces, copyNonDefaultOwnPropertyLiveBinding, copyOwnPropertyLiveBinding, copyPropertyLiveBinding, copyPropertyStatic, getFrozen, getWithToStringTag, HELPER_NAMES, Literal2, MemberExpression, FILE_PREFIX, IMPORT, MetaProperty, formatsMaybeAccessDocumentCurrentScript, accessedMetaUrlGlobals, accessedFileUrlGlobals, getResolveUrl, getRelativeUrlFromDocument, getGenericImportMetaMechanism, getFileUrlFromFullPath, getFileUrlFromRelativePath, getUrlFromDocument, relativeUrlMechanisms, importMetaMechanisms, UndefinedVariable, ExportDefaultVariable, NamespaceVariable, SyntheticNamedExportVariable, ExternalChunk, getDefineProperty, builtinModules2, nodeBuiltins, keypath, MISSING_EXPORT_SHIM_VARIABLE, getStarExcludes, getStarExcludesBlock, getImportBindingsBlock, getHoistedExportsBlock, getSyntheticExportsBlock, getMissingExportsBlock, finalisers, extractors, extractAssignedNames, reservedWords2, builtins2, forbiddenIdentifiers2, ArrayPattern, getIncludedPatternPath, ArrowFunctionExpression2, ObjectPattern, AssignmentExpression, AssignmentPattern, AwaitExpression, THEN_PATH, binaryOperators, BinaryExpression, BreakStatement, CallExpressionBase, CallExpression2, CatchClause2, ChainExpression, ClassBodyScope, ClassBody, ClassExpression, MultiExpression, ConditionalExpression, ContinueStatement, DebuggerStatement, Decorator, DoWhileStatement, EmptyStatement, ExportAllDeclaration, ExportNamedDeclaration, ExportSpecifier, ForInStatement, ForOfStatement, ForStatement, FunctionExpression, TrackingScope, unset, IfStatement, ImportAttribute, ImportDeclaration, ImportDefaultSpecifier, VariableDeclarator2, ImportExpression, accessedImportGlobals, ImportNamespaceSpecifier, ImportSpecifier, JSXIdentifier, JSXAttribute, JSXClosingBase, JSXClosingElement, JSXClosingFragment, JSXSpreadAttribute, JSXEmptyExpression, JSXExpressionContainer, JSXElementBase, JSXElement, JSXFragment, JSXMemberExpression, JSXNamespacedName, JSXOpeningElement, JSXOpeningFragment, JSXSpreadChild, JSXText, LabeledStatement, LogicalExpression, NewExpression, ObjectExpression2, PanicError2, ParseError2, PrivateIdentifier, Program2, Property2, PropertyDefinition, ReturnStatement2, SequenceExpression, Super, SwitchCase, SwitchStatement, TaggedTemplateExpression, TemplateElement, TemplateLiteral2, ModuleScope, ThisExpression, ThrowStatement, TryStatement, unaryOperators, UNASSIGNED, UnaryExpression, CHARACTERS_THAT_DO_NOT_REQUIRE_SPACE, UpdateExpression, VariableDeclaration, WhileStatement, YieldExpression, nodeTypeStrings, nodeConstructors$1, bufferParsers, UnknownNode, nodeConstructors, ExportShimVariable, BuildPhase, sourceMapCache, ATTRIBUTE_KEYWORDS, getPropertyKey, timers, timeStart, timeEnd, TIMED_PLUGIN_HOOKS, MISSING_EXPORT_SHIM_DESCRIPTION, Module, copyNameToModulesMap, concatSeparator, concatDblSeparator, DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT, hashPlaceholderLeft, hashPlaceholderRight, hashPlaceholderOverhead, MAX_HASH_SIZE, DEFAULT_HASH_SIZE, getHashPlaceholderGenerator, REPLACER_REGEX, replacePlaceholders, replaceSinglePlaceholder, replacePlaceholdersWithDefaultAndGetContainedPlaceholders, lowercaseBundleKeys, FILE_PLACEHOLDER, getOutputBundle, removeUnreferencedAssets, NON_ASSET_EXTENSIONS, Chunk2, QUERY_HASH_REGEX, resolveFileName, compareExecIndex, wrapIfNeeded, Source, Link, textEncoder, getHash64, getHash36, getHash16, hasherByType, SOURCEMAPPING_URL, Bundle2, GlobalScope, ANONYMOUS_PLUGIN_PREFIX, ANONYMOUS_OUTPUT_PLUGIN_PREFIX, NO_CACHE, getOnLog, getDefaultOnLog, addLogToString, normalizeLog, defaultPrintLog, treeshakePresets, jsxPresets, generatedCodePresets, objectifyOption, objectifyOptionWithPresets, getOptionWithPreset, normalizePluginOption, RESOLVE_DEPENDENCIES, ModuleLoader, emittedFileTypes, FileEmitter, inputHookNames, inputHooks, PluginDriver, Queue, Graph, handleBeforeExit, rejectByPluginDriver, getCache, getIdMatcher, getInput, getJsx, getMaxParallelFileOps, getModuleContext, getTreeshake, getHasModuleSideEffects, INVALID_CHAR_REGEX, DRIVE_LETTER_REGEX, getFile, getFormat, getInlineDynamicImports, getPreserveModules, getPreserveModulesRoot, getAmd, getAddon, getDir, getEntryFileNames, getExternalImportAttributes, getGeneratedCode, getIndent, ALLOWED_INTEROP_TYPES, getInterop, validateInterop, getManualChunks, getMinifyInternalExports, getSourcemapFileNames, getSourcemapBaseUrl, SortingFileType, picocolors, hasRequiredPicocolors, picocolorsExports, pc, bold, cyan, dim, red;
var init_node_entry = __esm({
  "node_modules/.pnpm/@rollup+wasm-node@4.37.0/node_modules/@rollup/wasm-node/dist/es/shared/node-entry.js"() {
    init_parseAst();
    import_native2 = __toESM(require_native());
    version2 = "4.37.0";
    comma2 = ",".charCodeAt(0);
    semicolon2 = ";".charCodeAt(0);
    chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    intToChar2 = new Uint8Array(64);
    charToInt2 = new Uint8Array(128);
    for (let i = 0; i < chars$1.length; i++) {
      const c = chars$1.charCodeAt(i);
      intToChar2[i] = c;
      charToInt2[c] = i;
    }
    bufLength2 = 1024 * 16;
    td2 = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
      decode(buf) {
        const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
        return out.toString();
      }
    } : {
      decode(buf) {
        let out = "";
        for (let i = 0; i < buf.length; i++) {
          out += String.fromCharCode(buf[i]);
        }
        return out;
      }
    };
    StringWriter2 = class {
      constructor() {
        this.pos = 0;
        this.out = "";
        this.buffer = new Uint8Array(bufLength2);
      }
      write(v2) {
        const { buffer: buffer4 } = this;
        buffer4[this.pos++] = v2;
        if (this.pos === bufLength2) {
          this.out += td2.decode(buffer4);
          this.pos = 0;
        }
      }
      flush() {
        const { buffer: buffer4, out, pos } = this;
        return pos > 0 ? out + td2.decode(buffer4.subarray(0, pos)) : out;
      }
    };
    StringReader2 = class {
      constructor(buffer4) {
        this.pos = 0;
        this.buffer = buffer4;
      }
      next() {
        return this.buffer.charCodeAt(this.pos++);
      }
      peek() {
        return this.buffer.charCodeAt(this.pos);
      }
      indexOf(char) {
        const { buffer: buffer4, pos } = this;
        const idx = buffer4.indexOf(char, pos);
        return idx === -1 ? buffer4.length : idx;
      }
    };
    BitSet = class _BitSet {
      constructor(arg) {
        this.bits = arg instanceof _BitSet ? arg.bits.slice() : [];
      }
      add(n2) {
        this.bits[n2 >> 5] |= 1 << (n2 & 31);
      }
      has(n2) {
        return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
      }
    };
    Chunk$1 = class Chunk {
      constructor(start3, end6, content) {
        this.start = start3;
        this.end = end6;
        this.original = content;
        this.intro = "";
        this.outro = "";
        this.content = content;
        this.storeName = false;
        this.edited = false;
        {
          this.previous = null;
          this.next = null;
        }
      }
      appendLeft(content) {
        this.outro += content;
      }
      appendRight(content) {
        this.intro = this.intro + content;
      }
      clone() {
        const chunk5 = new Chunk(this.start, this.end, this.original);
        chunk5.intro = this.intro;
        chunk5.outro = this.outro;
        chunk5.content = this.content;
        chunk5.storeName = this.storeName;
        chunk5.edited = this.edited;
        return chunk5;
      }
      contains(index) {
        return this.start < index && index < this.end;
      }
      eachNext(fn2) {
        let chunk5 = this;
        while (chunk5) {
          fn2(chunk5);
          chunk5 = chunk5.next;
        }
      }
      eachPrevious(fn2) {
        let chunk5 = this;
        while (chunk5) {
          fn2(chunk5);
          chunk5 = chunk5.previous;
        }
      }
      edit(content, storeName, contentOnly) {
        this.content = content;
        if (!contentOnly) {
          this.intro = "";
          this.outro = "";
        }
        this.storeName = storeName;
        this.edited = true;
        return this;
      }
      prependLeft(content) {
        this.outro = content + this.outro;
      }
      prependRight(content) {
        this.intro = content + this.intro;
      }
      reset() {
        this.intro = "";
        this.outro = "";
        if (this.edited) {
          this.content = this.original;
          this.storeName = false;
          this.edited = false;
        }
      }
      split(index) {
        const sliceIndex = index - this.start;
        const originalBefore = this.original.slice(0, sliceIndex);
        const originalAfter = this.original.slice(sliceIndex);
        this.original = originalBefore;
        const newChunk = new Chunk(index, this.end, originalAfter);
        newChunk.outro = this.outro;
        this.outro = "";
        this.end = index;
        if (this.edited) {
          newChunk.edit("", false);
          this.content = "";
        } else {
          this.content = originalBefore;
        }
        newChunk.next = this.next;
        if (newChunk.next) newChunk.next.previous = newChunk;
        newChunk.previous = this;
        this.next = newChunk;
        return newChunk;
      }
      toString() {
        return this.intro + this.content + this.outro;
      }
      trimEnd(rx) {
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length) return true;
        const trimmed2 = this.content.replace(rx, "");
        if (trimmed2.length) {
          if (trimmed2 !== this.content) {
            this.split(this.start + trimmed2.length).edit("", void 0, true);
            if (this.edited) {
              this.edit(trimmed2, this.storeName, true);
            }
          }
          return true;
        } else {
          this.edit("", void 0, true);
          this.intro = this.intro.replace(rx, "");
          if (this.intro.length) return true;
        }
      }
      trimStart(rx) {
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length) return true;
        const trimmed2 = this.content.replace(rx, "");
        if (trimmed2.length) {
          if (trimmed2 !== this.content) {
            const newChunk = this.split(this.end - trimmed2.length);
            if (this.edited) {
              newChunk.edit(trimmed2, this.storeName, true);
            }
            this.edit("", void 0, true);
          }
          return true;
        } else {
          this.edit("", void 0, true);
          this.outro = this.outro.replace(rx, "");
          if (this.outro.length) return true;
        }
      }
    };
    btoa2 = /* @__PURE__ */ getBtoa();
    SourceMap2 = class {
      constructor(properties) {
        this.version = 3;
        this.file = properties.file;
        this.sources = properties.sources;
        this.sourcesContent = properties.sourcesContent;
        this.names = properties.names;
        this.mappings = encode2(properties.mappings);
        if (typeof properties.x_google_ignoreList !== "undefined") {
          this.x_google_ignoreList = properties.x_google_ignoreList;
        }
        if (typeof properties.debugId !== "undefined") {
          this.debugId = properties.debugId;
        }
      }
      toString() {
        return JSON.stringify(this);
      }
      toUrl() {
        return "data:application/json;charset=utf-8;base64," + btoa2(this.toString());
      }
    };
    toString3 = Object.prototype.toString;
    wordRegex = /\w/;
    Mappings = class {
      constructor(hires) {
        this.hires = hires;
        this.generatedCodeLine = 0;
        this.generatedCodeColumn = 0;
        this.raw = [];
        this.rawSegments = this.raw[this.generatedCodeLine] = [];
        this.pending = null;
      }
      addEdit(sourceIndex2, content, loc, nameIndex) {
        if (content.length) {
          const contentLengthMinusOne = content.length - 1;
          let contentLineEnd = content.indexOf("\n", 0);
          let previousContentLineEnd = -1;
          while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
            const segment2 = [this.generatedCodeColumn, sourceIndex2, loc.line, loc.column];
            if (nameIndex >= 0) {
              segment2.push(nameIndex);
            }
            this.rawSegments.push(segment2);
            this.generatedCodeLine += 1;
            this.raw[this.generatedCodeLine] = this.rawSegments = [];
            this.generatedCodeColumn = 0;
            previousContentLineEnd = contentLineEnd;
            contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
          }
          const segment = [this.generatedCodeColumn, sourceIndex2, loc.line, loc.column];
          if (nameIndex >= 0) {
            segment.push(nameIndex);
          }
          this.rawSegments.push(segment);
          this.advance(content.slice(previousContentLineEnd + 1));
        } else if (this.pending) {
          this.rawSegments.push(this.pending);
          this.advance(content);
        }
        this.pending = null;
      }
      addUneditedChunk(sourceIndex2, chunk5, original, loc, sourcemapLocations) {
        let originalCharIndex = chunk5.start;
        let first3 = true;
        let charInHiresBoundary = false;
        while (originalCharIndex < chunk5.end) {
          if (original[originalCharIndex] === "\n") {
            loc.line += 1;
            loc.column = 0;
            this.generatedCodeLine += 1;
            this.raw[this.generatedCodeLine] = this.rawSegments = [];
            this.generatedCodeColumn = 0;
            first3 = true;
            charInHiresBoundary = false;
          } else {
            if (this.hires || first3 || sourcemapLocations.has(originalCharIndex)) {
              const segment = [this.generatedCodeColumn, sourceIndex2, loc.line, loc.column];
              if (this.hires === "boundary") {
                if (wordRegex.test(original[originalCharIndex])) {
                  if (!charInHiresBoundary) {
                    this.rawSegments.push(segment);
                    charInHiresBoundary = true;
                  }
                } else {
                  this.rawSegments.push(segment);
                  charInHiresBoundary = false;
                }
              } else {
                this.rawSegments.push(segment);
              }
            }
            loc.column += 1;
            this.generatedCodeColumn += 1;
            first3 = false;
          }
          originalCharIndex += 1;
        }
        this.pending = null;
      }
      advance(str) {
        if (!str) return;
        const lines = str.split("\n");
        if (lines.length > 1) {
          for (let i = 0; i < lines.length - 1; i++) {
            this.generatedCodeLine++;
            this.raw[this.generatedCodeLine] = this.rawSegments = [];
          }
          this.generatedCodeColumn = 0;
        }
        this.generatedCodeColumn += lines[lines.length - 1].length;
      }
    };
    n = "\n";
    warned = {
      insertLeft: false,
      insertRight: false,
      storeName: false
    };
    MagicString = class _MagicString {
      constructor(string4, options = {}) {
        const chunk5 = new Chunk$1(0, string4.length, string4);
        Object.defineProperties(this, {
          original: { writable: true, value: string4 },
          outro: { writable: true, value: "" },
          intro: { writable: true, value: "" },
          firstChunk: { writable: true, value: chunk5 },
          lastChunk: { writable: true, value: chunk5 },
          lastSearchedChunk: { writable: true, value: chunk5 },
          byStart: { writable: true, value: {} },
          byEnd: { writable: true, value: {} },
          filename: { writable: true, value: options.filename },
          indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
          sourcemapLocations: { writable: true, value: new BitSet() },
          storedNames: { writable: true, value: {} },
          indentStr: { writable: true, value: void 0 },
          ignoreList: { writable: true, value: options.ignoreList },
          offset: { writable: true, value: options.offset || 0 }
        });
        this.byStart[0] = chunk5;
        this.byEnd[string4.length] = chunk5;
      }
      addSourcemapLocation(char) {
        this.sourcemapLocations.add(char);
      }
      append(content) {
        if (typeof content !== "string") throw new TypeError("outro content must be a string");
        this.outro += content;
        return this;
      }
      appendLeft(index, content) {
        index = index + this.offset;
        if (typeof content !== "string") throw new TypeError("inserted content must be a string");
        this._split(index);
        const chunk5 = this.byEnd[index];
        if (chunk5) {
          chunk5.appendLeft(content);
        } else {
          this.intro += content;
        }
        return this;
      }
      appendRight(index, content) {
        index = index + this.offset;
        if (typeof content !== "string") throw new TypeError("inserted content must be a string");
        this._split(index);
        const chunk5 = this.byStart[index];
        if (chunk5) {
          chunk5.appendRight(content);
        } else {
          this.outro += content;
        }
        return this;
      }
      clone() {
        const cloned = new _MagicString(this.original, { filename: this.filename, offset: this.offset });
        let originalChunk = this.firstChunk;
        let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
        while (originalChunk) {
          cloned.byStart[clonedChunk.start] = clonedChunk;
          cloned.byEnd[clonedChunk.end] = clonedChunk;
          const nextOriginalChunk = originalChunk.next;
          const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
          if (nextClonedChunk) {
            clonedChunk.next = nextClonedChunk;
            nextClonedChunk.previous = clonedChunk;
            clonedChunk = nextClonedChunk;
          }
          originalChunk = nextOriginalChunk;
        }
        cloned.lastChunk = clonedChunk;
        if (this.indentExclusionRanges) {
          cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
        }
        cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
        cloned.intro = this.intro;
        cloned.outro = this.outro;
        return cloned;
      }
      generateDecodedMap(options) {
        options = options || {};
        const sourceIndex2 = 0;
        const names = Object.keys(this.storedNames);
        const mappings = new Mappings(options.hires);
        const locate2 = getLocator2(this.original);
        if (this.intro) {
          mappings.advance(this.intro);
        }
        this.firstChunk.eachNext((chunk5) => {
          const loc = locate2(chunk5.start);
          if (chunk5.intro.length) mappings.advance(chunk5.intro);
          if (chunk5.edited) {
            mappings.addEdit(
              sourceIndex2,
              chunk5.content,
              loc,
              chunk5.storeName ? names.indexOf(chunk5.original) : -1
            );
          } else {
            mappings.addUneditedChunk(sourceIndex2, chunk5, this.original, loc, this.sourcemapLocations);
          }
          if (chunk5.outro.length) mappings.advance(chunk5.outro);
        });
        return {
          file: options.file ? options.file.split(/[/\\]/).pop() : void 0,
          sources: [
            options.source ? getRelativePath(options.file || "", options.source) : options.file || ""
          ],
          sourcesContent: options.includeContent ? [this.original] : void 0,
          names,
          mappings: mappings.raw,
          x_google_ignoreList: this.ignoreList ? [sourceIndex2] : void 0
        };
      }
      generateMap(options) {
        return new SourceMap2(this.generateDecodedMap(options));
      }
      _ensureindentStr() {
        if (this.indentStr === void 0) {
          this.indentStr = guessIndent(this.original);
        }
      }
      _getRawIndentString() {
        this._ensureindentStr();
        return this.indentStr;
      }
      getIndentString() {
        this._ensureindentStr();
        return this.indentStr === null ? "	" : this.indentStr;
      }
      indent(indentStr, options) {
        const pattern = /^[^\r\n]/gm;
        if (isObject3(indentStr)) {
          options = indentStr;
          indentStr = void 0;
        }
        if (indentStr === void 0) {
          this._ensureindentStr();
          indentStr = this.indentStr || "	";
        }
        if (indentStr === "") return this;
        options = options || {};
        const isExcluded = {};
        if (options.exclude) {
          const exclusions = typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude;
          exclusions.forEach((exclusion) => {
            for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
              isExcluded[i] = true;
            }
          });
        }
        let shouldIndentNextCharacter = options.indentStart !== false;
        const replacer = (match18) => {
          if (shouldIndentNextCharacter) return `${indentStr}${match18}`;
          shouldIndentNextCharacter = true;
          return match18;
        };
        this.intro = this.intro.replace(pattern, replacer);
        let charIndex = 0;
        let chunk5 = this.firstChunk;
        while (chunk5) {
          const end6 = chunk5.end;
          if (chunk5.edited) {
            if (!isExcluded[charIndex]) {
              chunk5.content = chunk5.content.replace(pattern, replacer);
              if (chunk5.content.length) {
                shouldIndentNextCharacter = chunk5.content[chunk5.content.length - 1] === "\n";
              }
            }
          } else {
            charIndex = chunk5.start;
            while (charIndex < end6) {
              if (!isExcluded[charIndex]) {
                const char = this.original[charIndex];
                if (char === "\n") {
                  shouldIndentNextCharacter = true;
                } else if (char !== "\r" && shouldIndentNextCharacter) {
                  shouldIndentNextCharacter = false;
                  if (charIndex === chunk5.start) {
                    chunk5.prependRight(indentStr);
                  } else {
                    this._splitChunk(chunk5, charIndex);
                    chunk5 = chunk5.next;
                    chunk5.prependRight(indentStr);
                  }
                }
              }
              charIndex += 1;
            }
          }
          charIndex = chunk5.end;
          chunk5 = chunk5.next;
        }
        this.outro = this.outro.replace(pattern, replacer);
        return this;
      }
      insert() {
        throw new Error(
          "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
        );
      }
      insertLeft(index, content) {
        if (!warned.insertLeft) {
          console.warn(
            "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
          );
          warned.insertLeft = true;
        }
        return this.appendLeft(index, content);
      }
      insertRight(index, content) {
        if (!warned.insertRight) {
          console.warn(
            "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
          );
          warned.insertRight = true;
        }
        return this.prependRight(index, content);
      }
      move(start3, end6, index) {
        start3 = start3 + this.offset;
        end6 = end6 + this.offset;
        index = index + this.offset;
        if (index >= start3 && index <= end6) throw new Error("Cannot move a selection inside itself");
        this._split(start3);
        this._split(end6);
        this._split(index);
        const first3 = this.byStart[start3];
        const last6 = this.byEnd[end6];
        const oldLeft = first3.previous;
        const oldRight = last6.next;
        const newRight = this.byStart[index];
        if (!newRight && last6 === this.lastChunk) return this;
        const newLeft = newRight ? newRight.previous : this.lastChunk;
        if (oldLeft) oldLeft.next = oldRight;
        if (oldRight) oldRight.previous = oldLeft;
        if (newLeft) newLeft.next = first3;
        if (newRight) newRight.previous = last6;
        if (!first3.previous) this.firstChunk = last6.next;
        if (!last6.next) {
          this.lastChunk = first3.previous;
          this.lastChunk.next = null;
        }
        first3.previous = newLeft;
        last6.next = newRight || null;
        if (!newLeft) this.firstChunk = first3;
        if (!newRight) this.lastChunk = last6;
        return this;
      }
      overwrite(start3, end6, content, options) {
        options = options || {};
        return this.update(start3, end6, content, { ...options, overwrite: !options.contentOnly });
      }
      update(start3, end6, content, options) {
        start3 = start3 + this.offset;
        end6 = end6 + this.offset;
        if (typeof content !== "string") throw new TypeError("replacement content must be a string");
        if (this.original.length !== 0) {
          while (start3 < 0) start3 += this.original.length;
          while (end6 < 0) end6 += this.original.length;
        }
        if (end6 > this.original.length) throw new Error("end is out of bounds");
        if (start3 === end6)
          throw new Error(
            "Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead"
          );
        this._split(start3);
        this._split(end6);
        if (options === true) {
          if (!warned.storeName) {
            console.warn(
              "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
            );
            warned.storeName = true;
          }
          options = { storeName: true };
        }
        const storeName = options !== void 0 ? options.storeName : false;
        const overwrite = options !== void 0 ? options.overwrite : false;
        if (storeName) {
          const original = this.original.slice(start3, end6);
          Object.defineProperty(this.storedNames, original, {
            writable: true,
            value: true,
            enumerable: true
          });
        }
        const first3 = this.byStart[start3];
        const last6 = this.byEnd[end6];
        if (first3) {
          let chunk5 = first3;
          while (chunk5 !== last6) {
            if (chunk5.next !== this.byStart[chunk5.end]) {
              throw new Error("Cannot overwrite across a split point");
            }
            chunk5 = chunk5.next;
            chunk5.edit("", false);
          }
          first3.edit(content, storeName, !overwrite);
        } else {
          const newChunk = new Chunk$1(start3, end6, "").edit(content, storeName);
          last6.next = newChunk;
          newChunk.previous = last6;
        }
        return this;
      }
      prepend(content) {
        if (typeof content !== "string") throw new TypeError("outro content must be a string");
        this.intro = content + this.intro;
        return this;
      }
      prependLeft(index, content) {
        index = index + this.offset;
        if (typeof content !== "string") throw new TypeError("inserted content must be a string");
        this._split(index);
        const chunk5 = this.byEnd[index];
        if (chunk5) {
          chunk5.prependLeft(content);
        } else {
          this.intro = content + this.intro;
        }
        return this;
      }
      prependRight(index, content) {
        index = index + this.offset;
        if (typeof content !== "string") throw new TypeError("inserted content must be a string");
        this._split(index);
        const chunk5 = this.byStart[index];
        if (chunk5) {
          chunk5.prependRight(content);
        } else {
          this.outro = content + this.outro;
        }
        return this;
      }
      remove(start3, end6) {
        start3 = start3 + this.offset;
        end6 = end6 + this.offset;
        if (this.original.length !== 0) {
          while (start3 < 0) start3 += this.original.length;
          while (end6 < 0) end6 += this.original.length;
        }
        if (start3 === end6) return this;
        if (start3 < 0 || end6 > this.original.length) throw new Error("Character is out of bounds");
        if (start3 > end6) throw new Error("end must be greater than start");
        this._split(start3);
        this._split(end6);
        let chunk5 = this.byStart[start3];
        while (chunk5) {
          chunk5.intro = "";
          chunk5.outro = "";
          chunk5.edit("");
          chunk5 = end6 > chunk5.end ? this.byStart[chunk5.end] : null;
        }
        return this;
      }
      reset(start3, end6) {
        start3 = start3 + this.offset;
        end6 = end6 + this.offset;
        if (this.original.length !== 0) {
          while (start3 < 0) start3 += this.original.length;
          while (end6 < 0) end6 += this.original.length;
        }
        if (start3 === end6) return this;
        if (start3 < 0 || end6 > this.original.length) throw new Error("Character is out of bounds");
        if (start3 > end6) throw new Error("end must be greater than start");
        this._split(start3);
        this._split(end6);
        let chunk5 = this.byStart[start3];
        while (chunk5) {
          chunk5.reset();
          chunk5 = end6 > chunk5.end ? this.byStart[chunk5.end] : null;
        }
        return this;
      }
      lastChar() {
        if (this.outro.length) return this.outro[this.outro.length - 1];
        let chunk5 = this.lastChunk;
        do {
          if (chunk5.outro.length) return chunk5.outro[chunk5.outro.length - 1];
          if (chunk5.content.length) return chunk5.content[chunk5.content.length - 1];
          if (chunk5.intro.length) return chunk5.intro[chunk5.intro.length - 1];
        } while (chunk5 = chunk5.previous);
        if (this.intro.length) return this.intro[this.intro.length - 1];
        return "";
      }
      lastLine() {
        let lineIndex = this.outro.lastIndexOf(n);
        if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
        let lineStr = this.outro;
        let chunk5 = this.lastChunk;
        do {
          if (chunk5.outro.length > 0) {
            lineIndex = chunk5.outro.lastIndexOf(n);
            if (lineIndex !== -1) return chunk5.outro.substr(lineIndex + 1) + lineStr;
            lineStr = chunk5.outro + lineStr;
          }
          if (chunk5.content.length > 0) {
            lineIndex = chunk5.content.lastIndexOf(n);
            if (lineIndex !== -1) return chunk5.content.substr(lineIndex + 1) + lineStr;
            lineStr = chunk5.content + lineStr;
          }
          if (chunk5.intro.length > 0) {
            lineIndex = chunk5.intro.lastIndexOf(n);
            if (lineIndex !== -1) return chunk5.intro.substr(lineIndex + 1) + lineStr;
            lineStr = chunk5.intro + lineStr;
          }
        } while (chunk5 = chunk5.previous);
        lineIndex = this.intro.lastIndexOf(n);
        if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
        return this.intro + lineStr;
      }
      slice(start3 = 0, end6 = this.original.length - this.offset) {
        start3 = start3 + this.offset;
        end6 = end6 + this.offset;
        if (this.original.length !== 0) {
          while (start3 < 0) start3 += this.original.length;
          while (end6 < 0) end6 += this.original.length;
        }
        let result = "";
        let chunk5 = this.firstChunk;
        while (chunk5 && (chunk5.start > start3 || chunk5.end <= start3)) {
          if (chunk5.start < end6 && chunk5.end >= end6) {
            return result;
          }
          chunk5 = chunk5.next;
        }
        if (chunk5 && chunk5.edited && chunk5.start !== start3)
          throw new Error(`Cannot use replaced character ${start3} as slice start anchor.`);
        const startChunk = chunk5;
        while (chunk5) {
          if (chunk5.intro && (startChunk !== chunk5 || chunk5.start === start3)) {
            result += chunk5.intro;
          }
          const containsEnd = chunk5.start < end6 && chunk5.end >= end6;
          if (containsEnd && chunk5.edited && chunk5.end !== end6)
            throw new Error(`Cannot use replaced character ${end6} as slice end anchor.`);
          const sliceStart = startChunk === chunk5 ? start3 - chunk5.start : 0;
          const sliceEnd = containsEnd ? chunk5.content.length + end6 - chunk5.end : chunk5.content.length;
          result += chunk5.content.slice(sliceStart, sliceEnd);
          if (chunk5.outro && (!containsEnd || chunk5.end === end6)) {
            result += chunk5.outro;
          }
          if (containsEnd) {
            break;
          }
          chunk5 = chunk5.next;
        }
        return result;
      }
      // TODO deprecate this? not really very useful
      snip(start3, end6) {
        const clone4 = this.clone();
        clone4.remove(0, start3);
        clone4.remove(end6, clone4.original.length);
        return clone4;
      }
      _split(index) {
        if (this.byStart[index] || this.byEnd[index]) return;
        let chunk5 = this.lastSearchedChunk;
        const searchForward = index > chunk5.end;
        while (chunk5) {
          if (chunk5.contains(index)) return this._splitChunk(chunk5, index);
          chunk5 = searchForward ? this.byStart[chunk5.end] : this.byEnd[chunk5.start];
        }
      }
      _splitChunk(chunk5, index) {
        if (chunk5.edited && chunk5.content.length) {
          const loc = getLocator2(this.original)(index);
          throw new Error(
            `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \u2013 "${chunk5.original}")`
          );
        }
        const newChunk = chunk5.split(index);
        this.byEnd[index] = chunk5;
        this.byStart[index] = newChunk;
        this.byEnd[newChunk.end] = newChunk;
        if (chunk5 === this.lastChunk) this.lastChunk = newChunk;
        this.lastSearchedChunk = chunk5;
        return true;
      }
      toString() {
        let str = this.intro;
        let chunk5 = this.firstChunk;
        while (chunk5) {
          str += chunk5.toString();
          chunk5 = chunk5.next;
        }
        return str + this.outro;
      }
      isEmpty() {
        let chunk5 = this.firstChunk;
        do {
          if (chunk5.intro.length && chunk5.intro.trim() || chunk5.content.length && chunk5.content.trim() || chunk5.outro.length && chunk5.outro.trim())
            return false;
        } while (chunk5 = chunk5.next);
        return true;
      }
      length() {
        let chunk5 = this.firstChunk;
        let length3 = 0;
        do {
          length3 += chunk5.intro.length + chunk5.content.length + chunk5.outro.length;
        } while (chunk5 = chunk5.next);
        return length3;
      }
      trimLines() {
        return this.trim("[\\r\\n]");
      }
      trim(charType) {
        return this.trimStart(charType).trimEnd(charType);
      }
      trimEndAborted(charType) {
        const rx = new RegExp((charType || "\\s") + "+$");
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length) return true;
        let chunk5 = this.lastChunk;
        do {
          const end6 = chunk5.end;
          const aborted = chunk5.trimEnd(rx);
          if (chunk5.end !== end6) {
            if (this.lastChunk === chunk5) {
              this.lastChunk = chunk5.next;
            }
            this.byEnd[chunk5.end] = chunk5;
            this.byStart[chunk5.next.start] = chunk5.next;
            this.byEnd[chunk5.next.end] = chunk5.next;
          }
          if (aborted) return true;
          chunk5 = chunk5.previous;
        } while (chunk5);
        return false;
      }
      trimEnd(charType) {
        this.trimEndAborted(charType);
        return this;
      }
      trimStartAborted(charType) {
        const rx = new RegExp("^" + (charType || "\\s") + "+");
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length) return true;
        let chunk5 = this.firstChunk;
        do {
          const end6 = chunk5.end;
          const aborted = chunk5.trimStart(rx);
          if (chunk5.end !== end6) {
            if (chunk5 === this.lastChunk) this.lastChunk = chunk5.next;
            this.byEnd[chunk5.end] = chunk5;
            this.byStart[chunk5.next.start] = chunk5.next;
            this.byEnd[chunk5.next.end] = chunk5.next;
          }
          if (aborted) return true;
          chunk5 = chunk5.next;
        } while (chunk5);
        return false;
      }
      trimStart(charType) {
        this.trimStartAborted(charType);
        return this;
      }
      hasChanged() {
        return this.original !== this.toString();
      }
      _replaceRegexp(searchValue, replacement) {
        function getReplacement(match18, str) {
          if (typeof replacement === "string") {
            return replacement.replace(/\$(\$|&|\d+)/g, (_2, i) => {
              if (i === "$") return "$";
              if (i === "&") return match18[0];
              const num = +i;
              if (num < match18.length) return match18[+i];
              return `$${i}`;
            });
          } else {
            return replacement(...match18, match18.index, str, match18.groups);
          }
        }
        function matchAll(re2, str) {
          let match18;
          const matches = [];
          while (match18 = re2.exec(str)) {
            matches.push(match18);
          }
          return matches;
        }
        if (searchValue.global) {
          const matches = matchAll(searchValue, this.original);
          matches.forEach((match18) => {
            if (match18.index != null) {
              const replacement2 = getReplacement(match18, this.original);
              if (replacement2 !== match18[0]) {
                this.overwrite(match18.index, match18.index + match18[0].length, replacement2);
              }
            }
          });
        } else {
          const match18 = this.original.match(searchValue);
          if (match18 && match18.index != null) {
            const replacement2 = getReplacement(match18, this.original);
            if (replacement2 !== match18[0]) {
              this.overwrite(match18.index, match18.index + match18[0].length, replacement2);
            }
          }
        }
        return this;
      }
      _replaceString(string4, replacement) {
        const { original } = this;
        const index = original.indexOf(string4);
        if (index !== -1) {
          this.overwrite(index, index + string4.length, replacement);
        }
        return this;
      }
      replace(searchValue, replacement) {
        if (typeof searchValue === "string") {
          return this._replaceString(searchValue, replacement);
        }
        return this._replaceRegexp(searchValue, replacement);
      }
      _replaceAllString(string4, replacement) {
        const { original } = this;
        const stringLength = string4.length;
        for (let index = original.indexOf(string4); index !== -1; index = original.indexOf(string4, index + stringLength)) {
          const previous2 = original.slice(index, index + stringLength);
          if (previous2 !== replacement) this.overwrite(index, index + stringLength, replacement);
        }
        return this;
      }
      replaceAll(searchValue, replacement) {
        if (typeof searchValue === "string") {
          return this._replaceAllString(searchValue, replacement);
        }
        if (!searchValue.global) {
          throw new TypeError(
            "MagicString.prototype.replaceAll called with a non-global RegExp argument"
          );
        }
        return this._replaceRegexp(searchValue, replacement);
      }
    };
    hasOwnProp = Object.prototype.hasOwnProperty;
    Bundle$1 = class Bundle {
      constructor(options = {}) {
        this.intro = options.intro || "";
        this.separator = options.separator !== void 0 ? options.separator : "\n";
        this.sources = [];
        this.uniqueSources = [];
        this.uniqueSourceIndexByFilename = {};
      }
      addSource(source) {
        if (source instanceof MagicString) {
          return this.addSource({
            content: source,
            filename: source.filename,
            separator: this.separator
          });
        }
        if (!isObject3(source) || !source.content) {
          throw new Error(
            "bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`"
          );
        }
        ["filename", "ignoreList", "indentExclusionRanges", "separator"].forEach((option5) => {
          if (!hasOwnProp.call(source, option5)) source[option5] = source.content[option5];
        });
        if (source.separator === void 0) {
          source.separator = this.separator;
        }
        if (source.filename) {
          if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
            this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
            this.uniqueSources.push({ filename: source.filename, content: source.content.original });
          } else {
            const uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
            if (source.content.original !== uniqueSource.content) {
              throw new Error(`Illegal source: same filename (${source.filename}), different contents`);
            }
          }
        }
        this.sources.push(source);
        return this;
      }
      append(str, options) {
        this.addSource({
          content: new MagicString(str),
          separator: options && options.separator || ""
        });
        return this;
      }
      clone() {
        const bundle = new Bundle({
          intro: this.intro,
          separator: this.separator
        });
        this.sources.forEach((source) => {
          bundle.addSource({
            filename: source.filename,
            content: source.content.clone(),
            separator: source.separator
          });
        });
        return bundle;
      }
      generateDecodedMap(options = {}) {
        const names = [];
        let x_google_ignoreList = void 0;
        this.sources.forEach((source) => {
          Object.keys(source.content.storedNames).forEach((name) => {
            if (!~names.indexOf(name)) names.push(name);
          });
        });
        const mappings = new Mappings(options.hires);
        if (this.intro) {
          mappings.advance(this.intro);
        }
        this.sources.forEach((source, i) => {
          if (i > 0) {
            mappings.advance(this.separator);
          }
          const sourceIndex2 = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;
          const magicString = source.content;
          const locate2 = getLocator2(magicString.original);
          if (magicString.intro) {
            mappings.advance(magicString.intro);
          }
          magicString.firstChunk.eachNext((chunk5) => {
            const loc = locate2(chunk5.start);
            if (chunk5.intro.length) mappings.advance(chunk5.intro);
            if (source.filename) {
              if (chunk5.edited) {
                mappings.addEdit(
                  sourceIndex2,
                  chunk5.content,
                  loc,
                  chunk5.storeName ? names.indexOf(chunk5.original) : -1
                );
              } else {
                mappings.addUneditedChunk(
                  sourceIndex2,
                  chunk5,
                  magicString.original,
                  loc,
                  magicString.sourcemapLocations
                );
              }
            } else {
              mappings.advance(chunk5.content);
            }
            if (chunk5.outro.length) mappings.advance(chunk5.outro);
          });
          if (magicString.outro) {
            mappings.advance(magicString.outro);
          }
          if (source.ignoreList && sourceIndex2 !== -1) {
            if (x_google_ignoreList === void 0) {
              x_google_ignoreList = [];
            }
            x_google_ignoreList.push(sourceIndex2);
          }
        });
        return {
          file: options.file ? options.file.split(/[/\\]/).pop() : void 0,
          sources: this.uniqueSources.map((source) => {
            return options.file ? getRelativePath(options.file, source.filename) : source.filename;
          }),
          sourcesContent: this.uniqueSources.map((source) => {
            return options.includeContent ? source.content : null;
          }),
          names,
          mappings: mappings.raw,
          x_google_ignoreList
        };
      }
      generateMap(options) {
        return new SourceMap2(this.generateDecodedMap(options));
      }
      getIndentString() {
        const indentStringCounts = {};
        this.sources.forEach((source) => {
          const indentStr = source.content._getRawIndentString();
          if (indentStr === null) return;
          if (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;
          indentStringCounts[indentStr] += 1;
        });
        return Object.keys(indentStringCounts).sort((a2, b) => {
          return indentStringCounts[a2] - indentStringCounts[b];
        })[0] || "	";
      }
      indent(indentStr) {
        if (!arguments.length) {
          indentStr = this.getIndentString();
        }
        if (indentStr === "") return this;
        let trailingNewline = !this.intro || this.intro.slice(-1) === "\n";
        this.sources.forEach((source, i) => {
          const separator = source.separator !== void 0 ? source.separator : this.separator;
          const indentStart = trailingNewline || i > 0 && /\r?\n$/.test(separator);
          source.content.indent(indentStr, {
            exclude: source.indentExclusionRanges,
            indentStart
            //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
          });
          trailingNewline = source.content.lastChar() === "\n";
        });
        if (this.intro) {
          this.intro = indentStr + this.intro.replace(/^[^\n]/gm, (match18, index) => {
            return index > 0 ? indentStr + match18 : match18;
          });
        }
        return this;
      }
      prepend(str) {
        this.intro = str + this.intro;
        return this;
      }
      toString() {
        const body = this.sources.map((source, i) => {
          const separator = source.separator !== void 0 ? source.separator : this.separator;
          const str = (i > 0 ? separator : "") + source.content.toString();
          return str;
        }).join("");
        return this.intro + body;
      }
      isEmpty() {
        if (this.intro.length && this.intro.trim()) return false;
        if (this.sources.some((source) => !source.content.isEmpty())) return false;
        return true;
      }
      length() {
        return this.sources.reduce(
          (length3, source) => length3 + source.content.length(),
          this.intro.length
        );
      }
      trimLines() {
        return this.trim("[\\r\\n]");
      }
      trim(charType) {
        return this.trimStart(charType).trimEnd(charType);
      }
      trimStart(charType) {
        const rx = new RegExp("^" + (charType || "\\s") + "+");
        this.intro = this.intro.replace(rx, "");
        if (!this.intro) {
          let source;
          let i = 0;
          do {
            source = this.sources[i++];
            if (!source) {
              break;
            }
          } while (!source.content.trimStartAborted(charType));
        }
        return this;
      }
      trimEnd(charType) {
        const rx = new RegExp((charType || "\\s") + "+$");
        let source;
        let i = this.sources.length - 1;
        do {
          source = this.sources[i--];
          if (!source) {
            this.intro = this.intro.replace(rx, "");
            break;
          }
        } while (!source.content.trimEndAborted(charType));
        return this;
      }
    };
    NO_SEMICOLON = { isNoStatement: true };
    NON_WHITESPACE = /\S/g;
    WHITESPACE = /\s/;
    UnknownKey = Symbol("Unknown Key");
    UnknownNonAccessorKey = Symbol("Unknown Non-Accessor Key");
    UnknownInteger = Symbol("Unknown Integer");
    SymbolToStringTag = Symbol("Symbol.toStringTag");
    EMPTY_PATH = [];
    UNKNOWN_PATH = [UnknownKey];
    UNKNOWN_NON_ACCESSOR_PATH = [UnknownNonAccessorKey];
    UNKNOWN_INTEGER_PATH = [UnknownInteger];
    EntitiesKey = Symbol("Entities");
    EntityPathTracker = class {
      constructor() {
        this.entityPaths = Object.create(null, {
          [EntitiesKey]: { value: /* @__PURE__ */ new Set() }
        });
      }
      trackEntityAtPathAndGetIfTracked(path3, entity) {
        const trackedEntities = this.getEntities(path3);
        if (trackedEntities.has(entity))
          return true;
        trackedEntities.add(entity);
        return false;
      }
      withTrackedEntityAtPath(path3, entity, onUntracked, returnIfTracked) {
        const trackedEntities = this.getEntities(path3);
        if (trackedEntities.has(entity))
          return returnIfTracked;
        trackedEntities.add(entity);
        const result = onUntracked();
        trackedEntities.delete(entity);
        return result;
      }
      getEntities(path3) {
        let currentPaths = this.entityPaths;
        for (const pathSegment of path3) {
          currentPaths = currentPaths[pathSegment] ||= Object.create(null, {
            [EntitiesKey]: { value: /* @__PURE__ */ new Set() }
          });
        }
        return currentPaths[EntitiesKey];
      }
    };
    SHARED_RECURSION_TRACKER = new EntityPathTracker();
    DiscriminatedPathTracker = class {
      constructor() {
        this.entityPaths = Object.create(null, {
          [EntitiesKey]: { value: /* @__PURE__ */ new Map() }
        });
      }
      trackEntityAtPathAndGetIfTracked(path3, discriminator, entity) {
        let currentPaths = this.entityPaths;
        for (const pathSegment of path3) {
          currentPaths = currentPaths[pathSegment] ||= Object.create(null, {
            [EntitiesKey]: { value: /* @__PURE__ */ new Map() }
          });
        }
        const trackedEntities = getOrCreate(currentPaths[EntitiesKey], discriminator, getNewSet);
        if (trackedEntities.has(entity))
          return true;
        trackedEntities.add(entity);
        return false;
      }
    };
    UNKNOWN_INCLUDED_PATH = Object.freeze({ [UnknownKey]: EMPTY_OBJECT });
    IncludedFullPathTracker = class {
      constructor() {
        this.includedPaths = null;
      }
      includePathAndGetIfIncluded(path3) {
        let included = true;
        let parent = this;
        let parentSegment = "includedPaths";
        let currentPaths = this.includedPaths ||= (included = false, /* @__PURE__ */ Object.create(null));
        for (const pathSegment of path3) {
          if (currentPaths[UnknownKey]) {
            return true;
          }
          if (typeof pathSegment === "symbol") {
            parent[parentSegment] = UNKNOWN_INCLUDED_PATH;
            return false;
          }
          parent = currentPaths;
          parentSegment = pathSegment;
          currentPaths = currentPaths[pathSegment] ||= (included = false, /* @__PURE__ */ Object.create(null));
        }
        return included;
      }
    };
    UNKNOWN_INCLUDED_TOP_LEVEL_PATH = Object.freeze({
      [UnknownKey]: true
    });
    IncludedTopLevelPathTracker = class {
      constructor() {
        this.includedPaths = null;
      }
      includePathAndGetIfIncluded(path3) {
        let included = true;
        const includedPaths = this.includedPaths ||= (included = false, /* @__PURE__ */ Object.create(null));
        if (includedPaths[UnknownKey]) {
          return true;
        }
        const [firstPathSegment, secondPathSegment] = path3;
        if (!firstPathSegment) {
          return included;
        }
        if (typeof firstPathSegment === "symbol") {
          this.includedPaths = UNKNOWN_INCLUDED_TOP_LEVEL_PATH;
          return false;
        }
        if (secondPathSegment) {
          if (includedPaths[firstPathSegment] === UnknownKey) {
            return true;
          }
          includedPaths[firstPathSegment] = UnknownKey;
          return false;
        }
        if (includedPaths[firstPathSegment]) {
          return true;
        }
        includedPaths[firstPathSegment] = true;
        return false;
      }
      includeAllPaths(entity, context8, basePath) {
        const { includedPaths } = this;
        if (includedPaths) {
          if (includedPaths[UnknownKey]) {
            entity.includePath([...basePath, UnknownKey], context8);
          } else {
            const inclusionEntries = Object.entries(includedPaths);
            if (inclusionEntries.length === 0) {
              entity.includePath(basePath, context8);
            } else {
              for (const [key, value] of inclusionEntries) {
                entity.includePath(value === UnknownKey ? [...basePath, key, UnknownKey] : [...basePath, key], context8);
              }
            }
          }
        }
      }
    };
    UnknownValue = Symbol("Unknown Value");
    UnknownTruthyValue = Symbol("Unknown Truthy Value");
    UnknownFalsyValue = Symbol("Unknown Falsy Value");
    ExpressionEntity = class {
      constructor() {
        this.flags = 0;
      }
      get included() {
        return isFlagSet(
          this.flags,
          1
          /* Flag.included */
        );
      }
      set included(value) {
        this.flags = setFlag(this.flags, 1, value);
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, _path, _recursionTracker) {
        deoptimizeInteraction(interaction);
      }
      deoptimizePath(_path) {
      }
      /**
       * If possible it returns a stringifyable literal value for this node that
       * can be used for inlining or comparing values. Otherwise, it should return
       * UnknownValue.
       */
      getLiteralValueAtPath(_path, _recursionTracker, _origin) {
        return UnknownValue;
      }
      getReturnExpressionWhenCalledAtPath(_path, _interaction, _recursionTracker, _origin) {
        return UNKNOWN_RETURN_EXPRESSION;
      }
      hasEffectsOnInteractionAtPath(_path, _interaction, _context) {
        return true;
      }
      include(context8, _includeChildrenRecursively, _options) {
        if (!this.included)
          this.includeNode(context8);
      }
      includeNode(_context) {
        this.included = true;
      }
      includePath(_path, context8) {
        if (!this.included)
          this.includeNode(context8);
      }
      /* We are both including and including an unknown path here as the former
       * ensures that nested nodes are included while the latter ensures that all
       * paths of the expression are included.
       * */
      includeCallArguments(interaction, context8) {
        includeInteraction(interaction, context8);
      }
      shouldBeIncluded(_context) {
        return true;
      }
    };
    UNKNOWN_EXPRESSION = new class UnknownExpression extends ExpressionEntity {
    }();
    UNKNOWN_RETURN_EXPRESSION = [
      UNKNOWN_EXPRESSION,
      false
    ];
    deoptimizeInteraction = (interaction) => {
      for (const argument of interaction.args) {
        argument?.deoptimizePath(UNKNOWN_PATH);
      }
    };
    includeInteraction = ({ args: args2 }, context8) => {
      args2[0]?.includePath(UNKNOWN_PATH, context8);
      for (let argumentIndex = 1; argumentIndex < args2.length; argumentIndex++) {
        const argument = args2[argumentIndex];
        if (argument) {
          argument.includePath(UNKNOWN_PATH, context8);
          argument.include(context8, false);
        }
      }
    };
    INTERACTION_ACCESSED = 0;
    INTERACTION_ASSIGNED = 1;
    INTERACTION_CALLED = 2;
    NODE_INTERACTION_UNKNOWN_ACCESS = {
      args: [null],
      type: INTERACTION_ACCESSED
    };
    NODE_INTERACTION_UNKNOWN_ASSIGNMENT = {
      args: [null, UNKNOWN_EXPRESSION],
      type: INTERACTION_ASSIGNED
    };
    NODE_INTERACTION_UNKNOWN_CALL = {
      args: [null],
      type: INTERACTION_CALLED,
      withNew: false
    };
    PureFunctionKey = Symbol("PureFunction");
    getPureFunctions = ({ treeshake }) => {
      const pureFunctions = /* @__PURE__ */ Object.create(null);
      for (const functionName of treeshake ? treeshake.manualPureFunctions : []) {
        let currentFunctions = pureFunctions;
        for (const pathSegment of functionName.split(".")) {
          currentFunctions = currentFunctions[pathSegment] ||= /* @__PURE__ */ Object.create(null);
        }
        currentFunctions[PureFunctionKey] = true;
      }
      return pureFunctions;
    };
    Variable = class extends ExpressionEntity {
      markReassigned() {
        this.isReassigned = true;
      }
      constructor(name) {
        super();
        this.name = name;
        this.alwaysRendered = false;
        this.forbiddenNames = null;
        this.globalName = null;
        this.initReached = false;
        this.isId = false;
        this.kind = null;
        this.renderBaseName = null;
        this.renderName = null;
        this.isReassigned = false;
        this.onlyFunctionCallUsed = true;
      }
      /**
       * Binds identifiers that reference this variable to this variable.
       * Necessary to be able to change variable names.
       */
      addReference(_identifier) {
      }
      /**
       * Check if the identifier variable is only used as function call
       * @returns true if the variable is only used as function call
       */
      getOnlyFunctionCallUsed() {
        return this.onlyFunctionCallUsed;
      }
      /**
       * Collect the places where the identifier variable is used
       * @param usedPlace Where the variable is used
       */
      addUsedPlace(usedPlace) {
        const isFunctionCall = usedPlace.parent.type === CallExpression && usedPlace.parent.callee === usedPlace;
        if (!isFunctionCall && usedPlace.parent.type !== ExportDefaultDeclaration) {
          this.onlyFunctionCallUsed = false;
        }
      }
      /**
       * Prevent this variable from being renamed to this name to avoid name
       * collisions
       */
      forbidName(name) {
        (this.forbiddenNames ||= /* @__PURE__ */ new Set()).add(name);
      }
      getBaseVariableName() {
        return this.renderedLikeHoisted?.getBaseVariableName() || this.renderBaseName || this.renderName || this.name;
      }
      getName(getPropertyAccess, useOriginalName) {
        if (this.globalName) {
          return this.globalName;
        }
        if (useOriginalName?.(this)) {
          return this.name;
        }
        if (this.renderedLikeHoisted) {
          return this.renderedLikeHoisted.getName(getPropertyAccess, useOriginalName);
        }
        const name = this.renderName || this.name;
        return this.renderBaseName ? `${this.renderBaseName}${getPropertyAccess(name)}` : name;
      }
      hasEffectsOnInteractionAtPath(path3, { type }, _context) {
        return type !== INTERACTION_ACCESSED || path3.length > 0;
      }
      /**
       * Marks this variable as being part of the bundle, which is usually the case
       * when one of its identifiers becomes part of the bundle. Returns true if it
       * has not been included previously. Once a variable is included, it should
       * take care all its declarations are included.
       */
      includePath(path3, context8) {
        this.included = true;
        this.renderedLikeHoisted?.includePath(path3, context8);
      }
      /**
       * Links the rendered name of this variable to another variable and includes
       * this variable if the other variable is included.
       */
      renderLikeHoisted(variable) {
        this.renderedLikeHoisted = variable;
      }
      markCalledFromTryStatement() {
      }
      setRenderNames(baseName, name) {
        this.renderBaseName = baseName;
        this.renderName = name;
      }
    };
    ExternalVariable = class extends Variable {
      constructor(module, name) {
        super(name);
        this.referenced = false;
        this.module = module;
        this.isNamespace = name === "*";
      }
      addReference(identifier4) {
        this.referenced = true;
        if (this.name === "default" || this.name === "*") {
          this.module.suggestName(identifier4.name);
        }
      }
      hasEffectsOnInteractionAtPath(path3, { type }) {
        return type !== INTERACTION_ACCESSED || path3.length > (this.isNamespace ? 1 : 0);
      }
      includePath(path3, context8) {
        super.includePath(path3, context8);
        this.module.used = true;
      }
    };
    RESERVED_NAMES = /* @__PURE__ */ new Set([
      "await",
      "break",
      "case",
      "catch",
      "class",
      "const",
      "continue",
      "debugger",
      "default",
      "delete",
      "do",
      "else",
      "enum",
      "eval",
      "export",
      "extends",
      "false",
      "finally",
      "for",
      "function",
      "if",
      "implements",
      "import",
      "in",
      "instanceof",
      "interface",
      "let",
      "NaN",
      "new",
      "null",
      "package",
      "private",
      "protected",
      "public",
      "return",
      "static",
      "super",
      "switch",
      "this",
      "throw",
      "true",
      "try",
      "typeof",
      "undefined",
      "var",
      "void",
      "while",
      "with",
      "yield"
    ]);
    illegalCharacters = /[^\w$]/g;
    startsWithDigit = (value) => /\d/.test(value[0]);
    needsEscape = (value) => startsWithDigit(value) || RESERVED_NAMES.has(value) || value === "arguments";
    VALID_IDENTIFIER_REGEXP = /^[$_\p{ID_Start}][$\u200C\u200D\p{ID_Continue}]*$/u;
    NUMBER_REGEXP = /^(?:0|[1-9]\d*)$/;
    ExternalModule = class {
      constructor(options, id2, moduleSideEffects, meta, renormalizeRenderPath, attributes) {
        this.options = options;
        this.id = id2;
        this.renormalizeRenderPath = renormalizeRenderPath;
        this.dynamicImporters = [];
        this.execIndex = Infinity;
        this.exportedVariables = /* @__PURE__ */ new Map();
        this.importers = [];
        this.reexported = false;
        this.used = false;
        this.declarations = /* @__PURE__ */ new Map();
        this.mostCommonSuggestion = 0;
        this.nameSuggestions = /* @__PURE__ */ new Map();
        this.suggestedVariableName = makeLegal(id2.split(/[/\\]/).pop());
        const { importers, dynamicImporters } = this;
        this.info = {
          ast: null,
          attributes,
          code: null,
          dynamicallyImportedIdResolutions: EMPTY_ARRAY,
          dynamicallyImportedIds: EMPTY_ARRAY,
          get dynamicImporters() {
            return dynamicImporters.sort();
          },
          exportedBindings: null,
          exports: null,
          hasDefaultExport: null,
          id: id2,
          implicitlyLoadedAfterOneOf: EMPTY_ARRAY,
          implicitlyLoadedBefore: EMPTY_ARRAY,
          importedIdResolutions: EMPTY_ARRAY,
          importedIds: EMPTY_ARRAY,
          get importers() {
            return importers.sort();
          },
          isEntry: false,
          isExternal: true,
          isIncluded: null,
          meta,
          moduleSideEffects,
          syntheticNamedExports: false
        };
      }
      cacheInfoGetters() {
        cacheObjectGetters(this.info, ["dynamicImporters", "importers"]);
      }
      getVariableForExportName(name) {
        const declaration = this.declarations.get(name);
        if (declaration)
          return [declaration];
        const externalVariable = new ExternalVariable(this, name);
        this.declarations.set(name, externalVariable);
        this.exportedVariables.set(externalVariable, name);
        return [externalVariable];
      }
      suggestName(name) {
        const value = (this.nameSuggestions.get(name) ?? 0) + 1;
        this.nameSuggestions.set(name, value);
        if (value > this.mostCommonSuggestion) {
          this.mostCommonSuggestion = value;
          this.suggestedVariableName = name;
        }
      }
      warnUnusedImports() {
        const unused = [...this.declarations].filter(([name, declaration]) => name !== "*" && !declaration.included && !this.reexported && !declaration.referenced).map(([name]) => name);
        if (unused.length === 0)
          return;
        const importersSet = /* @__PURE__ */ new Set();
        for (const name of unused) {
          for (const importer of this.declarations.get(name).module.importers) {
            importersSet.add(importer);
          }
        }
        const importersArray = [...importersSet];
        this.options.onLog(LOGLEVEL_WARN, logUnusedExternalImports(this.id, unused, importersArray));
      }
    };
    doNothing = () => {
    };
    childNodeKeys = {
      ArrayExpression: ["elements"],
      ArrayPattern: ["elements"],
      ArrowFunctionExpression: ["params", "body"],
      AssignmentExpression: ["left", "right"],
      AssignmentPattern: ["left", "right"],
      AwaitExpression: ["argument"],
      BinaryExpression: ["left", "right"],
      BlockStatement: ["body"],
      BreakStatement: ["label"],
      CallExpression: ["callee", "arguments"],
      CatchClause: ["param", "body"],
      ChainExpression: ["expression"],
      ClassBody: ["body"],
      ClassDeclaration: ["decorators", "id", "superClass", "body"],
      ClassExpression: ["decorators", "id", "superClass", "body"],
      ConditionalExpression: ["test", "consequent", "alternate"],
      ContinueStatement: ["label"],
      DebuggerStatement: [],
      Decorator: ["expression"],
      DoWhileStatement: ["body", "test"],
      EmptyStatement: [],
      ExportAllDeclaration: ["exported", "source", "attributes"],
      ExportDefaultDeclaration: ["declaration"],
      ExportNamedDeclaration: ["specifiers", "source", "attributes", "declaration"],
      ExportSpecifier: ["local", "exported"],
      ExpressionStatement: ["expression"],
      ForInStatement: ["left", "right", "body"],
      ForOfStatement: ["left", "right", "body"],
      ForStatement: ["init", "test", "update", "body"],
      FunctionDeclaration: ["id", "params", "body"],
      FunctionExpression: ["id", "params", "body"],
      Identifier: [],
      IfStatement: ["test", "consequent", "alternate"],
      ImportAttribute: ["key", "value"],
      ImportDeclaration: ["specifiers", "source", "attributes"],
      ImportDefaultSpecifier: ["local"],
      ImportExpression: ["source", "options"],
      ImportNamespaceSpecifier: ["local"],
      ImportSpecifier: ["imported", "local"],
      JSXAttribute: ["name", "value"],
      JSXClosingElement: ["name"],
      JSXClosingFragment: [],
      JSXElement: ["openingElement", "children", "closingElement"],
      JSXEmptyExpression: [],
      JSXExpressionContainer: ["expression"],
      JSXFragment: ["openingFragment", "children", "closingFragment"],
      JSXIdentifier: [],
      JSXMemberExpression: ["object", "property"],
      JSXNamespacedName: ["namespace", "name"],
      JSXOpeningElement: ["name", "attributes"],
      JSXOpeningFragment: [],
      JSXSpreadAttribute: ["argument"],
      JSXSpreadChild: ["expression"],
      JSXText: [],
      LabeledStatement: ["label", "body"],
      Literal: [],
      LogicalExpression: ["left", "right"],
      MemberExpression: ["object", "property"],
      MetaProperty: ["meta", "property"],
      MethodDefinition: ["decorators", "key", "value"],
      NewExpression: ["callee", "arguments"],
      ObjectExpression: ["properties"],
      ObjectPattern: ["properties"],
      PanicError: [],
      ParseError: [],
      PrivateIdentifier: [],
      Program: ["body"],
      Property: ["key", "value"],
      PropertyDefinition: ["decorators", "key", "value"],
      RestElement: ["argument"],
      ReturnStatement: ["argument"],
      SequenceExpression: ["expressions"],
      SpreadElement: ["argument"],
      StaticBlock: ["body"],
      Super: [],
      SwitchCase: ["test", "consequent"],
      SwitchStatement: ["discriminant", "cases"],
      TaggedTemplateExpression: ["tag", "quasi"],
      TemplateElement: [],
      TemplateLiteral: ["quasis", "expressions"],
      ThisExpression: [],
      ThrowStatement: ["argument"],
      TryStatement: ["block", "handler", "finalizer"],
      UnaryExpression: ["argument"],
      UpdateExpression: ["argument"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id", "init"],
      WhileStatement: ["test", "body"],
      YieldExpression: ["argument"]
    };
    INCLUDE_PARAMETERS = "variables";
    IS_SKIPPED_CHAIN = Symbol("IS_SKIPPED_CHAIN");
    NodeBase = class extends ExpressionEntity {
      /**
       * Nodes can apply custom deoptimizations once they become part of the
       * executed code. To do this, they must initialize this as false, implement
       * applyDeoptimizations and call this from include and hasEffects if they have
       * custom handlers
       */
      get deoptimized() {
        return isFlagSet(
          this.flags,
          2
          /* Flag.deoptimized */
        );
      }
      set deoptimized(value) {
        this.flags = setFlag(this.flags, 2, value);
      }
      constructor(parent, parentScope) {
        super();
        this.parent = parent;
        this.scope = parentScope;
        this.createScope(parentScope);
      }
      addExportedVariables(_variables, _exportNamesByVariable) {
      }
      /**
       * Override this to bind assignments to variables and do any initialisations
       * that require the scopes to be populated with variables.
       */
      bind() {
        for (const key of childNodeKeys[this.type]) {
          const value = this[key];
          if (Array.isArray(value)) {
            for (const child of value) {
              child?.bind();
            }
          } else if (value) {
            value.bind();
          }
        }
      }
      /**
       * Override if this node should receive a different scope than the parent
       * scope.
       */
      createScope(parentScope) {
        this.scope = parentScope;
      }
      hasEffects(context8) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        for (const key of childNodeKeys[this.type]) {
          const value = this[key];
          if (value === null)
            continue;
          if (Array.isArray(value)) {
            for (const child of value) {
              if (child?.hasEffects(context8))
                return true;
            }
          } else if (value.hasEffects(context8))
            return true;
        }
        return false;
      }
      hasEffectsAsAssignmentTarget(context8, _checkAccess) {
        return this.hasEffects(context8) || this.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.assignmentInteraction, context8);
      }
      include(context8, includeChildrenRecursively, _options) {
        if (!this.included)
          this.includeNode(context8);
        for (const key of childNodeKeys[this.type]) {
          const value = this[key];
          if (value === null)
            continue;
          if (Array.isArray(value)) {
            for (const child of value) {
              child?.include(context8, includeChildrenRecursively);
            }
          } else {
            value.include(context8, includeChildrenRecursively);
          }
        }
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        for (const key of childNodeKeys[this.type]) {
          const value = this[key];
          if (value === null)
            continue;
          if (Array.isArray(value)) {
            for (const child of value) {
              child?.includePath(UNKNOWN_PATH, context8);
            }
          } else {
            value.includePath(UNKNOWN_PATH, context8);
          }
        }
      }
      includeAsAssignmentTarget(context8, includeChildrenRecursively, _deoptimizeAccess) {
        this.include(context8, includeChildrenRecursively);
      }
      /**
       * Override to perform special initialisation steps after the scope is
       * initialised
       */
      initialise() {
        this.scope.context.magicString.addSourcemapLocation(this.start);
        this.scope.context.magicString.addSourcemapLocation(this.end);
      }
      parseNode(esTreeNode) {
        for (const [key, value] of Object.entries(esTreeNode)) {
          if (this.hasOwnProperty(key))
            continue;
          if (key.charCodeAt(0) === 95) {
            if (key === ANNOTATION_KEY) {
              this.annotations = value;
            } else if (key === INVALID_ANNOTATION_KEY) {
              this.invalidAnnotations = value;
            }
          } else if (typeof value !== "object" || value === null) {
            this[key] = value;
          } else if (Array.isArray(value)) {
            this[key] = new Array(value.length);
            let index = 0;
            for (const child of value) {
              this[key][index++] = child === null ? null : new (this.scope.context.getNodeConstructor(child.type))(this, this.scope).parseNode(child);
            }
          } else {
            this[key] = new (this.scope.context.getNodeConstructor(value.type))(this, this.scope).parseNode(value);
          }
        }
        childNodeKeys[esTreeNode.type] ||= createChildNodeKeysForNode(esTreeNode);
        this.initialise();
        return this;
      }
      removeAnnotations(code) {
        if (this.annotations) {
          for (const annotation of this.annotations) {
            code.remove(annotation.start, annotation.end);
          }
        }
      }
      render(code, options) {
        for (const key of childNodeKeys[this.type]) {
          const value = this[key];
          if (value === null)
            continue;
          if (Array.isArray(value)) {
            for (const child of value) {
              child?.render(code, options);
            }
          } else {
            value.render(code, options);
          }
        }
      }
      setAssignedValue(value) {
        this.assignmentInteraction = { args: [null, value], type: INTERACTION_ASSIGNED };
      }
      shouldBeIncluded(context8) {
        return this.included || !context8.brokenFlow && this.hasEffects(createHasEffectsContext());
      }
      /**
       * Just deoptimize everything by default so that when e.g. we do not track
       * something properly, it is deoptimized.
       * @protected
       */
      applyDeoptimizations() {
        this.deoptimized = true;
        for (const key of childNodeKeys[this.type]) {
          const value = this[key];
          if (value === null)
            continue;
          if (Array.isArray(value)) {
            for (const child of value) {
              child?.deoptimizePath(UNKNOWN_PATH);
            }
          } else {
            value.deoptimizePath(UNKNOWN_PATH);
          }
        }
        this.scope.context.requestTreeshakingPass();
      }
    };
    UNDEFINED_EXPRESSION = new class UndefinedExpression extends ExpressionEntity {
      getLiteralValueAtPath(path3) {
        return path3.length > 0 ? UnknownValue : void 0;
      }
    }();
    returnsUnknown = {
      value: {
        hasEffectsWhenCalled: null,
        returns: UNKNOWN_EXPRESSION
      }
    };
    UNKNOWN_LITERAL_BOOLEAN = new class UnknownBoolean extends ExpressionEntity {
      getReturnExpressionWhenCalledAtPath(path3) {
        if (path3.length === 1) {
          return getMemberReturnExpressionWhenCalled(literalBooleanMembers, path3[0]);
        }
        return UNKNOWN_RETURN_EXPRESSION;
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        if (interaction.type === INTERACTION_ACCESSED) {
          return path3.length > 1;
        }
        if (interaction.type === INTERACTION_CALLED && path3.length === 1) {
          return hasMemberEffectWhenCalled(literalBooleanMembers, path3[0], interaction, context8);
        }
        return true;
      }
    }();
    returnsBoolean = {
      value: {
        hasEffectsWhenCalled: null,
        returns: UNKNOWN_LITERAL_BOOLEAN
      }
    };
    UNKNOWN_LITERAL_NUMBER = new class UnknownNumber extends ExpressionEntity {
      getReturnExpressionWhenCalledAtPath(path3) {
        if (path3.length === 1) {
          return getMemberReturnExpressionWhenCalled(literalNumberMembers, path3[0]);
        }
        return UNKNOWN_RETURN_EXPRESSION;
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        if (interaction.type === INTERACTION_ACCESSED) {
          return path3.length > 1;
        }
        if (interaction.type === INTERACTION_CALLED && path3.length === 1) {
          return hasMemberEffectWhenCalled(literalNumberMembers, path3[0], interaction, context8);
        }
        return true;
      }
    }();
    returnsNumber = {
      value: {
        hasEffectsWhenCalled: null,
        returns: UNKNOWN_LITERAL_NUMBER
      }
    };
    UNKNOWN_LITERAL_STRING = new class UnknownString extends ExpressionEntity {
      getReturnExpressionWhenCalledAtPath(path3) {
        if (path3.length === 1) {
          return getMemberReturnExpressionWhenCalled(literalStringMembers, path3[0]);
        }
        return UNKNOWN_RETURN_EXPRESSION;
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        if (interaction.type === INTERACTION_ACCESSED) {
          return path3.length > 1;
        }
        if (interaction.type === INTERACTION_CALLED && path3.length === 1) {
          return hasMemberEffectWhenCalled(literalStringMembers, path3[0], interaction, context8);
        }
        return true;
      }
    }();
    returnsString = {
      value: {
        hasEffectsWhenCalled: null,
        returns: UNKNOWN_LITERAL_STRING
      }
    };
    stringReplace = {
      value: {
        hasEffectsWhenCalled({ args: args2 }, context8) {
          const argument1 = args2[2];
          return args2.length < 3 || typeof argument1.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, {
            deoptimizeCache() {
            }
          }) === "symbol" && argument1.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, context8);
        },
        returns: UNKNOWN_LITERAL_STRING
      }
    };
    objectMembers = assembleMemberDescriptions({
      hasOwnProperty: returnsBoolean,
      isPrototypeOf: returnsBoolean,
      propertyIsEnumerable: returnsBoolean,
      toLocaleString: returnsString,
      toString: returnsString,
      valueOf: returnsUnknown
    });
    literalBooleanMembers = assembleMemberDescriptions({
      valueOf: returnsBoolean
    }, objectMembers);
    literalNumberMembers = assembleMemberDescriptions({
      toExponential: returnsString,
      toFixed: returnsString,
      toLocaleString: returnsString,
      toPrecision: returnsString,
      valueOf: returnsNumber
    }, objectMembers);
    literalRegExpMembers = assembleMemberDescriptions({
      exec: returnsUnknown,
      test: returnsBoolean
    }, objectMembers);
    literalStringMembers = assembleMemberDescriptions({
      anchor: returnsString,
      at: returnsUnknown,
      big: returnsString,
      blink: returnsString,
      bold: returnsString,
      charAt: returnsString,
      charCodeAt: returnsNumber,
      codePointAt: returnsUnknown,
      concat: returnsString,
      endsWith: returnsBoolean,
      fixed: returnsString,
      fontcolor: returnsString,
      fontsize: returnsString,
      includes: returnsBoolean,
      indexOf: returnsNumber,
      italics: returnsString,
      lastIndexOf: returnsNumber,
      link: returnsString,
      localeCompare: returnsNumber,
      match: returnsUnknown,
      matchAll: returnsUnknown,
      normalize: returnsString,
      padEnd: returnsString,
      padStart: returnsString,
      repeat: returnsString,
      replace: stringReplace,
      replaceAll: stringReplace,
      search: returnsNumber,
      slice: returnsString,
      small: returnsString,
      split: returnsUnknown,
      startsWith: returnsBoolean,
      strike: returnsString,
      sub: returnsString,
      substr: returnsString,
      substring: returnsString,
      sup: returnsString,
      toLocaleLowerCase: returnsString,
      toLocaleUpperCase: returnsString,
      toLowerCase: returnsString,
      toString: returnsString,
      // overrides the toString() method of the Object object; it does not inherit Object.prototype.toString()
      toUpperCase: returnsString,
      trim: returnsString,
      trimEnd: returnsString,
      trimLeft: returnsString,
      trimRight: returnsString,
      trimStart: returnsString,
      valueOf: returnsString
    }, objectMembers);
    Method = class extends ExpressionEntity {
      constructor(description) {
        super();
        this.description = description;
      }
      deoptimizeArgumentsOnInteractionAtPath({ args: args2, type }, path3) {
        if (type === INTERACTION_CALLED && path3.length === 0) {
          if (this.description.mutatesSelfAsArray) {
            args2[0]?.deoptimizePath(UNKNOWN_INTEGER_PATH);
          }
          if (this.description.mutatesArgs) {
            for (let index = 1; index < args2.length; index++) {
              args2[index].deoptimizePath(UNKNOWN_PATH);
            }
          }
        }
      }
      getReturnExpressionWhenCalledAtPath(path3, { args: args2 }) {
        if (path3.length > 0) {
          return UNKNOWN_RETURN_EXPRESSION;
        }
        return [
          this.description.returnsPrimitive || (this.description.returns === "self" ? args2[0] || UNKNOWN_EXPRESSION : this.description.returns()),
          false
        ];
      }
      hasEffectsOnInteractionAtPath(path3, { args: args2, type }, context8) {
        if (path3.length > (type === INTERACTION_ACCESSED ? 1 : 0)) {
          return true;
        }
        if (type === INTERACTION_CALLED) {
          if (this.description.mutatesSelfAsArray === true && args2[0]?.hasEffectsOnInteractionAtPath(UNKNOWN_INTEGER_PATH, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, context8)) {
            return true;
          }
          if (this.description.callsArgs) {
            for (const argumentIndex of this.description.callsArgs) {
              if (args2[argumentIndex + 1]?.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, context8)) {
                return true;
              }
            }
          }
        }
        return false;
      }
    };
    METHOD_RETURNS_BOOLEAN = [
      new Method({
        callsArgs: null,
        mutatesArgs: false,
        mutatesSelfAsArray: false,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
      })
    ];
    METHOD_RETURNS_STRING = [
      new Method({
        callsArgs: null,
        mutatesArgs: false,
        mutatesSelfAsArray: false,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_STRING
      })
    ];
    METHOD_RETURNS_NUMBER = [
      new Method({
        callsArgs: null,
        mutatesArgs: false,
        mutatesSelfAsArray: false,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
      })
    ];
    METHOD_RETURNS_UNKNOWN = [
      new Method({
        callsArgs: null,
        mutatesArgs: false,
        mutatesSelfAsArray: false,
        returns: null,
        returnsPrimitive: UNKNOWN_EXPRESSION
      })
    ];
    INTEGER_REG_EXP = /^\d+$/;
    ObjectEntity = class extends ExpressionEntity {
      get hasLostTrack() {
        return isFlagSet(
          this.flags,
          2048
          /* Flag.hasLostTrack */
        );
      }
      set hasLostTrack(value) {
        this.flags = setFlag(this.flags, 2048, value);
      }
      get hasUnknownDeoptimizedInteger() {
        return isFlagSet(
          this.flags,
          4096
          /* Flag.hasUnknownDeoptimizedInteger */
        );
      }
      set hasUnknownDeoptimizedInteger(value) {
        this.flags = setFlag(this.flags, 4096, value);
      }
      get hasUnknownDeoptimizedProperty() {
        return isFlagSet(
          this.flags,
          8192
          /* Flag.hasUnknownDeoptimizedProperty */
        );
      }
      set hasUnknownDeoptimizedProperty(value) {
        this.flags = setFlag(this.flags, 8192, value);
      }
      // If a PropertyMap is used, this will be taken as propertiesAndGettersByKey
      // and we assume there are no setters or getters
      constructor(properties, prototypeExpression, immutable = false) {
        super();
        this.prototypeExpression = prototypeExpression;
        this.immutable = immutable;
        this.additionalExpressionsToBeDeoptimized = /* @__PURE__ */ new Set();
        this.allProperties = [];
        this.deoptimizedPaths = /* @__PURE__ */ Object.create(null);
        this.expressionsToBeDeoptimizedByKey = /* @__PURE__ */ Object.create(null);
        this.gettersByKey = /* @__PURE__ */ Object.create(null);
        this.propertiesAndGettersByKey = /* @__PURE__ */ Object.create(null);
        this.propertiesAndSettersByKey = /* @__PURE__ */ Object.create(null);
        this.settersByKey = /* @__PURE__ */ Object.create(null);
        this.unknownIntegerProps = [];
        this.unmatchableGetters = [];
        this.unmatchablePropertiesAndGetters = [];
        this.unmatchablePropertiesAndSetters = [];
        this.unmatchableSetters = [];
        if (Array.isArray(properties)) {
          this.buildPropertyMaps(properties);
        } else {
          this.propertiesAndGettersByKey = this.propertiesAndSettersByKey = properties;
          for (const propertiesForKey of Object.values(properties)) {
            this.allProperties.push(...propertiesForKey);
          }
        }
      }
      deoptimizeAllProperties(noAccessors) {
        const isDeoptimized = this.hasLostTrack || this.hasUnknownDeoptimizedProperty;
        if (noAccessors) {
          this.hasUnknownDeoptimizedProperty = true;
        } else {
          this.hasLostTrack = true;
        }
        if (isDeoptimized) {
          return;
        }
        for (const properties of [
          ...Object.values(this.propertiesAndGettersByKey),
          ...Object.values(this.settersByKey)
        ]) {
          for (const property3 of properties) {
            property3.deoptimizePath(UNKNOWN_PATH);
          }
        }
        this.prototypeExpression?.deoptimizePath([UnknownKey, UnknownKey]);
        this.deoptimizeCachedEntities();
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        const [key, ...subPath] = path3;
        const { args: args2, type } = interaction;
        if (this.hasLostTrack || // single paths that are deoptimized will not become getters or setters
        (type === INTERACTION_CALLED || path3.length > 1) && (this.hasUnknownDeoptimizedProperty || typeof key === "string" && this.deoptimizedPaths[key])) {
          deoptimizeInteraction(interaction);
          return;
        }
        const [propertiesForExactMatchByKey, relevantPropertiesByKey, relevantUnmatchableProperties] = type === INTERACTION_CALLED || path3.length > 1 ? [
          this.propertiesAndGettersByKey,
          this.propertiesAndGettersByKey,
          this.unmatchablePropertiesAndGetters
        ] : type === INTERACTION_ACCESSED ? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters] : [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters];
        if (typeof key === "string") {
          if (propertiesForExactMatchByKey[key]) {
            const properties = relevantPropertiesByKey[key];
            if (properties) {
              for (const property3 of properties) {
                property3.deoptimizeArgumentsOnInteractionAtPath(interaction, subPath, recursionTracker);
              }
            }
            if (!this.immutable) {
              for (const argument of args2) {
                if (argument) {
                  this.additionalExpressionsToBeDeoptimized.add(argument);
                }
              }
            }
            return;
          }
          for (const property3 of relevantUnmatchableProperties) {
            property3.deoptimizeArgumentsOnInteractionAtPath(interaction, subPath, recursionTracker);
          }
          if (INTEGER_REG_EXP.test(key)) {
            for (const property3 of this.unknownIntegerProps) {
              property3.deoptimizeArgumentsOnInteractionAtPath(interaction, subPath, recursionTracker);
            }
          }
        } else {
          for (const properties of [
            ...Object.values(relevantPropertiesByKey),
            relevantUnmatchableProperties
          ]) {
            for (const property3 of properties) {
              property3.deoptimizeArgumentsOnInteractionAtPath(interaction, subPath, recursionTracker);
            }
          }
          for (const property3 of this.unknownIntegerProps) {
            property3.deoptimizeArgumentsOnInteractionAtPath(interaction, subPath, recursionTracker);
          }
        }
        if (!this.immutable) {
          for (const argument of args2) {
            if (argument) {
              this.additionalExpressionsToBeDeoptimized.add(argument);
            }
          }
        }
        this.prototypeExpression?.deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
      }
      deoptimizeIntegerProperties() {
        if (this.hasLostTrack || this.hasUnknownDeoptimizedProperty || this.hasUnknownDeoptimizedInteger) {
          return;
        }
        this.hasUnknownDeoptimizedInteger = true;
        for (const [key, propertiesAndGetters] of Object.entries(this.propertiesAndGettersByKey)) {
          if (INTEGER_REG_EXP.test(key)) {
            for (const property3 of propertiesAndGetters) {
              property3.deoptimizePath(UNKNOWN_PATH);
            }
          }
        }
        this.deoptimizeCachedIntegerEntities();
      }
      // Assumption: If only a specific path is deoptimized, no accessors are created
      deoptimizePath(path3) {
        if (this.hasLostTrack || this.immutable) {
          return;
        }
        const key = path3[0];
        if (path3.length === 1) {
          if (key === UnknownInteger) {
            return this.deoptimizeIntegerProperties();
          } else if (typeof key !== "string") {
            return this.deoptimizeAllProperties(key === UnknownNonAccessorKey);
          }
          if (!this.deoptimizedPaths[key]) {
            this.deoptimizedPaths[key] = true;
            const expressionsToBeDeoptimized = this.expressionsToBeDeoptimizedByKey[key];
            if (expressionsToBeDeoptimized) {
              for (const expression of expressionsToBeDeoptimized) {
                expression.deoptimizeCache();
              }
            }
          }
        }
        const subPath = path3.length === 1 ? UNKNOWN_PATH : path3.slice(1);
        for (const property3 of typeof key === "string" ? [
          ...this.propertiesAndGettersByKey[key] || this.unmatchablePropertiesAndGetters,
          ...this.settersByKey[key] || this.unmatchableSetters
        ] : this.allProperties) {
          property3.deoptimizePath(subPath);
        }
        this.prototypeExpression?.deoptimizePath(path3.length === 1 ? [path3[0], UnknownKey] : path3);
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        if (path3.length === 0) {
          return UnknownValue;
        }
        const key = path3[0];
        const expressionAtPath = this.getMemberExpressionAndTrackDeopt(key, origin);
        if (expressionAtPath) {
          return expressionAtPath.getLiteralValueAtPath(path3.slice(1), recursionTracker, origin);
        }
        if (this.prototypeExpression) {
          return this.prototypeExpression.getLiteralValueAtPath(path3, recursionTracker, origin);
        }
        if (path3.length === 1) {
          return void 0;
        }
        return UnknownValue;
      }
      getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin) {
        if (path3.length === 0) {
          return UNKNOWN_RETURN_EXPRESSION;
        }
        const [key, ...subPath] = path3;
        const expressionAtPath = this.getMemberExpressionAndTrackDeopt(key, origin);
        if (expressionAtPath) {
          return expressionAtPath.getReturnExpressionWhenCalledAtPath(subPath, interaction, recursionTracker, origin);
        }
        if (this.prototypeExpression) {
          return this.prototypeExpression.getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin);
        }
        return UNKNOWN_RETURN_EXPRESSION;
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        const [key, ...subPath] = path3;
        if (subPath.length > 0 || interaction.type === INTERACTION_CALLED) {
          const expressionAtPath = this.getMemberExpression(key);
          if (expressionAtPath) {
            return expressionAtPath.hasEffectsOnInteractionAtPath(subPath, interaction, context8);
          }
          if (this.prototypeExpression) {
            return this.prototypeExpression.hasEffectsOnInteractionAtPath(path3, interaction, context8);
          }
          return true;
        }
        if (key === UnknownNonAccessorKey)
          return false;
        if (this.hasLostTrack)
          return true;
        const [propertiesAndAccessorsByKey, accessorsByKey, unmatchableAccessors] = interaction.type === INTERACTION_ACCESSED ? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters] : [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters];
        if (typeof key === "string") {
          if (propertiesAndAccessorsByKey[key]) {
            const accessors = accessorsByKey[key];
            if (accessors) {
              for (const accessor of accessors) {
                if (accessor.hasEffectsOnInteractionAtPath(subPath, interaction, context8))
                  return true;
              }
            }
            return false;
          }
          for (const accessor of unmatchableAccessors) {
            if (accessor.hasEffectsOnInteractionAtPath(subPath, interaction, context8)) {
              return true;
            }
          }
        } else {
          for (const accessors of [...Object.values(accessorsByKey), unmatchableAccessors]) {
            for (const accessor of accessors) {
              if (accessor.hasEffectsOnInteractionAtPath(subPath, interaction, context8))
                return true;
            }
          }
        }
        if (this.prototypeExpression) {
          return this.prototypeExpression.hasEffectsOnInteractionAtPath(path3, interaction, context8);
        }
        return false;
      }
      include(context8, includeChildrenRecursively) {
        this.included = true;
        for (const property3 of this.allProperties) {
          if (includeChildrenRecursively || property3.shouldBeIncluded(context8)) {
            property3.include(context8, includeChildrenRecursively);
          }
        }
        this.prototypeExpression?.include(context8, includeChildrenRecursively);
      }
      includePath(path3, context8) {
        this.included = true;
        if (path3.length === 0)
          return;
        const [key, ...subPath] = path3;
        const [includedMembers, includedPath] = typeof key === "string" ? [
          /* @__PURE__ */ new Set([
            ...this.propertiesAndGettersByKey[key] || this.unmatchablePropertiesAndGetters,
            ...this.propertiesAndSettersByKey[key] || this.unmatchablePropertiesAndSetters
          ]),
          subPath
        ] : [this.allProperties, UNKNOWN_PATH];
        for (const property3 of includedMembers) {
          property3.includePath(includedPath, context8);
        }
        this.prototypeExpression?.includePath(path3, context8);
      }
      buildPropertyMaps(properties) {
        const { allProperties, propertiesAndGettersByKey, propertiesAndSettersByKey, settersByKey, gettersByKey, unknownIntegerProps, unmatchablePropertiesAndGetters, unmatchablePropertiesAndSetters, unmatchableGetters, unmatchableSetters } = this;
        for (let index = properties.length - 1; index >= 0; index--) {
          const { key, kind, property: property3 } = properties[index];
          allProperties.push(property3);
          if (typeof key === "string") {
            if (kind === "set") {
              if (!propertiesAndSettersByKey[key]) {
                propertiesAndSettersByKey[key] = [property3, ...unmatchablePropertiesAndSetters];
                settersByKey[key] = [property3, ...unmatchableSetters];
              }
            } else if (kind === "get") {
              if (!propertiesAndGettersByKey[key]) {
                propertiesAndGettersByKey[key] = [property3, ...unmatchablePropertiesAndGetters];
                gettersByKey[key] = [property3, ...unmatchableGetters];
              }
            } else {
              if (!propertiesAndSettersByKey[key]) {
                propertiesAndSettersByKey[key] = [property3, ...unmatchablePropertiesAndSetters];
              }
              if (!propertiesAndGettersByKey[key]) {
                propertiesAndGettersByKey[key] = [property3, ...unmatchablePropertiesAndGetters];
              }
            }
          } else {
            if (key === UnknownInteger) {
              unknownIntegerProps.push(property3);
              continue;
            }
            if (kind === "set")
              unmatchableSetters.push(property3);
            if (kind === "get")
              unmatchableGetters.push(property3);
            if (kind !== "get")
              unmatchablePropertiesAndSetters.push(property3);
            if (kind !== "set")
              unmatchablePropertiesAndGetters.push(property3);
          }
        }
      }
      deoptimizeCachedEntities() {
        for (const expressionsToBeDeoptimized of Object.values(this.expressionsToBeDeoptimizedByKey)) {
          for (const expression of expressionsToBeDeoptimized) {
            expression.deoptimizeCache();
          }
        }
        for (const expression of this.additionalExpressionsToBeDeoptimized) {
          expression.deoptimizePath(UNKNOWN_PATH);
        }
      }
      deoptimizeCachedIntegerEntities() {
        for (const [key, expressionsToBeDeoptimized] of Object.entries(this.expressionsToBeDeoptimizedByKey)) {
          if (INTEGER_REG_EXP.test(key)) {
            for (const expression of expressionsToBeDeoptimized) {
              expression.deoptimizeCache();
            }
          }
        }
        for (const expression of this.additionalExpressionsToBeDeoptimized) {
          expression.deoptimizePath(UNKNOWN_INTEGER_PATH);
        }
      }
      getMemberExpression(key) {
        if (this.hasLostTrack || this.hasUnknownDeoptimizedProperty || typeof key !== "string" || this.hasUnknownDeoptimizedInteger && INTEGER_REG_EXP.test(key) || this.deoptimizedPaths[key]) {
          return UNKNOWN_EXPRESSION;
        }
        const properties = this.propertiesAndGettersByKey[key];
        if (properties?.length === 1) {
          return properties[0];
        }
        if (properties || this.unmatchablePropertiesAndGetters.length > 0 || this.unknownIntegerProps.length > 0 && INTEGER_REG_EXP.test(key)) {
          return UNKNOWN_EXPRESSION;
        }
        return null;
      }
      getMemberExpressionAndTrackDeopt(key, origin) {
        if (typeof key !== "string") {
          return UNKNOWN_EXPRESSION;
        }
        const expression = this.getMemberExpression(key);
        if (!(expression === UNKNOWN_EXPRESSION || this.immutable)) {
          const expressionsToBeDeoptimized = this.expressionsToBeDeoptimizedByKey[key] = this.expressionsToBeDeoptimizedByKey[key] || [];
          expressionsToBeDeoptimized.push(origin);
        }
        return expression;
      }
    };
    isInteger = (property3) => typeof property3 === "string" && /^\d+$/.test(property3);
    OBJECT_PROTOTYPE_FALLBACK = new class ObjectPrototypeFallbackExpression extends ExpressionEntity {
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3) {
        if (interaction.type === INTERACTION_CALLED && path3.length === 1 && !isInteger(path3[0])) {
          deoptimizeInteraction(interaction);
        }
      }
      getLiteralValueAtPath(path3) {
        return path3.length === 1 && isInteger(path3[0]) ? void 0 : UnknownValue;
      }
      hasEffectsOnInteractionAtPath(path3, { type }) {
        return path3.length > 1 || type === INTERACTION_CALLED;
      }
    }();
    OBJECT_PROTOTYPE = new ObjectEntity({
      __proto__: null,
      hasOwnProperty: METHOD_RETURNS_BOOLEAN,
      isPrototypeOf: METHOD_RETURNS_BOOLEAN,
      propertyIsEnumerable: METHOD_RETURNS_BOOLEAN,
      toLocaleString: METHOD_RETURNS_STRING,
      toString: METHOD_RETURNS_STRING,
      valueOf: METHOD_RETURNS_UNKNOWN
    }, OBJECT_PROTOTYPE_FALLBACK, true);
    NEW_ARRAY_PROPERTIES = [
      { key: UnknownInteger, kind: "init", property: UNKNOWN_EXPRESSION },
      { key: "length", kind: "init", property: UNKNOWN_LITERAL_NUMBER }
    ];
    METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN = [
      new Method({
        callsArgs: [0],
        mutatesArgs: false,
        mutatesSelfAsArray: "deopt-only",
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
      })
    ];
    METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER = [
      new Method({
        callsArgs: [0],
        mutatesArgs: false,
        mutatesSelfAsArray: "deopt-only",
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
      })
    ];
    METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY = [
      new Method({
        callsArgs: null,
        mutatesArgs: false,
        mutatesSelfAsArray: true,
        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
        returnsPrimitive: null
      })
    ];
    METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY = [
      new Method({
        callsArgs: null,
        mutatesArgs: false,
        mutatesSelfAsArray: "deopt-only",
        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
        returnsPrimitive: null
      })
    ];
    METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY = [
      new Method({
        callsArgs: [0],
        mutatesArgs: false,
        mutatesSelfAsArray: "deopt-only",
        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
        returnsPrimitive: null
      })
    ];
    METHOD_MUTATES_SELF_AND_ARGS_RETURNS_NUMBER = [
      new Method({
        callsArgs: null,
        mutatesArgs: true,
        mutatesSelfAsArray: true,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
      })
    ];
    METHOD_MUTATES_SELF_RETURNS_UNKNOWN = [
      new Method({
        callsArgs: null,
        mutatesArgs: false,
        mutatesSelfAsArray: true,
        returns: null,
        returnsPrimitive: UNKNOWN_EXPRESSION
      })
    ];
    METHOD_DEOPTS_SELF_RETURNS_UNKNOWN = [
      new Method({
        callsArgs: null,
        mutatesArgs: false,
        mutatesSelfAsArray: "deopt-only",
        returns: null,
        returnsPrimitive: UNKNOWN_EXPRESSION
      })
    ];
    METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN = [
      new Method({
        callsArgs: [0],
        mutatesArgs: false,
        mutatesSelfAsArray: "deopt-only",
        returns: null,
        returnsPrimitive: UNKNOWN_EXPRESSION
      })
    ];
    METHOD_MUTATES_SELF_RETURNS_SELF = [
      new Method({
        callsArgs: null,
        mutatesArgs: false,
        mutatesSelfAsArray: true,
        returns: "self",
        returnsPrimitive: null
      })
    ];
    METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF = [
      new Method({
        callsArgs: [0],
        mutatesArgs: false,
        mutatesSelfAsArray: true,
        returns: "self",
        returnsPrimitive: null
      })
    ];
    ARRAY_PROTOTYPE = new ObjectEntity({
      __proto__: null,
      // We assume that accessors have effects as we do not track the accessed value afterwards
      at: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN,
      concat: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      copyWithin: METHOD_MUTATES_SELF_RETURNS_SELF,
      entries: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      every: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN,
      fill: METHOD_MUTATES_SELF_RETURNS_SELF,
      filter: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      find: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      findIndex: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER,
      findLast: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      findLastIndex: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER,
      flat: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      flatMap: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      forEach: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      includes: METHOD_RETURNS_BOOLEAN,
      indexOf: METHOD_RETURNS_NUMBER,
      join: METHOD_RETURNS_STRING,
      keys: METHOD_RETURNS_UNKNOWN,
      lastIndexOf: METHOD_RETURNS_NUMBER,
      map: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      pop: METHOD_MUTATES_SELF_RETURNS_UNKNOWN,
      push: METHOD_MUTATES_SELF_AND_ARGS_RETURNS_NUMBER,
      reduce: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      reduceRight: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      reverse: METHOD_MUTATES_SELF_RETURNS_SELF,
      shift: METHOD_MUTATES_SELF_RETURNS_UNKNOWN,
      slice: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      some: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN,
      sort: METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF,
      splice: METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY,
      toLocaleString: METHOD_RETURNS_STRING,
      toString: METHOD_RETURNS_STRING,
      unshift: METHOD_MUTATES_SELF_AND_ARGS_RETURNS_NUMBER,
      values: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN
    }, OBJECT_PROTOTYPE, true);
    SpreadElement = class extends NodeBase {
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        if (path3.length > 0) {
          this.argument.deoptimizeArgumentsOnInteractionAtPath(interaction, UNKNOWN_PATH, recursionTracker);
        }
      }
      hasEffects(context8) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        const { propertyReadSideEffects } = this.scope.context.options.treeshake;
        return this.argument.hasEffects(context8) || propertyReadSideEffects && (propertyReadSideEffects === "always" || this.argument.hasEffectsOnInteractionAtPath(UNKNOWN_PATH, NODE_INTERACTION_UNKNOWN_ACCESS, context8));
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.argument.includePath(UNKNOWN_PATH, context8);
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.argument.deoptimizePath([UnknownKey, UnknownKey]);
        this.scope.context.requestTreeshakingPass();
      }
    };
    ArrayExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.objectEntity = null;
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
      }
      deoptimizePath(path3) {
        this.getObjectEntity().deoptimizePath(path3);
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        return this.getObjectEntity().getLiteralValueAtPath(path3, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin) {
        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        return this.getObjectEntity().hasEffectsOnInteractionAtPath(path3, interaction, context8);
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        for (const element of this.elements) {
          if (element) {
            element?.includePath(UNKNOWN_PATH, context8);
          }
        }
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        let hasSpread = false;
        for (let index = 0; index < this.elements.length; index++) {
          const element = this.elements[index];
          if (element && (hasSpread || element instanceof SpreadElement)) {
            hasSpread = true;
            element.deoptimizePath(UNKNOWN_PATH);
          }
        }
        this.scope.context.requestTreeshakingPass();
      }
      getObjectEntity() {
        if (this.objectEntity !== null) {
          return this.objectEntity;
        }
        const properties = [
          { key: "length", kind: "init", property: UNKNOWN_LITERAL_NUMBER }
        ];
        let hasSpread = false;
        for (let index = 0; index < this.elements.length; index++) {
          const element = this.elements[index];
          if (hasSpread || element instanceof SpreadElement) {
            if (element) {
              hasSpread = true;
              properties.unshift({ key: UnknownInteger, kind: "init", property: element });
            }
          } else if (element) {
            properties.push({ key: String(index), kind: "init", property: element });
          } else {
            properties.push({ key: String(index), kind: "init", property: UNDEFINED_EXPRESSION });
          }
        }
        return this.objectEntity = new ObjectEntity(properties, ARRAY_PROTOTYPE);
      }
    };
    ValueProperties = Symbol("Value Properties");
    getUnknownValue = () => UnknownValue;
    returnFalse = () => false;
    returnTrue = () => true;
    PURE = {
      deoptimizeArgumentsOnCall: doNothing,
      getLiteralValue: getUnknownValue,
      hasEffectsWhenCalled: returnFalse
    };
    IMPURE = {
      deoptimizeArgumentsOnCall: doNothing,
      getLiteralValue: getUnknownValue,
      hasEffectsWhenCalled: returnTrue
    };
    PURE_WITH_ARRAY = {
      deoptimizeArgumentsOnCall: doNothing,
      getLiteralValue: getUnknownValue,
      hasEffectsWhenCalled({ args: args2 }) {
        return args2.length > 1 && !(args2[1] instanceof ArrayExpression);
      }
    };
    GETTER_ACCESS = {
      deoptimizeArgumentsOnCall: doNothing,
      getLiteralValue: getUnknownValue,
      hasEffectsWhenCalled({ args: args2 }, context8) {
        const [_thisArgument, firstArgument] = args2;
        return !(firstArgument instanceof ExpressionEntity) || firstArgument.hasEffectsOnInteractionAtPath(UNKNOWN_PATH, NODE_INTERACTION_UNKNOWN_ACCESS, context8);
      }
    };
    O = {
      __proto__: null,
      [ValueProperties]: IMPURE
    };
    PF = {
      __proto__: null,
      [ValueProperties]: PURE
    };
    PF_NO_GETTER = {
      __proto__: null,
      [ValueProperties]: GETTER_ACCESS
    };
    MUTATES_ARG_WITHOUT_ACCESSOR = {
      __proto__: null,
      [ValueProperties]: {
        deoptimizeArgumentsOnCall({ args: [, firstArgument] }) {
          firstArgument?.deoptimizePath(UNKNOWN_PATH);
        },
        getLiteralValue: getUnknownValue,
        hasEffectsWhenCalled({ args: args2 }, context8) {
          return args2.length <= 1 || args2[1].hasEffectsOnInteractionAtPath(UNKNOWN_NON_ACCESSOR_PATH, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, context8);
        }
      }
    };
    C = {
      __proto__: null,
      [ValueProperties]: IMPURE,
      prototype: O
    };
    PC = {
      __proto__: null,
      [ValueProperties]: PURE,
      prototype: O
    };
    PC_WITH_ARRAY = {
      __proto__: null,
      [ValueProperties]: PURE_WITH_ARRAY,
      prototype: O
    };
    ARRAY_TYPE = {
      __proto__: null,
      [ValueProperties]: PURE,
      from: O,
      of: PF,
      prototype: O
    };
    INTL_MEMBER = {
      __proto__: null,
      [ValueProperties]: PURE,
      supportedLocalesOf: PC
    };
    knownGlobals = {
      // Placeholders for global objects to avoid shape mutations
      global: O,
      globalThis: O,
      self: O,
      window: O,
      // Common globals
      __proto__: null,
      [ValueProperties]: IMPURE,
      Array: {
        __proto__: null,
        [ValueProperties]: IMPURE,
        from: O,
        isArray: PF,
        of: PF,
        prototype: O
      },
      ArrayBuffer: {
        __proto__: null,
        [ValueProperties]: PURE,
        isView: PF,
        prototype: O
      },
      AggregateError: PC_WITH_ARRAY,
      Atomics: O,
      BigInt: C,
      BigInt64Array: C,
      BigUint64Array: C,
      Boolean: PC,
      constructor: C,
      DataView: PC,
      Date: {
        __proto__: null,
        [ValueProperties]: PURE,
        now: PF,
        parse: PF,
        prototype: O,
        UTC: PF
      },
      decodeURI: PF,
      decodeURIComponent: PF,
      encodeURI: PF,
      encodeURIComponent: PF,
      Error: PC,
      escape: PF,
      eval: O,
      EvalError: PC,
      FinalizationRegistry: C,
      Float32Array: ARRAY_TYPE,
      Float64Array: ARRAY_TYPE,
      Function: C,
      hasOwnProperty: O,
      Infinity: O,
      Int16Array: ARRAY_TYPE,
      Int32Array: ARRAY_TYPE,
      Int8Array: ARRAY_TYPE,
      isFinite: PF,
      isNaN: PF,
      isPrototypeOf: O,
      JSON: O,
      Map: PC_WITH_ARRAY,
      Math: {
        __proto__: null,
        [ValueProperties]: IMPURE,
        abs: PF,
        acos: PF,
        acosh: PF,
        asin: PF,
        asinh: PF,
        atan: PF,
        atan2: PF,
        atanh: PF,
        cbrt: PF,
        ceil: PF,
        clz32: PF,
        cos: PF,
        cosh: PF,
        exp: PF,
        expm1: PF,
        floor: PF,
        fround: PF,
        hypot: PF,
        imul: PF,
        log: PF,
        log10: PF,
        log1p: PF,
        log2: PF,
        max: PF,
        min: PF,
        pow: PF,
        random: PF,
        round: PF,
        sign: PF,
        sin: PF,
        sinh: PF,
        sqrt: PF,
        tan: PF,
        tanh: PF,
        trunc: PF
      },
      NaN: O,
      Number: {
        __proto__: null,
        [ValueProperties]: PURE,
        isFinite: PF,
        isInteger: PF,
        isNaN: PF,
        isSafeInteger: PF,
        parseFloat: PF,
        parseInt: PF,
        prototype: O
      },
      Object: {
        __proto__: null,
        [ValueProperties]: PURE,
        create: PF,
        // Technically those can throw in certain situations, but we ignore this as
        // code that relies on this will hopefully wrap this in a try-catch, which
        // deoptimizes everything anyway
        defineProperty: MUTATES_ARG_WITHOUT_ACCESSOR,
        defineProperties: MUTATES_ARG_WITHOUT_ACCESSOR,
        freeze: MUTATES_ARG_WITHOUT_ACCESSOR,
        getOwnPropertyDescriptor: PF,
        getOwnPropertyDescriptors: PF,
        getOwnPropertyNames: PF,
        getOwnPropertySymbols: PF,
        getPrototypeOf: PF,
        hasOwn: PF,
        is: PF,
        isExtensible: PF,
        isFrozen: PF,
        isSealed: PF,
        keys: PF,
        fromEntries: O,
        entries: PF_NO_GETTER,
        values: PF_NO_GETTER,
        prototype: O
      },
      parseFloat: PF,
      parseInt: PF,
      Promise: {
        __proto__: null,
        [ValueProperties]: IMPURE,
        all: O,
        allSettled: O,
        any: O,
        prototype: O,
        race: O,
        reject: O,
        resolve: O
      },
      propertyIsEnumerable: O,
      Proxy: {
        __proto__: null,
        [ValueProperties]: {
          deoptimizeArgumentsOnCall: ({ args: [, target, parameter] }) => {
            if (isObjectExpressionNode(parameter)) {
              const hasSpreadElement = parameter.properties.some((property3) => !isPropertyNode(property3));
              if (!hasSpreadElement) {
                for (const property3 of parameter.properties) {
                  property3.deoptimizeArgumentsOnInteractionAtPath({
                    args: [null, target],
                    type: INTERACTION_CALLED,
                    withNew: false
                  }, EMPTY_PATH, SHARED_RECURSION_TRACKER);
                }
                return;
              }
            }
            target.deoptimizePath(UNKNOWN_PATH);
          },
          getLiteralValue: getUnknownValue,
          hasEffectsWhenCalled: returnTrue
        }
      },
      RangeError: PC,
      ReferenceError: PC,
      Reflect: O,
      RegExp: PC,
      Set: PC_WITH_ARRAY,
      SharedArrayBuffer: C,
      String: {
        __proto__: null,
        [ValueProperties]: PURE,
        fromCharCode: PF,
        fromCodePoint: PF,
        prototype: O,
        raw: PF
      },
      Symbol: {
        __proto__: null,
        [ValueProperties]: PURE,
        for: PF,
        keyFor: PF,
        prototype: O,
        toStringTag: {
          __proto__: null,
          [ValueProperties]: {
            deoptimizeArgumentsOnCall: doNothing,
            getLiteralValue() {
              return SymbolToStringTag;
            },
            hasEffectsWhenCalled: returnTrue
          }
        }
      },
      SyntaxError: PC,
      toLocaleString: O,
      toString: O,
      TypeError: PC,
      Uint16Array: ARRAY_TYPE,
      Uint32Array: ARRAY_TYPE,
      Uint8Array: ARRAY_TYPE,
      Uint8ClampedArray: ARRAY_TYPE,
      // Technically, this is a global, but it needs special handling
      // undefined: ?,
      unescape: PF,
      URIError: PC,
      valueOf: O,
      WeakMap: PC_WITH_ARRAY,
      WeakRef: C,
      WeakSet: PC_WITH_ARRAY,
      // Additional globals shared by Node and Browser that are not strictly part of the language
      clearInterval: C,
      clearTimeout: C,
      console: {
        __proto__: null,
        [ValueProperties]: IMPURE,
        assert: C,
        clear: C,
        count: C,
        countReset: C,
        debug: C,
        dir: C,
        dirxml: C,
        error: C,
        exception: C,
        group: C,
        groupCollapsed: C,
        groupEnd: C,
        info: C,
        log: C,
        table: C,
        time: C,
        timeEnd: C,
        timeLog: C,
        trace: C,
        warn: C
      },
      Intl: {
        __proto__: null,
        [ValueProperties]: IMPURE,
        Collator: INTL_MEMBER,
        DateTimeFormat: INTL_MEMBER,
        DisplayNames: INTL_MEMBER,
        ListFormat: INTL_MEMBER,
        Locale: INTL_MEMBER,
        NumberFormat: INTL_MEMBER,
        PluralRules: INTL_MEMBER,
        RelativeTimeFormat: INTL_MEMBER,
        Segmenter: INTL_MEMBER
      },
      setInterval: C,
      setTimeout: C,
      TextDecoder: C,
      TextEncoder: C,
      URL: {
        __proto__: null,
        [ValueProperties]: IMPURE,
        prototype: O,
        canParse: PF
      },
      URLSearchParams: C,
      // Browser specific globals
      AbortController: C,
      AbortSignal: C,
      addEventListener: O,
      alert: O,
      AnalyserNode: C,
      Animation: C,
      AnimationEvent: C,
      applicationCache: O,
      ApplicationCache: C,
      ApplicationCacheErrorEvent: C,
      atob: O,
      Attr: C,
      Audio: C,
      AudioBuffer: C,
      AudioBufferSourceNode: C,
      AudioContext: C,
      AudioDestinationNode: C,
      AudioListener: C,
      AudioNode: C,
      AudioParam: C,
      AudioProcessingEvent: C,
      AudioScheduledSourceNode: C,
      AudioWorkletNode: C,
      BarProp: C,
      BaseAudioContext: C,
      BatteryManager: C,
      BeforeUnloadEvent: C,
      BiquadFilterNode: C,
      Blob: C,
      BlobEvent: C,
      blur: O,
      BroadcastChannel: C,
      btoa: O,
      ByteLengthQueuingStrategy: C,
      Cache: C,
      caches: O,
      CacheStorage: C,
      cancelAnimationFrame: O,
      cancelIdleCallback: O,
      CanvasCaptureMediaStreamTrack: C,
      CanvasGradient: C,
      CanvasPattern: C,
      CanvasRenderingContext2D: C,
      ChannelMergerNode: C,
      ChannelSplitterNode: C,
      CharacterData: C,
      clientInformation: O,
      ClipboardEvent: C,
      close: O,
      closed: O,
      CloseEvent: C,
      Comment: C,
      CompositionEvent: C,
      confirm: O,
      ConstantSourceNode: C,
      ConvolverNode: C,
      CountQueuingStrategy: C,
      createImageBitmap: O,
      Credential: C,
      CredentialsContainer: C,
      crypto: O,
      Crypto: C,
      CryptoKey: C,
      CSS: C,
      CSSConditionRule: C,
      CSSFontFaceRule: C,
      CSSGroupingRule: C,
      CSSImportRule: C,
      CSSKeyframeRule: C,
      CSSKeyframesRule: C,
      CSSMediaRule: C,
      CSSNamespaceRule: C,
      CSSPageRule: C,
      CSSRule: C,
      CSSRuleList: C,
      CSSStyleDeclaration: C,
      CSSStyleRule: C,
      CSSStyleSheet: C,
      CSSSupportsRule: C,
      CustomElementRegistry: C,
      customElements: O,
      CustomEvent: {
        __proto__: null,
        [ValueProperties]: {
          deoptimizeArgumentsOnCall({ args: args2 }) {
            args2[2]?.deoptimizePath(["detail"]);
          },
          getLiteralValue: getUnknownValue,
          hasEffectsWhenCalled: returnFalse
        },
        prototype: O
      },
      DataTransfer: C,
      DataTransferItem: C,
      DataTransferItemList: C,
      defaultstatus: O,
      defaultStatus: O,
      DelayNode: C,
      DeviceMotionEvent: C,
      DeviceOrientationEvent: C,
      devicePixelRatio: O,
      dispatchEvent: O,
      document: O,
      Document: C,
      DocumentFragment: C,
      DocumentType: C,
      DOMError: C,
      DOMException: C,
      DOMImplementation: C,
      DOMMatrix: C,
      DOMMatrixReadOnly: C,
      DOMParser: C,
      DOMPoint: C,
      DOMPointReadOnly: C,
      DOMQuad: C,
      DOMRect: C,
      DOMRectReadOnly: C,
      DOMStringList: C,
      DOMStringMap: C,
      DOMTokenList: C,
      DragEvent: C,
      DynamicsCompressorNode: C,
      Element: C,
      ErrorEvent: C,
      Event: C,
      EventSource: C,
      EventTarget: C,
      external: O,
      fetch: O,
      File: C,
      FileList: C,
      FileReader: C,
      find: O,
      focus: O,
      FocusEvent: C,
      FontFace: C,
      FontFaceSetLoadEvent: C,
      FormData: C,
      frames: O,
      GainNode: C,
      Gamepad: C,
      GamepadButton: C,
      GamepadEvent: C,
      getComputedStyle: O,
      getSelection: O,
      HashChangeEvent: C,
      Headers: C,
      history: O,
      History: C,
      HTMLAllCollection: C,
      HTMLAnchorElement: C,
      HTMLAreaElement: C,
      HTMLAudioElement: C,
      HTMLBaseElement: C,
      HTMLBodyElement: C,
      HTMLBRElement: C,
      HTMLButtonElement: C,
      HTMLCanvasElement: C,
      HTMLCollection: C,
      HTMLContentElement: C,
      HTMLDataElement: C,
      HTMLDataListElement: C,
      HTMLDetailsElement: C,
      HTMLDialogElement: C,
      HTMLDirectoryElement: C,
      HTMLDivElement: C,
      HTMLDListElement: C,
      HTMLDocument: C,
      HTMLElement: C,
      HTMLEmbedElement: C,
      HTMLFieldSetElement: C,
      HTMLFontElement: C,
      HTMLFormControlsCollection: C,
      HTMLFormElement: C,
      HTMLFrameElement: C,
      HTMLFrameSetElement: C,
      HTMLHeadElement: C,
      HTMLHeadingElement: C,
      HTMLHRElement: C,
      HTMLHtmlElement: C,
      HTMLIFrameElement: C,
      HTMLImageElement: C,
      HTMLInputElement: C,
      HTMLLabelElement: C,
      HTMLLegendElement: C,
      HTMLLIElement: C,
      HTMLLinkElement: C,
      HTMLMapElement: C,
      HTMLMarqueeElement: C,
      HTMLMediaElement: C,
      HTMLMenuElement: C,
      HTMLMetaElement: C,
      HTMLMeterElement: C,
      HTMLModElement: C,
      HTMLObjectElement: C,
      HTMLOListElement: C,
      HTMLOptGroupElement: C,
      HTMLOptionElement: C,
      HTMLOptionsCollection: C,
      HTMLOutputElement: C,
      HTMLParagraphElement: C,
      HTMLParamElement: C,
      HTMLPictureElement: C,
      HTMLPreElement: C,
      HTMLProgressElement: C,
      HTMLQuoteElement: C,
      HTMLScriptElement: C,
      HTMLSelectElement: C,
      HTMLShadowElement: C,
      HTMLSlotElement: C,
      HTMLSourceElement: C,
      HTMLSpanElement: C,
      HTMLStyleElement: C,
      HTMLTableCaptionElement: C,
      HTMLTableCellElement: C,
      HTMLTableColElement: C,
      HTMLTableElement: C,
      HTMLTableRowElement: C,
      HTMLTableSectionElement: C,
      HTMLTemplateElement: C,
      HTMLTextAreaElement: C,
      HTMLTimeElement: C,
      HTMLTitleElement: C,
      HTMLTrackElement: C,
      HTMLUListElement: C,
      HTMLUnknownElement: C,
      HTMLVideoElement: C,
      IDBCursor: C,
      IDBCursorWithValue: C,
      IDBDatabase: C,
      IDBFactory: C,
      IDBIndex: C,
      IDBKeyRange: C,
      IDBObjectStore: C,
      IDBOpenDBRequest: C,
      IDBRequest: C,
      IDBTransaction: C,
      IDBVersionChangeEvent: C,
      IdleDeadline: C,
      IIRFilterNode: C,
      Image: C,
      ImageBitmap: C,
      ImageBitmapRenderingContext: C,
      ImageCapture: C,
      ImageData: C,
      indexedDB: O,
      innerHeight: O,
      innerWidth: O,
      InputEvent: C,
      IntersectionObserver: C,
      IntersectionObserverEntry: C,
      isSecureContext: O,
      KeyboardEvent: C,
      KeyframeEffect: C,
      length: O,
      localStorage: O,
      location: O,
      Location: C,
      locationbar: O,
      matchMedia: O,
      MediaDeviceInfo: C,
      MediaDevices: C,
      MediaElementAudioSourceNode: C,
      MediaEncryptedEvent: C,
      MediaError: C,
      MediaKeyMessageEvent: C,
      MediaKeySession: C,
      MediaKeyStatusMap: C,
      MediaKeySystemAccess: C,
      MediaList: C,
      MediaQueryList: C,
      MediaQueryListEvent: C,
      MediaRecorder: C,
      MediaSettingsRange: C,
      MediaSource: C,
      MediaStream: C,
      MediaStreamAudioDestinationNode: C,
      MediaStreamAudioSourceNode: C,
      MediaStreamEvent: C,
      MediaStreamTrack: C,
      MediaStreamTrackEvent: C,
      menubar: O,
      MessageChannel: C,
      MessageEvent: C,
      MessagePort: C,
      MIDIAccess: C,
      MIDIConnectionEvent: C,
      MIDIInput: C,
      MIDIInputMap: C,
      MIDIMessageEvent: C,
      MIDIOutput: C,
      MIDIOutputMap: C,
      MIDIPort: C,
      MimeType: C,
      MimeTypeArray: C,
      MouseEvent: C,
      moveBy: O,
      moveTo: O,
      MutationEvent: C,
      MutationObserver: C,
      MutationRecord: C,
      name: O,
      NamedNodeMap: C,
      NavigationPreloadManager: C,
      navigator: O,
      Navigator: C,
      NetworkInformation: C,
      Node: C,
      NodeFilter: O,
      NodeIterator: C,
      NodeList: C,
      Notification: C,
      OfflineAudioCompletionEvent: C,
      OfflineAudioContext: C,
      offscreenBuffering: O,
      OffscreenCanvas: C,
      open: O,
      openDatabase: O,
      Option: C,
      origin: O,
      OscillatorNode: C,
      outerHeight: O,
      outerWidth: O,
      PageTransitionEvent: C,
      pageXOffset: O,
      pageYOffset: O,
      PannerNode: C,
      parent: O,
      Path2D: C,
      PaymentAddress: C,
      PaymentRequest: C,
      PaymentRequestUpdateEvent: C,
      PaymentResponse: C,
      performance: O,
      Performance: C,
      PerformanceEntry: C,
      PerformanceLongTaskTiming: C,
      PerformanceMark: C,
      PerformanceMeasure: C,
      PerformanceNavigation: C,
      PerformanceNavigationTiming: C,
      PerformanceObserver: C,
      PerformanceObserverEntryList: C,
      PerformancePaintTiming: C,
      PerformanceResourceTiming: C,
      PerformanceTiming: C,
      PeriodicWave: C,
      Permissions: C,
      PermissionStatus: C,
      personalbar: O,
      PhotoCapabilities: C,
      Plugin: C,
      PluginArray: C,
      PointerEvent: C,
      PopStateEvent: C,
      postMessage: O,
      Presentation: C,
      PresentationAvailability: C,
      PresentationConnection: C,
      PresentationConnectionAvailableEvent: C,
      PresentationConnectionCloseEvent: C,
      PresentationConnectionList: C,
      PresentationReceiver: C,
      PresentationRequest: C,
      print: O,
      ProcessingInstruction: C,
      ProgressEvent: C,
      PromiseRejectionEvent: C,
      prompt: O,
      PushManager: C,
      PushSubscription: C,
      PushSubscriptionOptions: C,
      queueMicrotask: O,
      RadioNodeList: C,
      Range: C,
      ReadableStream: C,
      RemotePlayback: C,
      removeEventListener: O,
      Request: C,
      requestAnimationFrame: O,
      requestIdleCallback: O,
      resizeBy: O,
      ResizeObserver: C,
      ResizeObserverEntry: C,
      resizeTo: O,
      Response: C,
      RTCCertificate: C,
      RTCDataChannel: C,
      RTCDataChannelEvent: C,
      RTCDtlsTransport: C,
      RTCIceCandidate: C,
      RTCIceTransport: C,
      RTCPeerConnection: C,
      RTCPeerConnectionIceEvent: C,
      RTCRtpReceiver: C,
      RTCRtpSender: C,
      RTCSctpTransport: C,
      RTCSessionDescription: C,
      RTCStatsReport: C,
      RTCTrackEvent: C,
      screen: O,
      Screen: C,
      screenLeft: O,
      ScreenOrientation: C,
      screenTop: O,
      screenX: O,
      screenY: O,
      ScriptProcessorNode: C,
      scroll: O,
      scrollbars: O,
      scrollBy: O,
      scrollTo: O,
      scrollX: O,
      scrollY: O,
      SecurityPolicyViolationEvent: C,
      Selection: C,
      ServiceWorker: C,
      ServiceWorkerContainer: C,
      ServiceWorkerRegistration: C,
      sessionStorage: O,
      ShadowRoot: C,
      SharedWorker: C,
      SourceBuffer: C,
      SourceBufferList: C,
      speechSynthesis: O,
      SpeechSynthesisEvent: C,
      SpeechSynthesisUtterance: C,
      StaticRange: C,
      status: O,
      statusbar: O,
      StereoPannerNode: C,
      stop: O,
      Storage: C,
      StorageEvent: C,
      StorageManager: C,
      styleMedia: O,
      StyleSheet: C,
      StyleSheetList: C,
      SubtleCrypto: C,
      SVGAElement: C,
      SVGAngle: C,
      SVGAnimatedAngle: C,
      SVGAnimatedBoolean: C,
      SVGAnimatedEnumeration: C,
      SVGAnimatedInteger: C,
      SVGAnimatedLength: C,
      SVGAnimatedLengthList: C,
      SVGAnimatedNumber: C,
      SVGAnimatedNumberList: C,
      SVGAnimatedPreserveAspectRatio: C,
      SVGAnimatedRect: C,
      SVGAnimatedString: C,
      SVGAnimatedTransformList: C,
      SVGAnimateElement: C,
      SVGAnimateMotionElement: C,
      SVGAnimateTransformElement: C,
      SVGAnimationElement: C,
      SVGCircleElement: C,
      SVGClipPathElement: C,
      SVGComponentTransferFunctionElement: C,
      SVGDefsElement: C,
      SVGDescElement: C,
      SVGDiscardElement: C,
      SVGElement: C,
      SVGEllipseElement: C,
      SVGFEBlendElement: C,
      SVGFEColorMatrixElement: C,
      SVGFEComponentTransferElement: C,
      SVGFECompositeElement: C,
      SVGFEConvolveMatrixElement: C,
      SVGFEDiffuseLightingElement: C,
      SVGFEDisplacementMapElement: C,
      SVGFEDistantLightElement: C,
      SVGFEDropShadowElement: C,
      SVGFEFloodElement: C,
      SVGFEFuncAElement: C,
      SVGFEFuncBElement: C,
      SVGFEFuncGElement: C,
      SVGFEFuncRElement: C,
      SVGFEGaussianBlurElement: C,
      SVGFEImageElement: C,
      SVGFEMergeElement: C,
      SVGFEMergeNodeElement: C,
      SVGFEMorphologyElement: C,
      SVGFEOffsetElement: C,
      SVGFEPointLightElement: C,
      SVGFESpecularLightingElement: C,
      SVGFESpotLightElement: C,
      SVGFETileElement: C,
      SVGFETurbulenceElement: C,
      SVGFilterElement: C,
      SVGForeignObjectElement: C,
      SVGGElement: C,
      SVGGeometryElement: C,
      SVGGradientElement: C,
      SVGGraphicsElement: C,
      SVGImageElement: C,
      SVGLength: C,
      SVGLengthList: C,
      SVGLinearGradientElement: C,
      SVGLineElement: C,
      SVGMarkerElement: C,
      SVGMaskElement: C,
      SVGMatrix: C,
      SVGMetadataElement: C,
      SVGMPathElement: C,
      SVGNumber: C,
      SVGNumberList: C,
      SVGPathElement: C,
      SVGPatternElement: C,
      SVGPoint: C,
      SVGPointList: C,
      SVGPolygonElement: C,
      SVGPolylineElement: C,
      SVGPreserveAspectRatio: C,
      SVGRadialGradientElement: C,
      SVGRect: C,
      SVGRectElement: C,
      SVGScriptElement: C,
      SVGSetElement: C,
      SVGStopElement: C,
      SVGStringList: C,
      SVGStyleElement: C,
      SVGSVGElement: C,
      SVGSwitchElement: C,
      SVGSymbolElement: C,
      SVGTextContentElement: C,
      SVGTextElement: C,
      SVGTextPathElement: C,
      SVGTextPositioningElement: C,
      SVGTitleElement: C,
      SVGTransform: C,
      SVGTransformList: C,
      SVGTSpanElement: C,
      SVGUnitTypes: C,
      SVGUseElement: C,
      SVGViewElement: C,
      TaskAttributionTiming: C,
      Text: C,
      TextEvent: C,
      TextMetrics: C,
      TextTrack: C,
      TextTrackCue: C,
      TextTrackCueList: C,
      TextTrackList: C,
      TimeRanges: C,
      toolbar: O,
      top: O,
      Touch: C,
      TouchEvent: C,
      TouchList: C,
      TrackEvent: C,
      TransitionEvent: C,
      TreeWalker: C,
      UIEvent: C,
      ValidityState: C,
      visualViewport: O,
      VisualViewport: C,
      VTTCue: C,
      WaveShaperNode: C,
      WebAssembly: O,
      WebGL2RenderingContext: C,
      WebGLActiveInfo: C,
      WebGLBuffer: C,
      WebGLContextEvent: C,
      WebGLFramebuffer: C,
      WebGLProgram: C,
      WebGLQuery: C,
      WebGLRenderbuffer: C,
      WebGLRenderingContext: C,
      WebGLSampler: C,
      WebGLShader: C,
      WebGLShaderPrecisionFormat: C,
      WebGLSync: C,
      WebGLTexture: C,
      WebGLTransformFeedback: C,
      WebGLUniformLocation: C,
      WebGLVertexArrayObject: C,
      WebSocket: C,
      WheelEvent: C,
      Window: C,
      Worker: C,
      WritableStream: C,
      XMLDocument: C,
      XMLHttpRequest: C,
      XMLHttpRequestEventTarget: C,
      XMLHttpRequestUpload: C,
      XMLSerializer: C,
      XPathEvaluator: C,
      XPathExpression: C,
      XPathResult: C,
      XSLTProcessor: C
    };
    for (const global2 of ["window", "global", "self", "globalThis"]) {
      knownGlobals[global2] = knownGlobals;
    }
    GlobalVariable = class extends Variable {
      constructor(name) {
        super(name);
        this.markReassigned();
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        switch (interaction.type) {
          // While there is no point in testing these cases as at the moment, they
          // are also covered via other means, we keep them for completeness
          case INTERACTION_ACCESSED:
          case INTERACTION_ASSIGNED: {
            if (!getGlobalAtPath([this.name, ...path3].slice(0, -1))) {
              super.deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
            }
            return;
          }
          case INTERACTION_CALLED: {
            const globalAtPath = getGlobalAtPath([this.name, ...path3]);
            if (globalAtPath) {
              globalAtPath.deoptimizeArgumentsOnCall(interaction);
            } else {
              super.deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
            }
            return;
          }
        }
      }
      getLiteralValueAtPath(path3, _recursionTracker, _origin) {
        const globalAtPath = getGlobalAtPath([this.name, ...path3]);
        return globalAtPath ? globalAtPath.getLiteralValue() : UnknownValue;
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        switch (interaction.type) {
          case INTERACTION_ACCESSED: {
            if (path3.length === 0) {
              return this.name !== "undefined" && !getGlobalAtPath([this.name]);
            }
            return !getGlobalAtPath([this.name, ...path3].slice(0, -1));
          }
          case INTERACTION_ASSIGNED: {
            return true;
          }
          case INTERACTION_CALLED: {
            const globalAtPath = getGlobalAtPath([this.name, ...path3]);
            return !globalAtPath || globalAtPath.hasEffectsWhenCalled(interaction, context8);
          }
        }
      }
    };
    MAX_PATH_DEPTH = 6;
    limitConcatenatedPathDepth = (path1, path22) => {
      const { length: length1 } = path1;
      const { length: length22 } = path22;
      return length1 === 0 ? path22 : length22 === 0 ? path1 : length1 + length22 > MAX_PATH_DEPTH ? [...path1, ...path22.slice(0, MAX_PATH_DEPTH - 1 - path1.length), "UnknownKey"] : [...path1, ...path22];
    };
    LocalVariable = class extends Variable {
      constructor(name, declarator, init2, initPath, context8, kind) {
        super(name);
        this.init = init2;
        this.initPath = initPath;
        this.kind = kind;
        this.calledFromTryStatement = false;
        this.additionalInitializers = null;
        this.includedPathTracker = new IncludedFullPathTracker();
        this.expressionsToBeDeoptimized = [];
        this.declarations = declarator ? [declarator] : [];
        this.deoptimizationTracker = context8.deoptimizationTracker;
        this.module = context8.module;
      }
      addDeclaration(identifier4, init2) {
        this.declarations.push(identifier4);
        this.markInitializersForDeoptimization().push(init2);
      }
      consolidateInitializers() {
        if (this.additionalInitializers) {
          for (const initializer of this.additionalInitializers) {
            initializer.deoptimizePath(UNKNOWN_PATH);
          }
        }
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        if (this.isReassigned || path3.length + this.initPath.length > MAX_PATH_DEPTH) {
          deoptimizeInteraction(interaction);
          return;
        }
        recursionTracker.withTrackedEntityAtPath(path3, this.init, () => {
          this.init.deoptimizeArgumentsOnInteractionAtPath(interaction, [...this.initPath, ...path3], recursionTracker);
        }, void 0);
      }
      deoptimizePath(path3) {
        if (this.isReassigned || this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path3, this)) {
          return;
        }
        if (path3.length === 0) {
          this.markReassigned();
          const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;
          this.expressionsToBeDeoptimized = EMPTY_ARRAY;
          for (const expression of expressionsToBeDeoptimized) {
            expression.deoptimizeCache();
          }
          this.init.deoptimizePath([...this.initPath, UnknownKey]);
        } else {
          this.init.deoptimizePath(limitConcatenatedPathDepth(this.initPath, path3));
        }
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        if (this.isReassigned || path3.length + this.initPath.length > MAX_PATH_DEPTH) {
          return UnknownValue;
        }
        return recursionTracker.withTrackedEntityAtPath(path3, this.init, () => {
          this.expressionsToBeDeoptimized.push(origin);
          return this.init.getLiteralValueAtPath([...this.initPath, ...path3], recursionTracker, origin);
        }, UnknownValue);
      }
      getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin) {
        if (this.isReassigned || path3.length + this.initPath.length > MAX_PATH_DEPTH) {
          return UNKNOWN_RETURN_EXPRESSION;
        }
        return recursionTracker.withTrackedEntityAtPath(path3, this.init, () => {
          this.expressionsToBeDeoptimized.push(origin);
          return this.init.getReturnExpressionWhenCalledAtPath([...this.initPath, ...path3], interaction, recursionTracker, origin);
        }, UNKNOWN_RETURN_EXPRESSION);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        if (path3.length + this.initPath.length > MAX_PATH_DEPTH) {
          return true;
        }
        switch (interaction.type) {
          case INTERACTION_ACCESSED: {
            if (this.isReassigned)
              return true;
            return !context8.accessed.trackEntityAtPathAndGetIfTracked(path3, this) && this.init.hasEffectsOnInteractionAtPath([...this.initPath, ...path3], interaction, context8);
          }
          case INTERACTION_ASSIGNED: {
            if (this.included)
              return true;
            if (path3.length === 0)
              return false;
            if (this.isReassigned)
              return true;
            return !context8.assigned.trackEntityAtPathAndGetIfTracked(path3, this) && this.init.hasEffectsOnInteractionAtPath([...this.initPath, ...path3], interaction, context8);
          }
          case INTERACTION_CALLED: {
            if (this.isReassigned)
              return true;
            return !(interaction.withNew ? context8.instantiated : context8.called).trackEntityAtPathAndGetIfTracked(path3, interaction.args, this) && this.init.hasEffectsOnInteractionAtPath([...this.initPath, ...path3], interaction, context8);
          }
        }
      }
      includePath(path3, context8) {
        if (!this.includedPathTracker.includePathAndGetIfIncluded(path3)) {
          this.module.scope.context.requestTreeshakingPass();
          if (!this.included) {
            this.module.scope.context.newlyIncludedVariableInits.add(this.init);
          }
          super.includePath(path3, context8);
          for (const declaration of this.declarations) {
            if (!declaration.included)
              declaration.include(context8, false);
            let node = declaration.parent;
            while (!node.included) {
              node.includeNode(context8);
              if (node.type === Program)
                break;
              node = node.parent;
            }
          }
          if (path3.length > 0) {
            this.init.includePath(limitConcatenatedPathDepth(this.initPath, path3), context8);
            this.additionalInitializers?.forEach((initializer) => initializer.includePath(UNKNOWN_PATH, context8));
          }
        }
      }
      includeCallArguments(interaction, context8) {
        if (this.isReassigned || context8.includedCallArguments.has(this.init) || // This can be removed again once we can include arguments when called at
        // a specific path
        this.initPath.length > 0) {
          includeInteraction(interaction, context8);
        } else {
          context8.includedCallArguments.add(this.init);
          this.init.includeCallArguments(interaction, context8);
          context8.includedCallArguments.delete(this.init);
        }
      }
      markCalledFromTryStatement() {
        this.calledFromTryStatement = true;
      }
      markInitializersForDeoptimization() {
        if (this.additionalInitializers === null) {
          this.additionalInitializers = [this.init];
          this.init = UNKNOWN_EXPRESSION;
          this.markReassigned();
        }
        return this.additionalInitializers;
      }
    };
    tdzVariableKinds = /* @__PURE__ */ new Set(["class", "const", "let", "var", "using", "await using"]);
    IdentifierBase = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.variable = null;
        this.isVariableReference = false;
      }
      get isTDZAccess() {
        if (!isFlagSet(
          this.flags,
          4
          /* Flag.tdzAccessDefined */
        )) {
          return null;
        }
        return isFlagSet(
          this.flags,
          8
          /* Flag.tdzAccess */
        );
      }
      set isTDZAccess(value) {
        this.flags = setFlag(this.flags, 4, true);
        this.flags = setFlag(this.flags, 8, value);
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        this.variable.deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
      }
      deoptimizePath(path3) {
        if (path3.length === 0 && !this.scope.contains(this.name)) {
          this.disallowImportReassignment();
        }
        this.variable?.deoptimizePath(path3);
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        return this.getVariableRespectingTDZ().getLiteralValueAtPath(path3, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin) {
        const [expression, isPure] = this.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin);
        return [expression, isPure || this.isPureFunction(path3)];
      }
      hasEffects(context8) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        if (this.isPossibleTDZ() && this.variable.kind !== "var") {
          return true;
        }
        return this.scope.context.options.treeshake.unknownGlobalSideEffects && this.variable instanceof GlobalVariable && !this.isPureFunction(EMPTY_PATH) && this.variable.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_ACCESS, context8);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        switch (interaction.type) {
          case INTERACTION_ACCESSED: {
            return this.variable !== null && !this.isPureFunction(path3) && this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(path3, interaction, context8);
          }
          case INTERACTION_ASSIGNED: {
            return (path3.length > 0 ? this.getVariableRespectingTDZ() : this.variable).hasEffectsOnInteractionAtPath(path3, interaction, context8);
          }
          case INTERACTION_CALLED: {
            return !this.isPureFunction(path3) && this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(path3, interaction, context8);
          }
        }
      }
      include(context8, includeChildrenRecursively) {
        if (!this.included)
          this.includeNode(context8);
        if (includeChildrenRecursively) {
          this.variable?.includePath(UNKNOWN_PATH, context8);
        }
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        if (this.variable !== null) {
          this.scope.context.includeVariableInModule(this.variable, EMPTY_PATH, context8);
        }
      }
      includePath(path3, context8) {
        if (!this.included) {
          this.included = true;
          if (!this.deoptimized)
            this.applyDeoptimizations();
          if (this.variable !== null) {
            this.scope.context.includeVariableInModule(this.variable, path3, context8);
          }
        } else if (path3.length > 0) {
          this.variable?.includePath(path3, context8);
        }
      }
      includeCallArguments(interaction, context8) {
        this.variable.includeCallArguments(interaction, context8);
      }
      isPossibleTDZ() {
        const cachedTdzAccess = this.isTDZAccess;
        if (cachedTdzAccess !== null)
          return cachedTdzAccess;
        if (!(this.variable instanceof LocalVariable && this.variable.kind && tdzVariableKinds.has(this.variable.kind) && // We ignore modules that did not receive a treeshaking pass yet as that
        // causes many false positives due to circular dependencies or disabled
        // moduleSideEffects.
        this.variable.module.hasTreeShakingPassStarted)) {
          return this.isTDZAccess = false;
        }
        let decl_id;
        if (this.variable.declarations && this.variable.declarations.length === 1 && (decl_id = this.variable.declarations[0]) && this.start < decl_id.start && closestParentFunctionOrProgram(this) === closestParentFunctionOrProgram(decl_id)) {
          return this.isTDZAccess = true;
        }
        if (!this.variable.initReached) {
          return this.isTDZAccess = true;
        }
        return this.isTDZAccess = false;
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        if (this.variable instanceof LocalVariable) {
          if (!this.variable.module.isExecuted) {
            markModuleAndImpureDependenciesAsExecuted(this.variable.module);
          }
          this.variable.consolidateInitializers();
          this.scope.context.requestTreeshakingPass();
        }
        if (this.isVariableReference) {
          this.variable.addUsedPlace(this);
          this.scope.context.requestTreeshakingPass();
        }
      }
      disallowImportReassignment() {
        return this.scope.context.error(logIllegalImportReassignment(this.name, this.scope.context.module.id), this.start);
      }
      getVariableRespectingTDZ() {
        if (this.isPossibleTDZ()) {
          return UNKNOWN_EXPRESSION;
        }
        return this.variable;
      }
      isPureFunction(path3) {
        let currentPureFunction = this.scope.context.manualPureFunctions[this.name];
        for (const segment of path3) {
          if (currentPureFunction) {
            if (currentPureFunction[PureFunctionKey]) {
              return true;
            }
            currentPureFunction = currentPureFunction[segment];
          } else {
            return false;
          }
        }
        return currentPureFunction?.[PureFunctionKey];
      }
    };
    ObjectMember = class extends ExpressionEntity {
      constructor(object, path3) {
        super();
        this.object = object;
        this.path = path3;
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        this.object.deoptimizeArgumentsOnInteractionAtPath(interaction, [...this.path, ...path3], recursionTracker);
      }
      deoptimizePath(path3) {
        this.object.deoptimizePath([...this.path, ...path3]);
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        return this.object.getLiteralValueAtPath([...this.path, ...path3], recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin) {
        return this.object.getReturnExpressionWhenCalledAtPath([...this.path, ...path3], interaction, recursionTracker, origin);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        return this.object.hasEffectsOnInteractionAtPath([...this.path, ...path3], interaction, context8);
      }
    };
    Identifier2 = class extends IdentifierBase {
      constructor() {
        super(...arguments);
        this.variable = null;
      }
      get isDestructuringDeoptimized() {
        return isFlagSet(
          this.flags,
          16777216
          /* Flag.destructuringDeoptimized */
        );
      }
      set isDestructuringDeoptimized(value) {
        this.flags = setFlag(this.flags, 16777216, value);
      }
      addExportedVariables(variables, exportNamesByVariable) {
        if (exportNamesByVariable.has(this.variable)) {
          variables.push(this.variable);
        }
      }
      bind() {
        if (!this.variable && is_reference(this, this.parent)) {
          this.variable = this.scope.findVariable(this.name);
          this.variable.addReference(this);
          this.isVariableReference = true;
        }
      }
      declare(kind, destructuredInitPath, init2) {
        let variable;
        const { treeshake } = this.scope.context.options;
        if (kind === "parameter") {
          variable = this.scope.addParameterDeclaration(this, destructuredInitPath);
        } else {
          variable = this.scope.addDeclaration(this, this.scope.context, init2, destructuredInitPath, kind);
          if (kind === "var" && treeshake && treeshake.correctVarValueBeforeDeclaration) {
            variable.markInitializersForDeoptimization();
          }
        }
        return [this.variable = variable];
      }
      deoptimizeAssignment(destructuredInitPath, init2) {
        this.deoptimizePath(EMPTY_PATH);
        init2.deoptimizePath([...destructuredInitPath, UnknownKey]);
      }
      hasEffectsWhenDestructuring(context8, destructuredInitPath, init2) {
        return destructuredInitPath.length > 0 && init2.hasEffectsOnInteractionAtPath(destructuredInitPath, NODE_INTERACTION_UNKNOWN_ACCESS, context8);
      }
      includeDestructuredIfNecessary(context8, destructuredInitPath, init2) {
        if (destructuredInitPath.length > 0 && !this.isDestructuringDeoptimized) {
          this.isDestructuringDeoptimized = true;
          init2.deoptimizeArgumentsOnInteractionAtPath({
            args: [new ObjectMember(init2, destructuredInitPath.slice(0, -1))],
            type: INTERACTION_ACCESSED
          }, destructuredInitPath, SHARED_RECURSION_TRACKER);
        }
        const { propertyReadSideEffects } = this.scope.context.options.treeshake;
        if (this.included ||= destructuredInitPath.length > 0 && !context8.brokenFlow && propertyReadSideEffects && (propertyReadSideEffects === "always" || init2.hasEffectsOnInteractionAtPath(destructuredInitPath, NODE_INTERACTION_UNKNOWN_ACCESS, createHasEffectsContext()))) {
          if (this.variable && !this.variable.included) {
            this.scope.context.includeVariableInModule(this.variable, EMPTY_PATH, context8);
          }
          init2.includePath(destructuredInitPath, context8);
          return true;
        }
        return false;
      }
      markDeclarationReached() {
        this.variable.initReached = true;
      }
      render(code, { snippets: { getPropertyAccess }, useOriginalName }, { renderedParentType, isCalleeOfRenderedParent, isShorthandProperty } = BLANK) {
        if (this.variable) {
          const name = this.variable.getName(getPropertyAccess, useOriginalName);
          if (name !== this.name) {
            code.overwrite(this.start, this.end, name, {
              contentOnly: true,
              storeName: true
            });
            if (isShorthandProperty) {
              code.prependRight(this.start, `${this.name}: `);
            }
          }
          if (name === "eval" && renderedParentType === CallExpression && isCalleeOfRenderedParent) {
            code.appendRight(this.start, "0, ");
          }
        }
      }
    };
    chars2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
    base = 64;
    Scope2 = class {
      constructor() {
        this.children = [];
        this.variables = /* @__PURE__ */ new Map();
      }
      /*
      Redeclaration rules:
      - var can redeclare var
      - in function scopes, function and var can redeclare function and var
      - var is hoisted across scopes, function remains in the scope it is declared
      - var and function can redeclare function parameters, but parameters cannot redeclare parameters
      - function cannot redeclare catch scope parameters
      - var can redeclare catch scope parameters in a way
          - if the parameter is an identifier and not a pattern
          - then the variable is still declared in the hoisted outer scope, but the initializer is assigned to the parameter
      - const, let, class, and function except in the cases above cannot redeclare anything
       */
      addDeclaration(identifier4, context8, init2, destructuredInitPath, kind) {
        const name = identifier4.name;
        const existingVariable = this.hoistedVariables?.get(name) || this.variables.get(name);
        if (existingVariable) {
          if (kind === "var" && existingVariable.kind === "var") {
            existingVariable.addDeclaration(identifier4, init2);
            return existingVariable;
          }
          context8.error(logRedeclarationError(name), identifier4.start);
        }
        const newVariable = new LocalVariable(identifier4.name, identifier4, init2, destructuredInitPath, context8, kind);
        this.variables.set(name, newVariable);
        return newVariable;
      }
      addHoistedVariable(name, variable) {
        (this.hoistedVariables ||= /* @__PURE__ */ new Map()).set(name, variable);
      }
      contains(name) {
        return this.variables.has(name);
      }
      findVariable(_name) {
        throw new Error("Internal Error: findVariable needs to be implemented by a subclass");
      }
    };
    ChildScope = class _ChildScope extends Scope2 {
      constructor(parent, context8) {
        super();
        this.parent = parent;
        this.context = context8;
        this.accessedOutsideVariables = /* @__PURE__ */ new Map();
        parent.children.push(this);
      }
      addAccessedDynamicImport(importExpression3) {
        (this.accessedDynamicImports || (this.accessedDynamicImports = /* @__PURE__ */ new Set())).add(importExpression3);
        if (this.parent instanceof _ChildScope) {
          this.parent.addAccessedDynamicImport(importExpression3);
        }
      }
      addAccessedGlobals(globals, accessedGlobalsByScope) {
        const accessedGlobals = accessedGlobalsByScope.get(this) || /* @__PURE__ */ new Set();
        for (const name of globals) {
          accessedGlobals.add(name);
        }
        accessedGlobalsByScope.set(this, accessedGlobals);
        if (this.parent instanceof _ChildScope) {
          this.parent.addAccessedGlobals(globals, accessedGlobalsByScope);
        }
      }
      addNamespaceMemberAccess(name, variable) {
        this.accessedOutsideVariables.set(name, variable);
        this.parent.addNamespaceMemberAccess(name, variable);
      }
      addReturnExpression(expression) {
        if (this.parent instanceof _ChildScope) {
          this.parent.addReturnExpression(expression);
        }
      }
      addUsedOutsideNames(usedNames, format5, exportNamesByVariable, accessedGlobalsByScope) {
        for (const variable of this.accessedOutsideVariables.values()) {
          if (variable.included) {
            usedNames.add(variable.getBaseVariableName());
            if (format5 === "system" && exportNamesByVariable.has(variable)) {
              usedNames.add("exports");
            }
          }
        }
        const accessedGlobals = accessedGlobalsByScope.get(this);
        if (accessedGlobals) {
          for (const name of accessedGlobals) {
            usedNames.add(name);
          }
        }
      }
      contains(name) {
        return this.variables.has(name) || this.parent.contains(name);
      }
      deconflict(format5, exportNamesByVariable, accessedGlobalsByScope) {
        const usedNames = /* @__PURE__ */ new Set();
        this.addUsedOutsideNames(usedNames, format5, exportNamesByVariable, accessedGlobalsByScope);
        if (this.accessedDynamicImports) {
          for (const importExpression3 of this.accessedDynamicImports) {
            if (importExpression3.inlineNamespace) {
              usedNames.add(importExpression3.inlineNamespace.getBaseVariableName());
            }
          }
        }
        for (const [name, variable] of this.variables) {
          if (variable.included || variable.alwaysRendered) {
            variable.setRenderNames(null, getSafeName(name, usedNames, variable.forbiddenNames));
          }
        }
        for (const scope5 of this.children) {
          scope5.deconflict(format5, exportNamesByVariable, accessedGlobalsByScope);
        }
      }
      findLexicalBoundary() {
        return this.parent.findLexicalBoundary();
      }
      findGlobal(name) {
        const variable = this.parent.findVariable(name);
        this.accessedOutsideVariables.set(name, variable);
        return variable;
      }
      findVariable(name) {
        const knownVariable = this.variables.get(name) || this.accessedOutsideVariables.get(name);
        if (knownVariable) {
          return knownVariable;
        }
        const variable = this.parent.findVariable(name);
        this.accessedOutsideVariables.set(name, variable);
        return variable;
      }
    };
    MethodBase = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.accessedValue = null;
      }
      get computed() {
        return isFlagSet(
          this.flags,
          1024
          /* Flag.computed */
        );
      }
      set computed(value) {
        this.flags = setFlag(this.flags, 1024, value);
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        if (interaction.type === INTERACTION_ACCESSED && this.kind === "get" && path3.length === 0) {
          return this.value.deoptimizeArgumentsOnInteractionAtPath({
            args: interaction.args,
            type: INTERACTION_CALLED,
            withNew: false
          }, EMPTY_PATH, recursionTracker);
        }
        if (interaction.type === INTERACTION_ASSIGNED && this.kind === "set" && path3.length === 0) {
          return this.value.deoptimizeArgumentsOnInteractionAtPath({
            args: interaction.args,
            type: INTERACTION_CALLED,
            withNew: false
          }, EMPTY_PATH, recursionTracker);
        }
        this.getAccessedValue()[0].deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
      }
      // As getter properties directly receive their values from fixed function
      // expressions, there is no known situation where a getter is deoptimized.
      deoptimizeCache() {
      }
      deoptimizePath(path3) {
        this.getAccessedValue()[0].deoptimizePath(path3);
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        return this.getAccessedValue()[0].getLiteralValueAtPath(path3, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin) {
        return this.getAccessedValue()[0].getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin);
      }
      hasEffects(context8) {
        return this.key.hasEffects(context8);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        if (this.kind === "get" && interaction.type === INTERACTION_ACCESSED && path3.length === 0) {
          return this.value.hasEffectsOnInteractionAtPath(EMPTY_PATH, {
            args: interaction.args,
            type: INTERACTION_CALLED,
            withNew: false
          }, context8);
        }
        if (this.kind === "set" && interaction.type === INTERACTION_ASSIGNED) {
          return this.value.hasEffectsOnInteractionAtPath(EMPTY_PATH, {
            args: interaction.args,
            type: INTERACTION_CALLED,
            withNew: false
          }, context8);
        }
        return this.getAccessedValue()[0].hasEffectsOnInteractionAtPath(path3, interaction, context8);
      }
      getAccessedValue() {
        if (this.accessedValue === null) {
          if (this.kind === "get") {
            this.accessedValue = UNKNOWN_RETURN_EXPRESSION;
            return this.accessedValue = this.value.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, SHARED_RECURSION_TRACKER, this);
          } else {
            return this.accessedValue = [this.value, false];
          }
        }
        return this.accessedValue;
      }
    };
    MethodBase.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    MethodBase.prototype.applyDeoptimizations = doNotDeoptimize;
    MethodDefinition = class extends MethodBase {
      hasEffects(context8) {
        return super.hasEffects(context8) || checkEffectForNodes(this.decorators, context8);
      }
    };
    BlockScope = class extends ChildScope {
      constructor(parent) {
        super(parent, parent.context);
      }
      addDeclaration(identifier4, context8, init2, destructuredInitPath, kind) {
        if (kind === "var") {
          const name = identifier4.name;
          const existingVariable = this.hoistedVariables?.get(name) || this.variables.get(name);
          if (existingVariable) {
            if (existingVariable.kind === "var" || kind === "var" && existingVariable.kind === "parameter") {
              existingVariable.addDeclaration(identifier4, init2);
              return existingVariable;
            }
            return context8.error(logRedeclarationError(name), identifier4.start);
          }
          const declaredVariable = this.parent.addDeclaration(identifier4, context8, init2, destructuredInitPath, kind);
          declaredVariable.markInitializersForDeoptimization();
          this.addHoistedVariable(name, declaredVariable);
          return declaredVariable;
        }
        return super.addDeclaration(identifier4, context8, init2, destructuredInitPath, kind);
      }
    };
    StaticBlock2 = class extends NodeBase {
      createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
      }
      hasEffects(context8) {
        for (const node of this.body) {
          if (node.hasEffects(context8))
            return true;
        }
        return false;
      }
      include(context8, includeChildrenRecursively) {
        this.included = true;
        for (const node of this.body) {
          if (includeChildrenRecursively || node.shouldBeIncluded(context8))
            node.include(context8, includeChildrenRecursively);
        }
      }
      render(code, options) {
        if (this.body.length > 0) {
          const bodyStartPos = findFirstOccurrenceOutsideComment(code.original.slice(this.start, this.end), "{") + 1;
          renderStatementList(this.body, code, this.start + bodyStartPos, this.end - 1, options);
        } else {
          super.render(code, options);
        }
      }
    };
    StaticBlock2.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    StaticBlock2.prototype.applyDeoptimizations = doNotDeoptimize;
    ClassNode = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.objectEntity = null;
      }
      createScope(parentScope) {
        this.scope = new ChildScope(parentScope, parentScope.context);
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
      }
      deoptimizeCache() {
        this.getObjectEntity().deoptimizeAllProperties();
      }
      deoptimizePath(path3) {
        this.getObjectEntity().deoptimizePath(path3);
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        return this.getObjectEntity().getLiteralValueAtPath(path3, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin) {
        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin);
      }
      hasEffects(context8) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        const initEffect = this.superClass?.hasEffects(context8) || this.body.hasEffects(context8);
        this.id?.markDeclarationReached();
        return initEffect || super.hasEffects(context8) || checkEffectForNodes(this.decorators, context8);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        return interaction.type === INTERACTION_CALLED && path3.length === 0 ? !interaction.withNew || (this.classConstructor === null ? this.superClass?.hasEffectsOnInteractionAtPath(path3, interaction, context8) : this.classConstructor.hasEffectsOnInteractionAtPath(path3, interaction, context8)) || false : this.getObjectEntity().hasEffectsOnInteractionAtPath(path3, interaction, context8);
      }
      include(context8, includeChildrenRecursively) {
        if (!this.included)
          this.includeNode(context8);
        this.superClass?.include(context8, includeChildrenRecursively);
        this.body.include(context8, includeChildrenRecursively);
        for (const decorator3 of this.decorators)
          decorator3.include(context8, includeChildrenRecursively);
        if (this.id) {
          this.id.markDeclarationReached();
          this.id.include(context8, includeChildrenRecursively);
        }
      }
      initialise() {
        super.initialise();
        this.id?.declare("class", EMPTY_PATH, this);
        for (const method of this.body.body) {
          if (method instanceof MethodDefinition && method.kind === "constructor") {
            this.classConstructor = method;
            return;
          }
        }
        this.classConstructor = null;
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        for (const definition of this.body.body) {
          if (!isStaticBlock(definition) && !(definition.static || definition instanceof MethodDefinition && definition.kind === "constructor")) {
            definition.deoptimizePath(UNKNOWN_PATH);
          }
        }
        this.scope.context.requestTreeshakingPass();
      }
      getObjectEntity() {
        if (this.objectEntity !== null) {
          return this.objectEntity;
        }
        const staticProperties = [];
        const dynamicMethods = [];
        for (const definition of this.body.body) {
          if (isStaticBlock(definition))
            continue;
          const properties = definition.static ? staticProperties : dynamicMethods;
          const definitionKind = definition.kind;
          if (properties === dynamicMethods && !definitionKind)
            continue;
          const kind = definitionKind === "set" || definitionKind === "get" ? definitionKind : "init";
          let key;
          if (definition.computed) {
            const keyValue = definition.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
            if (typeof keyValue === "symbol") {
              properties.push({ key: UnknownKey, kind, property: definition });
              continue;
            } else {
              key = String(keyValue);
            }
          } else {
            key = definition.key instanceof Identifier2 ? definition.key.name : String(definition.key.value);
          }
          properties.push({ key, kind, property: definition });
        }
        staticProperties.unshift({
          key: "prototype",
          kind: "init",
          property: new ObjectEntity(dynamicMethods, this.superClass ? new ObjectMember(this.superClass, ["prototype"]) : OBJECT_PROTOTYPE)
        });
        return this.objectEntity = new ObjectEntity(staticProperties, this.superClass || OBJECT_PROTOTYPE);
      }
    };
    ClassNode.prototype.includeNode = onlyIncludeSelf;
    ClassDeclaration = class extends ClassNode {
      initialise() {
        super.initialise();
        if (this.id !== null) {
          this.id.variable.isId = true;
        }
      }
      parseNode(esTreeNode) {
        if (esTreeNode.id !== null) {
          this.id = new Identifier2(this, this.scope.parent).parseNode(esTreeNode.id);
        }
        return super.parseNode(esTreeNode);
      }
      render(code, options) {
        const { exportNamesByVariable, format: format5, snippets: { _: _2, getPropertyAccess } } = options;
        if (this.id) {
          const { variable, name } = this.id;
          if (format5 === "system" && exportNamesByVariable.has(variable)) {
            code.appendLeft(this.end, `${_2}${getSystemExportStatement([variable], options)};`);
          }
          const renderedVariable = variable.getName(getPropertyAccess);
          if (renderedVariable !== name) {
            this.decorators.map((decorator3) => decorator3.render(code, options));
            this.superClass?.render(code, options);
            this.body.render(code, {
              ...options,
              useOriginalName: (_variable) => _variable === variable
            });
            code.prependRight(this.start, `let ${renderedVariable}${_2}=${_2}`);
            code.prependLeft(this.end, ";");
            return;
          }
        }
        super.render(code, options);
      }
      applyDeoptimizations() {
        super.applyDeoptimizations();
        const { id: id2, scope: scope5 } = this;
        if (id2) {
          const { name, variable } = id2;
          for (const accessedVariable of scope5.accessedOutsideVariables.values()) {
            if (accessedVariable !== variable) {
              accessedVariable.forbidName(name);
            }
          }
        }
      }
    };
    ArgumentsVariable = class extends LocalVariable {
      constructor(context8) {
        super("arguments", null, UNKNOWN_EXPRESSION, EMPTY_PATH, context8, "other");
      }
      addArgumentToBeDeoptimized(_argument) {
      }
      // Only If there is at least one reference, then we need to track all
      // arguments in order to be able to deoptimize them.
      addReference() {
        this.deoptimizedArguments = [];
        this.addArgumentToBeDeoptimized = addArgumentToBeDeoptimized;
      }
      hasEffectsOnInteractionAtPath(path3, { type }) {
        return type !== INTERACTION_ACCESSED || path3.length > 1;
      }
      includePath(path3, context8) {
        super.includePath(path3, context8);
        for (const argument of this.deoptimizedArguments) {
          argument.deoptimizePath(UNKNOWN_PATH);
        }
        this.deoptimizedArguments.length = 0;
      }
    };
    MAX_TRACKED_INTERACTIONS = 20;
    NO_INTERACTIONS = EMPTY_ARRAY;
    UNKNOWN_DEOPTIMIZED_FIELD = /* @__PURE__ */ new Set([UnknownKey]);
    EMPTY_PATH_TRACKER = new EntityPathTracker();
    UNKNOWN_DEOPTIMIZED_ENTITY = /* @__PURE__ */ new Set([UNKNOWN_EXPRESSION]);
    ParameterVariable = class extends LocalVariable {
      constructor(name, declarator, argumentPath, context8) {
        super(name, declarator, UNKNOWN_EXPRESSION, argumentPath, context8, "parameter");
        this.includedPathTracker = new IncludedTopLevelPathTracker();
        this.argumentsToBeDeoptimized = /* @__PURE__ */ new Set();
        this.deoptimizationInteractions = [];
        this.deoptimizations = new EntityPathTracker();
        this.deoptimizedFields = /* @__PURE__ */ new Set();
        this.expressionsDependingOnKnownValue = [];
        this.knownValue = null;
        this.knownValueLiteral = UnknownValue;
      }
      addArgumentForDeoptimization(entity) {
        this.updateKnownValue(entity);
        if (entity === UNKNOWN_EXPRESSION) {
          if (!this.argumentsToBeDeoptimized.has(UNKNOWN_EXPRESSION)) {
            this.argumentsToBeDeoptimized.add(UNKNOWN_EXPRESSION);
            for (const { interaction } of this.deoptimizationInteractions) {
              deoptimizeInteraction(interaction);
            }
            this.deoptimizationInteractions = NO_INTERACTIONS;
          }
        } else if (this.deoptimizedFields.has(UnknownKey)) {
          entity.deoptimizePath([...this.initPath, UnknownKey]);
        } else if (!this.argumentsToBeDeoptimized.has(entity)) {
          this.argumentsToBeDeoptimized.add(entity);
          for (const field of this.deoptimizedFields) {
            entity.deoptimizePath([...this.initPath, field]);
          }
          for (const { interaction, path: path3 } of this.deoptimizationInteractions) {
            entity.deoptimizeArgumentsOnInteractionAtPath(interaction, [...this.initPath, ...path3], SHARED_RECURSION_TRACKER);
          }
        }
      }
      /** This says we should not make assumptions about the value of the parameter.
       *  This is different from deoptimization that will also cause argument values
       *  to be deoptimized. */
      markReassigned() {
        if (this.isReassigned) {
          return;
        }
        super.markReassigned();
        for (const expression of this.expressionsDependingOnKnownValue) {
          expression.deoptimizeCache();
        }
        this.expressionsDependingOnKnownValue = EMPTY_ARRAY;
      }
      deoptimizeCache() {
        this.markReassigned();
      }
      /**
       * Update the known value of the parameter variable.
       * Must be called for every function call, so it can track all the arguments,
       * and deoptimizeCache itself to mark reassigned if the argument is changed.
       * @param argument The argument of the function call
       */
      updateKnownValue(argument) {
        if (this.isReassigned) {
          return;
        }
        if (this.knownValue === null) {
          this.knownValue = argument;
          this.knownValueLiteral = argument.getLiteralValueAtPath(this.initPath, SHARED_RECURSION_TRACKER, this);
          return;
        }
        if (this.knownValue === argument || this.knownValue instanceof Identifier2 && argument instanceof Identifier2 && this.knownValue.variable === argument.variable) {
          return;
        }
        const { knownValueLiteral } = this;
        if (typeof knownValueLiteral === "symbol" || argument.getLiteralValueAtPath(this.initPath, SHARED_RECURSION_TRACKER, this) !== knownValueLiteral) {
          this.markReassigned();
        }
      }
      /**
       * This function freezes the known value of the parameter variable,
       * so the optimization starts with a certain ExpressionEntity.
       * The optimization can be undone by calling `markReassigned`.
       * @returns the frozen value
       */
      getKnownValue() {
        return this.knownValue || UNKNOWN_EXPRESSION;
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        if (this.isReassigned || path3.length + this.initPath.length > MAX_PATH_DEPTH) {
          return UnknownValue;
        }
        const knownValue = this.getKnownValue();
        this.expressionsDependingOnKnownValue.push(origin);
        return recursionTracker.withTrackedEntityAtPath(path3, knownValue, () => knownValue.getLiteralValueAtPath([...this.initPath, ...path3], recursionTracker, origin), UnknownValue);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        const { type } = interaction;
        if (this.isReassigned || type === INTERACTION_ASSIGNED || path3.length + this.initPath.length > MAX_PATH_DEPTH) {
          return super.hasEffectsOnInteractionAtPath(path3, interaction, context8);
        }
        return !(type === INTERACTION_CALLED ? (interaction.withNew ? context8.instantiated : context8.called).trackEntityAtPathAndGetIfTracked(path3, interaction.args, this) : context8.accessed.trackEntityAtPathAndGetIfTracked(path3, this)) && this.getKnownValue().hasEffectsOnInteractionAtPath([...this.initPath, ...path3], interaction, context8);
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3) {
        if (path3.length >= 2 || this.argumentsToBeDeoptimized.has(UNKNOWN_EXPRESSION) || this.deoptimizationInteractions.length >= MAX_TRACKED_INTERACTIONS || path3.length === 1 && (this.deoptimizedFields.has(UnknownKey) || interaction.type === INTERACTION_CALLED && this.deoptimizedFields.has(path3[0])) || this.initPath.length + path3.length > MAX_PATH_DEPTH) {
          deoptimizeInteraction(interaction);
          return;
        }
        if (!this.deoptimizations.trackEntityAtPathAndGetIfTracked(path3, interaction.args)) {
          for (const entity of this.argumentsToBeDeoptimized) {
            entity.deoptimizeArgumentsOnInteractionAtPath(interaction, [...this.initPath, ...path3], SHARED_RECURSION_TRACKER);
          }
          if (!this.argumentsToBeDeoptimized.has(UNKNOWN_EXPRESSION)) {
            this.deoptimizationInteractions.push({
              interaction,
              path: path3
            });
          }
        }
      }
      deoptimizePath(path3) {
        if (path3.length === 0) {
          this.markReassigned();
          return;
        }
        if (this.deoptimizedFields.has(UnknownKey)) {
          return;
        }
        const key = path3[0];
        if (this.deoptimizedFields.has(key)) {
          return;
        }
        this.deoptimizedFields.add(key);
        for (const entity of this.argumentsToBeDeoptimized) {
          entity.deoptimizePath([...this.initPath, key]);
        }
        if (key === UnknownKey) {
          this.deoptimizationInteractions = NO_INTERACTIONS;
          this.deoptimizations = EMPTY_PATH_TRACKER;
          this.deoptimizedFields = UNKNOWN_DEOPTIMIZED_FIELD;
          this.argumentsToBeDeoptimized = UNKNOWN_DEOPTIMIZED_ENTITY;
        }
      }
      getReturnExpressionWhenCalledAtPath(path3) {
        if (path3.length === 0) {
          this.deoptimizePath(UNKNOWN_PATH);
        } else if (!this.deoptimizedFields.has(path3[0])) {
          this.deoptimizePath([path3[0]]);
        }
        return UNKNOWN_RETURN_EXPRESSION;
      }
      includeArgumentPaths(entity, context8) {
        this.includedPathTracker.includeAllPaths(entity, context8, this.initPath);
      }
    };
    ThisVariable = class extends ParameterVariable {
      constructor(context8) {
        super("this", null, EMPTY_PATH, context8);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        return (context8.replacedVariableInits.get(this) || UNKNOWN_EXPRESSION).hasEffectsOnInteractionAtPath(path3, interaction, context8);
      }
    };
    CatchBodyScope = class extends ChildScope {
      constructor(parent) {
        super(parent, parent.context);
        this.parent = parent;
      }
      addDeclaration(identifier4, context8, init2, destructuredInitPath, kind) {
        if (kind === "var") {
          const name = identifier4.name;
          const existingVariable = this.hoistedVariables?.get(name) || this.variables.get(name);
          if (existingVariable) {
            const existingKind = existingVariable.kind;
            if (existingKind === "parameter" && // If this is a destructured parameter, it is forbidden to redeclare
            existingVariable.declarations[0].parent.type === CatchClause) {
              const declaredVariable2 = this.parent.parent.addDeclaration(identifier4, context8, UNDEFINED_EXPRESSION, destructuredInitPath, kind);
              existingVariable.renderLikeHoisted(declaredVariable2);
              this.addHoistedVariable(name, declaredVariable2);
              return declaredVariable2;
            }
            if (existingKind === "var") {
              existingVariable.addDeclaration(identifier4, init2);
              return existingVariable;
            }
            return context8.error(logRedeclarationError(name), identifier4.start);
          }
          const declaredVariable = this.parent.parent.addDeclaration(identifier4, context8, init2, destructuredInitPath, kind);
          declaredVariable.markInitializersForDeoptimization();
          this.addHoistedVariable(name, declaredVariable);
          return declaredVariable;
        }
        return super.addDeclaration(identifier4, context8, init2, destructuredInitPath, kind);
      }
    };
    FunctionBodyScope = class extends ChildScope {
      constructor(parent) {
        super(parent, parent.context);
      }
      // There is stuff that is only allowed in function scopes, i.e. functions can
      // be redeclared, functions and var can redeclare each other
      addDeclaration(identifier4, context8, init2, destructuredInitPath, kind) {
        const name = identifier4.name;
        const existingVariable = this.hoistedVariables?.get(name) || this.variables.get(name);
        if (existingVariable) {
          const existingKind = existingVariable.kind;
          if ((kind === "var" || kind === "function") && (existingKind === "var" || existingKind === "function" || existingKind === "parameter")) {
            existingVariable.addDeclaration(identifier4, init2);
            return existingVariable;
          }
          context8.error(logRedeclarationError(name), identifier4.start);
        }
        const newVariable = new LocalVariable(identifier4.name, identifier4, init2, destructuredInitPath, context8, kind);
        this.variables.set(name, newVariable);
        return newVariable;
      }
    };
    ParameterScope = class extends ChildScope {
      constructor(parent, isCatchScope) {
        super(parent, parent.context);
        this.hasRest = false;
        this.parameters = [];
        this.bodyScope = isCatchScope ? new CatchBodyScope(this) : new FunctionBodyScope(this);
      }
      /**
       * Adds a parameter to this scope. Parameters must be added in the correct
       * order, i.e. from left to right.
       */
      addParameterDeclaration(identifier4, argumentPath) {
        const { name, start: start3 } = identifier4;
        const existingParameter = this.variables.get(name);
        if (existingParameter) {
          return this.context.error(logDuplicateArgumentNameError(name), start3);
        }
        const variable = new ParameterVariable(name, identifier4, argumentPath, this.context);
        this.variables.set(name, variable);
        this.bodyScope.addHoistedVariable(name, variable);
        return variable;
      }
      addParameterVariables(parameters, hasRest) {
        this.parameters = parameters;
        for (const parameterList of parameters) {
          for (const parameter of parameterList) {
            parameter.alwaysRendered = true;
          }
        }
        this.hasRest = hasRest;
      }
      includeCallArguments({ args: args2 }, context8) {
        let calledFromTryStatement = false;
        let argumentIncluded = false;
        const restParameter = this.hasRest && this.parameters[this.parameters.length - 1];
        let lastExplicitlyIncludedIndex = args2.length - 1;
        for (let argumentIndex = 1; argumentIndex < args2.length; argumentIndex++) {
          const argument = args2[argumentIndex];
          if (argument instanceof SpreadElement && !argumentIncluded) {
            argumentIncluded = true;
            lastExplicitlyIncludedIndex = argumentIndex - 1;
          }
          if (argumentIncluded) {
            argument.includePath(UNKNOWN_PATH, context8);
            argument.include(context8, false);
          }
        }
        for (let index = lastExplicitlyIncludedIndex; index >= 1; index--) {
          const parameterVariables = this.parameters[index - 1] || restParameter;
          const argument = args2[index];
          if (parameterVariables) {
            calledFromTryStatement = false;
            if (parameterVariables.length === 0) {
              argumentIncluded = true;
            } else {
              for (const parameterVariable of parameterVariables) {
                if (parameterVariable.calledFromTryStatement) {
                  calledFromTryStatement = true;
                }
                if (parameterVariable.included) {
                  argumentIncluded = true;
                  if (calledFromTryStatement) {
                    argument.include(context8, true);
                  } else {
                    parameterVariable.includeArgumentPaths(argument, context8);
                    argument.include(context8, false);
                  }
                }
              }
            }
          }
          if (argumentIncluded || argument.shouldBeIncluded(context8)) {
            argumentIncluded = true;
            argument.include(context8, calledFromTryStatement);
          }
        }
      }
    };
    ReturnValueScope = class extends ParameterScope {
      constructor() {
        super(...arguments);
        this.returnExpression = null;
        this.returnExpressions = [];
      }
      addReturnExpression(expression) {
        this.returnExpressions.push(expression);
      }
      deoptimizeArgumentsOnCall({ args: args2 }) {
        const { parameters } = this;
        let position = 0;
        for (; position < args2.length - 1; position++) {
          const argument = args2[position + 1];
          if (argument instanceof SpreadElement) {
            for (; position < parameters.length; position++) {
              args2[position + 1]?.deoptimizePath(UNKNOWN_PATH);
              for (const variable of parameters[position]) {
                variable.markReassigned();
              }
            }
            break;
          }
          if (this.hasRest && position >= parameters.length - 1) {
            argument.deoptimizePath(UNKNOWN_PATH);
          } else {
            const variables = parameters[position];
            if (variables) {
              for (const variable of variables) {
                variable.addArgumentForDeoptimization(argument);
              }
            }
            this.addArgumentToBeDeoptimized(argument);
          }
        }
        const nonRestParameterLength = this.hasRest ? parameters.length - 1 : parameters.length;
        for (; position < nonRestParameterLength; position++) {
          for (const variable of parameters[position]) {
            variable.addArgumentForDeoptimization(UNDEFINED_EXPRESSION);
          }
        }
      }
      getReturnExpression() {
        if (this.returnExpression === null)
          this.updateReturnExpression();
        return this.returnExpression;
      }
      deoptimizeAllParameters() {
        for (const parameter of this.parameters) {
          for (const variable of parameter) {
            variable.deoptimizePath(UNKNOWN_PATH);
            variable.markReassigned();
          }
        }
      }
      reassignAllParameters() {
        for (const parameter of this.parameters) {
          for (const variable of parameter) {
            variable.markReassigned();
          }
        }
      }
      addArgumentToBeDeoptimized(_argument) {
      }
      updateReturnExpression() {
        if (this.returnExpressions.length === 1) {
          this.returnExpression = this.returnExpressions[0];
        } else {
          this.returnExpression = UNKNOWN_EXPRESSION;
          for (const expression of this.returnExpressions) {
            expression.deoptimizePath(UNKNOWN_PATH);
          }
        }
      }
    };
    FunctionScope = class extends ReturnValueScope {
      constructor(parent, functionNode) {
        super(parent, false);
        this.functionNode = functionNode;
        const { context: context8 } = parent;
        this.variables.set("arguments", this.argumentsVariable = new ArgumentsVariable(context8));
        this.variables.set("this", this.thisVariable = new ThisVariable(context8));
      }
      findLexicalBoundary() {
        return this;
      }
      includeCallArguments(interaction, context8) {
        super.includeCallArguments(interaction, context8);
        if (this.argumentsVariable.included) {
          const { args: args2 } = interaction;
          for (let argumentIndex = 1; argumentIndex < args2.length; argumentIndex++) {
            const argument = args2[argumentIndex];
            if (argument) {
              argument.includePath(UNKNOWN_PATH, context8);
              argument.include(context8, false);
            }
          }
        }
      }
      addArgumentToBeDeoptimized(argument) {
        this.argumentsVariable.addArgumentToBeDeoptimized(argument);
      }
    };
    ExpressionStatement2 = class extends NodeBase {
      initialise() {
        super.initialise();
        if (this.directive && this.directive !== "use strict" && this.parent.type === Program) {
          this.scope.context.log(
            LOGLEVEL_WARN,
            // This is necessary, because either way (deleting or not) can lead to errors.
            logModuleLevelDirective(this.directive, this.scope.context.module.id),
            this.start
          );
        }
      }
      removeAnnotations(code) {
        this.expression.removeAnnotations(code);
      }
      render(code, options) {
        super.render(code, options);
        if (code.original[this.end - 1] !== ";") {
          code.appendLeft(this.end, ";");
        }
      }
      shouldBeIncluded(context8) {
        if (this.directive && this.directive !== "use strict")
          return this.parent.type !== Program;
        return super.shouldBeIncluded(context8);
      }
    };
    ExpressionStatement2.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    ExpressionStatement2.prototype.applyDeoptimizations = doNotDeoptimize;
    BlockStatement2 = class extends NodeBase {
      get deoptimizeBody() {
        return isFlagSet(
          this.flags,
          32768
          /* Flag.deoptimizeBody */
        );
      }
      set deoptimizeBody(value) {
        this.flags = setFlag(this.flags, 32768, value);
      }
      get directlyIncluded() {
        return isFlagSet(
          this.flags,
          16384
          /* Flag.directlyIncluded */
        );
      }
      set directlyIncluded(value) {
        this.flags = setFlag(this.flags, 16384, value);
      }
      addImplicitReturnExpressionToScope() {
        const lastStatement = this.body[this.body.length - 1];
        if (!lastStatement || lastStatement.type !== ReturnStatement) {
          this.scope.addReturnExpression(UNKNOWN_EXPRESSION);
        }
      }
      createScope(parentScope) {
        this.scope = this.parent.preventChildBlockScope ? parentScope : new BlockScope(parentScope);
      }
      hasEffects(context8) {
        if (this.deoptimizeBody)
          return true;
        for (const node of this.body) {
          if (context8.brokenFlow)
            break;
          if (node.hasEffects(context8))
            return true;
        }
        return false;
      }
      include(context8, includeChildrenRecursively) {
        if (!(this.deoptimizeBody && this.directlyIncluded)) {
          this.included = true;
          this.directlyIncluded = true;
          if (this.deoptimizeBody)
            includeChildrenRecursively = true;
          for (const node of this.body) {
            if (includeChildrenRecursively || node.shouldBeIncluded(context8))
              node.include(context8, includeChildrenRecursively);
          }
        }
      }
      initialise() {
        super.initialise();
        const firstBodyStatement = this.body[0];
        this.deoptimizeBody = firstBodyStatement instanceof ExpressionStatement2 && firstBodyStatement.directive === "use asm";
      }
      render(code, options) {
        if (this.body.length > 0) {
          renderStatementList(this.body, code, this.start + 1, this.end - 1, options);
        } else {
          super.render(code, options);
        }
      }
    };
    BlockStatement2.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    BlockStatement2.prototype.applyDeoptimizations = doNotDeoptimize;
    RestElement2 = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.declarationInit = null;
      }
      addExportedVariables(variables, exportNamesByVariable) {
        this.argument.addExportedVariables(variables, exportNamesByVariable);
      }
      declare(kind, destructuredInitPath, init2) {
        this.declarationInit = init2;
        return this.argument.declare(kind, getIncludedPatternPath$1(destructuredInitPath), init2);
      }
      deoptimizeAssignment(destructuredInitPath, init2) {
        this.argument.deoptimizeAssignment(getIncludedPatternPath$1(destructuredInitPath), init2);
      }
      deoptimizePath(path3) {
        if (path3.length === 0) {
          this.argument.deoptimizePath(EMPTY_PATH);
        }
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        return path3.length > 0 || this.argument.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context8);
      }
      hasEffectsWhenDestructuring(context8, destructuredInitPath, init2) {
        return this.argument.hasEffectsWhenDestructuring(context8, getIncludedPatternPath$1(destructuredInitPath), init2);
      }
      includeDestructuredIfNecessary(context8, destructuredInitPath, init2) {
        return this.included = this.argument.includeDestructuredIfNecessary(context8, getIncludedPatternPath$1(destructuredInitPath), init2) || this.included;
      }
      include(context8, includeChildrenRecursively) {
        if (!this.included)
          this.includeNode(context8);
        this.argument.include(context8, includeChildrenRecursively);
      }
      markDeclarationReached() {
        this.argument.markDeclarationReached();
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        if (this.declarationInit !== null) {
          this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);
          this.scope.context.requestTreeshakingPass();
        }
      }
    };
    RestElement2.prototype.includeNode = onlyIncludeSelf;
    getIncludedPatternPath$1 = (destructuredInitPath) => destructuredInitPath.at(-1) === UnknownKey ? destructuredInitPath : [...destructuredInitPath, UnknownKey];
    FunctionBase = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.parameterVariableValuesDeoptimized = false;
        this.includeCallArguments = this.scope.includeCallArguments.bind(this.scope);
      }
      get async() {
        return isFlagSet(
          this.flags,
          256
          /* Flag.async */
        );
      }
      set async(value) {
        this.flags = setFlag(this.flags, 256, value);
      }
      get deoptimizedReturn() {
        return isFlagSet(
          this.flags,
          512
          /* Flag.deoptimizedReturn */
        );
      }
      set deoptimizedReturn(value) {
        this.flags = setFlag(this.flags, 512, value);
      }
      get generator() {
        return isFlagSet(
          this.flags,
          4194304
          /* Flag.generator */
        );
      }
      set generator(value) {
        this.flags = setFlag(this.flags, 4194304, value);
      }
      get hasCachedEffects() {
        return isFlagSet(
          this.flags,
          67108864
          /* Flag.hasEffects */
        );
      }
      set hasCachedEffects(value) {
        this.flags = setFlag(this.flags, 67108864, value);
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        if (interaction.type === INTERACTION_CALLED && path3.length === 0) {
          this.scope.deoptimizeArgumentsOnCall(interaction);
        } else {
          this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
        }
      }
      deoptimizePath(path3) {
        this.getObjectEntity().deoptimizePath(path3);
        if (path3.length === 1 && path3[0] === UnknownKey) {
          this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
          this.scope.deoptimizeAllParameters();
        }
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        return this.getObjectEntity().getLiteralValueAtPath(path3, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin) {
        if (path3.length > 0) {
          return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin);
        }
        if (this.async) {
          if (!this.deoptimizedReturn) {
            this.deoptimizedReturn = true;
            this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
            this.scope.context.requestTreeshakingPass();
          }
          return UNKNOWN_RETURN_EXPRESSION;
        }
        return [this.scope.getReturnExpression(), false];
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        if (path3.length > 0 || interaction.type !== INTERACTION_CALLED) {
          return this.getObjectEntity().hasEffectsOnInteractionAtPath(path3, interaction, context8);
        }
        if (this.hasCachedEffects) {
          return true;
        }
        if (this.async) {
          const { propertyReadSideEffects: propertyReadSideEffects2 } = this.scope.context.options.treeshake;
          const returnExpression = this.scope.getReturnExpression();
          if (returnExpression.hasEffectsOnInteractionAtPath(["then"], NODE_INTERACTION_UNKNOWN_CALL, context8) || propertyReadSideEffects2 && (propertyReadSideEffects2 === "always" || returnExpression.hasEffectsOnInteractionAtPath(["then"], NODE_INTERACTION_UNKNOWN_ACCESS, context8))) {
            this.hasCachedEffects = true;
            return true;
          }
        }
        const { propertyReadSideEffects } = this.scope.context.options.treeshake;
        for (let index = 0; index < this.params.length; index++) {
          const parameter = this.params[index];
          if (parameter.hasEffects(context8) || propertyReadSideEffects && parameter.hasEffectsWhenDestructuring(context8, EMPTY_PATH, interaction.args[index + 1] || UNDEFINED_EXPRESSION)) {
            this.hasCachedEffects = true;
            return true;
          }
        }
        return false;
      }
      /**
       * If the function (expression or declaration) is only used as function calls
       */
      onlyFunctionCallUsed() {
        let variable = null;
        if (this.parent.type === VariableDeclarator) {
          variable = this.parent.id.variable ?? null;
        }
        if (this.parent.type === ExportDefaultDeclaration) {
          variable = this.parent.variable;
        }
        return variable?.getOnlyFunctionCallUsed() ?? false;
      }
      include(context8, includeChildrenRecursively) {
        if (!this.included)
          this.includeNode(context8);
        if (!(this.parameterVariableValuesDeoptimized || this.onlyFunctionCallUsed())) {
          this.parameterVariableValuesDeoptimized = true;
          this.scope.reassignAllParameters();
        }
        const { brokenFlow } = context8;
        context8.brokenFlow = false;
        this.body.include(context8, includeChildrenRecursively);
        context8.brokenFlow = brokenFlow;
      }
      initialise() {
        super.initialise();
        if (this.body instanceof BlockStatement2) {
          this.body.addImplicitReturnExpressionToScope();
        } else {
          this.scope.addReturnExpression(this.body);
        }
        if (this.annotations && this.scope.context.options.treeshake.annotations) {
          this.annotationNoSideEffects = this.annotations.some((comment) => comment.type === "noSideEffects");
        }
      }
      parseNode(esTreeNode) {
        const { body, params } = esTreeNode;
        const { scope: scope5 } = this;
        const { bodyScope, context: context8 } = scope5;
        const parameters = this.params = params.map((parameter) => new (context8.getNodeConstructor(parameter.type))(this, scope5).parseNode(parameter));
        scope5.addParameterVariables(parameters.map((parameter) => parameter.declare("parameter", EMPTY_PATH, UNKNOWN_EXPRESSION)), parameters[parameters.length - 1] instanceof RestElement2);
        this.body = new (context8.getNodeConstructor(body.type))(this, bodyScope).parseNode(body);
        return super.parseNode(esTreeNode);
      }
    };
    FunctionBase.prototype.preventChildBlockScope = true;
    FunctionBase.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    FunctionBase.prototype.applyDeoptimizations = doNotDeoptimize;
    FunctionNode = class extends FunctionBase {
      constructor() {
        super(...arguments);
        this.objectEntity = null;
      }
      createScope(parentScope) {
        this.scope = new FunctionScope(parentScope, this);
        this.constructedEntity = new ObjectEntity(/* @__PURE__ */ Object.create(null), OBJECT_PROTOTYPE);
        this.scope.thisVariable.addArgumentForDeoptimization(this.constructedEntity);
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        super.deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
        if (interaction.type === INTERACTION_CALLED && path3.length === 0 && interaction.args[0]) {
          this.scope.thisVariable.addArgumentForDeoptimization(interaction.args[0]);
        }
      }
      hasEffects(context8) {
        if (this.annotationNoSideEffects) {
          return false;
        }
        return !!this.id?.hasEffects(context8);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        if (this.annotationNoSideEffects && path3.length === 0 && interaction.type === INTERACTION_CALLED) {
          return false;
        }
        if (super.hasEffectsOnInteractionAtPath(path3, interaction, context8)) {
          return true;
        }
        if (path3.length === 0 && interaction.type === INTERACTION_CALLED) {
          const thisInit = context8.replacedVariableInits.get(this.scope.thisVariable);
          context8.replacedVariableInits.set(this.scope.thisVariable, interaction.withNew ? this.constructedEntity : UNKNOWN_EXPRESSION);
          const { brokenFlow, ignore: ignore3, replacedVariableInits } = context8;
          context8.ignore = {
            breaks: false,
            continues: false,
            labels: /* @__PURE__ */ new Set(),
            returnYield: true,
            this: interaction.withNew
          };
          if (this.body.hasEffects(context8)) {
            this.hasCachedEffects = true;
            return true;
          }
          context8.brokenFlow = brokenFlow;
          if (thisInit) {
            replacedVariableInits.set(this.scope.thisVariable, thisInit);
          } else {
            replacedVariableInits.delete(this.scope.thisVariable);
          }
          context8.ignore = ignore3;
        }
        return false;
      }
      include(context8, includeChildrenRecursively) {
        super.include(context8, includeChildrenRecursively);
        this.id?.include(context8, includeChildrenRecursively);
        const hasArguments = this.scope.argumentsVariable.included;
        for (const parameter of this.params) {
          if (!(parameter instanceof Identifier2) || hasArguments) {
            parameter.include(context8, includeChildrenRecursively);
          }
        }
      }
      includeNode(context8) {
        this.included = true;
        const hasArguments = this.scope.argumentsVariable.included;
        for (const parameter of this.params) {
          if (!(parameter instanceof Identifier2) || hasArguments) {
            parameter.includePath(UNKNOWN_PATH, context8);
          }
        }
      }
      initialise() {
        super.initialise();
        this.id?.declare("function", EMPTY_PATH, this);
      }
      getObjectEntity() {
        if (this.objectEntity !== null) {
          return this.objectEntity;
        }
        return this.objectEntity = new ObjectEntity([
          {
            key: "prototype",
            kind: "init",
            property: new ObjectEntity([], OBJECT_PROTOTYPE)
          }
        ], OBJECT_PROTOTYPE);
      }
    };
    FunctionDeclaration = class extends FunctionNode {
      initialise() {
        super.initialise();
        if (this.id !== null) {
          this.id.variable.isId = true;
        }
      }
      onlyFunctionCallUsed() {
        return this.id?.variable.getOnlyFunctionCallUsed() ?? super.onlyFunctionCallUsed();
      }
      parseNode(esTreeNode) {
        if (esTreeNode.id !== null) {
          this.id = new Identifier2(this, this.scope.parent).parseNode(esTreeNode.id);
        }
        return super.parseNode(esTreeNode);
      }
    };
    ExportDefaultDeclaration2 = class extends NodeBase {
      include(context8, includeChildrenRecursively) {
        this.included = true;
        this.declaration.include(context8, includeChildrenRecursively);
        if (includeChildrenRecursively) {
          this.scope.context.includeVariableInModule(this.variable, UNKNOWN_PATH, context8);
        }
      }
      includePath(path3, context8) {
        this.included = true;
        this.declaration.includePath(path3, context8);
      }
      initialise() {
        super.initialise();
        const declaration = this.declaration;
        this.declarationName = declaration.id && declaration.id.name || this.declaration.name;
        this.variable = this.scope.addExportDefaultDeclaration(this.declarationName || this.scope.context.getModuleName(), this, this.scope.context);
        this.scope.context.addExport(this);
      }
      removeAnnotations(code) {
        this.declaration.removeAnnotations(code);
      }
      render(code, options, nodeRenderOptions) {
        const { start: start3, end: end6 } = nodeRenderOptions;
        const declarationStart = getDeclarationStart(code.original, this.start);
        if (this.declaration instanceof FunctionDeclaration) {
          this.renderNamedDeclaration(code, declarationStart, this.declaration.id === null ? getFunctionIdInsertPosition(code.original, declarationStart) : null, options);
        } else if (this.declaration instanceof ClassDeclaration) {
          this.renderNamedDeclaration(code, declarationStart, this.declaration.id === null ? findFirstOccurrenceOutsideComment(code.original, "class", start3) + "class".length : null, options);
        } else if (this.variable.getOriginalVariable() !== this.variable) {
          treeshakeNode(this, code, start3, end6);
          return;
        } else if (this.variable.included) {
          this.renderVariableDeclaration(code, declarationStart, options);
        } else {
          code.remove(this.start, declarationStart);
          this.declaration.render(code, options, {
            renderedSurroundingElement: ExpressionStatement
          });
          if (code.original[this.end - 1] !== ";") {
            code.appendLeft(this.end, ";");
          }
          return;
        }
        this.declaration.render(code, options);
      }
      renderNamedDeclaration(code, declarationStart, idInsertPosition, options) {
        const { exportNamesByVariable, format: format5, snippets: { getPropertyAccess } } = options;
        const name = this.variable.getName(getPropertyAccess);
        code.remove(this.start, declarationStart);
        if (idInsertPosition !== null) {
          code.appendLeft(idInsertPosition, ` ${name}`);
        }
        if (format5 === "system" && this.declaration instanceof ClassDeclaration && exportNamesByVariable.has(this.variable)) {
          code.appendLeft(this.end, ` ${getSystemExportStatement([this.variable], options)};`);
        }
      }
      renderVariableDeclaration(code, declarationStart, { format: format5, exportNamesByVariable, snippets: { cnst, getPropertyAccess } }) {
        const hasTrailingSemicolon = code.original.charCodeAt(this.end - 1) === 59;
        const systemExportNames = format5 === "system" && exportNamesByVariable.get(this.variable);
        if (systemExportNames) {
          code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = exports(${JSON.stringify(systemExportNames[0])}, `);
          code.appendRight(hasTrailingSemicolon ? this.end - 1 : this.end, ")" + (hasTrailingSemicolon ? "" : ";"));
        } else {
          code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = `);
          if (!hasTrailingSemicolon) {
            code.appendLeft(this.end, ";");
          }
        }
      }
    };
    ExportDefaultDeclaration2.prototype.needsBoundaries = true;
    ExportDefaultDeclaration2.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    ExportDefaultDeclaration2.prototype.applyDeoptimizations = doNotDeoptimize;
    needsEscapeRegEx = /[\n\r'\\\u2028\u2029]/;
    quoteNewlineRegEx = /([\n\r'\u2028\u2029])/g;
    backSlashRegEx = /\\/g;
    INTEROP_DEFAULT_VARIABLE = "_interopDefault";
    INTEROP_DEFAULT_COMPAT_VARIABLE = "_interopDefaultCompat";
    INTEROP_NAMESPACE_VARIABLE = "_interopNamespace";
    INTEROP_NAMESPACE_COMPAT_VARIABLE = "_interopNamespaceCompat";
    INTEROP_NAMESPACE_DEFAULT_VARIABLE = "_interopNamespaceDefault";
    INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE = "_interopNamespaceDefaultOnly";
    MERGE_NAMESPACES_VARIABLE = "_mergeNamespaces";
    DOCUMENT_CURRENT_SCRIPT = "_documentCurrentScript";
    defaultInteropHelpersByInteropType = {
      auto: INTEROP_DEFAULT_VARIABLE,
      compat: INTEROP_DEFAULT_COMPAT_VARIABLE,
      default: null,
      defaultOnly: null,
      esModule: null
    };
    isDefaultAProperty = (interopType, externalLiveBindings) => interopType === "esModule" || externalLiveBindings && (interopType === "auto" || interopType === "compat");
    namespaceInteropHelpersByInteropType = {
      auto: INTEROP_NAMESPACE_VARIABLE,
      compat: INTEROP_NAMESPACE_COMPAT_VARIABLE,
      default: INTEROP_NAMESPACE_DEFAULT_VARIABLE,
      defaultOnly: INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE,
      esModule: null
    };
    canDefaultBeTakenFromNamespace = (interopType, externalLiveBindings) => interopType !== "esModule" && isDefaultAProperty(interopType, externalLiveBindings);
    getHelpersBlock = (additionalHelpers, accessedGlobals, indent, snippets, liveBindings, freeze, symbols) => {
      const usedHelpers = new Set(additionalHelpers);
      for (const variable of HELPER_NAMES) {
        if (accessedGlobals.has(variable)) {
          usedHelpers.add(variable);
        }
      }
      return HELPER_NAMES.map((variable) => usedHelpers.has(variable) ? HELPER_GENERATORS[variable](indent, snippets, liveBindings, freeze, symbols, usedHelpers) : "").join("");
    };
    HELPER_GENERATORS = {
      [DOCUMENT_CURRENT_SCRIPT](_t, { _: _2, n: n2 }) {
        return `var ${DOCUMENT_CURRENT_SCRIPT}${_2}=${_2}typeof document${_2}!==${_2}'undefined'${_2}?${_2}document.currentScript${_2}:${_2}null;${n2}`;
      },
      [INTEROP_DEFAULT_COMPAT_VARIABLE](_t, snippets, liveBindings) {
        const { _: _2, getDirectReturnFunction, n: n2 } = snippets;
        const [left3, right3] = getDirectReturnFunction(["e"], {
          functionReturn: true,
          lineBreakIndent: null,
          name: INTEROP_DEFAULT_COMPAT_VARIABLE
        });
        return `${left3}${getIsCompatNamespace(snippets)}${_2}?${_2}${liveBindings ? getDefaultLiveBinding(snippets) : getDefaultStatic(snippets)}${right3}${n2}${n2}`;
      },
      [INTEROP_DEFAULT_VARIABLE](_t, snippets, liveBindings) {
        const { _: _2, getDirectReturnFunction, n: n2 } = snippets;
        const [left3, right3] = getDirectReturnFunction(["e"], {
          functionReturn: true,
          lineBreakIndent: null,
          name: INTEROP_DEFAULT_VARIABLE
        });
        return `${left3}e${_2}&&${_2}e.__esModule${_2}?${_2}${liveBindings ? getDefaultLiveBinding(snippets) : getDefaultStatic(snippets)}${right3}${n2}${n2}`;
      },
      [INTEROP_NAMESPACE_COMPAT_VARIABLE](t, snippets, liveBindings, freeze, symbols, usedHelpers) {
        const { _: _2, getDirectReturnFunction, n: n2 } = snippets;
        if (usedHelpers.has(INTEROP_NAMESPACE_DEFAULT_VARIABLE)) {
          const [left3, right3] = getDirectReturnFunction(["e"], {
            functionReturn: true,
            lineBreakIndent: null,
            name: INTEROP_NAMESPACE_COMPAT_VARIABLE
          });
          return `${left3}${getIsCompatNamespace(snippets)}${_2}?${_2}e${_2}:${_2}${INTEROP_NAMESPACE_DEFAULT_VARIABLE}(e)${right3}${n2}${n2}`;
        }
        return `function ${INTEROP_NAMESPACE_COMPAT_VARIABLE}(e)${_2}{${n2}${t}if${_2}(${getIsCompatNamespace(snippets)})${_2}return e;${n2}` + createNamespaceObject(t, t, snippets, liveBindings, freeze, symbols) + `}${n2}${n2}`;
      },
      [INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE](_t, snippets, _liveBindings, freeze, symbols) {
        const { getDirectReturnFunction, getObject, n: n2, _: _2 } = snippets;
        const [left3, right3] = getDirectReturnFunction(["e"], {
          functionReturn: true,
          lineBreakIndent: null,
          name: INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE
        });
        return `${left3}${getFrozen(freeze, getWithToStringTag(symbols, getObject([
          [null, `__proto__:${_2}null`],
          ["default", "e"]
        ], { lineBreakIndent: null }), snippets))}${right3}${n2}${n2}`;
      },
      [INTEROP_NAMESPACE_DEFAULT_VARIABLE](t, snippets, liveBindings, freeze, symbols) {
        const { _: _2, n: n2 } = snippets;
        return `function ${INTEROP_NAMESPACE_DEFAULT_VARIABLE}(e)${_2}{${n2}` + createNamespaceObject(t, t, snippets, liveBindings, freeze, symbols) + `}${n2}${n2}`;
      },
      [INTEROP_NAMESPACE_VARIABLE](t, snippets, liveBindings, freeze, symbols, usedHelpers) {
        const { _: _2, getDirectReturnFunction, n: n2 } = snippets;
        if (usedHelpers.has(INTEROP_NAMESPACE_DEFAULT_VARIABLE)) {
          const [left3, right3] = getDirectReturnFunction(["e"], {
            functionReturn: true,
            lineBreakIndent: null,
            name: INTEROP_NAMESPACE_VARIABLE
          });
          return `${left3}e${_2}&&${_2}e.__esModule${_2}?${_2}e${_2}:${_2}${INTEROP_NAMESPACE_DEFAULT_VARIABLE}(e)${right3}${n2}${n2}`;
        }
        return `function ${INTEROP_NAMESPACE_VARIABLE}(e)${_2}{${n2}${t}if${_2}(e${_2}&&${_2}e.__esModule)${_2}return e;${n2}` + createNamespaceObject(t, t, snippets, liveBindings, freeze, symbols) + `}${n2}${n2}`;
      },
      [MERGE_NAMESPACES_VARIABLE](t, snippets, liveBindings, freeze, symbols) {
        const { _: _2, cnst, n: n2 } = snippets;
        const useForEach = cnst === "var" && liveBindings;
        return `function ${MERGE_NAMESPACES_VARIABLE}(n, m)${_2}{${n2}${t}${loopOverNamespaces(`{${n2}${t}${t}${t}if${_2}(k${_2}!==${_2}'default'${_2}&&${_2}!(k in n))${_2}{${n2}` + (liveBindings ? useForEach ? copyOwnPropertyLiveBinding : copyPropertyLiveBinding : copyPropertyStatic)(t, t + t + t + t, snippets) + `${t}${t}${t}}${n2}${t}${t}}`, useForEach, t, snippets)}${n2}${t}return ${getFrozen(freeze, getWithToStringTag(symbols, "n", snippets))};${n2}}${n2}${n2}`;
      }
    };
    getDefaultLiveBinding = ({ _: _2, getObject }) => `e${_2}:${_2}${getObject([["default", "e"]], { lineBreakIndent: null })}`;
    getDefaultStatic = ({ _: _2, getPropertyAccess }) => `e${getPropertyAccess("default")}${_2}:${_2}e`;
    getIsCompatNamespace = ({ _: _2 }) => `e${_2}&&${_2}typeof e${_2}===${_2}'object'${_2}&&${_2}'default'${_2}in e`;
    createNamespaceObject = (t, index, snippets, liveBindings, freeze, symbols) => {
      const { _: _2, cnst, getObject, getPropertyAccess, n: n2, s: s2 } = snippets;
      const copyProperty = `{${n2}` + (liveBindings ? copyNonDefaultOwnPropertyLiveBinding : copyPropertyStatic)(t, index + t + t, snippets) + `${index}${t}}`;
      return `${index}${cnst} n${_2}=${_2}Object.create(null${symbols ? `,${_2}{${_2}[Symbol.toStringTag]:${_2}${getToStringTagValue(getObject)}${_2}}` : ""});${n2}${index}if${_2}(e)${_2}{${n2}${index}${t}${loopOverKeys(copyProperty, !liveBindings, snippets)}${n2}${index}}${n2}${index}n${getPropertyAccess("default")}${_2}=${_2}e;${n2}${index}return ${getFrozen(freeze, "n")}${s2}${n2}`;
    };
    loopOverKeys = (body, allowVariableLoopVariable, { _: _2, cnst, getFunctionIntro, s: s2 }) => cnst !== "var" || allowVariableLoopVariable ? `for${_2}(${cnst} k in e)${_2}${body}` : `Object.keys(e).forEach(${getFunctionIntro(["k"], {
      isAsync: false,
      name: null
    })}${body})${s2}`;
    loopOverNamespaces = (body, useForEach, t, { _: _2, cnst, getDirectReturnFunction, getFunctionIntro, n: n2 }) => {
      if (useForEach) {
        const [left3, right3] = getDirectReturnFunction(["e"], {
          functionReturn: false,
          lineBreakIndent: { base: t, t },
          name: null
        });
        return `m.forEach(${left3}e${_2}&&${_2}typeof e${_2}!==${_2}'string'${_2}&&${_2}!Array.isArray(e)${_2}&&${_2}Object.keys(e).forEach(${getFunctionIntro(["k"], {
          isAsync: false,
          name: null
        })}${body})${right3});`;
      }
      return `for${_2}(var i${_2}=${_2}0;${_2}i${_2}<${_2}m.length;${_2}i++)${_2}{${n2}${t}${t}${cnst} e${_2}=${_2}m[i];${n2}${t}${t}if${_2}(typeof e${_2}!==${_2}'string'${_2}&&${_2}!Array.isArray(e))${_2}{${_2}for${_2}(${cnst} k in e)${_2}${body}${_2}}${n2}${t}}`;
    };
    copyNonDefaultOwnPropertyLiveBinding = (t, index, snippets) => {
      const { _: _2, n: n2 } = snippets;
      return `${index}if${_2}(k${_2}!==${_2}'default')${_2}{${n2}` + copyOwnPropertyLiveBinding(t, index + t, snippets) + `${index}}${n2}`;
    };
    copyOwnPropertyLiveBinding = (t, index, { _: _2, cnst, getDirectReturnFunction, n: n2 }) => {
      const [left3, right3] = getDirectReturnFunction([], {
        functionReturn: true,
        lineBreakIndent: null,
        name: null
      });
      return `${index}${cnst} d${_2}=${_2}Object.getOwnPropertyDescriptor(e,${_2}k);${n2}${index}Object.defineProperty(n,${_2}k,${_2}d.get${_2}?${_2}d${_2}:${_2}{${n2}${index}${t}enumerable:${_2}true,${n2}${index}${t}get:${_2}${left3}e[k]${right3}${n2}${index}});${n2}`;
    };
    copyPropertyLiveBinding = (t, index, { _: _2, cnst, getDirectReturnFunction, n: n2 }) => {
      const [left3, right3] = getDirectReturnFunction([], {
        functionReturn: true,
        lineBreakIndent: null,
        name: null
      });
      return `${index}${cnst} d${_2}=${_2}Object.getOwnPropertyDescriptor(e,${_2}k);${n2}${index}if${_2}(d)${_2}{${n2}${index}${t}Object.defineProperty(n,${_2}k,${_2}d.get${_2}?${_2}d${_2}:${_2}{${n2}${index}${t}${t}enumerable:${_2}true,${n2}${index}${t}${t}get:${_2}${left3}e[k]${right3}${n2}${index}${t}});${n2}${index}}${n2}`;
    };
    copyPropertyStatic = (_t, index, { _: _2, n: n2 }) => `${index}n[k]${_2}=${_2}e[k];${n2}`;
    getFrozen = (freeze, fragment) => freeze ? `Object.freeze(${fragment})` : fragment;
    getWithToStringTag = (symbols, fragment, { _: _2, getObject }) => symbols ? `Object.defineProperty(${fragment},${_2}Symbol.toStringTag,${_2}${getToStringTagValue(getObject)})` : fragment;
    HELPER_NAMES = Object.keys(HELPER_GENERATORS);
    Literal2 = class extends NodeBase {
      deoptimizeArgumentsOnInteractionAtPath() {
      }
      getLiteralValueAtPath(path3) {
        if (path3.length > 0 || // unknown literals can also be null but do not start with an "n"
        this.value === null && this.scope.context.code.charCodeAt(this.start) !== 110 || typeof this.value === "bigint" || // to support shims for regular expressions
        this.scope.context.code.charCodeAt(this.start) === 47) {
          return UnknownValue;
        }
        return this.value;
      }
      getReturnExpressionWhenCalledAtPath(path3) {
        if (path3.length !== 1)
          return UNKNOWN_RETURN_EXPRESSION;
        return getMemberReturnExpressionWhenCalled(this.members, path3[0]);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        switch (interaction.type) {
          case INTERACTION_ACCESSED: {
            return path3.length > (this.value === null ? 0 : 1);
          }
          case INTERACTION_ASSIGNED: {
            return true;
          }
          case INTERACTION_CALLED: {
            if (this.included && this.value instanceof RegExp && (this.value.global || this.value.sticky)) {
              return true;
            }
            return path3.length !== 1 || hasMemberEffectWhenCalled(this.members, path3[0], interaction, context8);
          }
        }
      }
      initialise() {
        super.initialise();
        this.members = getLiteralMembersForValue(this.value);
      }
      parseNode(esTreeNode) {
        this.value = esTreeNode.value;
        this.regex = esTreeNode.regex;
        return super.parseNode(esTreeNode);
      }
      render(code) {
        if (typeof this.value === "string") {
          code.indentExclusionRanges.push([this.start + 1, this.end - 1]);
        }
      }
    };
    Literal2.prototype.includeNode = onlyIncludeSelf;
    MemberExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.variable = null;
        this.expressionsToBeDeoptimized = [];
      }
      get computed() {
        return isFlagSet(
          this.flags,
          1024
          /* Flag.computed */
        );
      }
      set computed(value) {
        this.flags = setFlag(this.flags, 1024, value);
      }
      get optional() {
        return isFlagSet(
          this.flags,
          128
          /* Flag.optional */
        );
      }
      set optional(value) {
        this.flags = setFlag(this.flags, 128, value);
      }
      get assignmentDeoptimized() {
        return isFlagSet(
          this.flags,
          16
          /* Flag.assignmentDeoptimized */
        );
      }
      set assignmentDeoptimized(value) {
        this.flags = setFlag(this.flags, 16, value);
      }
      get bound() {
        return isFlagSet(
          this.flags,
          32
          /* Flag.bound */
        );
      }
      set bound(value) {
        this.flags = setFlag(this.flags, 32, value);
      }
      get isUndefined() {
        return isFlagSet(
          this.flags,
          64
          /* Flag.isUndefined */
        );
      }
      set isUndefined(value) {
        this.flags = setFlag(this.flags, 64, value);
      }
      bind() {
        this.bound = true;
        const path3 = getPathIfNotComputed(this);
        const baseVariable = path3 && this.scope.findVariable(path3[0].key);
        if (baseVariable?.isNamespace) {
          const resolvedVariable = resolveNamespaceVariables(baseVariable, path3.slice(1), this.scope.context);
          if (!resolvedVariable) {
            super.bind();
          } else if (resolvedVariable === "undefined") {
            this.isUndefined = true;
          } else {
            this.variable = resolvedVariable;
            this.scope.addNamespaceMemberAccess(getStringFromPath(path3), resolvedVariable);
          }
        } else {
          super.bind();
        }
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        if (this.variable) {
          this.variable.deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
        } else if (!this.isUndefined) {
          if (path3.length < MAX_PATH_DEPTH) {
            this.object.deoptimizeArgumentsOnInteractionAtPath(interaction, this.propertyKey === UnknownKey ? UNKNOWN_PATH : [this.propertyKey, ...path3], recursionTracker);
          } else {
            deoptimizeInteraction(interaction);
          }
        }
      }
      deoptimizeAssignment(destructuredInitPath, init2) {
        this.deoptimizePath(EMPTY_PATH);
        init2.deoptimizePath([...destructuredInitPath, UnknownKey]);
      }
      deoptimizeCache() {
        if (this.propertyKey === this.dynamicPropertyKey)
          return;
        const { expressionsToBeDeoptimized, object } = this;
        this.expressionsToBeDeoptimized = EMPTY_ARRAY;
        this.dynamicPropertyKey = this.propertyKey;
        object.deoptimizePath(UNKNOWN_PATH);
        if (this.included) {
          object.includePath(UNKNOWN_PATH, createInclusionContext());
        }
        for (const expression of expressionsToBeDeoptimized) {
          expression.deoptimizeCache();
        }
      }
      deoptimizePath(path3) {
        if (path3.length === 0)
          this.disallowNamespaceReassignment();
        if (this.variable) {
          this.variable.deoptimizePath(path3);
        } else if (!this.isUndefined) {
          const { propertyKey } = this;
          this.object.deoptimizePath([
            propertyKey === UnknownKey ? UnknownNonAccessorKey : propertyKey,
            ...path3.length < MAX_PATH_DEPTH ? path3 : [...path3.slice(0, MAX_PATH_DEPTH), UnknownKey]
          ]);
        }
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        if (this.variable) {
          return this.variable.getLiteralValueAtPath(path3, recursionTracker, origin);
        }
        if (this.isUndefined) {
          return void 0;
        }
        const propertyKey = this.getDynamicPropertyKey();
        if (propertyKey !== UnknownKey && path3.length < MAX_PATH_DEPTH) {
          if (propertyKey !== this.propertyKey)
            this.expressionsToBeDeoptimized.push(origin);
          return this.object.getLiteralValueAtPath([propertyKey, ...path3], recursionTracker, origin);
        }
        return UnknownValue;
      }
      getLiteralValueAtPathAsChainElement(path3, recursionTracker, origin) {
        if (this.variable) {
          return this.variable.getLiteralValueAtPath(path3, recursionTracker, origin);
        }
        if (this.isUndefined) {
          return void 0;
        }
        return getChainElementLiteralValueAtPath(this, this.object, path3, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin) {
        if (this.variable) {
          return this.variable.getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin);
        }
        if (this.isUndefined) {
          return [UNDEFINED_EXPRESSION, false];
        }
        const propertyKey = this.getDynamicPropertyKey();
        if (propertyKey !== UnknownKey && path3.length < MAX_PATH_DEPTH) {
          if (propertyKey !== this.propertyKey)
            this.expressionsToBeDeoptimized.push(origin);
          return this.object.getReturnExpressionWhenCalledAtPath([propertyKey, ...path3], interaction, recursionTracker, origin);
        }
        return UNKNOWN_RETURN_EXPRESSION;
      }
      hasEffects(context8) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        return this.property.hasEffects(context8) || this.object.hasEffects(context8) || this.hasAccessEffect(context8);
      }
      hasEffectsAsChainElement(context8) {
        if (this.variable || this.isUndefined)
          return this.hasEffects(context8);
        const objectHasEffects = "hasEffectsAsChainElement" in this.object ? this.object.hasEffectsAsChainElement(context8) : this.object.hasEffects(context8);
        if (objectHasEffects === IS_SKIPPED_CHAIN)
          return IS_SKIPPED_CHAIN;
        if (this.optional && this.object.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) == null) {
          return objectHasEffects || IS_SKIPPED_CHAIN;
        }
        if (!this.deoptimized)
          this.applyDeoptimizations();
        return objectHasEffects || this.property.hasEffects(context8) || this.hasAccessEffect(context8);
      }
      hasEffectsAsAssignmentTarget(context8, checkAccess) {
        if (checkAccess && !this.deoptimized)
          this.applyDeoptimizations();
        if (!this.assignmentDeoptimized)
          this.applyAssignmentDeoptimization();
        return this.property.hasEffects(context8) || this.object.hasEffects(context8) || checkAccess && this.hasAccessEffect(context8) || this.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.assignmentInteraction, context8);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        if (this.variable) {
          return this.variable.hasEffectsOnInteractionAtPath(path3, interaction, context8);
        }
        if (this.isUndefined) {
          return true;
        }
        if (path3.length < MAX_PATH_DEPTH) {
          return this.object.hasEffectsOnInteractionAtPath([this.getDynamicPropertyKey(), ...path3], interaction, context8);
        }
        return true;
      }
      hasEffectsWhenDestructuring(context8, destructuredInitPath, init2) {
        return destructuredInitPath.length > 0 && init2.hasEffectsOnInteractionAtPath(destructuredInitPath, NODE_INTERACTION_UNKNOWN_ACCESS, context8);
      }
      include(context8, includeChildrenRecursively) {
        if (!this.included)
          this.includeNode(context8);
        this.object.include(context8, includeChildrenRecursively);
        this.property.include(context8, includeChildrenRecursively);
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        if (this.variable) {
          this.scope.context.includeVariableInModule(this.variable, EMPTY_PATH, context8);
        } else if (!this.isUndefined) {
          this.object.includePath([this.propertyKey], context8);
        }
      }
      includeNodeAsAssignmentTarget(context8) {
        this.included = true;
        if (!this.assignmentDeoptimized)
          this.applyAssignmentDeoptimization();
        if (this.variable) {
          this.scope.context.includeVariableInModule(this.variable, EMPTY_PATH, context8);
        } else if (!this.isUndefined) {
          this.object.includePath([this.propertyKey], context8);
        }
      }
      includePath(path3, context8) {
        if (!this.included)
          this.includeNode(context8);
        if (this.variable) {
          this.variable?.includePath(path3, context8);
        } else if (!this.isUndefined) {
          this.object.includePath([
            this.propertyKey,
            ...path3.length < MAX_PATH_DEPTH ? path3 : [...path3.slice(0, MAX_PATH_DEPTH), UnknownKey]
          ], context8);
        }
      }
      includeAsAssignmentTarget(context8, includeChildrenRecursively, deoptimizeAccess) {
        if (!this.included)
          this.includeNodeAsAssignmentTarget(context8);
        if (deoptimizeAccess && !this.deoptimized)
          this.applyDeoptimizations();
        this.object.include(context8, includeChildrenRecursively);
        this.property.include(context8, includeChildrenRecursively);
      }
      includeCallArguments(interaction, context8) {
        if (this.variable) {
          this.variable.includeCallArguments(interaction, context8);
        } else {
          includeInteraction(interaction, context8);
        }
      }
      includeDestructuredIfNecessary(context8, destructuredInitPath, init2) {
        if (this.included ||= destructuredInitPath.length > 0 && !context8.brokenFlow && init2.hasEffectsOnInteractionAtPath(destructuredInitPath, NODE_INTERACTION_UNKNOWN_ACCESS, createHasEffectsContext())) {
          init2.include(context8, false);
          return true;
        }
        return false;
      }
      initialise() {
        super.initialise();
        this.dynamicPropertyKey = getResolvablePropertyKey(this);
        this.propertyKey = this.dynamicPropertyKey === null ? UnknownKey : this.dynamicPropertyKey;
        this.accessInteraction = { args: [this.object], type: INTERACTION_ACCESSED };
      }
      render(code, options, { renderedParentType, isCalleeOfRenderedParent, renderedSurroundingElement } = BLANK) {
        if (this.variable || this.isUndefined) {
          const { snippets: { getPropertyAccess } } = options;
          let replacement = this.variable ? this.variable.getName(getPropertyAccess) : "undefined";
          if (renderedParentType && isCalleeOfRenderedParent)
            replacement = "0, " + replacement;
          code.overwrite(this.start, this.end, replacement, {
            contentOnly: true,
            storeName: true
          });
        } else {
          if (renderedParentType && isCalleeOfRenderedParent) {
            code.appendRight(this.start, "0, ");
          }
          this.object.render(code, options, { renderedSurroundingElement });
          this.property.render(code, options);
        }
      }
      setAssignedValue(value) {
        this.assignmentInteraction = {
          args: [this.object, value],
          type: INTERACTION_ASSIGNED
        };
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        const { propertyReadSideEffects } = this.scope.context.options.treeshake;
        if (
          // Namespaces are not bound and should not be deoptimized
          this.bound && propertyReadSideEffects && !(this.variable || this.isUndefined)
        ) {
          this.object.deoptimizeArgumentsOnInteractionAtPath(this.accessInteraction, [this.propertyKey], SHARED_RECURSION_TRACKER);
          this.scope.context.requestTreeshakingPass();
        }
        if (this.variable) {
          this.variable.addUsedPlace(this);
          this.scope.context.requestTreeshakingPass();
        }
      }
      applyAssignmentDeoptimization() {
        this.assignmentDeoptimized = true;
        const { propertyReadSideEffects } = this.scope.context.options.treeshake;
        if (
          // Namespaces are not bound and should not be deoptimized
          this.bound && propertyReadSideEffects && !(this.variable || this.isUndefined)
        ) {
          this.object.deoptimizeArgumentsOnInteractionAtPath(this.assignmentInteraction, [this.propertyKey], SHARED_RECURSION_TRACKER);
          this.scope.context.requestTreeshakingPass();
        }
      }
      disallowNamespaceReassignment() {
        if (this.object instanceof Identifier2) {
          const variable = this.scope.findVariable(this.object.name);
          if (variable.isNamespace) {
            if (this.variable) {
              this.scope.context.includeVariableInModule(this.variable, UNKNOWN_PATH, createInclusionContext());
            }
            this.scope.context.log(LOGLEVEL_WARN, logIllegalImportReassignment(this.object.name, this.scope.context.module.id), this.start);
          }
        }
      }
      getDynamicPropertyKey() {
        if (this.dynamicPropertyKey === null) {
          this.dynamicPropertyKey = this.propertyKey;
          const value = this.property.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
          return this.dynamicPropertyKey = value === SymbolToStringTag ? value : typeof value === "symbol" ? UnknownKey : String(value);
        }
        return this.dynamicPropertyKey;
      }
      hasAccessEffect(context8) {
        const { propertyReadSideEffects } = this.scope.context.options.treeshake;
        return !(this.variable || this.isUndefined) && propertyReadSideEffects && (propertyReadSideEffects === "always" || this.object.hasEffectsOnInteractionAtPath([this.getDynamicPropertyKey()], this.accessInteraction, context8));
      }
    };
    FILE_PREFIX = "ROLLUP_FILE_URL_";
    IMPORT = "import";
    MetaProperty = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.metaProperty = null;
        this.preliminaryChunkId = null;
        this.referenceId = null;
      }
      getReferencedFileName(outputPluginDriver) {
        const { meta: { name }, metaProperty: metaProperty3 } = this;
        if (name === IMPORT && metaProperty3?.startsWith(FILE_PREFIX)) {
          return outputPluginDriver.getFileName(metaProperty3.slice(FILE_PREFIX.length));
        }
        return null;
      }
      hasEffects() {
        return false;
      }
      hasEffectsOnInteractionAtPath(path3, { type }) {
        return path3.length > 1 || type !== INTERACTION_ACCESSED;
      }
      include() {
        if (!this.included)
          this.includeNode();
      }
      includeNode() {
        this.included = true;
        if (this.meta.name === IMPORT) {
          this.scope.context.addImportMeta(this);
          const parent = this.parent;
          const metaProperty3 = this.metaProperty = parent instanceof MemberExpression && typeof parent.propertyKey === "string" ? parent.propertyKey : null;
          if (metaProperty3?.startsWith(FILE_PREFIX)) {
            this.referenceId = metaProperty3.slice(FILE_PREFIX.length);
          }
        }
      }
      render(code, renderOptions) {
        const { format: format5, pluginDriver, snippets } = renderOptions;
        const { scope: { context: { module } }, meta: { name }, metaProperty: metaProperty3, parent, preliminaryChunkId, referenceId, start: start3, end: end6 } = this;
        const { id: moduleId } = module;
        if (name !== IMPORT)
          return;
        const chunkId = preliminaryChunkId;
        if (referenceId) {
          const fileName = pluginDriver.getFileName(referenceId);
          const relativePath = normalize2(p2.relative(p2.dirname(chunkId), fileName));
          const replacement2 = pluginDriver.hookFirstSync("resolveFileUrl", [
            { chunkId, fileName, format: format5, moduleId, referenceId, relativePath }
          ]) || relativeUrlMechanisms[format5](relativePath);
          code.overwrite(parent.start, parent.end, replacement2, { contentOnly: true });
          return;
        }
        let replacement = pluginDriver.hookFirstSync("resolveImportMeta", [
          metaProperty3,
          { chunkId, format: format5, moduleId }
        ]);
        if (!replacement) {
          replacement = importMetaMechanisms[format5]?.(metaProperty3, { chunkId, snippets });
          renderOptions.accessedDocumentCurrentScript ||= formatsMaybeAccessDocumentCurrentScript.includes(format5) && replacement !== "undefined";
        }
        if (typeof replacement === "string") {
          if (parent instanceof MemberExpression) {
            code.overwrite(parent.start, parent.end, replacement, { contentOnly: true });
          } else {
            code.overwrite(start3, end6, replacement, { contentOnly: true });
          }
        }
      }
      setResolution(format5, accessedGlobalsByScope, preliminaryChunkId) {
        this.preliminaryChunkId = preliminaryChunkId;
        const accessedGlobals = (this.metaProperty?.startsWith(FILE_PREFIX) ? accessedFileUrlGlobals : accessedMetaUrlGlobals)[format5];
        if (accessedGlobals.length > 0) {
          this.scope.addAccessedGlobals(accessedGlobals, accessedGlobalsByScope);
        }
      }
    };
    formatsMaybeAccessDocumentCurrentScript = ["cjs", "iife", "umd"];
    accessedMetaUrlGlobals = {
      amd: ["document", "module", "URL"],
      cjs: ["document", "require", "URL", DOCUMENT_CURRENT_SCRIPT],
      es: [],
      iife: ["document", "URL", DOCUMENT_CURRENT_SCRIPT],
      system: ["module"],
      umd: ["document", "require", "URL", DOCUMENT_CURRENT_SCRIPT]
    };
    accessedFileUrlGlobals = {
      amd: ["document", "require", "URL"],
      cjs: ["document", "require", "URL"],
      es: [],
      iife: ["document", "URL"],
      system: ["module", "URL"],
      umd: ["document", "require", "URL"]
    };
    getResolveUrl = (path3, URL2 = "URL") => `new ${URL2}(${path3}).href`;
    getRelativeUrlFromDocument = (relativePath, umd2 = false) => getResolveUrl(`'${escapeId(relativePath)}', ${umd2 ? `typeof document === 'undefined' ? location.href : ` : ""}document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT' && document.currentScript.src || document.baseURI`);
    getGenericImportMetaMechanism = (getUrl) => (property3, { chunkId }) => {
      const urlMechanism = getUrl(chunkId);
      return property3 === null ? `({ url: ${urlMechanism} })` : property3 === "url" ? urlMechanism : "undefined";
    };
    getFileUrlFromFullPath = (path3) => `require('u' + 'rl').pathToFileURL(${path3}).href`;
    getFileUrlFromRelativePath = (path3) => getFileUrlFromFullPath(`__dirname + '/${escapeId(path3)}'`);
    getUrlFromDocument = (chunkId, umd2 = false) => `${umd2 ? `typeof document === 'undefined' ? location.href : ` : ""}(${DOCUMENT_CURRENT_SCRIPT} && ${DOCUMENT_CURRENT_SCRIPT}.tagName.toUpperCase() === 'SCRIPT' && ${DOCUMENT_CURRENT_SCRIPT}.src || new URL('${escapeId(chunkId)}', document.baseURI).href)`;
    relativeUrlMechanisms = {
      amd: (relativePath) => {
        if (relativePath[0] !== ".")
          relativePath = "./" + relativePath;
        return getResolveUrl(`require.toUrl('${escapeId(relativePath)}'), document.baseURI`);
      },
      cjs: (relativePath) => `(typeof document === 'undefined' ? ${getFileUrlFromRelativePath(relativePath)} : ${getRelativeUrlFromDocument(relativePath)})`,
      es: (relativePath) => getResolveUrl(`'${escapeId(relativePath)}', import.meta.url`),
      iife: (relativePath) => getRelativeUrlFromDocument(relativePath),
      system: (relativePath) => getResolveUrl(`'${escapeId(relativePath)}', module.meta.url`),
      umd: (relativePath) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getFileUrlFromRelativePath(relativePath)} : ${getRelativeUrlFromDocument(relativePath, true)})`
    };
    importMetaMechanisms = {
      amd: getGenericImportMetaMechanism(() => getResolveUrl(`module.uri, document.baseURI`)),
      cjs: getGenericImportMetaMechanism((chunkId) => `(typeof document === 'undefined' ? ${getFileUrlFromFullPath("__filename")} : ${getUrlFromDocument(chunkId)})`),
      iife: getGenericImportMetaMechanism((chunkId) => getUrlFromDocument(chunkId)),
      system: (property3, { snippets: { getPropertyAccess } }) => property3 === null ? `module.meta` : `module.meta${getPropertyAccess(property3)}`,
      umd: getGenericImportMetaMechanism((chunkId) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getFileUrlFromFullPath("__filename")} : ${getUrlFromDocument(chunkId, true)})`)
    };
    UndefinedVariable = class extends Variable {
      constructor() {
        super("undefined");
      }
      getLiteralValueAtPath() {
        return void 0;
      }
    };
    ExportDefaultVariable = class _ExportDefaultVariable extends LocalVariable {
      constructor(name, exportDefaultDeclaration3, context8) {
        super(name, exportDefaultDeclaration3, exportDefaultDeclaration3.declaration, EMPTY_PATH, context8, "other");
        this.hasId = false;
        this.originalId = null;
        this.originalVariable = null;
        const declaration = exportDefaultDeclaration3.declaration;
        if ((declaration instanceof FunctionDeclaration || declaration instanceof ClassDeclaration) && declaration.id) {
          this.hasId = true;
          this.originalId = declaration.id;
        } else if (declaration instanceof Identifier2) {
          this.originalId = declaration;
        }
      }
      addReference(identifier4) {
        if (!this.hasId) {
          this.name = identifier4.name;
        }
      }
      addUsedPlace(usedPlace) {
        const original = this.getOriginalVariable();
        if (original === this) {
          super.addUsedPlace(usedPlace);
        } else {
          original.addUsedPlace(usedPlace);
        }
      }
      forbidName(name) {
        const original = this.getOriginalVariable();
        if (original === this) {
          super.forbidName(name);
        } else {
          original.forbidName(name);
        }
      }
      getAssignedVariableName() {
        return this.originalId && this.originalId.name || null;
      }
      getBaseVariableName() {
        const original = this.getOriginalVariable();
        return original === this ? super.getBaseVariableName() : original.getBaseVariableName();
      }
      getDirectOriginalVariable() {
        return this.originalId && (this.hasId || !(this.originalId.isPossibleTDZ() || this.originalId.variable.isReassigned || this.originalId.variable instanceof UndefinedVariable || // this avoids a circular dependency
        "syntheticNamespace" in this.originalId.variable)) ? this.originalId.variable : null;
      }
      getName(getPropertyAccess) {
        const original = this.getOriginalVariable();
        return original === this ? super.getName(getPropertyAccess) : original.getName(getPropertyAccess);
      }
      getOriginalVariable() {
        if (this.originalVariable)
          return this.originalVariable;
        let original = this;
        let currentVariable;
        const checkedVariables = /* @__PURE__ */ new Set();
        do {
          checkedVariables.add(original);
          currentVariable = original;
          original = currentVariable.getDirectOriginalVariable();
        } while (original instanceof _ExportDefaultVariable && !checkedVariables.has(original));
        return this.originalVariable = original || currentVariable;
      }
    };
    NamespaceVariable = class extends Variable {
      constructor(context8) {
        super(context8.getModuleName());
        this.memberVariables = null;
        this.mergedNamespaces = [];
        this.referencedEarly = false;
        this.references = [];
        this.context = context8;
        this.module = context8.module;
      }
      addReference(identifier4) {
        this.references.push(identifier4);
        this.name = identifier4.name;
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        if (path3.length > 1 || path3.length === 1 && interaction.type === INTERACTION_CALLED) {
          const key = path3[0];
          if (typeof key === "string") {
            this.getMemberVariables()[key]?.deoptimizeArgumentsOnInteractionAtPath(interaction, path3.slice(1), recursionTracker);
          } else {
            deoptimizeInteraction(interaction);
          }
        }
      }
      deoptimizePath(path3) {
        if (path3.length > 1) {
          const key = path3[0];
          if (typeof key === "string") {
            this.getMemberVariables()[key]?.deoptimizePath(path3.slice(1));
          }
        }
      }
      getLiteralValueAtPath(path3) {
        if (path3[0] === SymbolToStringTag) {
          return "Module";
        }
        return UnknownValue;
      }
      getMemberVariables() {
        if (this.memberVariables) {
          return this.memberVariables;
        }
        const memberVariables = /* @__PURE__ */ Object.create(null);
        const sortedExports = [...this.context.getExports(), ...this.context.getReexports()].sort();
        for (const name of sortedExports) {
          if (name[0] !== "*" && name !== this.module.info.syntheticNamedExports) {
            const exportedVariable = this.context.traceExport(name);
            if (exportedVariable) {
              memberVariables[name] = exportedVariable;
            }
          }
        }
        return this.memberVariables = memberVariables;
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        const { type } = interaction;
        if (path3.length === 0) {
          return true;
        }
        if (path3.length === 1 && type !== INTERACTION_CALLED) {
          return type === INTERACTION_ASSIGNED;
        }
        const key = path3[0];
        if (typeof key !== "string") {
          return true;
        }
        const memberVariable = this.getMemberVariables()[key];
        return !memberVariable || memberVariable.hasEffectsOnInteractionAtPath(path3.slice(1), interaction, context8);
      }
      includePath(path3, context8) {
        super.includePath(path3, context8);
        this.context.includeAllExports();
      }
      prepare(accessedGlobalsByScope) {
        if (this.mergedNamespaces.length > 0) {
          this.module.scope.addAccessedGlobals([MERGE_NAMESPACES_VARIABLE], accessedGlobalsByScope);
        }
      }
      renderBlock(options) {
        const { exportNamesByVariable, format: format5, freeze, indent: t, symbols, snippets: { _: _2, cnst, getObject, getPropertyAccess, n: n2, s: s2 } } = options;
        const memberVariables = this.getMemberVariables();
        const members = Object.entries(memberVariables).filter(([_3, variable]) => variable.included).map(([name2, variable]) => {
          if (this.referencedEarly || variable.isReassigned || variable === this) {
            return [
              null,
              `get ${stringifyObjectKeyIfNeeded(name2)}${_2}()${_2}{${_2}return ${variable.getName(getPropertyAccess)}${s2}${_2}}`
            ];
          }
          return [name2, variable.getName(getPropertyAccess)];
        });
        members.unshift([null, `__proto__:${_2}null`]);
        let output = getObject(members, { lineBreakIndent: { base: "", t } });
        if (this.mergedNamespaces.length > 0) {
          const assignmentArguments = this.mergedNamespaces.map((variable) => variable.getName(getPropertyAccess));
          output = `/*#__PURE__*/${MERGE_NAMESPACES_VARIABLE}(${output},${_2}[${assignmentArguments.join(`,${_2}`)}])`;
        } else {
          if (symbols) {
            output = `/*#__PURE__*/Object.defineProperty(${output},${_2}Symbol.toStringTag,${_2}${getToStringTagValue(getObject)})`;
          }
          if (freeze) {
            output = `/*#__PURE__*/Object.freeze(${output})`;
          }
        }
        const name = this.getName(getPropertyAccess);
        output = `${cnst} ${name}${_2}=${_2}${output};`;
        if (format5 === "system" && exportNamesByVariable.has(this)) {
          output += `${n2}${getSystemExportStatement([this], options)};`;
        }
        return output;
      }
      renderFirst() {
        return this.referencedEarly;
      }
      setMergedNamespaces(mergedNamespaces) {
        this.mergedNamespaces = mergedNamespaces;
        const moduleExecIndex = this.context.getModuleExecIndex();
        for (const identifier4 of this.references) {
          const { context: context8 } = identifier4.scope;
          if (context8.getModuleExecIndex() <= moduleExecIndex) {
            this.referencedEarly = true;
            break;
          }
        }
      }
    };
    NamespaceVariable.prototype.isNamespace = true;
    SyntheticNamedExportVariable = class _SyntheticNamedExportVariable extends Variable {
      constructor(context8, name, syntheticNamespace) {
        super(name);
        this.baseVariable = null;
        this.context = context8;
        this.module = context8.module;
        this.syntheticNamespace = syntheticNamespace;
      }
      getBaseVariable() {
        if (this.baseVariable)
          return this.baseVariable;
        let baseVariable = this.syntheticNamespace;
        while (baseVariable instanceof ExportDefaultVariable || baseVariable instanceof _SyntheticNamedExportVariable) {
          if (baseVariable instanceof ExportDefaultVariable) {
            const original = baseVariable.getOriginalVariable();
            if (original === baseVariable)
              break;
            baseVariable = original;
          }
          if (baseVariable instanceof _SyntheticNamedExportVariable) {
            baseVariable = baseVariable.syntheticNamespace;
          }
        }
        return this.baseVariable = baseVariable;
      }
      getBaseVariableName() {
        return this.syntheticNamespace.getBaseVariableName();
      }
      getName(getPropertyAccess) {
        return `${this.syntheticNamespace.getName(getPropertyAccess)}${getPropertyAccess(this.name)}`;
      }
      includePath(path3, context8) {
        super.includePath(path3, context8);
        this.context.includeVariableInModule(this.syntheticNamespace, path3, context8);
      }
      setRenderNames(baseName, name) {
        super.setRenderNames(baseName, name);
      }
    };
    ExternalChunk = class {
      constructor(module, options, inputBase) {
        this.options = options;
        this.inputBase = inputBase;
        this.defaultVariableName = "";
        this.namespaceVariableName = "";
        this.variableName = "";
        this.fileName = null;
        this.importAttributes = null;
        this.id = module.id;
        this.moduleInfo = module.info;
        this.renormalizeRenderPath = module.renormalizeRenderPath;
        this.suggestedVariableName = module.suggestedVariableName;
      }
      getFileName() {
        if (this.fileName) {
          return this.fileName;
        }
        const { paths } = this.options;
        return this.fileName = (typeof paths === "function" ? paths(this.id) : paths[this.id]) || (this.renormalizeRenderPath ? normalize2(p2.relative(this.inputBase, this.id)) : this.id);
      }
      getImportAttributes(snippets) {
        return this.importAttributes ||= formatAttributes2(["es", "cjs"].includes(this.options.format) && this.options.externalImportAttributes && this.moduleInfo.attributes, snippets);
      }
      getImportPath(importer) {
        return escapeId(this.renormalizeRenderPath ? getImportPath(importer, this.getFileName(), this.options.format === "amd", false) : this.getFileName());
      }
    };
    getDefineProperty = (name, needsLiveBinding, t, { _: _2, getDirectReturnFunction, n: n2 }) => {
      if (needsLiveBinding) {
        const [left3, right3] = getDirectReturnFunction([], {
          functionReturn: true,
          lineBreakIndent: null,
          name: null
        });
        return `Object.defineProperty(exports,${_2}k,${_2}{${n2}${t}${t}enumerable:${_2}true,${n2}${t}${t}get:${_2}${left3}${name}[k]${right3}${n2}${t}})`;
      }
      return `exports[k]${_2}=${_2}${name}[k]`;
    };
    builtinModules2 = [
      "node:assert",
      "assert",
      "node:assert/strict",
      "assert/strict",
      "node:async_hooks",
      "async_hooks",
      "node:buffer",
      "buffer",
      "node:child_process",
      "child_process",
      "node:cluster",
      "cluster",
      "node:console",
      "console",
      "node:constants",
      "constants",
      "node:crypto",
      "crypto",
      "node:dgram",
      "dgram",
      "node:diagnostics_channel",
      "diagnostics_channel",
      "node:dns",
      "dns",
      "node:dns/promises",
      "dns/promises",
      "node:domain",
      "domain",
      "node:events",
      "events",
      "node:fs",
      "fs",
      "node:fs/promises",
      "fs/promises",
      "node:http",
      "http",
      "node:http2",
      "http2",
      "node:https",
      "https",
      "node:inspector",
      "inspector",
      "node:inspector/promises",
      "inspector/promises",
      "node:module",
      "module",
      "node:net",
      "net",
      "node:os",
      "os",
      "node:path",
      "path",
      "node:path/posix",
      "path/posix",
      "node:path/win32",
      "path/win32",
      "node:perf_hooks",
      "perf_hooks",
      "node:process",
      "process",
      "node:querystring",
      "querystring",
      "node:quic",
      "node:readline",
      "readline",
      "node:readline/promises",
      "readline/promises",
      "node:repl",
      "repl",
      "node:sea",
      "node:sqlite",
      "node:stream",
      "stream",
      "node:stream/consumers",
      "stream/consumers",
      "node:stream/promises",
      "stream/promises",
      "node:stream/web",
      "stream/web",
      "node:string_decoder",
      "string_decoder",
      "node:test",
      "node:test/reporters",
      "node:timers",
      "timers",
      "node:timers/promises",
      "timers/promises",
      "node:tls",
      "tls",
      "node:trace_events",
      "trace_events",
      "node:tty",
      "tty",
      "node:url",
      "url",
      "node:util",
      "util",
      "node:util/types",
      "util/types",
      "node:v8",
      "v8",
      "node:vm",
      "vm",
      "node:wasi",
      "wasi",
      "node:worker_threads",
      "worker_threads",
      "node:zlib",
      "zlib"
    ];
    nodeBuiltins = new Set(builtinModules2);
    keypath = (keypath2, getPropertyAccess) => keypath2.split(".").map(getPropertyAccess).join("");
    MISSING_EXPORT_SHIM_VARIABLE = "_missingExportShim";
    getStarExcludes = ({ dependencies, exports }) => {
      const starExcludes = new Set(exports.map((expt) => expt.exported));
      starExcludes.add("default");
      for (const { reexports } of dependencies) {
        if (reexports) {
          for (const reexport of reexports) {
            if (reexport.reexported !== "*")
              starExcludes.add(reexport.reexported);
          }
        }
      }
      return starExcludes;
    };
    getStarExcludesBlock = (starExcludes, t, { _: _2, cnst, getObject, n: n2 }) => {
      if (starExcludes) {
        const fields = [...starExcludes].map((property3) => [
          property3,
          "1"
        ]);
        fields.unshift([null, `__proto__:${_2}null`]);
        return `${n2}${t}${cnst} _starExcludes${_2}=${_2}${getObject(fields, {
          lineBreakIndent: { base: t, t }
        })};`;
      }
      return "";
    };
    getImportBindingsBlock = (importBindings, t, { _: _2, n: n2 }) => importBindings.length > 0 ? `${n2}${t}var ${importBindings.join(`,${_2}`)};` : "";
    getHoistedExportsBlock = (exports, t, snippets) => getExportsBlock(exports.filter((expt) => expt.hoisted).map((expt) => ({ name: expt.exported, value: expt.local })), t, snippets);
    getSyntheticExportsBlock = (exports, t, snippets) => getExportsBlock(exports.filter((expt) => expt.expression).map((expt) => ({ name: expt.exported, value: expt.local })), t, snippets);
    getMissingExportsBlock = (exports, t, snippets) => getExportsBlock(exports.filter((expt) => expt.local === MISSING_EXPORT_SHIM_VARIABLE).map((expt) => ({ name: expt.exported, value: MISSING_EXPORT_SHIM_VARIABLE })), t, snippets);
    finalisers = { amd, cjs, es, iife, system, umd };
    extractors = {
      ArrayPattern(names, param) {
        for (const element of param.elements) {
          if (element)
            extractors[element.type](names, element);
        }
      },
      AssignmentPattern(names, param) {
        extractors[param.left.type](names, param.left);
      },
      Identifier(names, param) {
        names.push(param.name);
      },
      MemberExpression() {
      },
      ObjectPattern(names, param) {
        for (const prop of param.properties) {
          if (prop.type === "RestElement") {
            extractors.RestElement(names, prop);
          } else {
            extractors[prop.value.type](names, prop.value);
          }
        }
      },
      RestElement(names, param) {
        extractors[param.argument.type](names, param.argument);
      }
    };
    extractAssignedNames = function extractAssignedNames2(param) {
      const names = [];
      extractors[param.type](names, param);
      return names;
    };
    reservedWords2 = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
    builtins2 = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
    forbiddenIdentifiers2 = new Set(`${reservedWords2} ${builtins2}`.split(" "));
    forbiddenIdentifiers2.add("");
    ArrayPattern = class extends NodeBase {
      addExportedVariables(variables, exportNamesByVariable) {
        for (const element of this.elements) {
          element?.addExportedVariables(variables, exportNamesByVariable);
        }
      }
      declare(kind, destructuredInitPath, init2) {
        const variables = [];
        const includedPatternPath = getIncludedPatternPath(destructuredInitPath);
        for (const element of this.elements) {
          if (element !== null) {
            variables.push(...element.declare(kind, includedPatternPath, init2));
          }
        }
        return variables;
      }
      deoptimizeAssignment(destructuredInitPath, init2) {
        const includedPatternPath = getIncludedPatternPath(destructuredInitPath);
        for (const element of this.elements) {
          element?.deoptimizeAssignment(includedPatternPath, init2);
        }
      }
      // Patterns can only be deoptimized at the empty path at the moment
      deoptimizePath() {
        for (const element of this.elements) {
          element?.deoptimizePath(EMPTY_PATH);
        }
      }
      hasEffectsWhenDestructuring(context8, destructuredInitPath, init2) {
        const includedPatternPath = getIncludedPatternPath(destructuredInitPath);
        for (const element of this.elements) {
          if (element?.hasEffectsWhenDestructuring(context8, includedPatternPath, init2)) {
            return true;
          }
        }
        return false;
      }
      // Patterns are only checked at the empty path at the moment
      hasEffectsOnInteractionAtPath(_path, interaction, context8) {
        for (const element of this.elements) {
          if (element?.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context8))
            return true;
        }
        return false;
      }
      includeDestructuredIfNecessary(context8, destructuredInitPath, init2) {
        let included = false;
        const includedPatternPath = getIncludedPatternPath(destructuredInitPath);
        for (const element of this.elements) {
          if (element) {
            element.included ||= included;
            included = element.includeDestructuredIfNecessary(context8, includedPatternPath, init2) || included;
          }
        }
        if (included) {
          for (const element of this.elements) {
            if (element && !element.included) {
              element.included = true;
              element.includeDestructuredIfNecessary(context8, includedPatternPath, init2);
            }
          }
        }
        return this.included ||= included;
      }
      markDeclarationReached() {
        for (const element of this.elements) {
          element?.markDeclarationReached();
        }
      }
    };
    ArrayPattern.prototype.includeNode = onlyIncludeSelf;
    getIncludedPatternPath = (destructuredInitPath) => destructuredInitPath.at(-1) === UnknownKey ? destructuredInitPath : [...destructuredInitPath, UnknownInteger];
    ArrowFunctionExpression2 = class extends FunctionBase {
      constructor() {
        super(...arguments);
        this.objectEntity = null;
      }
      get expression() {
        return isFlagSet(
          this.flags,
          8388608
          /* Flag.expression */
        );
      }
      set expression(value) {
        this.flags = setFlag(this.flags, 8388608, value);
      }
      createScope(parentScope) {
        this.scope = new ReturnValueScope(parentScope, false);
      }
      hasEffects() {
        return false;
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        if (this.annotationNoSideEffects && path3.length === 0 && interaction.type === INTERACTION_CALLED) {
          return false;
        }
        if (super.hasEffectsOnInteractionAtPath(path3, interaction, context8)) {
          return true;
        }
        if (interaction.type === INTERACTION_CALLED) {
          const { ignore: ignore3, brokenFlow } = context8;
          context8.ignore = {
            breaks: false,
            continues: false,
            labels: /* @__PURE__ */ new Set(),
            returnYield: true,
            this: false
          };
          if (this.body.hasEffects(context8))
            return true;
          context8.ignore = ignore3;
          context8.brokenFlow = brokenFlow;
        }
        return false;
      }
      onlyFunctionCallUsed() {
        const isIIFE = this.parent.type === CallExpression && this.parent.callee === this;
        return isIIFE || super.onlyFunctionCallUsed();
      }
      include(context8, includeChildrenRecursively) {
        super.include(context8, includeChildrenRecursively);
        for (const parameter of this.params) {
          if (!(parameter instanceof Identifier2)) {
            parameter.include(context8, includeChildrenRecursively);
          }
        }
      }
      includeNode(context8) {
        this.included = true;
        this.body.includePath(UNKNOWN_PATH, context8);
        for (const parameter of this.params) {
          if (!(parameter instanceof Identifier2)) {
            parameter.includePath(UNKNOWN_PATH, context8);
          }
        }
      }
      getObjectEntity() {
        if (this.objectEntity !== null) {
          return this.objectEntity;
        }
        return this.objectEntity = new ObjectEntity([], OBJECT_PROTOTYPE);
      }
    };
    ObjectPattern = class extends NodeBase {
      addExportedVariables(variables, exportNamesByVariable) {
        for (const property3 of this.properties) {
          if (property3.type === Property) {
            property3.value.addExportedVariables(variables, exportNamesByVariable);
          } else {
            property3.argument.addExportedVariables(variables, exportNamesByVariable);
          }
        }
      }
      declare(kind, destructuredInitPath, init2) {
        const variables = [];
        for (const property3 of this.properties) {
          variables.push(...property3.declare(kind, destructuredInitPath, init2));
        }
        return variables;
      }
      deoptimizeAssignment(destructuredInitPath, init2) {
        for (const property3 of this.properties) {
          property3.deoptimizeAssignment(destructuredInitPath, init2);
        }
      }
      deoptimizePath(path3) {
        if (path3.length === 0) {
          for (const property3 of this.properties) {
            property3.deoptimizePath(path3);
          }
        }
      }
      hasEffectsOnInteractionAtPath(_path, interaction, context8) {
        for (const property3 of this.properties) {
          if (property3.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context8))
            return true;
        }
        return false;
      }
      hasEffectsWhenDestructuring(context8, destructuredInitPath, init2) {
        for (const property3 of this.properties) {
          if (property3.hasEffectsWhenDestructuring(context8, destructuredInitPath, init2))
            return true;
        }
        return false;
      }
      includeDestructuredIfNecessary(context8, destructuredInitPath, init2) {
        if (!this.properties.length)
          return false;
        const lastProperty = this.properties.at(-1);
        const lastPropertyIncluded = lastProperty.includeDestructuredIfNecessary(context8, destructuredInitPath, init2);
        const lastPropertyIsRestElement = lastProperty.type === RestElement;
        let included = lastPropertyIsRestElement ? lastPropertyIncluded : false;
        for (const property3 of this.properties.slice(0, -1)) {
          if (lastPropertyIsRestElement && lastPropertyIncluded) {
            property3.includeNode(context8);
          }
          included = property3.includeDestructuredIfNecessary(context8, destructuredInitPath, init2) || included;
        }
        return this.included ||= included;
      }
      markDeclarationReached() {
        for (const property3 of this.properties) {
          property3.markDeclarationReached();
        }
      }
      render(code, options) {
        if (this.properties.length > 0) {
          const separatedNodes = getCommaSeparatedNodesWithBoundaries(this.properties, code, this.start + 1, this.end - 1);
          let lastSeparatorPos = null;
          for (const { node, separator, start: start3, end: end6 } of separatedNodes) {
            if (!node.included) {
              treeshakeNode(node, code, start3, end6);
              continue;
            }
            lastSeparatorPos = separator;
            node.render(code, options);
          }
          if (lastSeparatorPos) {
            code.remove(lastSeparatorPos, this.end - 1);
          }
        }
      }
    };
    ObjectPattern.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    ObjectPattern.prototype.applyDeoptimizations = doNotDeoptimize;
    AssignmentExpression = class extends NodeBase {
      hasEffects(context8) {
        const { deoptimized, left: left3, operator, right: right3 } = this;
        if (!deoptimized)
          this.applyDeoptimizations();
        return right3.hasEffects(context8) || left3.hasEffectsAsAssignmentTarget(context8, operator !== "=") || this.left.hasEffectsWhenDestructuring?.(context8, EMPTY_PATH, right3);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        return this.right.hasEffectsOnInteractionAtPath(path3, interaction, context8);
      }
      include(context8, includeChildrenRecursively) {
        const { deoptimized, left: left3, right: right3, operator } = this;
        if (!deoptimized)
          this.applyDeoptimizations();
        if (!this.included)
          this.includeNode(context8);
        const hasEffectsContext = createHasEffectsContext();
        if (includeChildrenRecursively || operator !== "=" || left3.included || left3.hasEffectsAsAssignmentTarget(hasEffectsContext, false) || left3.hasEffectsWhenDestructuring?.(hasEffectsContext, EMPTY_PATH, right3)) {
          left3.includeAsAssignmentTarget(context8, includeChildrenRecursively, operator !== "=");
        }
        right3.include(context8, includeChildrenRecursively);
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.right.includePath(UNKNOWN_PATH, context8);
      }
      initialise() {
        super.initialise();
        if (this.left instanceof Identifier2) {
          const variable = this.scope.variables.get(this.left.name);
          if (variable?.kind === "const") {
            this.scope.context.error(logConstVariableReassignError(), this.left.start);
          }
        }
        this.left.setAssignedValue(this.right);
      }
      render(code, options, { preventASI, renderedParentType, renderedSurroundingElement } = BLANK) {
        const { left: left3, right: right3, start: start3, end: end6, parent } = this;
        if (left3.included) {
          left3.render(code, options);
          right3.render(code, options);
        } else {
          const inclusionStart = findNonWhiteSpace(code.original, findFirstOccurrenceOutsideComment(code.original, "=", left3.end) + 1);
          code.remove(start3, inclusionStart);
          if (preventASI) {
            removeLineBreaks(code, inclusionStart, right3.start);
          }
          right3.render(code, options, {
            renderedParentType: renderedParentType || parent.type,
            renderedSurroundingElement: renderedSurroundingElement || parent.type
          });
        }
        if (options.format === "system") {
          if (left3 instanceof Identifier2) {
            const variable = left3.variable;
            const exportNames = options.exportNamesByVariable.get(variable);
            if (exportNames) {
              if (exportNames.length === 1) {
                renderSystemExportExpression(variable, start3, end6, code, options);
              } else {
                renderSystemExportSequenceAfterExpression(variable, start3, end6, parent.type !== ExpressionStatement, code, options);
              }
              return;
            }
          } else {
            const systemPatternExports = [];
            left3.addExportedVariables(systemPatternExports, options.exportNamesByVariable);
            if (systemPatternExports.length > 0) {
              renderSystemExportFunction(systemPatternExports, start3, end6, renderedSurroundingElement === ExpressionStatement, code, options);
              return;
            }
          }
        }
        if (left3.included && left3 instanceof ObjectPattern && (renderedSurroundingElement === ExpressionStatement || renderedSurroundingElement === ArrowFunctionExpression)) {
          code.appendRight(start3, "(");
          code.prependLeft(end6, ")");
        }
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.left.deoptimizeAssignment(EMPTY_PATH, this.right);
        this.scope.context.requestTreeshakingPass();
      }
    };
    AssignmentPattern = class extends NodeBase {
      addExportedVariables(variables, exportNamesByVariable) {
        this.left.addExportedVariables(variables, exportNamesByVariable);
      }
      declare(kind, destructuredInitPath, init2) {
        return this.left.declare(kind, destructuredInitPath, init2);
      }
      deoptimizeAssignment(destructuredInitPath, init2) {
        this.left.deoptimizeAssignment(destructuredInitPath, init2);
      }
      deoptimizePath(path3) {
        if (path3.length === 0) {
          this.left.deoptimizePath(path3);
        }
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        return path3.length > 0 || this.left.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context8);
      }
      hasEffectsWhenDestructuring(context8, destructuredInitPath, init2) {
        return this.left.hasEffectsWhenDestructuring(context8, destructuredInitPath, init2);
      }
      includeDestructuredIfNecessary(context8, destructuredInitPath, init2) {
        let included = this.left.includeDestructuredIfNecessary(context8, destructuredInitPath, init2) || this.included;
        if (included ||= this.right.shouldBeIncluded(context8)) {
          this.right.include(context8, false);
          if (!this.left.included) {
            this.left.included = true;
            this.left.includeDestructuredIfNecessary(context8, destructuredInitPath, init2);
          }
        }
        return this.included = included;
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.right.includePath(UNKNOWN_PATH, context8);
      }
      markDeclarationReached() {
        this.left.markDeclarationReached();
      }
      render(code, options, { isShorthandProperty } = BLANK) {
        this.left.render(code, options, { isShorthandProperty });
        this.right.render(code, options);
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.left.deoptimizePath(EMPTY_PATH);
        this.right.deoptimizePath(UNKNOWN_PATH);
        this.scope.context.requestTreeshakingPass();
      }
    };
    AwaitExpression = class extends NodeBase {
      get isTopLevelAwait() {
        return isFlagSet(
          this.flags,
          134217728
          /* Flag.isTopLevelAwait */
        );
      }
      set isTopLevelAwait(value) {
        this.flags = setFlag(this.flags, 134217728, value);
      }
      hasEffects() {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        return true;
      }
      include(context8, includeChildrenRecursively) {
        if (!this.included)
          this.includeNode(context8);
        this.argument.include(context8, includeChildrenRecursively);
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        checkTopLevelAwait: {
          let parent = this.parent;
          do {
            if (parent instanceof FunctionNode || parent instanceof ArrowFunctionExpression2)
              break checkTopLevelAwait;
          } while (parent = parent.parent);
          this.scope.context.usesTopLevelAwait = true;
          this.isTopLevelAwait = true;
        }
        this.argument.includePath(THEN_PATH, context8);
      }
      includePath(path3, context8) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        if (!this.included)
          this.includeNode(context8);
        this.argument.includePath(path3, context8);
      }
    };
    THEN_PATH = ["then"];
    binaryOperators = {
      "!=": (left3, right3) => left3 != right3,
      "!==": (left3, right3) => left3 !== right3,
      "%": (left3, right3) => left3 % right3,
      "&": (left3, right3) => left3 & right3,
      "*": (left3, right3) => left3 * right3,
      // At the moment, "**" will be transpiled to Math.pow
      "**": (left3, right3) => left3 ** right3,
      "+": (left3, right3) => left3 + right3,
      "-": (left3, right3) => left3 - right3,
      "/": (left3, right3) => left3 / right3,
      "<": (left3, right3) => left3 < right3,
      "<<": (left3, right3) => left3 << right3,
      "<=": (left3, right3) => left3 <= right3,
      "==": (left3, right3) => left3 == right3,
      "===": (left3, right3) => left3 === right3,
      ">": (left3, right3) => left3 > right3,
      ">=": (left3, right3) => left3 >= right3,
      ">>": (left3, right3) => left3 >> right3,
      ">>>": (left3, right3) => left3 >>> right3,
      "^": (left3, right3) => left3 ^ right3,
      "|": (left3, right3) => left3 | right3
      // We use the fallback for cases where we return something unknown
      // in: () => UnknownValue,
      // instanceof: () => UnknownValue,
    };
    BinaryExpression = class extends NodeBase {
      deoptimizeCache() {
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        if (path3.length > 0)
          return UnknownValue;
        const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
        if (typeof leftValue === "symbol")
          return UnknownValue;
        const rightValue = this.right.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
        if (typeof rightValue === "symbol")
          return UnknownValue;
        const operatorFunction = binaryOperators[this.operator];
        if (!operatorFunction)
          return UnknownValue;
        return operatorFunction(leftValue, rightValue);
      }
      hasEffects(context8) {
        if (this.operator === "+" && this.parent instanceof ExpressionStatement2 && this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) === "") {
          return true;
        }
        return super.hasEffects(context8);
      }
      hasEffectsOnInteractionAtPath(path3, { type }) {
        return type !== INTERACTION_ACCESSED || path3.length > 1;
      }
      includeNode(context8) {
        this.included = true;
        if (this.operator === "in") {
          this.right.includePath(UNKNOWN_PATH, context8);
        }
      }
      removeAnnotations(code) {
        this.left.removeAnnotations(code);
      }
      render(code, options, { renderedSurroundingElement } = BLANK) {
        this.left.render(code, options, { renderedSurroundingElement });
        this.right.render(code, options);
      }
    };
    BinaryExpression.prototype.applyDeoptimizations = doNotDeoptimize;
    BreakStatement = class extends NodeBase {
      hasEffects(context8) {
        if (this.label) {
          if (!context8.ignore.labels.has(this.label.name))
            return true;
          context8.includedLabels.add(this.label.name);
        } else {
          if (!context8.ignore.breaks)
            return true;
          context8.hasBreak = true;
        }
        context8.brokenFlow = true;
        return false;
      }
      include(context8, includeChildrenRecursively) {
        this.included = true;
        if (this.label) {
          this.label.include(context8, includeChildrenRecursively);
          context8.includedLabels.add(this.label.name);
        } else {
          context8.hasBreak = true;
        }
        context8.brokenFlow = true;
      }
    };
    BreakStatement.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    BreakStatement.prototype.applyDeoptimizations = doNotDeoptimize;
    CallExpressionBase = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.returnExpression = null;
        this.deoptimizableDependentExpressions = [];
        this.expressionsToBeDeoptimized = /* @__PURE__ */ new Set();
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        const { args: args2 } = interaction;
        const [returnExpression, isPure] = this.getReturnExpression(recursionTracker);
        if (isPure)
          return;
        const deoptimizedExpressions = args2.filter((expression) => !!expression && expression !== UNKNOWN_EXPRESSION);
        if (deoptimizedExpressions.length === 0)
          return;
        if (returnExpression === UNKNOWN_EXPRESSION) {
          for (const expression of deoptimizedExpressions) {
            expression.deoptimizePath(UNKNOWN_PATH);
          }
        } else {
          recursionTracker.withTrackedEntityAtPath(path3, returnExpression, () => {
            for (const expression of deoptimizedExpressions) {
              this.expressionsToBeDeoptimized.add(expression);
            }
            returnExpression.deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
          }, null);
        }
      }
      deoptimizeCache() {
        if (this.returnExpression?.[0] !== UNKNOWN_EXPRESSION) {
          this.returnExpression = UNKNOWN_RETURN_EXPRESSION;
          const { deoptimizableDependentExpressions, expressionsToBeDeoptimized } = this;
          this.expressionsToBeDeoptimized = EMPTY_SET;
          this.deoptimizableDependentExpressions = EMPTY_ARRAY;
          for (const expression of deoptimizableDependentExpressions) {
            expression.deoptimizeCache();
          }
          for (const expression of expressionsToBeDeoptimized) {
            expression.deoptimizePath(UNKNOWN_PATH);
          }
        }
      }
      deoptimizePath(path3) {
        if (path3.length === 0 || this.scope.context.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path3, this)) {
          return;
        }
        const [returnExpression] = this.getReturnExpression();
        if (returnExpression !== UNKNOWN_EXPRESSION) {
          returnExpression.deoptimizePath(path3);
        }
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        const [returnExpression] = this.getReturnExpression(recursionTracker);
        if (returnExpression === UNKNOWN_EXPRESSION) {
          return UnknownValue;
        }
        return recursionTracker.withTrackedEntityAtPath(path3, returnExpression, () => {
          this.deoptimizableDependentExpressions.push(origin);
          return returnExpression.getLiteralValueAtPath(path3, recursionTracker, origin);
        }, UnknownValue);
      }
      getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin) {
        const returnExpression = this.getReturnExpression(recursionTracker);
        if (returnExpression[0] === UNKNOWN_EXPRESSION) {
          return returnExpression;
        }
        return recursionTracker.withTrackedEntityAtPath(path3, returnExpression, () => {
          this.deoptimizableDependentExpressions.push(origin);
          const [expression, isPure] = returnExpression[0].getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin);
          return [expression, isPure || returnExpression[1]];
        }, UNKNOWN_RETURN_EXPRESSION);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        const { type } = interaction;
        if (type === INTERACTION_CALLED) {
          const { args: args2, withNew } = interaction;
          if ((withNew ? context8.instantiated : context8.called).trackEntityAtPathAndGetIfTracked(path3, args2, this)) {
            return false;
          }
        } else if ((type === INTERACTION_ASSIGNED ? context8.assigned : context8.accessed).trackEntityAtPathAndGetIfTracked(path3, this)) {
          return false;
        }
        const [returnExpression, isPure] = this.getReturnExpression();
        return (type === INTERACTION_ASSIGNED || !isPure) && returnExpression.hasEffectsOnInteractionAtPath(path3, interaction, context8);
      }
    };
    CallExpression2 = class extends CallExpressionBase {
      get optional() {
        return isFlagSet(
          this.flags,
          128
          /* Flag.optional */
        );
      }
      set optional(value) {
        this.flags = setFlag(this.flags, 128, value);
      }
      bind() {
        super.bind();
        if (this.callee instanceof Identifier2) {
          const variable = this.scope.findVariable(this.callee.name);
          if (variable.isNamespace) {
            this.scope.context.log(LOGLEVEL_WARN, logCannotCallNamespace(this.callee.name), this.start);
          }
          if (this.callee.name === "eval") {
            this.scope.context.log(LOGLEVEL_WARN, logEval(this.scope.context.module.id), this.start);
          }
        }
        this.interaction = {
          args: [
            this.callee instanceof MemberExpression && !this.callee.variable ? this.callee.object : null,
            ...this.arguments
          ],
          type: INTERACTION_CALLED,
          withNew: false
        };
      }
      getLiteralValueAtPathAsChainElement(path3, recursionTracker, origin) {
        return getChainElementLiteralValueAtPath(this, this.callee, path3, recursionTracker, origin);
      }
      hasEffects(context8) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        for (const argument of this.arguments) {
          if (argument.hasEffects(context8))
            return true;
        }
        if (this.annotationPure) {
          return false;
        }
        return this.callee.hasEffects(context8) || this.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context8);
      }
      hasEffectsAsChainElement(context8) {
        const calleeHasEffects = "hasEffectsAsChainElement" in this.callee ? this.callee.hasEffectsAsChainElement(context8) : this.callee.hasEffects(context8);
        if (calleeHasEffects === IS_SKIPPED_CHAIN)
          return IS_SKIPPED_CHAIN;
        if (this.optional && this.callee.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) == null) {
          return !this.annotationPure && calleeHasEffects || IS_SKIPPED_CHAIN;
        }
        if (!this.deoptimized)
          this.applyDeoptimizations();
        for (const argument of this.arguments) {
          if (argument.hasEffects(context8))
            return true;
        }
        return !this.annotationPure && (calleeHasEffects || this.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context8));
      }
      include(context8, includeChildrenRecursively) {
        if (!this.included)
          this.includeNode(context8);
        if (includeChildrenRecursively) {
          super.include(context8, true);
          if (includeChildrenRecursively === INCLUDE_PARAMETERS && this.callee instanceof Identifier2 && this.callee.variable) {
            this.callee.variable.markCalledFromTryStatement();
          }
        } else {
          this.callee.include(context8, false);
          this.callee.includeCallArguments(this.interaction, context8);
        }
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.callee.includePath(UNKNOWN_PATH, context8);
      }
      initialise() {
        super.initialise();
        if (this.annotations && this.scope.context.options.treeshake.annotations) {
          this.annotationPure = this.annotations.some((comment) => comment.type === "pure");
        }
      }
      render(code, options, { renderedSurroundingElement } = BLANK) {
        this.callee.render(code, options, {
          isCalleeOfRenderedParent: true,
          renderedSurroundingElement
        });
        renderCallArguments(code, options, this);
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.callee.deoptimizeArgumentsOnInteractionAtPath(this.interaction, EMPTY_PATH, SHARED_RECURSION_TRACKER);
        this.scope.context.requestTreeshakingPass();
      }
      getReturnExpression(recursionTracker = SHARED_RECURSION_TRACKER) {
        if (this.returnExpression === null) {
          this.returnExpression = UNKNOWN_RETURN_EXPRESSION;
          return this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.interaction, recursionTracker, this);
        }
        return this.returnExpression;
      }
    };
    CatchClause2 = class extends NodeBase {
      createScope(parentScope) {
        this.scope = new ParameterScope(parentScope, true);
      }
      parseNode(esTreeNode) {
        const { body, param, type } = esTreeNode;
        this.type = type;
        if (param) {
          this.param = new (this.scope.context.getNodeConstructor(param.type))(this, this.scope).parseNode(param);
          this.param.declare("parameter", EMPTY_PATH, UNKNOWN_EXPRESSION);
        }
        this.body = new BlockStatement2(this, this.scope.bodyScope).parseNode(body);
        return super.parseNode(esTreeNode);
      }
    };
    CatchClause2.prototype.preventChildBlockScope = true;
    CatchClause2.prototype.includeNode = onlyIncludeSelf;
    ChainExpression = class extends NodeBase {
      // deoptimizations are not relevant as we are not caching values
      deoptimizeCache() {
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        const literalValue = this.expression.getLiteralValueAtPathAsChainElement(path3, recursionTracker, origin);
        return literalValue === IS_SKIPPED_CHAIN ? void 0 : literalValue;
      }
      hasEffects(context8) {
        return this.expression.hasEffectsAsChainElement(context8) === true;
      }
      includePath(path3, context8) {
        this.included = true;
        this.expression.includePath(path3, context8);
      }
      removeAnnotations(code) {
        this.expression.removeAnnotations(code);
      }
    };
    ChainExpression.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    ChainExpression.prototype.applyDeoptimizations = doNotDeoptimize;
    ClassBodyScope = class extends ChildScope {
      constructor(parent, classNode) {
        const { context: context8 } = parent;
        super(parent, context8);
        this.variables.set("this", this.thisVariable = new LocalVariable("this", null, classNode, EMPTY_PATH, context8, "other"));
        this.instanceScope = new ChildScope(this, context8);
        this.instanceScope.variables.set("this", new ThisVariable(context8));
      }
      findLexicalBoundary() {
        return this;
      }
    };
    ClassBody = class extends NodeBase {
      createScope(parentScope) {
        this.scope = new ClassBodyScope(parentScope, this.parent);
      }
      include(context8, includeChildrenRecursively) {
        this.included = true;
        this.scope.context.includeVariableInModule(this.scope.thisVariable, UNKNOWN_PATH, context8);
        for (const definition of this.body) {
          definition.include(context8, includeChildrenRecursively);
        }
      }
      parseNode(esTreeNode) {
        const body = this.body = new Array(esTreeNode.body.length);
        let index = 0;
        for (const definition of esTreeNode.body) {
          body[index++] = new (this.scope.context.getNodeConstructor(definition.type))(this, definition.static ? this.scope : this.scope.instanceScope).parseNode(definition);
        }
        return super.parseNode(esTreeNode);
      }
    };
    ClassBody.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    ClassBody.prototype.applyDeoptimizations = doNotDeoptimize;
    ClassExpression = class extends ClassNode {
      render(code, options, { renderedSurroundingElement } = BLANK) {
        super.render(code, options);
        if (renderedSurroundingElement === ExpressionStatement) {
          code.appendRight(this.start, "(");
          code.prependLeft(this.end, ")");
        }
      }
    };
    MultiExpression = class _MultiExpression extends ExpressionEntity {
      constructor(expressions) {
        super();
        this.expressions = expressions;
      }
      deoptimizePath(path3) {
        for (const expression of this.expressions) {
          expression.deoptimizePath(path3);
        }
      }
      getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin) {
        return [
          new _MultiExpression(this.expressions.map((expression) => expression.getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin)[0])),
          false
        ];
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        for (const expression of this.expressions) {
          if (expression.hasEffectsOnInteractionAtPath(path3, interaction, context8))
            return true;
        }
        return false;
      }
    };
    ConditionalExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.expressionsToBeDeoptimized = [];
        this.usedBranch = null;
      }
      get isBranchResolutionAnalysed() {
        return isFlagSet(
          this.flags,
          65536
          /* Flag.isBranchResolutionAnalysed */
        );
      }
      set isBranchResolutionAnalysed(value) {
        this.flags = setFlag(this.flags, 65536, value);
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        this.consequent.deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
        this.alternate.deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
      }
      deoptimizeCache() {
        if (this.usedBranch !== null) {
          const unusedBranch = this.usedBranch === this.consequent ? this.alternate : this.consequent;
          this.usedBranch = null;
          unusedBranch.deoptimizePath(UNKNOWN_PATH);
          if (this.included) {
            unusedBranch.includePath(UNKNOWN_PATH, createInclusionContext());
          }
          const { expressionsToBeDeoptimized } = this;
          this.expressionsToBeDeoptimized = EMPTY_ARRAY;
          for (const expression of expressionsToBeDeoptimized) {
            expression.deoptimizeCache();
          }
        }
      }
      deoptimizePath(path3) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch) {
          usedBranch.deoptimizePath(path3);
        } else {
          this.consequent.deoptimizePath(path3);
          this.alternate.deoptimizePath(path3);
        }
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        const usedBranch = this.getUsedBranch();
        if (!usedBranch)
          return UnknownValue;
        this.expressionsToBeDeoptimized.push(origin);
        return usedBranch.getLiteralValueAtPath(path3, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin) {
        const usedBranch = this.getUsedBranch();
        if (!usedBranch)
          return [
            new MultiExpression([
              this.consequent.getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin)[0],
              this.alternate.getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin)[0]
            ]),
            false
          ];
        this.expressionsToBeDeoptimized.push(origin);
        return usedBranch.getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin);
      }
      hasEffects(context8) {
        if (this.test.hasEffects(context8))
          return true;
        const usedBranch = this.getUsedBranch();
        if (!usedBranch) {
          return this.consequent.hasEffects(context8) || this.alternate.hasEffects(context8);
        }
        return usedBranch.hasEffects(context8);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        const usedBranch = this.getUsedBranch();
        if (!usedBranch) {
          return this.consequent.hasEffectsOnInteractionAtPath(path3, interaction, context8) || this.alternate.hasEffectsOnInteractionAtPath(path3, interaction, context8);
        }
        return usedBranch.hasEffectsOnInteractionAtPath(path3, interaction, context8);
      }
      include(context8, includeChildrenRecursively) {
        this.included = true;
        const usedBranch = this.getUsedBranch();
        if (usedBranch === null || includeChildrenRecursively || this.test.shouldBeIncluded(context8)) {
          this.test.include(context8, includeChildrenRecursively);
          this.consequent.include(context8, includeChildrenRecursively);
          this.alternate.include(context8, includeChildrenRecursively);
        } else {
          usedBranch.include(context8, includeChildrenRecursively);
        }
      }
      includePath(path3, context8) {
        this.included = true;
        const usedBranch = this.getUsedBranch();
        if (usedBranch === null || this.test.shouldBeIncluded(context8)) {
          this.consequent.includePath(path3, context8);
          this.alternate.includePath(path3, context8);
        } else {
          usedBranch.includePath(path3, context8);
        }
      }
      includeCallArguments(interaction, context8) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch) {
          usedBranch.includeCallArguments(interaction, context8);
        } else {
          this.consequent.includeCallArguments(interaction, context8);
          this.alternate.includeCallArguments(interaction, context8);
        }
      }
      removeAnnotations(code) {
        this.test.removeAnnotations(code);
      }
      render(code, options, { isCalleeOfRenderedParent, preventASI, renderedParentType, renderedSurroundingElement } = BLANK) {
        if (this.test.included) {
          this.test.render(code, options, { renderedSurroundingElement });
          this.consequent.render(code, options);
          this.alternate.render(code, options);
        } else {
          const usedBranch = this.getUsedBranch();
          const colonPos = findFirstOccurrenceOutsideComment(code.original, ":", this.consequent.end);
          const inclusionStart = findNonWhiteSpace(code.original, (this.consequent.included ? findFirstOccurrenceOutsideComment(code.original, "?", this.test.end) : colonPos) + 1);
          if (preventASI) {
            removeLineBreaks(code, inclusionStart, usedBranch.start);
          }
          code.remove(this.start, inclusionStart);
          if (this.consequent.included) {
            code.remove(colonPos, this.end);
          }
          this.test.removeAnnotations(code);
          usedBranch.render(code, options, {
            isCalleeOfRenderedParent,
            preventASI: true,
            renderedParentType: renderedParentType || this.parent.type,
            renderedSurroundingElement: renderedSurroundingElement || this.parent.type
          });
        }
      }
      getUsedBranch() {
        if (this.isBranchResolutionAnalysed) {
          return this.usedBranch;
        }
        this.isBranchResolutionAnalysed = true;
        const testValue = tryCastLiteralValueToBoolean(this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this));
        return typeof testValue === "symbol" ? null : this.usedBranch = testValue ? this.consequent : this.alternate;
      }
    };
    ConditionalExpression.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    ConditionalExpression.prototype.applyDeoptimizations = doNotDeoptimize;
    ContinueStatement = class extends NodeBase {
      hasEffects(context8) {
        if (this.label) {
          if (!context8.ignore.labels.has(this.label.name))
            return true;
          context8.includedLabels.add(this.label.name);
        } else {
          if (!context8.ignore.continues)
            return true;
          context8.hasContinue = true;
        }
        context8.brokenFlow = true;
        return false;
      }
      include(context8, includeChildrenRecursively) {
        this.included = true;
        if (this.label) {
          this.label.include(context8, includeChildrenRecursively);
          context8.includedLabels.add(this.label.name);
        } else {
          context8.hasContinue = true;
        }
        context8.brokenFlow = true;
      }
    };
    ContinueStatement.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    ContinueStatement.prototype.applyDeoptimizations = doNotDeoptimize;
    DebuggerStatement = class extends NodeBase {
      hasEffects() {
        return true;
      }
    };
    DebuggerStatement.prototype.includeNode = onlyIncludeSelf;
    Decorator = class extends NodeBase {
      hasEffects(context8) {
        return this.expression.hasEffects(context8) || this.expression.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, context8);
      }
    };
    Decorator.prototype.includeNode = onlyIncludeSelf;
    DoWhileStatement = class extends NodeBase {
      hasEffects(context8) {
        if (this.test.hasEffects(context8))
          return true;
        return hasLoopBodyEffects(context8, this.body);
      }
      include(context8, includeChildrenRecursively) {
        this.included = true;
        this.test.include(context8, includeChildrenRecursively);
        includeLoopBody(context8, this.body, includeChildrenRecursively);
      }
    };
    DoWhileStatement.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    DoWhileStatement.prototype.applyDeoptimizations = doNotDeoptimize;
    EmptyStatement = class extends NodeBase {
      hasEffects() {
        return false;
      }
    };
    EmptyStatement.prototype.includeNode = onlyIncludeSelf;
    ExportAllDeclaration = class extends NodeBase {
      hasEffects() {
        return false;
      }
      initialise() {
        super.initialise();
        this.scope.context.addExport(this);
      }
      render(code, _options, nodeRenderOptions) {
        code.remove(nodeRenderOptions.start, nodeRenderOptions.end);
      }
    };
    ExportAllDeclaration.prototype.needsBoundaries = true;
    ExportAllDeclaration.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    ExportAllDeclaration.prototype.applyDeoptimizations = doNotDeoptimize;
    ExportNamedDeclaration = class extends NodeBase {
      bind() {
        this.declaration?.bind();
      }
      hasEffects(context8) {
        return !!this.declaration?.hasEffects(context8);
      }
      initialise() {
        super.initialise();
        this.scope.context.addExport(this);
      }
      removeAnnotations(code) {
        this.declaration?.removeAnnotations(code);
      }
      render(code, options, nodeRenderOptions) {
        const { start: start3, end: end6 } = nodeRenderOptions;
        if (this.declaration === null) {
          code.remove(start3, end6);
        } else {
          let endBoundary = this.declaration.start;
          if (this.declaration instanceof ClassDeclaration) {
            const decorators = this.declaration.decorators;
            for (const decorator3 of decorators) {
              endBoundary = Math.min(endBoundary, decorator3.start);
            }
            if (endBoundary <= this.start) {
              endBoundary = this.declaration.start;
            }
          }
          code.remove(this.start, endBoundary);
          this.declaration.render(code, options, { end: end6, start: start3 });
        }
      }
    };
    ExportNamedDeclaration.prototype.needsBoundaries = true;
    ExportNamedDeclaration.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    ExportNamedDeclaration.prototype.applyDeoptimizations = doNotDeoptimize;
    ExportSpecifier = class extends NodeBase {
    };
    ExportSpecifier.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    ExportSpecifier.prototype.applyDeoptimizations = doNotDeoptimize;
    ForInStatement = class extends NodeBase {
      createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
      }
      hasEffects(context8) {
        const { body, deoptimized, left: left3, right: right3 } = this;
        if (!deoptimized)
          this.applyDeoptimizations();
        if (left3.hasEffectsAsAssignmentTarget(context8, false) || right3.hasEffects(context8))
          return true;
        return hasLoopBodyEffects(context8, body);
      }
      include(context8, includeChildrenRecursively) {
        const { body, deoptimized, left: left3, right: right3 } = this;
        if (!deoptimized)
          this.applyDeoptimizations();
        if (!this.included)
          this.includeNode(context8);
        left3.includeAsAssignmentTarget(context8, includeChildrenRecursively || true, false);
        right3.include(context8, includeChildrenRecursively);
        includeLoopBody(context8, body, includeChildrenRecursively);
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.right.includePath(UNKNOWN_PATH, context8);
      }
      initialise() {
        super.initialise();
        this.left.setAssignedValue(UNKNOWN_EXPRESSION);
      }
      render(code, options) {
        this.left.render(code, options, NO_SEMICOLON);
        this.right.render(code, options, NO_SEMICOLON);
        if (code.original.charCodeAt(this.right.start - 1) === 110) {
          code.prependLeft(this.right.start, " ");
        }
        this.body.render(code, options);
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.left.deoptimizePath(EMPTY_PATH);
        this.scope.context.requestTreeshakingPass();
      }
    };
    ForOfStatement = class extends NodeBase {
      get await() {
        return isFlagSet(
          this.flags,
          131072
          /* Flag.await */
        );
      }
      set await(value) {
        this.flags = setFlag(this.flags, 131072, value);
      }
      createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
      }
      hasEffects() {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        return true;
      }
      include(context8, includeChildrenRecursively) {
        const { body, deoptimized, left: left3, right: right3 } = this;
        if (!deoptimized)
          this.applyDeoptimizations();
        if (!this.included)
          this.includeNode(context8);
        left3.includeAsAssignmentTarget(context8, includeChildrenRecursively || true, false);
        right3.include(context8, includeChildrenRecursively);
        includeLoopBody(context8, body, includeChildrenRecursively);
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.right.includePath(UNKNOWN_PATH, context8);
      }
      initialise() {
        super.initialise();
        this.left.setAssignedValue(UNKNOWN_EXPRESSION);
      }
      render(code, options) {
        this.left.render(code, options, NO_SEMICOLON);
        this.right.render(code, options, NO_SEMICOLON);
        if (code.original.charCodeAt(this.right.start - 1) === 102) {
          code.prependLeft(this.right.start, " ");
        }
        this.body.render(code, options);
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.left.deoptimizePath(EMPTY_PATH);
        this.right.deoptimizePath(UNKNOWN_PATH);
        this.scope.context.requestTreeshakingPass();
      }
    };
    ForStatement = class extends NodeBase {
      createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
      }
      hasEffects(context8) {
        if (this.init?.hasEffects(context8) || this.test?.hasEffects(context8) || this.update?.hasEffects(context8)) {
          return true;
        }
        return hasLoopBodyEffects(context8, this.body);
      }
      include(context8, includeChildrenRecursively) {
        this.included = true;
        this.init?.include(context8, includeChildrenRecursively, {
          asSingleStatement: true
        });
        this.test?.include(context8, includeChildrenRecursively);
        this.update?.include(context8, includeChildrenRecursively);
        includeLoopBody(context8, this.body, includeChildrenRecursively);
      }
      render(code, options) {
        this.init?.render(code, options, NO_SEMICOLON);
        this.test?.render(code, options, NO_SEMICOLON);
        this.update?.render(code, options, NO_SEMICOLON);
        this.body.render(code, options);
      }
    };
    ForStatement.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    ForStatement.prototype.applyDeoptimizations = doNotDeoptimize;
    FunctionExpression = class extends FunctionNode {
      createScope(parentScope) {
        super.createScope(this.idScope = new ChildScope(parentScope, parentScope.context));
      }
      parseNode(esTreeNode) {
        if (esTreeNode.id !== null) {
          this.id = new Identifier2(this, this.idScope).parseNode(esTreeNode.id);
        }
        return super.parseNode(esTreeNode);
      }
      onlyFunctionCallUsed() {
        const isIIFE = this.parent.type === CallExpression && this.parent.callee === this && (this.id === null || this.id.variable.getOnlyFunctionCallUsed());
        return isIIFE || super.onlyFunctionCallUsed();
      }
      render(code, options, { renderedSurroundingElement } = BLANK) {
        super.render(code, options);
        if (renderedSurroundingElement === ExpressionStatement) {
          code.appendRight(this.start, "(");
          code.prependLeft(this.end, ")");
        }
      }
    };
    TrackingScope = class extends BlockScope {
      constructor() {
        super(...arguments);
        this.hoistedDeclarations = [];
      }
      addDeclaration(identifier4, context8, init2, destructuredInitPath, kind) {
        this.hoistedDeclarations.push(identifier4);
        return super.addDeclaration(identifier4, context8, init2, destructuredInitPath, kind);
      }
    };
    unset = Symbol("unset");
    IfStatement = class _IfStatement extends NodeBase {
      constructor() {
        super(...arguments);
        this.testValue = unset;
      }
      deoptimizeCache() {
        this.testValue = UnknownValue;
      }
      hasEffects(context8) {
        if (this.test.hasEffects(context8)) {
          return true;
        }
        const testValue = this.getTestValue();
        if (typeof testValue === "symbol") {
          const { brokenFlow } = context8;
          if (this.consequent.hasEffects(context8))
            return true;
          const consequentBrokenFlow = context8.brokenFlow;
          context8.brokenFlow = brokenFlow;
          if (this.alternate === null)
            return false;
          if (this.alternate.hasEffects(context8))
            return true;
          context8.brokenFlow = context8.brokenFlow && consequentBrokenFlow;
          return false;
        }
        return testValue ? this.consequent.hasEffects(context8) : !!this.alternate?.hasEffects(context8);
      }
      include(context8, includeChildrenRecursively) {
        this.included = true;
        if (includeChildrenRecursively) {
          this.includeRecursively(includeChildrenRecursively, context8);
        } else {
          const testValue = this.getTestValue();
          if (typeof testValue === "symbol") {
            this.includeUnknownTest(context8);
          } else {
            this.includeKnownTest(context8, testValue);
          }
        }
      }
      parseNode(esTreeNode) {
        this.consequent = new (this.scope.context.getNodeConstructor(esTreeNode.consequent.type))(this, this.consequentScope = new TrackingScope(this.scope)).parseNode(esTreeNode.consequent);
        if (esTreeNode.alternate) {
          this.alternate = new (this.scope.context.getNodeConstructor(esTreeNode.alternate.type))(this, this.alternateScope = new TrackingScope(this.scope)).parseNode(esTreeNode.alternate);
        }
        return super.parseNode(esTreeNode);
      }
      render(code, options) {
        const { snippets: { getPropertyAccess } } = options;
        const testValue = this.getTestValue();
        const hoistedDeclarations = [];
        const includesIfElse = this.test.included;
        const noTreeshake = !this.scope.context.options.treeshake;
        if (includesIfElse) {
          this.test.render(code, options);
        } else {
          code.remove(this.start, this.consequent.start);
        }
        if (this.consequent.included && (noTreeshake || typeof testValue === "symbol" || testValue)) {
          this.consequent.render(code, options);
        } else {
          code.overwrite(this.consequent.start, this.consequent.end, includesIfElse ? ";" : "");
          hoistedDeclarations.push(...this.consequentScope.hoistedDeclarations);
        }
        if (this.alternate) {
          if (this.alternate.included && (noTreeshake || typeof testValue === "symbol" || !testValue)) {
            if (includesIfElse) {
              if (code.original.charCodeAt(this.alternate.start - 1) === 101) {
                code.prependLeft(this.alternate.start, " ");
              }
            } else {
              code.remove(this.consequent.end, this.alternate.start);
            }
            this.alternate.render(code, options);
          } else {
            if (includesIfElse && this.shouldKeepAlternateBranch()) {
              code.overwrite(this.alternate.start, this.end, ";");
            } else {
              code.remove(this.consequent.end, this.end);
            }
            hoistedDeclarations.push(...this.alternateScope.hoistedDeclarations);
          }
        }
        this.renderHoistedDeclarations(hoistedDeclarations, code, getPropertyAccess);
      }
      getTestValue() {
        if (this.testValue === unset) {
          return this.testValue = tryCastLiteralValueToBoolean(this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this));
        }
        return this.testValue;
      }
      includeKnownTest(context8, testValue) {
        if (this.test.shouldBeIncluded(context8)) {
          this.test.include(context8, false);
        }
        if (testValue && this.consequent.shouldBeIncluded(context8)) {
          this.consequent.include(context8, false, { asSingleStatement: true });
        }
        if (!testValue && this.alternate?.shouldBeIncluded(context8)) {
          this.alternate.include(context8, false, { asSingleStatement: true });
        }
      }
      includeRecursively(includeChildrenRecursively, context8) {
        this.test.include(context8, includeChildrenRecursively);
        this.consequent.include(context8, includeChildrenRecursively);
        this.alternate?.include(context8, includeChildrenRecursively);
      }
      includeUnknownTest(context8) {
        this.test.include(context8, false);
        const { brokenFlow } = context8;
        let consequentBrokenFlow = false;
        if (this.consequent.shouldBeIncluded(context8)) {
          this.consequent.include(context8, false, { asSingleStatement: true });
          consequentBrokenFlow = context8.brokenFlow;
          context8.brokenFlow = brokenFlow;
        }
        if (this.alternate?.shouldBeIncluded(context8)) {
          this.alternate.include(context8, false, { asSingleStatement: true });
          context8.brokenFlow = context8.brokenFlow && consequentBrokenFlow;
        }
      }
      renderHoistedDeclarations(hoistedDeclarations, code, getPropertyAccess) {
        const hoistedVariables = [
          ...new Set(hoistedDeclarations.map((identifier4) => {
            const variable = identifier4.variable;
            return variable.included ? variable.getName(getPropertyAccess) : "";
          }))
        ].filter(Boolean).join(", ");
        if (hoistedVariables) {
          const parentType = this.parent.type;
          const needsBraces = parentType !== Program && parentType !== BlockStatement;
          code.prependRight(this.start, `${needsBraces ? "{ " : ""}var ${hoistedVariables}; `);
          if (needsBraces) {
            code.appendLeft(this.end, ` }`);
          }
        }
      }
      shouldKeepAlternateBranch() {
        let currentParent = this.parent;
        do {
          if (currentParent instanceof _IfStatement && currentParent.alternate) {
            return true;
          }
          if (currentParent instanceof BlockStatement2) {
            return false;
          }
          currentParent = currentParent.parent;
        } while (currentParent);
        return false;
      }
    };
    IfStatement.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    IfStatement.prototype.applyDeoptimizations = doNotDeoptimize;
    ImportAttribute = class extends NodeBase {
    };
    ImportDeclaration = class extends NodeBase {
      // Do not bind specifiers or attributes
      bind() {
      }
      hasEffects() {
        return false;
      }
      initialise() {
        super.initialise();
        this.scope.context.addImport(this);
      }
      render(code, _options, nodeRenderOptions) {
        code.remove(nodeRenderOptions.start, nodeRenderOptions.end);
      }
    };
    ImportDeclaration.prototype.needsBoundaries = true;
    ImportDeclaration.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    ImportDeclaration.prototype.applyDeoptimizations = doNotDeoptimize;
    ImportDefaultSpecifier = class extends NodeBase {
    };
    ImportDefaultSpecifier.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    ImportDefaultSpecifier.prototype.applyDeoptimizations = doNotDeoptimize;
    VariableDeclarator2 = class extends NodeBase {
      declareDeclarator(kind, isUsingDeclaration) {
        this.isUsingDeclaration = isUsingDeclaration;
        this.id.declare(kind, EMPTY_PATH, this.init || UNDEFINED_EXPRESSION);
      }
      deoptimizePath(path3) {
        this.id.deoptimizePath(path3);
      }
      hasEffects(context8) {
        const initEffect = this.init?.hasEffects(context8);
        this.id.markDeclarationReached();
        return initEffect || this.isUsingDeclaration || this.id.hasEffects(context8) || this.scope.context.options.treeshake.propertyReadSideEffects && this.id.hasEffectsWhenDestructuring(context8, EMPTY_PATH, this.init || UNDEFINED_EXPRESSION);
      }
      include(context8, includeChildrenRecursively) {
        const { id: id2, init: init2 } = this;
        if (!this.included)
          this.includeNode();
        init2?.include(context8, includeChildrenRecursively);
        id2.markDeclarationReached();
        if (includeChildrenRecursively) {
          id2.include(context8, includeChildrenRecursively);
        } else {
          id2.includeDestructuredIfNecessary(context8, EMPTY_PATH, init2 || UNDEFINED_EXPRESSION);
        }
      }
      removeAnnotations(code) {
        this.init?.removeAnnotations(code);
      }
      render(code, options) {
        const { exportNamesByVariable, snippets: { _: _2, getPropertyAccess } } = options;
        const { end: end6, id: id2, init: init2, start: start3 } = this;
        const renderId = id2.included || this.isUsingDeclaration;
        if (renderId) {
          id2.render(code, options);
        } else {
          const operatorPos = findFirstOccurrenceOutsideComment(code.original, "=", id2.end);
          code.remove(start3, findNonWhiteSpace(code.original, operatorPos + 1));
        }
        if (init2) {
          if (id2 instanceof Identifier2 && init2 instanceof ClassExpression && !init2.id) {
            const renderedVariable = id2.variable.getName(getPropertyAccess);
            if (renderedVariable !== id2.name) {
              code.appendLeft(init2.start + 5, ` ${id2.name}`);
            }
          }
          init2.render(code, options, renderId ? BLANK : { renderedSurroundingElement: ExpressionStatement });
        } else if (id2 instanceof Identifier2 && isReassignedExportsMember(id2.variable, exportNamesByVariable)) {
          code.appendLeft(end6, `${_2}=${_2}void 0`);
        }
      }
      includeNode() {
        this.included = true;
        const { id: id2, init: init2 } = this;
        if (init2 && id2 instanceof Identifier2 && init2 instanceof ClassExpression && !init2.id) {
          const { name, variable } = id2;
          for (const accessedVariable of init2.scope.accessedOutsideVariables.values()) {
            if (accessedVariable !== variable) {
              accessedVariable.forbidName(name);
            }
          }
        }
      }
    };
    VariableDeclarator2.prototype.applyDeoptimizations = doNotDeoptimize;
    ImportExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.inlineNamespace = null;
        this.hasUnknownAccessedKey = false;
        this.accessedPropKey = /* @__PURE__ */ new Set();
        this.attributes = null;
        this.mechanism = null;
        this.namespaceExportName = void 0;
        this.resolution = null;
        this.resolutionString = null;
      }
      // Do not bind attributes
      bind() {
        this.source.bind();
      }
      get isFollowingTopLevelAwait() {
        return this.parent instanceof AwaitExpression && this.parent.isTopLevelAwait;
      }
      /**
       * Get imported variables for deterministic usage, valid cases are:
       *
       * - `const { foo } = await import('bar')`.
       * - `(await import('bar')).foo`
       * - `import('bar').then(({ foo }) => {})`
       *
       * Returns empty array if it's side-effect only import.
       * Returns undefined if it's not fully deterministic.
       */
      getDeterministicImportedNames() {
        const parent1 = this.parent;
        if (parent1 instanceof ExpressionStatement2) {
          return EMPTY_ARRAY;
        }
        if (parent1 instanceof AwaitExpression) {
          const parent2 = parent1.parent;
          if (parent2 instanceof ExpressionStatement2) {
            return EMPTY_ARRAY;
          }
          if (parent2 instanceof VariableDeclarator2) {
            const declaration = parent2.id;
            if (declaration instanceof Identifier2) {
              return this.hasUnknownAccessedKey ? void 0 : [...this.accessedPropKey];
            }
            if (declaration instanceof ObjectPattern) {
              return getDeterministicObjectDestructure(declaration);
            }
          }
          if (parent2 instanceof MemberExpression) {
            const id2 = parent2.property;
            if (!parent2.computed && id2 instanceof Identifier2) {
              return [id2.name];
            }
          }
          return;
        }
        if (parent1 instanceof MemberExpression) {
          const callExpression3 = parent1.parent;
          const property3 = parent1.property;
          if (!(callExpression3 instanceof CallExpression2) || !(property3 instanceof Identifier2)) {
            return;
          }
          const memberName = property3.name;
          if (callExpression3.parent instanceof ExpressionStatement2 && ["catch", "finally"].includes(memberName)) {
            return EMPTY_ARRAY;
          }
          if (memberName !== "then")
            return;
          if (callExpression3.arguments.length === 0) {
            return EMPTY_ARRAY;
          }
          const argument = callExpression3.arguments[0];
          if (callExpression3.arguments.length !== 1 || !(argument instanceof ArrowFunctionExpression2 || argument instanceof FunctionExpression)) {
            return;
          }
          if (argument.params.length === 0) {
            return EMPTY_ARRAY;
          }
          const declaration = argument.params[0];
          if (argument.params.length === 1 && declaration instanceof ObjectPattern) {
            return getDeterministicObjectDestructure(declaration);
          }
          return;
        }
      }
      hasEffects() {
        return true;
      }
      include(context8, includeChildrenRecursively) {
        if (!this.included)
          this.includeNode();
        this.source.include(context8, includeChildrenRecursively);
      }
      includeNode() {
        this.included = true;
        this.scope.context.includeDynamicImport(this);
        this.scope.addAccessedDynamicImport(this);
      }
      includePath(path3) {
        if (!this.included)
          this.includeNode();
        if (this.hasUnknownAccessedKey)
          return;
        if (path3[0] === UnknownKey) {
          this.hasUnknownAccessedKey = true;
        } else if (typeof path3[0] === "string") {
          this.accessedPropKey.add(path3[0]);
        }
        this.scope.context.includeDynamicImport(this);
      }
      initialise() {
        super.initialise();
        this.scope.context.addDynamicImport(this);
      }
      parseNode(esTreeNode) {
        this.sourceAstNode = esTreeNode.source;
        return super.parseNode(esTreeNode);
      }
      render(code, options) {
        const { snippets: { _: _2, getDirectReturnFunction, getObject, getPropertyAccess }, importAttributesKey } = options;
        if (this.inlineNamespace) {
          const [left3, right3] = getDirectReturnFunction([], {
            functionReturn: true,
            lineBreakIndent: null,
            name: null
          });
          code.overwrite(this.start, this.end, `Promise.resolve().then(${left3}${this.inlineNamespace.getName(getPropertyAccess)}${right3})`);
          return;
        }
        if (this.mechanism) {
          code.overwrite(this.start, findFirstOccurrenceOutsideComment(code.original, "(", this.start + 6) + 1, this.mechanism.left);
          code.overwrite(this.end - 1, this.end, this.mechanism.right);
        }
        if (this.resolutionString) {
          code.overwrite(this.source.start, this.source.end, this.resolutionString);
          if (this.namespaceExportName) {
            const [left3, right3] = getDirectReturnFunction(["n"], {
              functionReturn: true,
              lineBreakIndent: null,
              name: null
            });
            code.prependLeft(this.end, `.then(${left3}n.${this.namespaceExportName}${right3})`);
          }
        } else {
          this.source.render(code, options);
        }
        if (this.attributes !== true) {
          if (this.options) {
            code.overwrite(this.source.end, this.end - 1, "", { contentOnly: true });
          }
          if (this.attributes) {
            code.appendLeft(this.end - 1, `,${_2}${getObject([[importAttributesKey, this.attributes]], {
              lineBreakIndent: null
            })}`);
          }
        }
      }
      setExternalResolution(exportMode, resolution, options, snippets, pluginDriver, accessedGlobalsByScope, resolutionString, namespaceExportName, attributes, ownChunk, targetChunk) {
        const { format: format5 } = options;
        this.inlineNamespace = null;
        this.resolution = resolution;
        this.resolutionString = resolutionString;
        this.namespaceExportName = namespaceExportName;
        this.attributes = attributes;
        const accessedGlobals = [...accessedImportGlobals[format5] || []];
        let helper;
        ({ helper, mechanism: this.mechanism } = this.getDynamicImportMechanismAndHelper(resolution, exportMode, options, snippets, pluginDriver, ownChunk, targetChunk));
        if (helper) {
          accessedGlobals.push(helper);
        }
        if (accessedGlobals.length > 0) {
          this.scope.addAccessedGlobals(accessedGlobals, accessedGlobalsByScope);
        }
      }
      setInternalResolution(inlineNamespace) {
        this.inlineNamespace = inlineNamespace;
      }
      getDynamicImportMechanismAndHelper(resolution, exportMode, { compact: compact2, dynamicImportInCjs, format: format5, generatedCode: { arrowFunctions }, interop }, { _: _2, getDirectReturnFunction, getDirectReturnIifeLeft }, pluginDriver, ownChunk, targetChunk) {
        const mechanism = pluginDriver.hookFirstSync("renderDynamicImport", [
          {
            chunk: getChunkInfoWithPath(ownChunk),
            customResolution: typeof this.resolution === "string" ? this.resolution : null,
            format: format5,
            getTargetChunkImports() {
              if (targetChunk === null)
                return null;
              const chunkInfos = [];
              const importerPath = ownChunk.getFileName();
              for (const dep of targetChunk.dependencies) {
                const resolvedImportPath = `'${dep.getImportPath(importerPath)}'`;
                if (dep instanceof ExternalChunk) {
                  chunkInfos.push({
                    fileName: dep.getFileName(),
                    resolvedImportPath,
                    type: "external"
                  });
                } else {
                  chunkInfos.push({
                    chunk: dep.getPreRenderedChunkInfo(),
                    fileName: dep.getFileName(),
                    resolvedImportPath,
                    type: "internal"
                  });
                }
              }
              return chunkInfos;
            },
            moduleId: this.scope.context.module.id,
            targetChunk: targetChunk ? getChunkInfoWithPath(targetChunk) : null,
            targetModuleId: this.resolution && typeof this.resolution !== "string" ? this.resolution.id : null
          }
        ]);
        if (mechanism) {
          return { helper: null, mechanism };
        }
        const hasDynamicTarget = !this.resolution || typeof this.resolution === "string";
        switch (format5) {
          case "cjs": {
            if (dynamicImportInCjs && (!resolution || typeof resolution === "string" || resolution instanceof ExternalModule)) {
              return { helper: null, mechanism: null };
            }
            const helper = getInteropHelper(resolution, exportMode, interop);
            let left3 = `require(`;
            let right3 = `)`;
            if (helper) {
              left3 = `/*#__PURE__*/${helper}(${left3}`;
              right3 += ")";
            }
            const [functionLeft, functionRight] = getDirectReturnFunction([], {
              functionReturn: true,
              lineBreakIndent: null,
              name: null
            });
            left3 = `Promise.resolve().then(${functionLeft}${left3}`;
            right3 += `${functionRight})`;
            if (!arrowFunctions && hasDynamicTarget) {
              left3 = getDirectReturnIifeLeft(["t"], `${left3}t${right3}`, {
                needsArrowReturnParens: false,
                needsWrappedFunction: true
              });
              right3 = ")";
            }
            return {
              helper,
              mechanism: { left: left3, right: right3 }
            };
          }
          case "amd": {
            const resolve9 = compact2 ? "c" : "resolve";
            const reject = compact2 ? "e" : "reject";
            const helper = getInteropHelper(resolution, exportMode, interop);
            const [resolveLeft, resolveRight] = getDirectReturnFunction(["m"], {
              functionReturn: false,
              lineBreakIndent: null,
              name: null
            });
            const resolveNamespace = helper ? `${resolveLeft}${resolve9}(/*#__PURE__*/${helper}(m))${resolveRight}` : resolve9;
            const [handlerLeft, handlerRight] = getDirectReturnFunction([resolve9, reject], {
              functionReturn: false,
              lineBreakIndent: null,
              name: null
            });
            let left3 = `new Promise(${handlerLeft}require([`;
            let right3 = `],${_2}${resolveNamespace},${_2}${reject})${handlerRight})`;
            if (!arrowFunctions && hasDynamicTarget) {
              left3 = getDirectReturnIifeLeft(["t"], `${left3}t${right3}`, {
                needsArrowReturnParens: false,
                needsWrappedFunction: true
              });
              right3 = ")";
            }
            return {
              helper,
              mechanism: { left: left3, right: right3 }
            };
          }
          case "system": {
            return {
              helper: null,
              mechanism: {
                left: "module.import(",
                right: ")"
              }
            };
          }
        }
        return { helper: null, mechanism: null };
      }
    };
    ImportExpression.prototype.applyDeoptimizations = doNotDeoptimize;
    accessedImportGlobals = {
      amd: ["require"],
      cjs: ["require"],
      system: ["module"]
    };
    ImportNamespaceSpecifier = class extends NodeBase {
    };
    ImportNamespaceSpecifier.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    ImportNamespaceSpecifier.prototype.applyDeoptimizations = doNotDeoptimize;
    ImportSpecifier = class extends NodeBase {
    };
    ImportSpecifier.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    ImportSpecifier.prototype.applyDeoptimizations = doNotDeoptimize;
    JSXIdentifier = class extends IdentifierBase {
      constructor() {
        super(...arguments);
        this.isNativeElement = false;
      }
      bind() {
        const type = this.getType();
        if (type === 0) {
          this.variable = this.scope.findVariable(this.name);
          this.variable.addReference(this);
        } else if (type === 1) {
          this.isNativeElement = true;
        }
      }
      include(context8) {
        if (!this.included)
          this.includeNode(context8);
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        if (this.variable !== null) {
          this.scope.context.includeVariableInModule(this.variable, EMPTY_PATH, context8);
        }
      }
      includePath(path3, context8) {
        if (!this.included) {
          this.included = true;
          if (this.variable !== null) {
            this.scope.context.includeVariableInModule(this.variable, path3, context8);
          }
        } else if (path3.length > 0) {
          this.variable?.includePath(path3, context8);
        }
      }
      render(code, { snippets: { getPropertyAccess }, useOriginalName }) {
        if (this.variable) {
          const name = this.variable.getName(getPropertyAccess, useOriginalName);
          if (name !== this.name) {
            code.overwrite(this.start, this.end, name, {
              contentOnly: true,
              storeName: true
            });
          }
        } else if (this.isNativeElement && this.scope.context.options.jsx.mode !== "preserve") {
          code.update(this.start, this.end, JSON.stringify(this.name));
        }
      }
      getType() {
        switch (this.parent.type) {
          case "JSXOpeningElement":
          case "JSXClosingElement": {
            return this.name.startsWith(this.name.charAt(0).toUpperCase()) ? 0 : 1;
          }
          case "JSXMemberExpression": {
            return this.parent.object === this ? 0 : 2;
          }
          case "JSXAttribute":
          case "JSXNamespacedName": {
            return 2;
          }
          default: {
            throw new Error(`Unexpected parent node type for JSXIdentifier: ${this.parent.type}`);
          }
        }
      }
    };
    JSXAttribute = class extends NodeBase {
      render(code, options, { jsxMode } = BLANK) {
        super.render(code, options);
        if (["classic", "automatic"].includes(jsxMode)) {
          const { name, value } = this;
          const key = name instanceof JSXIdentifier ? name.name : `${name.namespace.name}:${name.name.name}`;
          if (!(jsxMode === "automatic" && key === "key")) {
            const safeKey = stringifyObjectKeyIfNeeded(key);
            if (key !== safeKey) {
              code.overwrite(name.start, name.end, safeKey, { contentOnly: true });
            }
            if (value) {
              code.overwrite(name.end, value.start, ": ", { contentOnly: true });
            } else {
              code.appendLeft(name.end, ": true");
            }
          }
        }
      }
    };
    JSXAttribute.prototype.includeNode = onlyIncludeSelf;
    JSXClosingBase = class extends NodeBase {
      render(code, options) {
        const { mode } = this.scope.context.options.jsx;
        if (mode !== "preserve") {
          code.overwrite(this.start, this.end, ")", { contentOnly: true });
        } else {
          super.render(code, options);
        }
      }
    };
    JSXClosingBase.prototype.includeNode = onlyIncludeSelf;
    JSXClosingElement = class extends JSXClosingBase {
    };
    JSXClosingFragment = class extends JSXClosingBase {
    };
    JSXSpreadAttribute = class extends NodeBase {
      render(code, options) {
        this.argument.render(code, options);
        const { mode } = this.scope.context.options.jsx;
        if (mode !== "preserve") {
          code.overwrite(this.start, this.argument.start, "", { contentOnly: true });
          code.overwrite(this.argument.end, this.end, "", { contentOnly: true });
        }
      }
    };
    JSXEmptyExpression = class extends NodeBase {
    };
    JSXEmptyExpression.prototype.includeNode = onlyIncludeSelf;
    JSXExpressionContainer = class extends NodeBase {
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.expression.includePath(UNKNOWN_PATH, context8);
      }
      render(code, options) {
        const { mode } = this.scope.context.options.jsx;
        if (mode !== "preserve") {
          code.remove(this.start, this.expression.start);
          code.remove(this.expression.end, this.end);
        }
        this.expression.render(code, options);
      }
    };
    JSXElementBase = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.factoryVariable = null;
        this.factory = null;
      }
      initialise() {
        super.initialise();
        const { importSource } = this.jsxMode = this.getRenderingMode();
        if (importSource) {
          this.scope.context.addImportSource(importSource);
        }
      }
      include(context8, includeChildrenRecursively) {
        if (!this.included)
          this.includeNode(context8);
        for (const child of this.children) {
          child.include(context8, includeChildrenRecursively);
        }
      }
      includeNode(context8) {
        this.included = true;
        const { factory, importSource, mode } = this.jsxMode;
        if (factory) {
          this.factory = factory;
          this.factoryVariable = getAndIncludeFactoryVariable(factory, mode === "preserve", importSource, this, context8);
        }
      }
      getRenderingMode() {
        const jsx = this.scope.context.options.jsx;
        const { mode, factory, importSource } = jsx;
        if (mode === "automatic") {
          return {
            factory: getRenderedJsxChildren(this.children) > 1 ? "jsxs" : "jsx",
            importSource: jsx.jsxImportSource,
            mode
          };
        }
        return { factory, importSource, mode };
      }
      renderChildren(code, options, openingEnd) {
        const { children: children2 } = this;
        let hasMultipleChildren = false;
        let childrenEnd = openingEnd;
        let firstChild = null;
        for (const child of children2) {
          if (child instanceof JSXExpressionContainer && child.expression instanceof JSXEmptyExpression) {
            code.remove(childrenEnd, child.end);
          } else {
            code.appendLeft(childrenEnd, ", ");
            child.render(code, options);
            if (firstChild) {
              hasMultipleChildren = true;
            } else {
              firstChild = child;
            }
          }
          childrenEnd = child.end;
        }
        return { childrenEnd, firstChild, hasMultipleChildren };
      }
    };
    JSXElementBase.prototype.applyDeoptimizations = doNotDeoptimize;
    JSXElement = class extends JSXElementBase {
      include(context8, includeChildrenRecursively) {
        super.include(context8, includeChildrenRecursively);
        this.openingElement.include(context8, includeChildrenRecursively);
        this.closingElement?.include(context8, includeChildrenRecursively);
      }
      render(code, options) {
        switch (this.jsxMode.mode) {
          case "classic": {
            this.renderClassicMode(code, options);
            break;
          }
          case "automatic": {
            this.renderAutomaticMode(code, options);
            break;
          }
          default: {
            super.render(code, options);
          }
        }
      }
      getRenderingMode() {
        const jsx = this.scope.context.options.jsx;
        const { mode, factory, importSource } = jsx;
        if (mode === "automatic") {
          let hasSpread = false;
          for (const attribute of this.openingElement.attributes) {
            if (attribute instanceof JSXSpreadAttribute) {
              hasSpread = true;
            } else if (hasSpread && attribute.name.name === "key") {
              return { factory, importSource, mode: "classic" };
            }
          }
        }
        return super.getRenderingMode();
      }
      renderClassicMode(code, options) {
        const { snippets: { getPropertyAccess }, useOriginalName } = options;
        const { closingElement, end: end6, factory, factoryVariable, openingElement: { end: openingEnd, selfClosing } } = this;
        const [, ...nestedName] = factory.split(".");
        const { firstAttribute, hasAttributes, hasSpread, inObject, previousEnd } = this.renderAttributes(code, options, [factoryVariable.getName(getPropertyAccess, useOriginalName), ...nestedName].join("."), false);
        this.wrapAttributes(code, inObject, hasAttributes, hasSpread, firstAttribute, "null", previousEnd);
        this.renderChildren(code, options, openingEnd);
        if (selfClosing) {
          code.appendLeft(end6, ")");
        } else {
          closingElement.render(code, options);
        }
      }
      renderAutomaticMode(code, options) {
        const { snippets: { getPropertyAccess }, useOriginalName } = options;
        const { closingElement, end: end6, factoryVariable, openingElement: { end: openindEnd, selfClosing } } = this;
        let { firstAttribute, hasAttributes, hasSpread, inObject, keyAttribute, previousEnd } = this.renderAttributes(code, options, factoryVariable.getName(getPropertyAccess, useOriginalName), true);
        const { firstChild, hasMultipleChildren, childrenEnd } = this.renderChildren(code, options, openindEnd);
        if (firstChild) {
          code.prependRight(firstChild.start, `children: ${hasMultipleChildren ? "[" : ""}`);
          if (!inObject) {
            code.prependRight(firstChild.start, "{ ");
            inObject = true;
          }
          previousEnd = closingElement.start;
          if (hasMultipleChildren) {
            code.appendLeft(previousEnd, "]");
          }
        }
        this.wrapAttributes(code, inObject, hasAttributes || !!firstChild, hasSpread, firstAttribute || firstChild, "{}", childrenEnd);
        if (keyAttribute) {
          const { value } = keyAttribute;
          code.appendLeft(childrenEnd, ", ");
          if (value) {
            code.move(value.start, value.end, childrenEnd);
          } else {
            code.appendLeft(childrenEnd, "true");
          }
        }
        if (selfClosing) {
          code.appendLeft(keyAttribute?.value?.end || end6, ")");
        } else {
          closingElement.render(code, options);
        }
      }
      renderAttributes(code, options, factoryName, extractKeyAttribute) {
        const { jsxMode: { mode }, openingElement } = this;
        const { attributes, end: openingEnd, start: openingStart, name: { start: nameStart, end: nameEnd } } = openingElement;
        code.update(openingStart, nameStart, `/*#__PURE__*/${factoryName}(`);
        openingElement.render(code, options, { jsxMode: mode });
        let keyAttribute = null;
        let hasSpread = false;
        let inObject = false;
        let previousEnd = nameEnd;
        let hasAttributes = false;
        let firstAttribute = null;
        for (const attribute of attributes) {
          if (attribute instanceof JSXAttribute) {
            if (extractKeyAttribute && attribute.name.name === "key") {
              keyAttribute = attribute;
              code.remove(previousEnd, attribute.value?.start || attribute.end);
              continue;
            }
            code.appendLeft(previousEnd, ",");
            if (!inObject) {
              code.prependRight(attribute.start, "{ ");
              inObject = true;
            }
            hasAttributes = true;
          } else {
            if (inObject) {
              if (hasAttributes) {
                code.appendLeft(previousEnd, " ");
              }
              code.appendLeft(previousEnd, "},");
              inObject = false;
            } else {
              code.appendLeft(previousEnd, ",");
            }
            hasSpread = true;
          }
          previousEnd = attribute.end;
          if (!firstAttribute) {
            firstAttribute = attribute;
          }
        }
        code.remove(attributes.at(-1)?.end || previousEnd, openingEnd);
        return { firstAttribute, hasAttributes, hasSpread, inObject, keyAttribute, previousEnd };
      }
      wrapAttributes(code, inObject, hasAttributes, hasSpread, firstAttribute, missingAttributesFallback, attributesEnd) {
        if (inObject) {
          code.appendLeft(attributesEnd, " }");
        }
        if (hasSpread) {
          if (hasAttributes) {
            const { start: start3 } = firstAttribute;
            if (firstAttribute instanceof JSXSpreadAttribute) {
              code.prependRight(start3, "{}, ");
            }
            code.prependRight(start3, "Object.assign(");
            code.appendLeft(attributesEnd, ")");
          }
        } else if (!hasAttributes) {
          code.appendLeft(attributesEnd, `, ${missingAttributesFallback}`);
        }
      }
    };
    JSXFragment = class extends JSXElementBase {
      include(context8, includeChildrenRecursively) {
        super.include(context8, includeChildrenRecursively);
        this.openingFragment.include(context8, includeChildrenRecursively);
        this.closingFragment.include(context8, includeChildrenRecursively);
      }
      render(code, options) {
        switch (this.jsxMode.mode) {
          case "classic": {
            this.renderClassicMode(code, options);
            break;
          }
          case "automatic": {
            this.renderAutomaticMode(code, options);
            break;
          }
          default: {
            super.render(code, options);
          }
        }
      }
      renderClassicMode(code, options) {
        const { snippets: { getPropertyAccess }, useOriginalName } = options;
        const { closingFragment, factory, factoryVariable, openingFragment, start: start3 } = this;
        const [, ...nestedName] = factory.split(".");
        openingFragment.render(code, options);
        code.prependRight(start3, `/*#__PURE__*/${[
          factoryVariable.getName(getPropertyAccess, useOriginalName),
          ...nestedName
        ].join(".")}(`);
        code.appendLeft(openingFragment.end, ", null");
        this.renderChildren(code, options, openingFragment.end);
        closingFragment.render(code, options);
      }
      renderAutomaticMode(code, options) {
        const { snippets: { getPropertyAccess }, useOriginalName } = options;
        const { closingFragment, factoryVariable, openingFragment, start: start3 } = this;
        openingFragment.render(code, options);
        code.prependRight(start3, `/*#__PURE__*/${factoryVariable.getName(getPropertyAccess, useOriginalName)}(`);
        const { firstChild, hasMultipleChildren, childrenEnd } = this.renderChildren(code, options, openingFragment.end);
        if (firstChild) {
          code.prependRight(firstChild.start, `{ children: ${hasMultipleChildren ? "[" : ""}`);
          if (hasMultipleChildren) {
            code.appendLeft(closingFragment.start, "]");
          }
          code.appendLeft(childrenEnd, " }");
        } else {
          code.appendLeft(openingFragment.end, ", {}");
        }
        closingFragment.render(code, options);
      }
    };
    JSXMemberExpression = class extends NodeBase {
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.object.includePath([this.property.name], context8);
      }
      includePath(path3, context8) {
        if (!this.included)
          this.includeNode(context8);
        this.object.includePath([this.property.name, ...path3], context8);
      }
    };
    JSXNamespacedName = class extends NodeBase {
    };
    JSXNamespacedName.prototype.includeNode = onlyIncludeSelf;
    JSXOpeningElement = class extends NodeBase {
      render(code, options, { jsxMode = this.scope.context.options.jsx.mode } = {}) {
        this.name.render(code, options);
        for (const attribute of this.attributes) {
          attribute.render(code, options, { jsxMode });
        }
      }
    };
    JSXOpeningElement.prototype.includeNode = onlyIncludeSelf;
    JSXOpeningFragment = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.fragment = null;
        this.fragmentVariable = null;
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        const jsx = this.scope.context.options.jsx;
        if (jsx.mode === "automatic") {
          this.fragment = "Fragment";
          this.fragmentVariable = getAndIncludeFactoryVariable("Fragment", false, jsx.jsxImportSource, this, context8);
        } else {
          const { fragment, importSource, mode } = jsx;
          if (fragment != null) {
            this.fragment = fragment;
            this.fragmentVariable = getAndIncludeFactoryVariable(fragment, mode === "preserve", importSource, this, context8);
          }
        }
      }
      render(code, options) {
        const { mode } = this.scope.context.options.jsx;
        if (mode !== "preserve") {
          const { snippets: { getPropertyAccess }, useOriginalName } = options;
          const [, ...nestedFragment] = this.fragment.split(".");
          const fragment = [
            this.fragmentVariable.getName(getPropertyAccess, useOriginalName),
            ...nestedFragment
          ].join(".");
          code.update(this.start, this.end, fragment);
        }
      }
    };
    JSXSpreadChild = class extends NodeBase {
      render(code, options) {
        super.render(code, options);
        const { mode } = this.scope.context.options.jsx;
        if (mode !== "preserve") {
          code.overwrite(this.start, this.expression.start, "...", { contentOnly: true });
          code.overwrite(this.expression.end, this.end, "", { contentOnly: true });
        }
      }
    };
    JSXText = class extends NodeBase {
      render(code) {
        const { mode } = this.scope.context.options.jsx;
        if (mode !== "preserve") {
          code.overwrite(this.start, this.end, JSON.stringify(this.value), {
            contentOnly: true
          });
        }
      }
    };
    JSXText.prototype.includeNode = onlyIncludeSelf;
    LabeledStatement = class extends NodeBase {
      hasEffects(context8) {
        const { brokenFlow, includedLabels } = context8;
        context8.ignore.labels.add(this.label.name);
        context8.includedLabels = /* @__PURE__ */ new Set();
        let bodyHasEffects = false;
        if (this.body.hasEffects(context8)) {
          bodyHasEffects = true;
        } else {
          context8.ignore.labels.delete(this.label.name);
          if (context8.includedLabels.has(this.label.name)) {
            context8.includedLabels.delete(this.label.name);
            context8.brokenFlow = brokenFlow;
          }
        }
        context8.includedLabels = /* @__PURE__ */ new Set([...includedLabels, ...context8.includedLabels]);
        return bodyHasEffects;
      }
      include(context8, includeChildrenRecursively) {
        if (!this.included)
          this.includeNode(context8);
        const { brokenFlow, includedLabels } = context8;
        context8.includedLabels = /* @__PURE__ */ new Set();
        this.body.include(context8, includeChildrenRecursively);
        if (includeChildrenRecursively || context8.includedLabels.has(this.label.name)) {
          this.label.include(context8, includeChildrenRecursively);
          context8.includedLabels.delete(this.label.name);
          context8.brokenFlow = brokenFlow;
        }
        context8.includedLabels = /* @__PURE__ */ new Set([...includedLabels, ...context8.includedLabels]);
      }
      includeNode(context8) {
        this.included = true;
        this.body.includePath(UNKNOWN_PATH, context8);
      }
      render(code, options) {
        if (this.label.included) {
          this.label.render(code, options);
        } else {
          code.remove(this.start, findNonWhiteSpace(code.original, findFirstOccurrenceOutsideComment(code.original, ":", this.label.end) + 1));
        }
        this.body.render(code, options);
      }
    };
    LabeledStatement.prototype.applyDeoptimizations = doNotDeoptimize;
    LogicalExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.expressionsToBeDeoptimized = [];
        this.usedBranch = null;
      }
      //private isBranchResolutionAnalysed = false;
      get isBranchResolutionAnalysed() {
        return isFlagSet(
          this.flags,
          65536
          /* Flag.isBranchResolutionAnalysed */
        );
      }
      set isBranchResolutionAnalysed(value) {
        this.flags = setFlag(this.flags, 65536, value);
      }
      get hasDeoptimizedCache() {
        return isFlagSet(
          this.flags,
          33554432
          /* Flag.hasDeoptimizedCache */
        );
      }
      set hasDeoptimizedCache(value) {
        this.flags = setFlag(this.flags, 33554432, value);
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        this.left.deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
        this.right.deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
      }
      deoptimizeCache() {
        if (this.hasDeoptimizedCache)
          return;
        this.hasDeoptimizedCache = true;
        if (this.usedBranch) {
          const unusedBranch = this.usedBranch === this.left ? this.right : this.left;
          this.usedBranch = null;
          unusedBranch.deoptimizePath(UNKNOWN_PATH);
          if (this.included) {
            unusedBranch.includePath(UNKNOWN_PATH, createInclusionContext());
          }
        }
        const { scope: { context: context8 }, expressionsToBeDeoptimized } = this;
        this.expressionsToBeDeoptimized = EMPTY_ARRAY;
        for (const expression of expressionsToBeDeoptimized) {
          expression.deoptimizeCache();
        }
        context8.requestTreeshakingPass();
      }
      deoptimizePath(path3) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch) {
          usedBranch.deoptimizePath(path3);
        } else {
          this.left.deoptimizePath(path3);
          this.right.deoptimizePath(path3);
        }
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        if (origin === this)
          return UnknownValue;
        const usedBranch = this.getUsedBranch();
        if (usedBranch) {
          this.expressionsToBeDeoptimized.push(origin);
          return usedBranch.getLiteralValueAtPath(path3, recursionTracker, origin);
        } else if (!this.hasDeoptimizedCache && !path3.length) {
          const rightValue = this.right.getLiteralValueAtPath(path3, recursionTracker, origin);
          const booleanOrUnknown = tryCastLiteralValueToBoolean(rightValue);
          if (typeof booleanOrUnknown !== "symbol") {
            if (!booleanOrUnknown && this.operator === "&&") {
              this.expressionsToBeDeoptimized.push(origin);
              return UnknownFalsyValue;
            }
            if (booleanOrUnknown && this.operator === "||") {
              this.expressionsToBeDeoptimized.push(origin);
              return UnknownTruthyValue;
            }
          }
        }
        return UnknownValue;
      }
      getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch) {
          this.expressionsToBeDeoptimized.push(origin);
          return usedBranch.getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin);
        }
        return [
          new MultiExpression([
            this.left.getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin)[0],
            this.right.getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin)[0]
          ]),
          false
        ];
      }
      hasEffects(context8) {
        if (this.left.hasEffects(context8)) {
          return true;
        }
        if (this.getUsedBranch() !== this.left) {
          return this.right.hasEffects(context8);
        }
        return false;
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch) {
          return usedBranch.hasEffectsOnInteractionAtPath(path3, interaction, context8);
        }
        return this.left.hasEffectsOnInteractionAtPath(path3, interaction, context8) || this.right.hasEffectsOnInteractionAtPath(path3, interaction, context8);
      }
      include(context8, includeChildrenRecursively) {
        this.included = true;
        const usedBranch = this.getUsedBranch();
        if (includeChildrenRecursively || !usedBranch || usedBranch === this.right && this.left.shouldBeIncluded(context8)) {
          this.left.include(context8, includeChildrenRecursively);
          this.right.include(context8, includeChildrenRecursively);
        } else {
          usedBranch.include(context8, includeChildrenRecursively);
        }
      }
      includePath(path3, context8) {
        this.included = true;
        const usedBranch = this.getUsedBranch();
        if (!usedBranch || usedBranch === this.right && this.left.shouldBeIncluded(context8)) {
          this.left.includePath(path3, context8);
          this.right.includePath(path3, context8);
        } else {
          usedBranch.includePath(path3, context8);
        }
      }
      removeAnnotations(code) {
        this.left.removeAnnotations(code);
      }
      render(code, options, { isCalleeOfRenderedParent, preventASI, renderedParentType, renderedSurroundingElement } = BLANK) {
        if (!this.left.included || !this.right.included) {
          const operatorPos = findFirstOccurrenceOutsideComment(code.original, this.operator, this.left.end);
          if (this.right.included) {
            const removePos = findNonWhiteSpace(code.original, operatorPos + 2);
            code.remove(this.start, removePos);
            if (preventASI) {
              removeLineBreaks(code, removePos, this.right.start);
            }
            this.left.removeAnnotations(code);
          } else {
            code.remove(findLastWhiteSpaceReverse(code.original, this.left.end, operatorPos), this.end);
          }
          this.getUsedBranch().render(code, options, {
            isCalleeOfRenderedParent,
            preventASI,
            renderedParentType: renderedParentType || this.parent.type,
            renderedSurroundingElement: renderedSurroundingElement || this.parent.type
          });
        } else {
          this.left.render(code, options, {
            preventASI,
            renderedSurroundingElement
          });
          this.right.render(code, options);
        }
      }
      getUsedBranch() {
        if (!this.isBranchResolutionAnalysed) {
          this.isBranchResolutionAnalysed = true;
          const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
          const booleanOrUnknown = tryCastLiteralValueToBoolean(leftValue);
          if (typeof booleanOrUnknown === "symbol") {
            return null;
          } else {
            this.usedBranch = this.operator === "||" && booleanOrUnknown || this.operator === "&&" && !booleanOrUnknown || this.operator === "??" && leftValue != null ? this.left : this.right;
          }
        }
        return this.usedBranch;
      }
    };
    LogicalExpression.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    LogicalExpression.prototype.applyDeoptimizations = doNotDeoptimize;
    NewExpression = class extends NodeBase {
      hasEffects(context8) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        for (const argument of this.arguments) {
          if (argument.hasEffects(context8))
            return true;
        }
        if (this.annotationPure) {
          return false;
        }
        return this.callee.hasEffects(context8) || this.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context8);
      }
      hasEffectsOnInteractionAtPath(path3, { type }) {
        return path3.length > 0 || type !== INTERACTION_ACCESSED;
      }
      include(context8, includeChildrenRecursively) {
        if (!this.included)
          this.includeNode(context8);
        if (includeChildrenRecursively) {
          super.include(context8, true);
        } else {
          this.callee.include(context8, false);
          this.callee.includeCallArguments(this.interaction, context8);
        }
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.callee.includePath(UNKNOWN_PATH, context8);
      }
      initialise() {
        super.initialise();
        this.interaction = {
          args: [null, ...this.arguments],
          type: INTERACTION_CALLED,
          withNew: true
        };
        if (this.annotations && this.scope.context.options.treeshake.annotations) {
          this.annotationPure = this.annotations.some((comment) => comment.type === "pure");
        }
      }
      render(code, options) {
        this.callee.render(code, options);
        renderCallArguments(code, options, this);
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.callee.deoptimizeArgumentsOnInteractionAtPath(this.interaction, EMPTY_PATH, SHARED_RECURSION_TRACKER);
        this.scope.context.requestTreeshakingPass();
      }
    };
    ObjectExpression2 = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.objectEntity = null;
        this.protoProp = null;
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
      }
      deoptimizeCache() {
        this.getObjectEntity().deoptimizeAllProperties();
      }
      deoptimizePath(path3) {
        this.getObjectEntity().deoptimizePath(path3);
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        return this.getObjectEntity().getLiteralValueAtPath(path3, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin) {
        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        return this.getObjectEntity().hasEffectsOnInteractionAtPath(path3, interaction, context8);
      }
      include(context8, includeChildrenRecursively) {
        if (!this.included)
          this.includeNode(context8);
        this.getObjectEntity().include(context8, includeChildrenRecursively);
        this.protoProp?.include(context8, includeChildrenRecursively);
      }
      includeNode(context8) {
        this.included = true;
        this.protoProp?.includePath(UNKNOWN_PATH, context8);
      }
      includePath(path3, context8) {
        if (!this.included)
          this.includeNode(context8);
        this.getObjectEntity().includePath(path3, context8);
      }
      render(code, options, { renderedSurroundingElement } = BLANK) {
        if (renderedSurroundingElement === ExpressionStatement || renderedSurroundingElement === ArrowFunctionExpression) {
          code.appendRight(this.start, "(");
          code.prependLeft(this.end, ")");
        }
        if (this.properties.length > 0) {
          const separatedNodes = getCommaSeparatedNodesWithBoundaries(this.properties, code, this.start + 1, this.end - 1);
          let lastSeparatorPos = null;
          for (const { node, separator, start: start3, end: end6 } of separatedNodes) {
            if (!node.included) {
              treeshakeNode(node, code, start3, end6);
              continue;
            }
            lastSeparatorPos = separator;
            node.render(code, options);
          }
          if (lastSeparatorPos) {
            code.remove(lastSeparatorPos, this.end - 1);
          }
        }
      }
      getObjectEntity() {
        if (this.objectEntity !== null) {
          return this.objectEntity;
        }
        let prototype = OBJECT_PROTOTYPE;
        const properties = [];
        for (const property3 of this.properties) {
          if (property3 instanceof SpreadElement) {
            properties.push({ key: UnknownKey, kind: "init", property: property3 });
            continue;
          }
          let key;
          if (property3.computed) {
            const keyValue = property3.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
            if (typeof keyValue === "symbol") {
              properties.push({ key: UnknownKey, kind: property3.kind, property: property3 });
              continue;
            } else {
              key = String(keyValue);
            }
          } else {
            key = property3.key instanceof Identifier2 ? property3.key.name : String(property3.key.value);
            if (key === "__proto__" && property3.kind === "init") {
              this.protoProp = property3;
              prototype = property3.value instanceof Literal2 && property3.value.value === null ? null : property3.value;
              continue;
            }
          }
          properties.push({ key, kind: property3.kind, property: property3 });
        }
        return this.objectEntity = new ObjectEntity(properties, prototype);
      }
    };
    ObjectExpression2.prototype.applyDeoptimizations = doNotDeoptimize;
    PanicError2 = class extends NodeBase {
      initialise() {
        const id2 = this.scope.context.module.id;
        const parseError3 = getRollupError(logParseError(this.message));
        const moduleParseError = logModuleParseError(parseError3, id2);
        return error3(moduleParseError);
      }
    };
    ParseError2 = class extends NodeBase {
      initialise() {
        const pos = this.start;
        const id2 = this.scope.context.module.id;
        const parseError3 = getRollupError(logParseError(this.message, pos));
        const moduleParseError = logModuleParseError(parseError3, id2);
        this.scope.context.error(moduleParseError, pos);
      }
    };
    PrivateIdentifier = class extends NodeBase {
    };
    PrivateIdentifier.prototype.includeNode = onlyIncludeSelf;
    Program2 = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.hasCachedEffect = null;
        this.hasLoggedEffect = false;
      }
      hasCachedEffects() {
        if (!this.included) {
          return false;
        }
        return this.hasCachedEffect === null ? this.hasCachedEffect = this.hasEffects(createHasEffectsContext()) : this.hasCachedEffect;
      }
      hasEffects(context8) {
        for (const node of this.body) {
          if (node.hasEffects(context8)) {
            if (this.scope.context.options.experimentalLogSideEffects && !this.hasLoggedEffect) {
              this.hasLoggedEffect = true;
              const { code, log: log5, module } = this.scope.context;
              log5(LOGLEVEL_INFO, logFirstSideEffect(code, module.id, locate(code, node.start, { offsetLine: 1 })), node.start);
            }
            return this.hasCachedEffect = true;
          }
        }
        return false;
      }
      include(context8, includeChildrenRecursively) {
        this.included = true;
        for (const node of this.body) {
          if (includeChildrenRecursively || node.shouldBeIncluded(context8)) {
            node.include(context8, includeChildrenRecursively);
          }
        }
      }
      initialise() {
        super.initialise();
        if (this.invalidAnnotations)
          for (const { start: start3, end: end6, type } of this.invalidAnnotations) {
            this.scope.context.magicString.remove(start3, end6);
            if (type === "pure" || type === "noSideEffects") {
              this.scope.context.log(LOGLEVEL_WARN, logInvalidAnnotation(this.scope.context.code.slice(start3, end6), this.scope.context.module.id, type), start3);
            }
          }
      }
      render(code, options) {
        let start3 = this.start;
        if (code.original.startsWith("#!")) {
          start3 = Math.min(code.original.indexOf("\n") + 1, this.end);
          code.remove(0, start3);
        }
        if (this.body.length > 0) {
          while (code.original[start3] === "/" && /[*/]/.test(code.original[start3 + 1])) {
            const firstLineBreak = findFirstLineBreakOutsideComment(code.original.slice(start3, this.body[0].start));
            if (firstLineBreak[0] === -1) {
              break;
            }
            start3 += firstLineBreak[1];
          }
          renderStatementList(this.body, code, start3, this.end, options);
        } else {
          super.render(code, options);
        }
      }
    };
    Program2.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    Program2.prototype.applyDeoptimizations = doNotDeoptimize;
    Property2 = class extends MethodBase {
      //declare method: boolean;
      get method() {
        return isFlagSet(
          this.flags,
          262144
          /* Flag.method */
        );
      }
      set method(value) {
        this.flags = setFlag(this.flags, 262144, value);
      }
      //declare shorthand: boolean;
      get shorthand() {
        return isFlagSet(
          this.flags,
          524288
          /* Flag.shorthand */
        );
      }
      set shorthand(value) {
        this.flags = setFlag(this.flags, 524288, value);
      }
      declare(kind, destructuredInitPath, init2) {
        return this.value.declare(kind, this.getPathInProperty(destructuredInitPath), init2);
      }
      deoptimizeAssignment(destructuredInitPath, init2) {
        this.value.deoptimizeAssignment?.(this.getPathInProperty(destructuredInitPath), init2);
      }
      hasEffects(context8) {
        return this.key.hasEffects(context8) || this.value.hasEffects(context8);
      }
      hasEffectsWhenDestructuring(context8, destructuredInitPath, init2) {
        return this.value.hasEffectsWhenDestructuring?.(context8, this.getPathInProperty(destructuredInitPath), init2);
      }
      includeDestructuredIfNecessary(context8, destructuredInitPath, init2) {
        const path3 = this.getPathInProperty(destructuredInitPath);
        let included = this.value.includeDestructuredIfNecessary(context8, path3, init2) || this.included;
        if (included ||= this.key.hasEffects(createHasEffectsContext())) {
          this.key.include(context8, false);
          if (!this.value.included) {
            this.value.included = true;
            this.value.includeDestructuredIfNecessary(context8, path3, init2);
          }
        }
        return this.included = included;
      }
      include(context8, includeChildrenRecursively) {
        this.included = true;
        this.key.include(context8, includeChildrenRecursively);
        this.value.include(context8, includeChildrenRecursively);
      }
      includePath(path3, context8) {
        this.included = true;
        this.value.includePath(path3, context8);
      }
      markDeclarationReached() {
        this.value.markDeclarationReached();
      }
      render(code, options) {
        if (!this.shorthand) {
          this.key.render(code, options);
        }
        this.value.render(code, options, { isShorthandProperty: this.shorthand });
      }
      getPathInProperty(destructuredInitPath) {
        return destructuredInitPath.at(-1) === UnknownKey ? destructuredInitPath : (
          // For now, we only consider static paths as we do not know how to
          // deoptimize the path in the dynamic case.
          this.computed ? [...destructuredInitPath, UnknownKey] : this.key instanceof Identifier2 ? [...destructuredInitPath, this.key.name] : [...destructuredInitPath, String(this.key.value)]
        );
      }
    };
    Property2.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    Property2.prototype.applyDeoptimizations = doNotDeoptimize;
    PropertyDefinition = class extends NodeBase {
      get computed() {
        return isFlagSet(
          this.flags,
          1024
          /* Flag.computed */
        );
      }
      set computed(value) {
        this.flags = setFlag(this.flags, 1024, value);
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        this.value?.deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
      }
      deoptimizePath(path3) {
        this.value?.deoptimizePath(path3);
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        return this.value ? this.value.getLiteralValueAtPath(path3, recursionTracker, origin) : UnknownValue;
      }
      getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin) {
        return this.value ? this.value.getReturnExpressionWhenCalledAtPath(path3, interaction, recursionTracker, origin) : UNKNOWN_RETURN_EXPRESSION;
      }
      hasEffects(context8) {
        return this.key.hasEffects(context8) || this.static && !!this.value?.hasEffects(context8) || checkEffectForNodes(this.decorators, context8);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        return !this.value || this.value.hasEffectsOnInteractionAtPath(path3, interaction, context8);
      }
      includeNode(context8) {
        this.included = true;
        this.value?.includePath(UNKNOWN_PATH, context8);
        for (const decorator3 of this.decorators) {
          decorator3.includePath(UNKNOWN_PATH, context8);
        }
      }
    };
    PropertyDefinition.prototype.applyDeoptimizations = doNotDeoptimize;
    ReturnStatement2 = class extends NodeBase {
      hasEffects(context8) {
        if (!context8.ignore.returnYield || this.argument?.hasEffects(context8))
          return true;
        context8.brokenFlow = true;
        return false;
      }
      include(context8, includeChildrenRecursively) {
        if (!this.included)
          this.includeNode(context8);
        this.argument?.include(context8, includeChildrenRecursively);
        context8.brokenFlow = true;
      }
      includeNode(context8) {
        this.included = true;
        this.argument?.includePath(UNKNOWN_PATH, context8);
      }
      initialise() {
        super.initialise();
        this.scope.addReturnExpression(this.argument || UNKNOWN_EXPRESSION);
      }
      render(code, options) {
        if (this.argument) {
          this.argument.render(code, options, { preventASI: true });
          if (this.argument.start === this.start + 6) {
            code.prependLeft(this.start + 6, " ");
          }
        }
      }
    };
    ReturnStatement2.prototype.applyDeoptimizations = doNotDeoptimize;
    SequenceExpression = class extends NodeBase {
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        this.expressions[this.expressions.length - 1].deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
      }
      deoptimizePath(path3) {
        this.expressions[this.expressions.length - 1].deoptimizePath(path3);
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        return this.expressions[this.expressions.length - 1].getLiteralValueAtPath(path3, recursionTracker, origin);
      }
      hasEffects(context8) {
        for (const expression of this.expressions) {
          if (expression.hasEffects(context8))
            return true;
        }
        return false;
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        return this.expressions[this.expressions.length - 1].hasEffectsOnInteractionAtPath(path3, interaction, context8);
      }
      include(context8, includeChildrenRecursively) {
        this.included = true;
        const lastExpression = this.expressions[this.expressions.length - 1];
        for (const expression of this.expressions) {
          if (includeChildrenRecursively || expression === lastExpression && !(this.parent instanceof ExpressionStatement2) || expression.shouldBeIncluded(context8)) {
            expression.include(context8, includeChildrenRecursively);
          }
        }
      }
      includePath(path3, context8) {
        this.included = true;
        this.expressions[this.expressions.length - 1].includePath(path3, context8);
      }
      removeAnnotations(code) {
        this.expressions[0].removeAnnotations(code);
      }
      render(code, options, { renderedParentType, isCalleeOfRenderedParent, preventASI } = BLANK) {
        let includedNodes = 0;
        let lastSeparatorPos = null;
        const lastNode = this.expressions[this.expressions.length - 1];
        for (const { node, separator, start: start3, end: end6 } of getCommaSeparatedNodesWithBoundaries(this.expressions, code, this.start, this.end)) {
          if (!node.included) {
            treeshakeNode(node, code, start3, end6);
            continue;
          }
          includedNodes++;
          lastSeparatorPos = separator;
          if (includedNodes === 1 && preventASI) {
            removeLineBreaks(code, start3, node.start);
          }
          if (includedNodes === 1) {
            const parentType = renderedParentType || this.parent.type;
            node.render(code, options, {
              isCalleeOfRenderedParent: isCalleeOfRenderedParent && node === lastNode,
              renderedParentType: parentType,
              renderedSurroundingElement: parentType
            });
          } else {
            node.render(code, options);
          }
        }
        if (lastSeparatorPos) {
          code.remove(lastSeparatorPos, this.end);
        }
      }
    };
    SequenceExpression.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    SequenceExpression.prototype.applyDeoptimizations = doNotDeoptimize;
    Super = class extends NodeBase {
      bind() {
        this.variable = this.scope.findVariable("this");
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        this.variable.deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
      }
      deoptimizePath(path3) {
        this.variable.deoptimizePath(path3);
      }
      include(context8) {
        if (!this.included)
          this.includeNode(context8);
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.scope.context.includeVariableInModule(this.variable, EMPTY_PATH, context8);
      }
    };
    SwitchCase = class extends NodeBase {
      hasEffects(context8) {
        if (this.test?.hasEffects(context8))
          return true;
        for (const node of this.consequent) {
          if (context8.brokenFlow)
            break;
          if (node.hasEffects(context8))
            return true;
        }
        return false;
      }
      include(context8, includeChildrenRecursively) {
        this.included = true;
        this.test?.include(context8, includeChildrenRecursively);
        for (const node of this.consequent) {
          if (includeChildrenRecursively || node.shouldBeIncluded(context8))
            node.include(context8, includeChildrenRecursively);
        }
      }
      render(code, options, nodeRenderOptions) {
        if (this.test) {
          this.test.render(code, options);
          if (this.test.start === this.start + 4) {
            code.prependLeft(this.test.start, " ");
          }
        }
        if (this.consequent.length > 0) {
          const testEnd = this.test ? this.test.end : findFirstOccurrenceOutsideComment(code.original, "default", this.start) + 7;
          const consequentStart = findFirstOccurrenceOutsideComment(code.original, ":", testEnd) + 1;
          renderStatementList(this.consequent, code, consequentStart, nodeRenderOptions.end, options);
        }
      }
    };
    SwitchCase.prototype.needsBoundaries = true;
    SwitchCase.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    SwitchCase.prototype.applyDeoptimizations = doNotDeoptimize;
    SwitchStatement = class extends NodeBase {
      createScope(parentScope) {
        this.parentScope = parentScope;
        this.scope = new BlockScope(parentScope);
      }
      hasEffects(context8) {
        if (this.discriminant.hasEffects(context8))
          return true;
        const { brokenFlow, hasBreak, ignore: ignore3 } = context8;
        const { breaks } = ignore3;
        ignore3.breaks = true;
        context8.hasBreak = false;
        let onlyHasBrokenFlow = true;
        for (const switchCase3 of this.cases) {
          if (switchCase3.hasEffects(context8))
            return true;
          onlyHasBrokenFlow &&= context8.brokenFlow && !context8.hasBreak;
          context8.hasBreak = false;
          context8.brokenFlow = brokenFlow;
        }
        if (this.defaultCase !== null) {
          context8.brokenFlow = onlyHasBrokenFlow;
        }
        ignore3.breaks = breaks;
        context8.hasBreak = hasBreak;
        return false;
      }
      include(context8, includeChildrenRecursively) {
        this.included = true;
        this.discriminant.include(context8, includeChildrenRecursively);
        const { brokenFlow, hasBreak } = context8;
        context8.hasBreak = false;
        let onlyHasBrokenFlow = true;
        let isCaseIncluded = includeChildrenRecursively || this.defaultCase !== null && this.defaultCase < this.cases.length - 1;
        for (let caseIndex = this.cases.length - 1; caseIndex >= 0; caseIndex--) {
          const switchCase3 = this.cases[caseIndex];
          if (switchCase3.included) {
            isCaseIncluded = true;
          }
          if (!isCaseIncluded) {
            const hasEffectsContext = createHasEffectsContext();
            hasEffectsContext.ignore.breaks = true;
            isCaseIncluded = switchCase3.hasEffects(hasEffectsContext);
          }
          if (isCaseIncluded) {
            switchCase3.include(context8, includeChildrenRecursively);
            onlyHasBrokenFlow &&= context8.brokenFlow && !context8.hasBreak;
            context8.hasBreak = false;
            context8.brokenFlow = brokenFlow;
          } else {
            onlyHasBrokenFlow = brokenFlow;
          }
        }
        if (isCaseIncluded && this.defaultCase !== null) {
          context8.brokenFlow = onlyHasBrokenFlow;
        }
        context8.hasBreak = hasBreak;
      }
      initialise() {
        super.initialise();
        for (let caseIndex = 0; caseIndex < this.cases.length; caseIndex++) {
          if (this.cases[caseIndex].test === null) {
            this.defaultCase = caseIndex;
            return;
          }
        }
        this.defaultCase = null;
      }
      parseNode(esTreeNode) {
        this.discriminant = new (this.scope.context.getNodeConstructor(esTreeNode.discriminant.type))(this, this.parentScope).parseNode(esTreeNode.discriminant);
        return super.parseNode(esTreeNode);
      }
      render(code, options) {
        this.discriminant.render(code, options);
        if (this.cases.length > 0) {
          renderStatementList(this.cases, code, this.cases[0].start, this.end - 1, options);
        }
      }
    };
    SwitchStatement.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    SwitchStatement.prototype.applyDeoptimizations = doNotDeoptimize;
    TaggedTemplateExpression = class extends CallExpressionBase {
      bind() {
        super.bind();
        if (this.tag.type === Identifier) {
          const name = this.tag.name;
          const variable = this.scope.findVariable(name);
          if (variable.isNamespace) {
            this.scope.context.log(LOGLEVEL_WARN, logCannotCallNamespace(name), this.start);
          }
        }
      }
      hasEffects(context8) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        for (const argument of this.quasi.expressions) {
          if (argument.hasEffects(context8))
            return true;
        }
        return this.tag.hasEffects(context8) || this.tag.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context8);
      }
      include(context8, includeChildrenRecursively) {
        if (!this.included)
          this.includeNode(context8);
        if (includeChildrenRecursively) {
          super.include(context8, true);
        } else {
          this.quasi.include(context8, false);
          this.tag.include(context8, false);
          this.tag.includeCallArguments(this.interaction, context8);
        }
      }
      initialise() {
        super.initialise();
        this.args = [UNKNOWN_EXPRESSION, ...this.quasi.expressions];
        this.interaction = {
          args: [
            this.tag instanceof MemberExpression && !this.tag.variable ? this.tag.object : null,
            ...this.args
          ],
          type: INTERACTION_CALLED,
          withNew: false
        };
      }
      render(code, options) {
        this.tag.render(code, options, { isCalleeOfRenderedParent: true });
        this.quasi.render(code, options);
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.tag.deoptimizeArgumentsOnInteractionAtPath(this.interaction, EMPTY_PATH, SHARED_RECURSION_TRACKER);
        this.scope.context.requestTreeshakingPass();
      }
      getReturnExpression(recursionTracker = SHARED_RECURSION_TRACKER) {
        if (this.returnExpression === null) {
          this.returnExpression = UNKNOWN_RETURN_EXPRESSION;
          return this.returnExpression = this.tag.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.interaction, recursionTracker, this);
        }
        return this.returnExpression;
      }
    };
    TaggedTemplateExpression.prototype.includeNode = onlyIncludeSelf;
    TemplateElement = class extends NodeBase {
      get tail() {
        return isFlagSet(
          this.flags,
          1048576
          /* Flag.tail */
        );
      }
      set tail(value) {
        this.flags = setFlag(this.flags, 1048576, value);
      }
      // Do not try to bind value
      bind() {
      }
      hasEffects() {
        return false;
      }
      parseNode(esTreeNode) {
        this.value = esTreeNode.value;
        return super.parseNode(esTreeNode);
      }
      render() {
      }
    };
    TemplateElement.prototype.includeNode = onlyIncludeSelf;
    TemplateLiteral2 = class extends NodeBase {
      deoptimizeArgumentsOnInteractionAtPath() {
      }
      getLiteralValueAtPath(path3) {
        if (path3.length > 0 || this.quasis.length !== 1) {
          return UnknownValue;
        }
        return this.quasis[0].value.cooked;
      }
      getReturnExpressionWhenCalledAtPath(path3) {
        if (path3.length !== 1) {
          return UNKNOWN_RETURN_EXPRESSION;
        }
        return getMemberReturnExpressionWhenCalled(literalStringMembers, path3[0]);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        if (interaction.type === INTERACTION_ACCESSED) {
          return path3.length > 1;
        }
        if (interaction.type === INTERACTION_CALLED && path3.length === 1) {
          return hasMemberEffectWhenCalled(literalStringMembers, path3[0], interaction, context8);
        }
        return true;
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        for (const node of this.expressions) {
          node.includePath(UNKNOWN_PATH, context8);
        }
      }
      render(code, options) {
        code.indentExclusionRanges.push([this.start, this.end]);
        super.render(code, options);
      }
    };
    ModuleScope = class extends ChildScope {
      constructor(parent, context8) {
        super(parent, context8);
        this.variables.set("this", new LocalVariable("this", null, UNDEFINED_EXPRESSION, EMPTY_PATH, context8, "other"));
      }
      addDeclaration(identifier4, context8, init2, destructuredInitPath, kind) {
        if (this.context.module.importDescriptions.has(identifier4.name)) {
          context8.error(logRedeclarationError(identifier4.name), identifier4.start);
        }
        return super.addDeclaration(identifier4, context8, init2, destructuredInitPath, kind);
      }
      addExportDefaultDeclaration(name, exportDefaultDeclaration3, context8) {
        const variable = new ExportDefaultVariable(name, exportDefaultDeclaration3, context8);
        this.variables.set("default", variable);
        return variable;
      }
      addNamespaceMemberAccess() {
      }
      deconflict(format5, exportNamesByVariable, accessedGlobalsByScope) {
        for (const scope5 of this.children)
          scope5.deconflict(format5, exportNamesByVariable, accessedGlobalsByScope);
      }
      findLexicalBoundary() {
        return this;
      }
      findVariable(name) {
        const knownVariable = this.variables.get(name) || this.accessedOutsideVariables.get(name);
        if (knownVariable) {
          return knownVariable;
        }
        const variable = this.context.traceVariable(name) || this.parent.findVariable(name);
        if (variable instanceof GlobalVariable) {
          this.accessedOutsideVariables.set(name, variable);
        }
        return variable;
      }
    };
    ThisExpression = class extends NodeBase {
      bind() {
        this.variable = this.scope.findVariable("this");
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker) {
        this.variable.deoptimizeArgumentsOnInteractionAtPath(interaction, path3, recursionTracker);
      }
      deoptimizePath(path3) {
        this.variable.deoptimizePath(path3);
      }
      hasEffectsOnInteractionAtPath(path3, interaction, context8) {
        if (path3.length === 0) {
          return interaction.type !== INTERACTION_ACCESSED;
        }
        return this.variable.hasEffectsOnInteractionAtPath(path3, interaction, context8);
      }
      include(context8) {
        if (!this.included)
          this.includeNode(context8);
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.scope.context.includeVariableInModule(this.variable, EMPTY_PATH, context8);
      }
      includePath(path3, context8) {
        if (!this.included) {
          this.included = true;
          this.scope.context.includeVariableInModule(this.variable, path3, context8);
        } else if (path3.length > 0) {
          this.variable.includePath(path3, context8);
        }
        const functionScope = findFunctionScope(this.scope, this.variable);
        if (functionScope && functionScope.functionNode.parent instanceof Property2 && functionScope.functionNode.parent.parent instanceof ObjectExpression2) {
          functionScope.functionNode.parent.parent.includePath(path3, context8);
        }
      }
      initialise() {
        super.initialise();
        this.alias = this.scope.findLexicalBoundary() instanceof ModuleScope ? this.scope.context.moduleContext : null;
        if (this.alias === "undefined") {
          this.scope.context.log(LOGLEVEL_WARN, logThisIsUndefined(), this.start);
        }
      }
      render(code) {
        if (this.alias !== null) {
          code.overwrite(this.start, this.end, this.alias, {
            contentOnly: false,
            storeName: true
          });
        }
      }
    };
    ThrowStatement = class extends NodeBase {
      hasEffects() {
        return true;
      }
      include(context8, includeChildrenRecursively) {
        if (!this.included)
          this.includeNode(context8);
        this.argument.include(context8, includeChildrenRecursively);
        context8.brokenFlow = true;
      }
      includeNode(context8) {
        if (!this.included) {
          this.included = true;
          this.argument.includePath(UNKNOWN_PATH, context8);
        }
      }
      render(code, options) {
        this.argument.render(code, options, { preventASI: true });
        if (this.argument.start === this.start + 5) {
          code.prependLeft(this.start + 5, " ");
        }
      }
    };
    TryStatement = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.directlyIncluded = false;
        this.includedLabelsAfterBlock = null;
      }
      hasEffects(context8) {
        return (this.scope.context.options.treeshake.tryCatchDeoptimization ? this.block.body.length > 0 : this.block.hasEffects(context8)) || !!this.finalizer?.hasEffects(context8);
      }
      include(context8, includeChildrenRecursively) {
        const tryCatchDeoptimization = this.scope.context.options.treeshake?.tryCatchDeoptimization;
        const { brokenFlow, includedLabels } = context8;
        if (!this.directlyIncluded || !tryCatchDeoptimization) {
          this.included = true;
          this.directlyIncluded = true;
          this.block.include(context8, tryCatchDeoptimization ? INCLUDE_PARAMETERS : includeChildrenRecursively);
          if (includedLabels.size > 0) {
            this.includedLabelsAfterBlock = [...includedLabels];
          }
          context8.brokenFlow = brokenFlow;
        } else if (this.includedLabelsAfterBlock) {
          for (const label of this.includedLabelsAfterBlock) {
            includedLabels.add(label);
          }
        }
        if (this.handler !== null) {
          this.handler.include(context8, includeChildrenRecursively);
          context8.brokenFlow = brokenFlow;
        }
        this.finalizer?.include(context8, includeChildrenRecursively);
      }
    };
    TryStatement.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    TryStatement.prototype.applyDeoptimizations = doNotDeoptimize;
    unaryOperators = {
      "!": (value) => !value,
      "+": (value) => +value,
      "-": (value) => -value,
      delete: () => UnknownValue,
      typeof: (value) => typeof value,
      void: () => void 0,
      "~": (value) => ~value
    };
    UNASSIGNED = Symbol("Unassigned");
    UnaryExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.renderedLiteralValue = UNASSIGNED;
      }
      get prefix() {
        return isFlagSet(
          this.flags,
          2097152
          /* Flag.prefix */
        );
      }
      set prefix(value) {
        this.flags = setFlag(this.flags, 2097152, value);
      }
      deoptimizeCache() {
        this.renderedLiteralValue = UnknownValue;
      }
      getLiteralValueAtPath(path3, recursionTracker, origin) {
        if (path3.length > 0)
          return UnknownValue;
        const argumentValue = this.argument.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
        if (typeof argumentValue === "symbol") {
          if (this.operator === "void")
            return void 0;
          if (this.operator === "!") {
            if (argumentValue === UnknownFalsyValue)
              return true;
            if (argumentValue === UnknownTruthyValue)
              return false;
          }
          return UnknownValue;
        }
        return unaryOperators[this.operator](argumentValue);
      }
      hasEffects(context8) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        if (this.operator === "typeof" && this.argument instanceof Identifier2)
          return false;
        return this.argument.hasEffects(context8) || this.operator === "delete" && this.argument.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, context8);
      }
      hasEffectsOnInteractionAtPath(path3, { type }) {
        return type !== INTERACTION_ACCESSED || path3.length > (this.operator === "void" ? 0 : 1);
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        if (this.operator === "delete") {
          this.argument.deoptimizePath(EMPTY_PATH);
          this.scope.context.requestTreeshakingPass();
        }
      }
      getRenderedLiteralValue(includeChildrenRecursively) {
        if (this.renderedLiteralValue !== UNASSIGNED)
          return this.renderedLiteralValue;
        return this.renderedLiteralValue = includeChildrenRecursively ? UnknownValue : getRenderedLiteralValue(this.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this));
      }
      include(context8, includeChildrenRecursively, _options) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.included = true;
        if (typeof this.getRenderedLiteralValue(includeChildrenRecursively) === "symbol" || this.argument.shouldBeIncluded(context8)) {
          this.argument.include(context8, includeChildrenRecursively);
          this.renderedLiteralValue = UnknownValue;
        }
      }
      render(code, options) {
        if (typeof this.renderedLiteralValue === "symbol") {
          super.render(code, options);
        } else {
          let value = this.renderedLiteralValue;
          if (!CHARACTERS_THAT_DO_NOT_REQUIRE_SPACE.test(code.original[this.start - 1])) {
            value = ` ${value}`;
          }
          code.overwrite(this.start, this.end, value);
        }
      }
    };
    CHARACTERS_THAT_DO_NOT_REQUIRE_SPACE = /[\s([=%&*+-/<>^|,?:;]/;
    UnaryExpression.prototype.includeNode = onlyIncludeSelf;
    UpdateExpression = class extends NodeBase {
      hasEffects(context8) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        return this.argument.hasEffectsAsAssignmentTarget(context8, true);
      }
      hasEffectsOnInteractionAtPath(path3, { type }) {
        return path3.length > 1 || type !== INTERACTION_ACCESSED;
      }
      include(context8, includeChildrenRecursively) {
        if (!this.included)
          this.includeNode(context8);
        this.argument.includeAsAssignmentTarget(context8, includeChildrenRecursively, true);
      }
      initialise() {
        super.initialise();
        this.argument.setAssignedValue(UNKNOWN_EXPRESSION);
      }
      render(code, options) {
        const { exportNamesByVariable, format: format5, snippets: { _: _2 } } = options;
        this.argument.render(code, options);
        if (format5 === "system") {
          const variable = this.argument.variable;
          const exportNames = exportNamesByVariable.get(variable);
          if (exportNames) {
            if (this.prefix) {
              if (exportNames.length === 1) {
                renderSystemExportExpression(variable, this.start, this.end, code, options);
              } else {
                renderSystemExportSequenceAfterExpression(variable, this.start, this.end, this.parent.type !== ExpressionStatement, code, options);
              }
            } else {
              const operator = this.operator[0];
              renderSystemExportSequenceBeforeExpression(variable, this.start, this.end, this.parent.type !== ExpressionStatement, code, options, `${_2}${operator}${_2}1`);
            }
          }
        }
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.argument.deoptimizePath(EMPTY_PATH);
        if (this.argument instanceof Identifier2) {
          const variable = this.scope.findVariable(this.argument.name);
          variable.markReassigned();
        }
        this.scope.context.requestTreeshakingPass();
      }
    };
    UpdateExpression.prototype.includeNode = onlyIncludeSelf;
    VariableDeclaration = class extends NodeBase {
      deoptimizePath() {
        for (const declarator of this.declarations) {
          declarator.deoptimizePath(EMPTY_PATH);
        }
      }
      hasEffectsOnInteractionAtPath() {
        return false;
      }
      include(context8, includeChildrenRecursively, { asSingleStatement } = BLANK) {
        this.included = true;
        for (const declarator of this.declarations) {
          if (includeChildrenRecursively || declarator.shouldBeIncluded(context8)) {
            declarator.include(context8, includeChildrenRecursively);
          }
          const { id: id2, init: init2 } = declarator;
          if (asSingleStatement) {
            id2.include(context8, includeChildrenRecursively);
          }
          if (init2 && id2.included && !init2.included && (id2 instanceof ObjectPattern || id2 instanceof ArrayPattern)) {
            init2.include(context8, includeChildrenRecursively);
          }
        }
      }
      initialise() {
        super.initialise();
        this.isUsingDeclaration = this.kind === "await using" || this.kind === "using";
        for (const declarator of this.declarations) {
          declarator.declareDeclarator(this.kind, this.isUsingDeclaration);
        }
      }
      removeAnnotations(code) {
        this.declarations[0].removeAnnotations(code);
      }
      render(code, options, nodeRenderOptions = BLANK) {
        if (this.isUsingDeclaration || areAllDeclarationsIncludedAndNotExported(this.declarations, options.exportNamesByVariable)) {
          for (const declarator of this.declarations) {
            declarator.render(code, options);
          }
          if (!nodeRenderOptions.isNoStatement && code.original.charCodeAt(this.end - 1) !== 59) {
            code.appendLeft(this.end, ";");
          }
        } else {
          this.renderReplacedDeclarations(code, options);
        }
      }
      renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, systemPatternExports, options) {
        if (code.original.charCodeAt(this.end - 1) === 59) {
          code.remove(this.end - 1, this.end);
        }
        separatorString += ";";
        if (lastSeparatorPos === null) {
          code.appendLeft(renderedContentEnd, separatorString);
        } else {
          if (code.original.charCodeAt(actualContentEnd - 1) === 10 && (code.original.charCodeAt(this.end) === 10 || code.original.charCodeAt(this.end) === 13)) {
            actualContentEnd--;
            if (code.original.charCodeAt(actualContentEnd) === 13) {
              actualContentEnd--;
            }
          }
          if (actualContentEnd === lastSeparatorPos + 1) {
            code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString);
          } else {
            code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
            code.remove(actualContentEnd, renderedContentEnd);
          }
        }
        if (systemPatternExports.length > 0) {
          code.appendLeft(renderedContentEnd, ` ${getSystemExportStatement(systemPatternExports, options)};`);
        }
      }
      renderReplacedDeclarations(code, options) {
        const separatedNodes = getCommaSeparatedNodesWithBoundaries(this.declarations, code, this.start + this.kind.length, this.end - (code.original.charCodeAt(this.end - 1) === 59 ? 1 : 0));
        let actualContentEnd, renderedContentEnd;
        renderedContentEnd = findNonWhiteSpace(code.original, this.start + this.kind.length);
        let lastSeparatorPos = renderedContentEnd - 1;
        code.remove(this.start, lastSeparatorPos);
        let isInDeclaration = false;
        let hasRenderedContent = false;
        let separatorString = "", leadingString, nextSeparatorString;
        const aggregatedSystemExports = [];
        const singleSystemExport = gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports);
        for (const { node, start: start3, separator, contentEnd, end: end6 } of separatedNodes) {
          if (!node.included) {
            treeshakeNode(node, code, start3, end6);
            continue;
          }
          node.render(code, options);
          leadingString = "";
          nextSeparatorString = "";
          if (!node.id.included || node.id instanceof Identifier2 && isReassignedExportsMember(node.id.variable, options.exportNamesByVariable)) {
            if (hasRenderedContent) {
              separatorString += ";";
            }
            isInDeclaration = false;
          } else {
            if (singleSystemExport && singleSystemExport === node.id.variable) {
              const operatorPos = findFirstOccurrenceOutsideComment(code.original, "=", node.id.end);
              renderSystemExportExpression(singleSystemExport, findNonWhiteSpace(code.original, operatorPos + 1), separator === null ? contentEnd : separator, code, options);
            }
            if (isInDeclaration) {
              separatorString += ",";
            } else {
              if (hasRenderedContent) {
                separatorString += ";";
              }
              leadingString += `${this.kind} `;
              isInDeclaration = true;
            }
          }
          if (renderedContentEnd === lastSeparatorPos + 1) {
            code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString + leadingString);
          } else {
            code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
            code.appendLeft(renderedContentEnd, leadingString);
          }
          actualContentEnd = contentEnd;
          renderedContentEnd = end6;
          hasRenderedContent = true;
          lastSeparatorPos = separator;
          separatorString = nextSeparatorString;
        }
        this.renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, aggregatedSystemExports, options);
      }
    };
    VariableDeclaration.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    VariableDeclaration.prototype.applyDeoptimizations = doNotDeoptimize;
    WhileStatement = class extends NodeBase {
      hasEffects(context8) {
        if (this.test.hasEffects(context8))
          return true;
        return hasLoopBodyEffects(context8, this.body);
      }
      include(context8, includeChildrenRecursively) {
        this.included = true;
        this.test.include(context8, includeChildrenRecursively);
        includeLoopBody(context8, this.body, includeChildrenRecursively);
      }
    };
    WhileStatement.prototype.includeNode = onlyIncludeSelfNoDeoptimize;
    WhileStatement.prototype.applyDeoptimizations = doNotDeoptimize;
    YieldExpression = class extends NodeBase {
      applyDeoptimizations() {
        this.deoptimized = true;
        this.argument?.deoptimizePath(UNKNOWN_PATH);
      }
      hasEffects(context8) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        return !(context8.ignore.returnYield && !this.argument?.hasEffects(context8));
      }
      includeNode(context8) {
        this.included = true;
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.argument?.includePath(UNKNOWN_PATH, context8);
      }
      render(code, options) {
        if (this.argument) {
          this.argument.render(code, options, { preventASI: true });
          if (this.argument.start === this.start + 5) {
            code.prependLeft(this.start + 5, " ");
          }
        }
      }
    };
    nodeTypeStrings = [
      "PanicError",
      "ParseError",
      "ArrayExpression",
      "ArrayPattern",
      "ArrowFunctionExpression",
      "AssignmentExpression",
      "AssignmentPattern",
      "AwaitExpression",
      "BinaryExpression",
      "BlockStatement",
      "BreakStatement",
      "CallExpression",
      "CatchClause",
      "ChainExpression",
      "ClassBody",
      "ClassDeclaration",
      "ClassExpression",
      "ConditionalExpression",
      "ContinueStatement",
      "DebuggerStatement",
      "Decorator",
      "ExpressionStatement",
      "DoWhileStatement",
      "EmptyStatement",
      "ExportAllDeclaration",
      "ExportDefaultDeclaration",
      "ExportNamedDeclaration",
      "ExportSpecifier",
      "ExpressionStatement",
      "ForInStatement",
      "ForOfStatement",
      "ForStatement",
      "FunctionDeclaration",
      "FunctionExpression",
      "Identifier",
      "IfStatement",
      "ImportAttribute",
      "ImportDeclaration",
      "ImportDefaultSpecifier",
      "ImportExpression",
      "ImportNamespaceSpecifier",
      "ImportSpecifier",
      "JSXAttribute",
      "JSXClosingElement",
      "JSXClosingFragment",
      "JSXElement",
      "JSXEmptyExpression",
      "JSXExpressionContainer",
      "JSXFragment",
      "JSXIdentifier",
      "JSXMemberExpression",
      "JSXNamespacedName",
      "JSXOpeningElement",
      "JSXOpeningFragment",
      "JSXSpreadAttribute",
      "JSXSpreadChild",
      "JSXText",
      "LabeledStatement",
      "Literal",
      "Literal",
      "Literal",
      "Literal",
      "Literal",
      "Literal",
      "LogicalExpression",
      "MemberExpression",
      "MetaProperty",
      "MethodDefinition",
      "NewExpression",
      "ObjectExpression",
      "ObjectPattern",
      "PrivateIdentifier",
      "Program",
      "Property",
      "PropertyDefinition",
      "RestElement",
      "ReturnStatement",
      "SequenceExpression",
      "SpreadElement",
      "StaticBlock",
      "Super",
      "SwitchCase",
      "SwitchStatement",
      "TaggedTemplateExpression",
      "TemplateElement",
      "TemplateLiteral",
      "ThisExpression",
      "ThrowStatement",
      "TryStatement",
      "UnaryExpression",
      "UpdateExpression",
      "VariableDeclaration",
      "VariableDeclarator",
      "WhileStatement",
      "YieldExpression"
    ];
    nodeConstructors$1 = [
      PanicError2,
      ParseError2,
      ArrayExpression,
      ArrayPattern,
      ArrowFunctionExpression2,
      AssignmentExpression,
      AssignmentPattern,
      AwaitExpression,
      BinaryExpression,
      BlockStatement2,
      BreakStatement,
      CallExpression2,
      CatchClause2,
      ChainExpression,
      ClassBody,
      ClassDeclaration,
      ClassExpression,
      ConditionalExpression,
      ContinueStatement,
      DebuggerStatement,
      Decorator,
      ExpressionStatement2,
      DoWhileStatement,
      EmptyStatement,
      ExportAllDeclaration,
      ExportDefaultDeclaration2,
      ExportNamedDeclaration,
      ExportSpecifier,
      ExpressionStatement2,
      ForInStatement,
      ForOfStatement,
      ForStatement,
      FunctionDeclaration,
      FunctionExpression,
      Identifier2,
      IfStatement,
      ImportAttribute,
      ImportDeclaration,
      ImportDefaultSpecifier,
      ImportExpression,
      ImportNamespaceSpecifier,
      ImportSpecifier,
      JSXAttribute,
      JSXClosingElement,
      JSXClosingFragment,
      JSXElement,
      JSXEmptyExpression,
      JSXExpressionContainer,
      JSXFragment,
      JSXIdentifier,
      JSXMemberExpression,
      JSXNamespacedName,
      JSXOpeningElement,
      JSXOpeningFragment,
      JSXSpreadAttribute,
      JSXSpreadChild,
      JSXText,
      LabeledStatement,
      Literal2,
      Literal2,
      Literal2,
      Literal2,
      Literal2,
      Literal2,
      LogicalExpression,
      MemberExpression,
      MetaProperty,
      MethodDefinition,
      NewExpression,
      ObjectExpression2,
      ObjectPattern,
      PrivateIdentifier,
      Program2,
      Property2,
      PropertyDefinition,
      RestElement2,
      ReturnStatement2,
      SequenceExpression,
      SpreadElement,
      StaticBlock2,
      Super,
      SwitchCase,
      SwitchStatement,
      TaggedTemplateExpression,
      TemplateElement,
      TemplateLiteral2,
      ThisExpression,
      ThrowStatement,
      TryStatement,
      UnaryExpression,
      UpdateExpression,
      VariableDeclaration,
      VariableDeclarator2,
      WhileStatement,
      YieldExpression
    ];
    bufferParsers = [
      function panicError2(node, position, buffer4) {
        node.message = buffer4.convertString(buffer4[position]);
      },
      function parseError2(node, position, buffer4) {
        node.message = buffer4.convertString(buffer4[position]);
      },
      function arrayExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.elements = convertNodeList2(node, scope5, buffer4[position], buffer4);
      },
      function arrayPattern2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.elements = convertNodeList2(node, scope5, buffer4[position], buffer4);
      },
      function arrowFunctionExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const flags = buffer4[position];
        node.async = (flags & 1) === 1;
        node.expression = (flags & 2) === 2;
        node.generator = (flags & 4) === 4;
        const annotations = node.annotations = convertAnnotations(buffer4[position + 1], buffer4);
        node.annotationNoSideEffects = annotations.some((comment) => comment.type === "noSideEffects");
        const parameters = node.params = convertNodeList2(node, scope5, buffer4[position + 2], buffer4);
        scope5.addParameterVariables(parameters.map((parameter) => parameter.declare("parameter", EMPTY_PATH, UNKNOWN_EXPRESSION)), parameters[parameters.length - 1] instanceof RestElement2);
        node.body = convertNode2(node, scope5.bodyScope, buffer4[position + 3], buffer4);
      },
      function assignmentExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.operator = FIXED_STRINGS[buffer4[position]];
        node.left = convertNode2(node, scope5, buffer4[position + 1], buffer4);
        node.right = convertNode2(node, scope5, buffer4[position + 2], buffer4);
      },
      function assignmentPattern2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.left = convertNode2(node, scope5, buffer4[position], buffer4);
        node.right = convertNode2(node, scope5, buffer4[position + 1], buffer4);
      },
      function awaitExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.argument = convertNode2(node, scope5, buffer4[position], buffer4);
      },
      function binaryExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.operator = FIXED_STRINGS[buffer4[position]];
        node.left = convertNode2(node, scope5, buffer4[position + 1], buffer4);
        node.right = convertNode2(node, scope5, buffer4[position + 2], buffer4);
      },
      function blockStatement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.body = convertNodeList2(node, scope5, buffer4[position], buffer4);
      },
      function breakStatement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const labelPosition = buffer4[position];
        node.label = labelPosition === 0 ? null : convertNode2(node, scope5, labelPosition, buffer4);
      },
      function callExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const flags = buffer4[position];
        node.optional = (flags & 1) === 1;
        node.annotations = convertAnnotations(buffer4[position + 1], buffer4);
        node.callee = convertNode2(node, scope5, buffer4[position + 2], buffer4);
        node.arguments = convertNodeList2(node, scope5, buffer4[position + 3], buffer4);
      },
      function catchClause2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const parameterPosition = buffer4[position];
        const parameter = node.param = parameterPosition === 0 ? null : convertNode2(node, scope5, parameterPosition, buffer4);
        parameter?.declare("parameter", EMPTY_PATH, UNKNOWN_EXPRESSION);
        node.body = convertNode2(node, scope5.bodyScope, buffer4[position + 1], buffer4);
      },
      function chainExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.expression = convertNode2(node, scope5, buffer4[position], buffer4);
      },
      function classBody2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const bodyPosition = buffer4[position];
        if (bodyPosition) {
          const length3 = buffer4[bodyPosition];
          const body = node.body = new Array(length3);
          for (let index = 0; index < length3; index++) {
            const nodePosition = buffer4[bodyPosition + 1 + index];
            body[index] = convertNode2(node, (buffer4[nodePosition + 3] & 1) === 0 ? scope5.instanceScope : scope5, nodePosition, buffer4);
          }
        } else {
          node.body = [];
        }
      },
      function classDeclaration2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.decorators = convertNodeList2(node, scope5, buffer4[position], buffer4);
        const idPosition = buffer4[position + 1];
        node.id = idPosition === 0 ? null : convertNode2(node, scope5.parent, idPosition, buffer4);
        const superClassPosition = buffer4[position + 2];
        node.superClass = superClassPosition === 0 ? null : convertNode2(node, scope5, superClassPosition, buffer4);
        node.body = convertNode2(node, scope5, buffer4[position + 3], buffer4);
      },
      function classExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.decorators = convertNodeList2(node, scope5, buffer4[position], buffer4);
        const idPosition = buffer4[position + 1];
        node.id = idPosition === 0 ? null : convertNode2(node, scope5, idPosition, buffer4);
        const superClassPosition = buffer4[position + 2];
        node.superClass = superClassPosition === 0 ? null : convertNode2(node, scope5, superClassPosition, buffer4);
        node.body = convertNode2(node, scope5, buffer4[position + 3], buffer4);
      },
      function conditionalExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.test = convertNode2(node, scope5, buffer4[position], buffer4);
        node.consequent = convertNode2(node, scope5, buffer4[position + 1], buffer4);
        node.alternate = convertNode2(node, scope5, buffer4[position + 2], buffer4);
      },
      function continueStatement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const labelPosition = buffer4[position];
        node.label = labelPosition === 0 ? null : convertNode2(node, scope5, labelPosition, buffer4);
      },
      function debuggerStatement2() {
      },
      function decorator2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.expression = convertNode2(node, scope5, buffer4[position], buffer4);
      },
      function directive2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.directive = buffer4.convertString(buffer4[position]);
        node.expression = convertNode2(node, scope5, buffer4[position + 1], buffer4);
      },
      function doWhileStatement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.body = convertNode2(node, scope5, buffer4[position], buffer4);
        node.test = convertNode2(node, scope5, buffer4[position + 1], buffer4);
      },
      function emptyStatement2() {
      },
      function exportAllDeclaration2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const exportedPosition = buffer4[position];
        node.exported = exportedPosition === 0 ? null : convertNode2(node, scope5, exportedPosition, buffer4);
        node.source = convertNode2(node, scope5, buffer4[position + 1], buffer4);
        node.attributes = convertNodeList2(node, scope5, buffer4[position + 2], buffer4);
      },
      function exportDefaultDeclaration2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.declaration = convertNode2(node, scope5, buffer4[position], buffer4);
      },
      function exportNamedDeclaration2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.specifiers = convertNodeList2(node, scope5, buffer4[position], buffer4);
        const sourcePosition = buffer4[position + 1];
        node.source = sourcePosition === 0 ? null : convertNode2(node, scope5, sourcePosition, buffer4);
        node.attributes = convertNodeList2(node, scope5, buffer4[position + 2], buffer4);
        const declarationPosition = buffer4[position + 3];
        node.declaration = declarationPosition === 0 ? null : convertNode2(node, scope5, declarationPosition, buffer4);
      },
      function exportSpecifier2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.local = convertNode2(node, scope5, buffer4[position], buffer4);
        const exportedPosition = buffer4[position + 1];
        node.exported = exportedPosition === 0 ? node.local : convertNode2(node, scope5, exportedPosition, buffer4);
      },
      function expressionStatement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.expression = convertNode2(node, scope5, buffer4[position], buffer4);
      },
      function forInStatement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.left = convertNode2(node, scope5, buffer4[position], buffer4);
        node.right = convertNode2(node, scope5, buffer4[position + 1], buffer4);
        node.body = convertNode2(node, scope5, buffer4[position + 2], buffer4);
      },
      function forOfStatement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const flags = buffer4[position];
        node.await = (flags & 1) === 1;
        node.left = convertNode2(node, scope5, buffer4[position + 1], buffer4);
        node.right = convertNode2(node, scope5, buffer4[position + 2], buffer4);
        node.body = convertNode2(node, scope5, buffer4[position + 3], buffer4);
      },
      function forStatement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const initPosition = buffer4[position];
        node.init = initPosition === 0 ? null : convertNode2(node, scope5, initPosition, buffer4);
        const testPosition = buffer4[position + 1];
        node.test = testPosition === 0 ? null : convertNode2(node, scope5, testPosition, buffer4);
        const updatePosition = buffer4[position + 2];
        node.update = updatePosition === 0 ? null : convertNode2(node, scope5, updatePosition, buffer4);
        node.body = convertNode2(node, scope5, buffer4[position + 3], buffer4);
      },
      function functionDeclaration2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const flags = buffer4[position];
        node.async = (flags & 1) === 1;
        node.generator = (flags & 2) === 2;
        const annotations = node.annotations = convertAnnotations(buffer4[position + 1], buffer4);
        node.annotationNoSideEffects = annotations.some((comment) => comment.type === "noSideEffects");
        const idPosition = buffer4[position + 2];
        node.id = idPosition === 0 ? null : convertNode2(node, scope5.parent, idPosition, buffer4);
        const parameters = node.params = convertNodeList2(node, scope5, buffer4[position + 3], buffer4);
        scope5.addParameterVariables(parameters.map((parameter) => parameter.declare("parameter", EMPTY_PATH, UNKNOWN_EXPRESSION)), parameters[parameters.length - 1] instanceof RestElement2);
        node.body = convertNode2(node, scope5.bodyScope, buffer4[position + 4], buffer4);
      },
      function functionExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const flags = buffer4[position];
        node.async = (flags & 1) === 1;
        node.generator = (flags & 2) === 2;
        const annotations = node.annotations = convertAnnotations(buffer4[position + 1], buffer4);
        node.annotationNoSideEffects = annotations.some((comment) => comment.type === "noSideEffects");
        const idPosition = buffer4[position + 2];
        node.id = idPosition === 0 ? null : convertNode2(node, node.idScope, idPosition, buffer4);
        const parameters = node.params = convertNodeList2(node, scope5, buffer4[position + 3], buffer4);
        scope5.addParameterVariables(parameters.map((parameter) => parameter.declare("parameter", EMPTY_PATH, UNKNOWN_EXPRESSION)), parameters[parameters.length - 1] instanceof RestElement2);
        node.body = convertNode2(node, scope5.bodyScope, buffer4[position + 4], buffer4);
      },
      function identifier3(node, position, buffer4) {
        node.name = buffer4.convertString(buffer4[position]);
      },
      function ifStatement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.test = convertNode2(node, scope5, buffer4[position], buffer4);
        node.consequent = convertNode2(node, node.consequentScope = new TrackingScope(scope5), buffer4[position + 1], buffer4);
        const alternatePosition = buffer4[position + 2];
        node.alternate = alternatePosition === 0 ? null : convertNode2(node, node.alternateScope = new TrackingScope(scope5), alternatePosition, buffer4);
      },
      function importAttribute2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.key = convertNode2(node, scope5, buffer4[position], buffer4);
        node.value = convertNode2(node, scope5, buffer4[position + 1], buffer4);
      },
      function importDeclaration2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.specifiers = convertNodeList2(node, scope5, buffer4[position], buffer4);
        node.source = convertNode2(node, scope5, buffer4[position + 1], buffer4);
        node.attributes = convertNodeList2(node, scope5, buffer4[position + 2], buffer4);
      },
      function importDefaultSpecifier2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.local = convertNode2(node, scope5, buffer4[position], buffer4);
      },
      function importExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.source = convertNode2(node, scope5, buffer4[position], buffer4);
        node.sourceAstNode = convertNode(buffer4[position], buffer4);
        const optionsPosition = buffer4[position + 1];
        node.options = optionsPosition === 0 ? null : convertNode2(node, scope5, optionsPosition, buffer4);
      },
      function importNamespaceSpecifier2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.local = convertNode2(node, scope5, buffer4[position], buffer4);
      },
      function importSpecifier2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const importedPosition = buffer4[position];
        node.local = convertNode2(node, scope5, buffer4[position + 1], buffer4);
        node.imported = importedPosition === 0 ? node.local : convertNode2(node, scope5, importedPosition, buffer4);
      },
      function jsxAttribute2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.name = convertNode2(node, scope5, buffer4[position], buffer4);
        const valuePosition = buffer4[position + 1];
        node.value = valuePosition === 0 ? null : convertNode2(node, scope5, valuePosition, buffer4);
      },
      function jsxClosingElement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.name = convertNode2(node, scope5, buffer4[position], buffer4);
      },
      function jsxClosingFragment2() {
      },
      function jsxElement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.openingElement = convertNode2(node, scope5, buffer4[position], buffer4);
        node.children = convertNodeList2(node, scope5, buffer4[position + 1], buffer4);
        const closingElementPosition = buffer4[position + 2];
        node.closingElement = closingElementPosition === 0 ? null : convertNode2(node, scope5, closingElementPosition, buffer4);
      },
      function jsxEmptyExpression2() {
      },
      function jsxExpressionContainer2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.expression = convertNode2(node, scope5, buffer4[position], buffer4);
      },
      function jsxFragment2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.openingFragment = convertNode2(node, scope5, buffer4[position], buffer4);
        node.children = convertNodeList2(node, scope5, buffer4[position + 1], buffer4);
        node.closingFragment = convertNode2(node, scope5, buffer4[position + 2], buffer4);
      },
      function jsxIdentifier2(node, position, buffer4) {
        node.name = buffer4.convertString(buffer4[position]);
      },
      function jsxMemberExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.object = convertNode2(node, scope5, buffer4[position], buffer4);
        node.property = convertNode2(node, scope5, buffer4[position + 1], buffer4);
      },
      function jsxNamespacedName2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.namespace = convertNode2(node, scope5, buffer4[position], buffer4);
        node.name = convertNode2(node, scope5, buffer4[position + 1], buffer4);
      },
      function jsxOpeningElement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const flags = buffer4[position];
        node.selfClosing = (flags & 1) === 1;
        node.name = convertNode2(node, scope5, buffer4[position + 1], buffer4);
        node.attributes = convertNodeList2(node, scope5, buffer4[position + 2], buffer4);
      },
      function jsxOpeningFragment2(node) {
        node.attributes = [];
        node.selfClosing = false;
      },
      function jsxSpreadAttribute2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.argument = convertNode2(node, scope5, buffer4[position], buffer4);
      },
      function jsxSpreadChild2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.expression = convertNode2(node, scope5, buffer4[position], buffer4);
      },
      function jsxText2(node, position, buffer4) {
        node.value = buffer4.convertString(buffer4[position]);
        node.raw = buffer4.convertString(buffer4[position + 1]);
      },
      function labeledStatement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.label = convertNode2(node, scope5, buffer4[position], buffer4);
        node.body = convertNode2(node, scope5, buffer4[position + 1], buffer4);
      },
      function literalBigInt2(node, position, buffer4) {
        const bigint = node.bigint = buffer4.convertString(buffer4[position]);
        node.raw = buffer4.convertString(buffer4[position + 1]);
        node.value = BigInt(bigint);
      },
      function literalBoolean2(node, position, buffer4) {
        const flags = buffer4[position];
        const value = node.value = (flags & 1) === 1;
        node.raw = value ? "true" : "false";
      },
      function literalNull2(node) {
        node.value = null;
      },
      function literalNumber2(node, position, buffer4) {
        const rawPosition = buffer4[position];
        node.raw = rawPosition === 0 ? void 0 : buffer4.convertString(rawPosition);
        node.value = new DataView(buffer4.buffer).getFloat64(position + 1 << 2, true);
      },
      function literalRegExp2(node, position, buffer4) {
        const flags = buffer4.convertString(buffer4[position]);
        const pattern = buffer4.convertString(buffer4[position + 1]);
        node.raw = `/${pattern}/${flags}`;
        node.regex = { flags, pattern };
        node.value = new RegExp(pattern, flags);
      },
      function literalString2(node, position, buffer4) {
        node.value = buffer4.convertString(buffer4[position]);
        const rawPosition = buffer4[position + 1];
        node.raw = rawPosition === 0 ? void 0 : buffer4.convertString(rawPosition);
      },
      function logicalExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.operator = FIXED_STRINGS[buffer4[position]];
        node.left = convertNode2(node, scope5, buffer4[position + 1], buffer4);
        node.right = convertNode2(node, scope5, buffer4[position + 2], buffer4);
      },
      function memberExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const flags = buffer4[position];
        node.computed = (flags & 1) === 1;
        node.optional = (flags & 2) === 2;
        node.object = convertNode2(node, scope5, buffer4[position + 1], buffer4);
        node.property = convertNode2(node, scope5, buffer4[position + 2], buffer4);
      },
      function metaProperty2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.meta = convertNode2(node, scope5, buffer4[position], buffer4);
        node.property = convertNode2(node, scope5, buffer4[position + 1], buffer4);
      },
      function methodDefinition2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const flags = buffer4[position];
        node.static = (flags & 1) === 1;
        node.computed = (flags & 2) === 2;
        node.decorators = convertNodeList2(node, scope5, buffer4[position + 1], buffer4);
        node.key = convertNode2(node, scope5, buffer4[position + 2], buffer4);
        node.value = convertNode2(node, scope5, buffer4[position + 3], buffer4);
        node.kind = FIXED_STRINGS[buffer4[position + 4]];
      },
      function newExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.annotations = convertAnnotations(buffer4[position], buffer4);
        node.callee = convertNode2(node, scope5, buffer4[position + 1], buffer4);
        node.arguments = convertNodeList2(node, scope5, buffer4[position + 2], buffer4);
      },
      function objectExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.properties = convertNodeList2(node, scope5, buffer4[position], buffer4);
      },
      function objectPattern2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.properties = convertNodeList2(node, scope5, buffer4[position], buffer4);
      },
      function privateIdentifier2(node, position, buffer4) {
        node.name = buffer4.convertString(buffer4[position]);
      },
      function program2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.body = convertNodeList2(node, scope5, buffer4[position], buffer4);
        node.invalidAnnotations = convertAnnotations(buffer4[position + 1], buffer4);
      },
      function property2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const flags = buffer4[position];
        node.method = (flags & 1) === 1;
        node.shorthand = (flags & 2) === 2;
        node.computed = (flags & 4) === 4;
        const keyPosition = buffer4[position + 1];
        node.value = convertNode2(node, scope5, buffer4[position + 2], buffer4);
        node.kind = FIXED_STRINGS[buffer4[position + 3]];
        node.key = keyPosition === 0 ? node.value : convertNode2(node, scope5, keyPosition, buffer4);
      },
      function propertyDefinition2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const flags = buffer4[position];
        node.static = (flags & 1) === 1;
        node.computed = (flags & 2) === 2;
        node.decorators = convertNodeList2(node, scope5, buffer4[position + 1], buffer4);
        node.key = convertNode2(node, scope5, buffer4[position + 2], buffer4);
        const valuePosition = buffer4[position + 3];
        node.value = valuePosition === 0 ? null : convertNode2(node, scope5, valuePosition, buffer4);
      },
      function restElement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.argument = convertNode2(node, scope5, buffer4[position], buffer4);
      },
      function returnStatement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const argumentPosition = buffer4[position];
        node.argument = argumentPosition === 0 ? null : convertNode2(node, scope5, argumentPosition, buffer4);
      },
      function sequenceExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.expressions = convertNodeList2(node, scope5, buffer4[position], buffer4);
      },
      function spreadElement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.argument = convertNode2(node, scope5, buffer4[position], buffer4);
      },
      function staticBlock2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.body = convertNodeList2(node, scope5, buffer4[position], buffer4);
      },
      function superElement2() {
      },
      function switchCase2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const testPosition = buffer4[position];
        node.test = testPosition === 0 ? null : convertNode2(node, scope5, testPosition, buffer4);
        node.consequent = convertNodeList2(node, scope5, buffer4[position + 1], buffer4);
      },
      function switchStatement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.discriminant = convertNode2(node, node.parentScope, buffer4[position], buffer4);
        node.cases = convertNodeList2(node, scope5, buffer4[position + 1], buffer4);
      },
      function taggedTemplateExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.tag = convertNode2(node, scope5, buffer4[position], buffer4);
        node.quasi = convertNode2(node, scope5, buffer4[position + 1], buffer4);
      },
      function templateElement2(node, position, buffer4) {
        const flags = buffer4[position];
        node.tail = (flags & 1) === 1;
        const cookedPosition = buffer4[position + 1];
        const cooked = cookedPosition === 0 ? void 0 : buffer4.convertString(cookedPosition);
        const raw = buffer4.convertString(buffer4[position + 2]);
        node.value = { cooked, raw };
      },
      function templateLiteral2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.quasis = convertNodeList2(node, scope5, buffer4[position], buffer4);
        node.expressions = convertNodeList2(node, scope5, buffer4[position + 1], buffer4);
      },
      function thisExpression2() {
      },
      function throwStatement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.argument = convertNode2(node, scope5, buffer4[position], buffer4);
      },
      function tryStatement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.block = convertNode2(node, scope5, buffer4[position], buffer4);
        const handlerPosition = buffer4[position + 1];
        node.handler = handlerPosition === 0 ? null : convertNode2(node, scope5, handlerPosition, buffer4);
        const finalizerPosition = buffer4[position + 2];
        node.finalizer = finalizerPosition === 0 ? null : convertNode2(node, scope5, finalizerPosition, buffer4);
      },
      function unaryExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.operator = FIXED_STRINGS[buffer4[position]];
        node.argument = convertNode2(node, scope5, buffer4[position + 1], buffer4);
      },
      function updateExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const flags = buffer4[position];
        node.prefix = (flags & 1) === 1;
        node.operator = FIXED_STRINGS[buffer4[position + 1]];
        node.argument = convertNode2(node, scope5, buffer4[position + 2], buffer4);
      },
      function variableDeclaration2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.kind = FIXED_STRINGS[buffer4[position]];
        node.declarations = convertNodeList2(node, scope5, buffer4[position + 1], buffer4);
      },
      function variableDeclarator2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.id = convertNode2(node, scope5, buffer4[position], buffer4);
        const initPosition = buffer4[position + 1];
        node.init = initPosition === 0 ? null : convertNode2(node, scope5, initPosition, buffer4);
      },
      function whileStatement2(node, position, buffer4) {
        const { scope: scope5 } = node;
        node.test = convertNode2(node, scope5, buffer4[position], buffer4);
        node.body = convertNode2(node, scope5, buffer4[position + 1], buffer4);
      },
      function yieldExpression2(node, position, buffer4) {
        const { scope: scope5 } = node;
        const flags = buffer4[position];
        node.delegate = (flags & 1) === 1;
        const argumentPosition = buffer4[position + 1];
        node.argument = argumentPosition === 0 ? null : convertNode2(node, scope5, argumentPosition, buffer4);
      }
    ];
    UnknownNode = class extends NodeBase {
      hasEffects() {
        return true;
      }
      include(context8) {
        super.include(context8, true);
      }
    };
    nodeConstructors = {
      ArrayExpression,
      ArrayPattern,
      ArrowFunctionExpression: ArrowFunctionExpression2,
      AssignmentExpression,
      AssignmentPattern,
      AwaitExpression,
      BinaryExpression,
      BlockStatement: BlockStatement2,
      BreakStatement,
      CallExpression: CallExpression2,
      CatchClause: CatchClause2,
      ChainExpression,
      ClassBody,
      ClassDeclaration,
      ClassExpression,
      ConditionalExpression,
      ContinueStatement,
      DebuggerStatement,
      Decorator,
      DoWhileStatement,
      EmptyStatement,
      ExportAllDeclaration,
      ExportDefaultDeclaration: ExportDefaultDeclaration2,
      ExportNamedDeclaration,
      ExportSpecifier,
      ExpressionStatement: ExpressionStatement2,
      ForInStatement,
      ForOfStatement,
      ForStatement,
      FunctionDeclaration,
      FunctionExpression,
      Identifier: Identifier2,
      IfStatement,
      ImportAttribute,
      ImportDeclaration,
      ImportDefaultSpecifier,
      ImportExpression,
      ImportNamespaceSpecifier,
      ImportSpecifier,
      JSXAttribute,
      JSXClosingElement,
      JSXClosingFragment,
      JSXElement,
      JSXEmptyExpression,
      JSXExpressionContainer,
      JSXFragment,
      JSXIdentifier,
      JSXMemberExpression,
      JSXNamespacedName,
      JSXOpeningElement,
      JSXOpeningFragment,
      JSXSpreadAttribute,
      JSXSpreadChild,
      JSXText,
      LabeledStatement,
      Literal: Literal2,
      LogicalExpression,
      MemberExpression,
      MetaProperty,
      MethodDefinition,
      NewExpression,
      ObjectExpression: ObjectExpression2,
      ObjectPattern,
      PanicError: PanicError2,
      ParseError: ParseError2,
      PrivateIdentifier,
      Program: Program2,
      Property: Property2,
      PropertyDefinition,
      RestElement: RestElement2,
      ReturnStatement: ReturnStatement2,
      SequenceExpression,
      SpreadElement,
      StaticBlock: StaticBlock2,
      Super,
      SwitchCase,
      SwitchStatement,
      TaggedTemplateExpression,
      TemplateElement,
      TemplateLiteral: TemplateLiteral2,
      ThisExpression,
      ThrowStatement,
      TryStatement,
      UnaryExpression,
      UnknownNode,
      UpdateExpression,
      VariableDeclaration,
      VariableDeclarator: VariableDeclarator2,
      WhileStatement,
      YieldExpression
    };
    ExportShimVariable = class extends Variable {
      constructor(module) {
        super(MISSING_EXPORT_SHIM_VARIABLE);
        this.module = module;
      }
      includePath(path3, context8) {
        super.includePath(path3, context8);
        this.module.needsExportShim = true;
      }
    };
    (function(BuildPhase2) {
      BuildPhase2[BuildPhase2["LOAD_AND_PARSE"] = 0] = "LOAD_AND_PARSE";
      BuildPhase2[BuildPhase2["ANALYSE"] = 1] = "ANALYSE";
      BuildPhase2[BuildPhase2["GENERATE"] = 2] = "GENERATE";
    })(BuildPhase || (BuildPhase = {}));
    sourceMapCache = /* @__PURE__ */ new WeakMap();
    ATTRIBUTE_KEYWORDS = /* @__PURE__ */ new Set(["assert", "with"]);
    getPropertyKey = (property3) => {
      const key = property3.key;
      return key && !property3.computed && (key.name || key.value);
    };
    timers = /* @__PURE__ */ new Map();
    timeStart = doNothing;
    timeEnd = doNothing;
    TIMED_PLUGIN_HOOKS = [
      "augmentChunkHash",
      "buildEnd",
      "buildStart",
      "generateBundle",
      "load",
      "moduleParsed",
      "options",
      "outputOptions",
      "renderChunk",
      "renderDynamicImport",
      "renderStart",
      "resolveDynamicImport",
      "resolveFileUrl",
      "resolveId",
      "resolveImportMeta",
      "shouldTransformCachedModule",
      "transform",
      "writeBundle"
    ];
    MISSING_EXPORT_SHIM_DESCRIPTION = {
      identifier: null,
      localName: MISSING_EXPORT_SHIM_VARIABLE
    };
    Module = class _Module {
      constructor(graph, id2, options, isEntry, moduleSideEffects, syntheticNamedExports, meta, attributes) {
        this.graph = graph;
        this.id = id2;
        this.options = options;
        this.alternativeReexportModules = /* @__PURE__ */ new Map();
        this.chunkFileNames = /* @__PURE__ */ new Set();
        this.chunkNames = [];
        this.cycles = /* @__PURE__ */ new Set();
        this.dependencies = /* @__PURE__ */ new Set();
        this.dynamicDependencies = /* @__PURE__ */ new Set();
        this.dynamicImporters = [];
        this.dynamicImports = [];
        this.execIndex = Infinity;
        this.hasTreeShakingPassStarted = false;
        this.implicitlyLoadedAfter = /* @__PURE__ */ new Set();
        this.implicitlyLoadedBefore = /* @__PURE__ */ new Set();
        this.importDescriptions = /* @__PURE__ */ new Map();
        this.importMetas = [];
        this.importedFromNotTreeshaken = false;
        this.importers = [];
        this.includedDynamicImporters = [];
        this.includedDirectTopLevelAwaitingDynamicImporters = /* @__PURE__ */ new Set();
        this.includedImports = /* @__PURE__ */ new Set();
        this.isExecuted = false;
        this.isUserDefinedEntryPoint = false;
        this.needsExportShim = false;
        this.sideEffectDependenciesByVariable = /* @__PURE__ */ new Map();
        this.sourcesWithAttributes = /* @__PURE__ */ new Map();
        this.allExportNames = null;
        this.allExportsIncluded = false;
        this.ast = null;
        this.exportAllModules = [];
        this.exportAllSources = /* @__PURE__ */ new Set();
        this.exportNamesByVariable = null;
        this.exportShimVariable = new ExportShimVariable(this);
        this.exports = /* @__PURE__ */ new Map();
        this.namespaceReexportsByName = /* @__PURE__ */ new Map();
        this.reexportDescriptions = /* @__PURE__ */ new Map();
        this.relevantDependencies = null;
        this.syntheticExports = /* @__PURE__ */ new Map();
        this.syntheticNamespace = null;
        this.transformDependencies = [];
        this.transitiveReexports = null;
        this.excludeFromSourcemap = /\0/.test(id2);
        this.context = options.moduleContext(id2);
        this.preserveSignature = this.options.preserveEntrySignatures;
        const module = this;
        const { dynamicImports, dynamicImporters, exportAllSources, exports, implicitlyLoadedAfter, implicitlyLoadedBefore, importers, reexportDescriptions, sourcesWithAttributes } = this;
        this.info = {
          ast: null,
          attributes,
          code: null,
          get dynamicallyImportedIdResolutions() {
            return dynamicImports.map(({ argument }) => typeof argument === "string" && module.resolvedIds[argument]).filter(Boolean);
          },
          get dynamicallyImportedIds() {
            return dynamicImports.map(({ id: id3 }) => id3).filter((id3) => id3 != null);
          },
          get dynamicImporters() {
            return dynamicImporters.sort();
          },
          get exportedBindings() {
            const exportBindings = { ".": [...exports.keys()] };
            for (const [name, { source }] of reexportDescriptions) {
              (exportBindings[source] ??= []).push(name);
            }
            for (const source of exportAllSources) {
              (exportBindings[source] ??= []).push("*");
            }
            return exportBindings;
          },
          get exports() {
            return [
              ...exports.keys(),
              ...reexportDescriptions.keys(),
              ...[...exportAllSources].map(() => "*")
            ];
          },
          get hasDefaultExport() {
            if (!module.ast) {
              return null;
            }
            return module.exports.has("default") || reexportDescriptions.has("default");
          },
          id: id2,
          get implicitlyLoadedAfterOneOf() {
            return Array.from(implicitlyLoadedAfter, getId).sort();
          },
          get implicitlyLoadedBefore() {
            return Array.from(implicitlyLoadedBefore, getId).sort();
          },
          get importedIdResolutions() {
            return Array.from(sourcesWithAttributes.keys(), (source) => module.resolvedIds[source]).filter(Boolean);
          },
          get importedIds() {
            return Array.from(sourcesWithAttributes.keys(), (source) => module.resolvedIds[source]?.id).filter(Boolean);
          },
          get importers() {
            return importers.sort();
          },
          isEntry,
          isExternal: false,
          get isIncluded() {
            if (graph.phase !== BuildPhase.GENERATE) {
              return null;
            }
            return module.isIncluded();
          },
          meta: { ...meta },
          moduleSideEffects,
          syntheticNamedExports
        };
      }
      basename() {
        const base2 = p2.basename(this.id);
        const extension = p2.extname(this.id);
        return makeLegal(extension ? base2.slice(0, -extension.length) : base2);
      }
      bindReferences() {
        this.ast.bind();
      }
      cacheInfoGetters() {
        cacheObjectGetters(this.info, [
          "dynamicallyImportedIdResolutions",
          "dynamicallyImportedIds",
          "dynamicImporters",
          "exportedBindings",
          "exports",
          "hasDefaultExport",
          "implicitlyLoadedAfterOneOf",
          "implicitlyLoadedBefore",
          "importedIdResolutions",
          "importedIds",
          "importers"
        ]);
      }
      error(properties, pos) {
        if (pos !== void 0) {
          this.addLocationToLogProps(properties, pos);
        }
        return error3(properties);
      }
      // sum up the length of all ast nodes that are included
      estimateSize() {
        let size16 = 0;
        for (const node of this.ast.body) {
          if (node.included) {
            size16 += node.end - node.start;
          }
        }
        return size16;
      }
      getAllExportNames() {
        if (this.allExportNames) {
          return this.allExportNames;
        }
        this.allExportNames = /* @__PURE__ */ new Set([...this.exports.keys(), ...this.reexportDescriptions.keys()]);
        for (const module of this.exportAllModules) {
          if (module instanceof ExternalModule) {
            this.allExportNames.add(`*${module.id}`);
            continue;
          }
          for (const name of module.getAllExportNames()) {
            if (name !== "default")
              this.allExportNames.add(name);
          }
        }
        if (typeof this.info.syntheticNamedExports === "string") {
          this.allExportNames.delete(this.info.syntheticNamedExports);
        }
        return this.allExportNames;
      }
      getDependenciesToBeIncluded() {
        if (this.relevantDependencies)
          return this.relevantDependencies;
        this.relevantDependencies = /* @__PURE__ */ new Set();
        const necessaryDependencies = /* @__PURE__ */ new Set();
        const alwaysCheckedDependencies = /* @__PURE__ */ new Set();
        const dependencyVariables = new Set(this.includedImports);
        if (this.info.isEntry || this.includedDynamicImporters.length > 0 || this.namespace.included || this.implicitlyLoadedAfter.size > 0) {
          for (const exportName of [...this.getReexports(), ...this.getExports()]) {
            const [exportedVariable] = this.getVariableForExportName(exportName);
            if (exportedVariable?.included) {
              dependencyVariables.add(exportedVariable);
            }
          }
        }
        for (let variable of dependencyVariables) {
          const sideEffectDependencies = this.sideEffectDependenciesByVariable.get(variable);
          if (sideEffectDependencies) {
            for (const module of sideEffectDependencies) {
              alwaysCheckedDependencies.add(module);
            }
          }
          if (variable instanceof SyntheticNamedExportVariable) {
            variable = variable.getBaseVariable();
          } else if (variable instanceof ExportDefaultVariable) {
            variable = variable.getOriginalVariable();
          }
          necessaryDependencies.add(variable.module);
        }
        if (!this.options.treeshake || this.info.moduleSideEffects === "no-treeshake") {
          for (const dependency of this.dependencies) {
            this.relevantDependencies.add(dependency);
          }
        } else {
          this.addRelevantSideEffectDependencies(this.relevantDependencies, necessaryDependencies, alwaysCheckedDependencies);
        }
        for (const dependency of necessaryDependencies) {
          this.relevantDependencies.add(dependency);
        }
        return this.relevantDependencies;
      }
      getExportNamesByVariable() {
        if (this.exportNamesByVariable) {
          return this.exportNamesByVariable;
        }
        const exportNamesByVariable = /* @__PURE__ */ new Map();
        for (const exportName of this.getAllExportNames()) {
          let [tracedVariable] = this.getVariableForExportName(exportName);
          if (tracedVariable instanceof ExportDefaultVariable) {
            tracedVariable = tracedVariable.getOriginalVariable();
          }
          if (!tracedVariable || !(tracedVariable.included || tracedVariable instanceof ExternalVariable)) {
            continue;
          }
          const existingExportNames = exportNamesByVariable.get(tracedVariable);
          if (existingExportNames) {
            existingExportNames.push(exportName);
          } else {
            exportNamesByVariable.set(tracedVariable, [exportName]);
          }
        }
        return this.exportNamesByVariable = exportNamesByVariable;
      }
      getExports() {
        return [...this.exports.keys()];
      }
      getReexports() {
        if (this.transitiveReexports) {
          return this.transitiveReexports;
        }
        this.transitiveReexports = [];
        const reexports = new Set(this.reexportDescriptions.keys());
        for (const module of this.exportAllModules) {
          if (module instanceof ExternalModule) {
            reexports.add(`*${module.id}`);
          } else {
            for (const name of [...module.getReexports(), ...module.getExports()]) {
              if (name !== "default")
                reexports.add(name);
            }
          }
        }
        return this.transitiveReexports = [...reexports];
      }
      getRenderedExports() {
        const renderedExports = [];
        const removedExports = [];
        for (const exportName of this.exports.keys()) {
          const [variable] = this.getVariableForExportName(exportName);
          (variable?.included ? renderedExports : removedExports).push(exportName);
        }
        return { removedExports, renderedExports };
      }
      getSyntheticNamespace() {
        if (this.syntheticNamespace === null) {
          this.syntheticNamespace = void 0;
          [this.syntheticNamespace] = this.getVariableForExportName(typeof this.info.syntheticNamedExports === "string" ? this.info.syntheticNamedExports : "default", { onlyExplicit: true });
        }
        if (!this.syntheticNamespace) {
          return error3(logSyntheticNamedExportsNeedNamespaceExport(this.id, this.info.syntheticNamedExports));
        }
        return this.syntheticNamespace;
      }
      getVariableForExportName(name, { importerForSideEffects, isExportAllSearch, onlyExplicit, searchedNamesAndModules } = EMPTY_OBJECT) {
        if (name[0] === "*") {
          if (name.length === 1) {
            return [this.namespace];
          }
          const module = this.graph.modulesById.get(name.slice(1));
          return module.getVariableForExportName("*");
        }
        const reexportDeclaration = this.reexportDescriptions.get(name);
        if (reexportDeclaration) {
          const [variable] = getVariableForExportNameRecursive(reexportDeclaration.module, reexportDeclaration.localName, importerForSideEffects, false, searchedNamesAndModules);
          if (!variable) {
            return this.error(logMissingExport(reexportDeclaration.localName, this.id, reexportDeclaration.module.id), reexportDeclaration.start);
          }
          if (importerForSideEffects) {
            setAlternativeExporterIfCyclic(variable, importerForSideEffects, this);
            if (this.info.moduleSideEffects) {
              getOrCreate(importerForSideEffects.sideEffectDependenciesByVariable, variable, getNewSet).add(this);
            }
          }
          return [variable];
        }
        const exportDeclaration = this.exports.get(name);
        if (exportDeclaration) {
          if (exportDeclaration === MISSING_EXPORT_SHIM_DESCRIPTION) {
            return [this.exportShimVariable];
          }
          const name2 = exportDeclaration.localName;
          const variable = this.traceVariable(name2, {
            importerForSideEffects,
            searchedNamesAndModules
          });
          if (importerForSideEffects) {
            setAlternativeExporterIfCyclic(variable, importerForSideEffects, this);
            getOrCreate(importerForSideEffects.sideEffectDependenciesByVariable, variable, getNewSet).add(this);
          }
          return [variable];
        }
        if (onlyExplicit) {
          return [null];
        }
        if (name !== "default") {
          const foundNamespaceReexport = this.namespaceReexportsByName.get(name) ?? this.getVariableFromNamespaceReexports(name, importerForSideEffects, searchedNamesAndModules);
          this.namespaceReexportsByName.set(name, foundNamespaceReexport);
          if (foundNamespaceReexport[0]) {
            return foundNamespaceReexport;
          }
        }
        if (this.info.syntheticNamedExports) {
          return [
            getOrCreate(this.syntheticExports, name, () => new SyntheticNamedExportVariable(this.astContext, name, this.getSyntheticNamespace()))
          ];
        }
        if (!isExportAllSearch && this.options.shimMissingExports) {
          this.shimMissingExport(name);
          return [this.exportShimVariable];
        }
        return [null];
      }
      hasEffects() {
        return this.info.moduleSideEffects === "no-treeshake" || this.ast.hasCachedEffects();
      }
      include() {
        const context8 = createInclusionContext();
        if (this.ast.shouldBeIncluded(context8))
          this.ast.include(context8, false);
      }
      includeAllExports(includeNamespaceMembers) {
        if (this.allExportsIncluded)
          return;
        this.allExportsIncluded = true;
        if (!this.isExecuted) {
          markModuleAndImpureDependenciesAsExecuted(this);
          this.graph.needsTreeshakingPass = true;
        }
        const inclusionContext = createInclusionContext();
        for (const exportName of this.exports.keys()) {
          if (includeNamespaceMembers || exportName !== this.info.syntheticNamedExports) {
            const variable = this.getVariableForExportName(exportName)[0];
            if (!variable) {
              return error3(logMissingEntryExport(exportName, this.id));
            }
            this.includeVariable(variable, UNKNOWN_PATH, inclusionContext);
            variable.deoptimizePath(UNKNOWN_PATH);
          }
        }
        for (const name of this.getReexports()) {
          const [variable] = this.getVariableForExportName(name);
          if (variable) {
            variable.deoptimizePath(UNKNOWN_PATH);
            this.includeVariable(variable, UNKNOWN_PATH, inclusionContext);
            if (variable instanceof ExternalVariable) {
              variable.module.reexported = true;
            }
          }
        }
        if (includeNamespaceMembers) {
          this.namespace.setMergedNamespaces(this.includeAndGetAdditionalMergedNamespaces());
        }
      }
      includeAllInBundle() {
        this.ast.include(createInclusionContext(), true);
        this.includeAllExports(false);
      }
      includeExportsByNames(names) {
        if (!this.isExecuted) {
          markModuleAndImpureDependenciesAsExecuted(this);
          this.graph.needsTreeshakingPass = true;
        }
        let includeNamespaceMembers = false;
        const inclusionContext = createInclusionContext();
        for (const name of names) {
          const variable = this.getVariableForExportName(name)[0];
          if (variable) {
            variable.deoptimizePath(UNKNOWN_PATH);
            this.includeVariable(variable, UNKNOWN_PATH, inclusionContext);
          }
          if (!this.exports.has(name) && !this.reexportDescriptions.has(name)) {
            includeNamespaceMembers = true;
          }
        }
        if (includeNamespaceMembers) {
          this.namespace.setMergedNamespaces(this.includeAndGetAdditionalMergedNamespaces());
        }
      }
      isIncluded() {
        return this.ast && (this.ast.included || this.namespace.included || this.importedFromNotTreeshaken || this.exportShimVariable.included);
      }
      linkImports() {
        this.addModulesToImportDescriptions(this.importDescriptions);
        this.addModulesToImportDescriptions(this.reexportDescriptions);
        const externalExportAllModules = [];
        for (const source of this.exportAllSources) {
          const module = this.graph.modulesById.get(this.resolvedIds[source].id);
          if (module instanceof ExternalModule) {
            externalExportAllModules.push(module);
            continue;
          }
          this.exportAllModules.push(module);
        }
        this.exportAllModules.push(...externalExportAllModules);
      }
      log(level, properties, pos) {
        this.addLocationToLogProps(properties, pos);
        this.options.onLog(level, properties);
      }
      render(options) {
        const source = this.magicString.clone();
        this.ast.render(source, options);
        source.trim();
        const { usesTopLevelAwait } = this.astContext;
        if (usesTopLevelAwait && options.format !== "es" && options.format !== "system") {
          return error3(logInvalidFormatForTopLevelAwait(this.id, options.format));
        }
        return { source, usesTopLevelAwait };
      }
      async setSource({ ast, code, customTransformCache, originalCode, originalSourcemap, resolvedIds, sourcemapChain, transformDependencies, transformFiles, ...moduleOptions }) {
        timeStart("generate ast", 3);
        if (code.startsWith("#!")) {
          const shebangEndPosition = code.indexOf("\n");
          this.shebang = code.slice(2, shebangEndPosition);
        }
        this.info.code = code;
        this.originalCode = originalCode;
        this.originalSourcemap = decodedSourcemap(originalSourcemap);
        this.sourcemapChain = sourcemapChain.map((mapOrMissing) => mapOrMissing.missing ? mapOrMissing : decodedSourcemap(mapOrMissing));
        resetSourcemapCache(this.originalSourcemap, this.sourcemapChain);
        if (transformFiles) {
          this.transformFiles = transformFiles;
        }
        this.transformDependencies = transformDependencies;
        this.customTransformCache = customTransformCache;
        this.updateOptions(moduleOptions);
        this.resolvedIds = resolvedIds ?? /* @__PURE__ */ Object.create(null);
        const fileName = this.id;
        this.magicString = new MagicString(code, {
          filename: this.excludeFromSourcemap ? null : fileName,
          // don't include plugin helpers in sourcemap
          indentExclusionRanges: []
        });
        this.astContext = {
          addDynamicImport: this.addDynamicImport.bind(this),
          addExport: this.addExport.bind(this),
          addImport: this.addImport.bind(this),
          addImportMeta: this.addImportMeta.bind(this),
          addImportSource: this.addImportSource.bind(this),
          code,
          // Only needed for debugging
          deoptimizationTracker: this.graph.deoptimizationTracker,
          error: this.error.bind(this),
          fileName,
          // Needed for warnings
          getExports: this.getExports.bind(this),
          getImportedJsxFactoryVariable: this.getImportedJsxFactoryVariable.bind(this),
          getModuleExecIndex: () => this.execIndex,
          getModuleName: this.basename.bind(this),
          getNodeConstructor: (name) => nodeConstructors[name] || nodeConstructors.UnknownNode,
          getReexports: this.getReexports.bind(this),
          importDescriptions: this.importDescriptions,
          includeAllExports: () => this.includeAllExports(true),
          includeDynamicImport: this.includeDynamicImport.bind(this),
          includeVariableInModule: this.includeVariableInModule.bind(this),
          log: this.log.bind(this),
          magicString: this.magicString,
          manualPureFunctions: this.graph.pureFunctions,
          module: this,
          moduleContext: this.context,
          newlyIncludedVariableInits: this.graph.newlyIncludedVariableInits,
          options: this.options,
          requestTreeshakingPass: () => this.graph.needsTreeshakingPass = true,
          traceExport: (name) => this.getVariableForExportName(name)[0],
          traceVariable: this.traceVariable.bind(this),
          usesTopLevelAwait: false
        };
        this.scope = new ModuleScope(this.graph.scope, this.astContext);
        this.namespace = new NamespaceVariable(this.astContext);
        const programParent = { context: this.astContext, type: "Module" };
        if (ast) {
          this.ast = new nodeConstructors[ast.type](programParent, this.scope).parseNode(ast);
          this.info.ast = ast;
        } else {
          timeEnd("generate ast", 3);
          const astBuffer = await (0, import_native2.parseAsync)(code, false, this.options.jsx !== false);
          timeStart("generate ast", 3);
          this.ast = convertProgram2(astBuffer, programParent, this.scope);
          Object.defineProperty(this.info, "ast", {
            get: () => {
              if (this.graph.astLru.has(fileName)) {
                return this.graph.astLru.get(fileName);
              } else {
                const parsedAst = this.tryParse();
                if (this.options.cache !== false) {
                  Object.defineProperty(this.info, "ast", {
                    value: parsedAst
                  });
                  return parsedAst;
                }
                this.graph.astLru.set(fileName, parsedAst);
                return parsedAst;
              }
            }
          });
        }
        timeEnd("generate ast", 3);
      }
      toJSON() {
        return {
          ast: this.info.ast,
          attributes: this.info.attributes,
          code: this.info.code,
          customTransformCache: this.customTransformCache,
          dependencies: Array.from(this.dependencies, getId),
          id: this.id,
          meta: this.info.meta,
          moduleSideEffects: this.info.moduleSideEffects,
          originalCode: this.originalCode,
          originalSourcemap: this.originalSourcemap,
          resolvedIds: this.resolvedIds,
          sourcemapChain: this.sourcemapChain,
          syntheticNamedExports: this.info.syntheticNamedExports,
          transformDependencies: this.transformDependencies,
          transformFiles: this.transformFiles
        };
      }
      traceVariable(name, { importerForSideEffects, isExportAllSearch, searchedNamesAndModules } = EMPTY_OBJECT) {
        const localVariable = this.scope.variables.get(name);
        if (localVariable) {
          return localVariable;
        }
        const importDescription = this.importDescriptions.get(name);
        if (importDescription) {
          const otherModule = importDescription.module;
          if (otherModule instanceof _Module && importDescription.name === "*") {
            return otherModule.namespace;
          }
          const [declaration] = getVariableForExportNameRecursive(otherModule, importDescription.name, importerForSideEffects || this, isExportAllSearch, searchedNamesAndModules);
          if (!declaration) {
            return this.error(logMissingExport(importDescription.name, this.id, otherModule.id), importDescription.start);
          }
          return declaration;
        }
        return null;
      }
      updateOptions({ meta, moduleSideEffects, syntheticNamedExports }) {
        if (moduleSideEffects != null) {
          this.info.moduleSideEffects = moduleSideEffects;
        }
        if (syntheticNamedExports != null) {
          this.info.syntheticNamedExports = syntheticNamedExports;
        }
        if (meta != null) {
          Object.assign(this.info.meta, meta);
        }
      }
      addDynamicImport(node) {
        let argument = node.sourceAstNode;
        if (argument.type === TemplateLiteral) {
          if (argument.quasis.length === 1 && typeof argument.quasis[0].value.cooked === "string") {
            argument = argument.quasis[0].value.cooked;
          }
        } else if (argument.type === Literal && typeof argument.value === "string") {
          argument = argument.value;
        }
        this.dynamicImports.push({ argument, id: null, node, resolution: null });
      }
      assertUniqueExportName(name, nodeStart) {
        if (this.exports.has(name) || this.reexportDescriptions.has(name)) {
          this.error(logDuplicateExportError(name), nodeStart);
        }
      }
      addExport(node) {
        if (node instanceof ExportDefaultDeclaration2) {
          this.assertUniqueExportName("default", node.start);
          this.exports.set("default", {
            identifier: node.variable.getAssignedVariableName(),
            localName: "default"
          });
        } else if (node instanceof ExportAllDeclaration) {
          const source = node.source.value;
          this.addSource(source, node);
          if (node.exported) {
            const name = node.exported instanceof Literal2 ? node.exported.value : node.exported.name;
            this.assertUniqueExportName(name, node.exported.start);
            this.reexportDescriptions.set(name, {
              localName: "*",
              module: null,
              // filled in later,
              source,
              start: node.start
            });
          } else {
            this.exportAllSources.add(source);
          }
        } else if (node.source instanceof Literal2) {
          const source = node.source.value;
          this.addSource(source, node);
          for (const { exported, local, start: start3 } of node.specifiers) {
            const name = exported instanceof Literal2 ? exported.value : exported.name;
            this.assertUniqueExportName(name, start3);
            this.reexportDescriptions.set(name, {
              localName: local instanceof Literal2 ? local.value : local.name,
              module: null,
              // filled in later,
              source,
              start: start3
            });
          }
        } else if (node.declaration) {
          const declaration = node.declaration;
          if (declaration instanceof VariableDeclaration) {
            for (const declarator of declaration.declarations) {
              for (const localName of extractAssignedNames(declarator.id)) {
                this.assertUniqueExportName(localName, declarator.id.start);
                this.exports.set(localName, { identifier: null, localName });
              }
            }
          } else {
            const localName = declaration.id.name;
            this.assertUniqueExportName(localName, declaration.id.start);
            this.exports.set(localName, { identifier: null, localName });
          }
        } else {
          for (const { local, exported } of node.specifiers) {
            const localName = local.name;
            const exportedName = exported instanceof Identifier2 ? exported.name : exported.value;
            this.assertUniqueExportName(exportedName, exported.start);
            this.exports.set(exportedName, { identifier: null, localName });
          }
        }
      }
      addImport(node) {
        const source = node.source.value;
        this.addSource(source, node);
        for (const specifier of node.specifiers) {
          const localName = specifier.local.name;
          if (this.scope.variables.has(localName) || this.importDescriptions.has(localName)) {
            this.error(logRedeclarationError(localName), specifier.local.start);
          }
          const name = specifier instanceof ImportDefaultSpecifier ? "default" : specifier instanceof ImportNamespaceSpecifier ? "*" : specifier.imported instanceof Identifier2 ? specifier.imported.name : specifier.imported.value;
          this.importDescriptions.set(localName, {
            module: null,
            // filled in later
            name,
            source,
            start: specifier.start
          });
        }
      }
      addImportSource(importSource) {
        if (importSource && !this.sourcesWithAttributes.has(importSource)) {
          this.sourcesWithAttributes.set(importSource, EMPTY_OBJECT);
        }
      }
      addImportMeta(node) {
        this.importMetas.push(node);
      }
      addLocationToLogProps(properties, pos) {
        properties.id = this.id;
        properties.pos = pos;
        let code = this.info.code;
        const location = locate(code, pos, { offsetLine: 1 });
        if (location) {
          let { column, line } = location;
          try {
            ({ column, line } = getOriginalLocation(this.sourcemapChain, { column, line }));
            code = this.originalCode;
          } catch (error_) {
            this.options.onLog(LOGLEVEL_WARN, logInvalidSourcemapForError(error_, this.id, column, line, pos));
          }
          augmentCodeLocation(properties, { column, line }, code, this.id);
        }
      }
      addModulesToImportDescriptions(importDescription) {
        for (const specifier of importDescription.values()) {
          const { id: id2 } = this.resolvedIds[specifier.source];
          specifier.module = this.graph.modulesById.get(id2);
        }
      }
      addRelevantSideEffectDependencies(relevantDependencies, necessaryDependencies, alwaysCheckedDependencies) {
        const handledDependencies = /* @__PURE__ */ new Set();
        const addSideEffectDependencies = (possibleDependencies) => {
          for (const dependency of possibleDependencies) {
            if (handledDependencies.has(dependency)) {
              continue;
            }
            handledDependencies.add(dependency);
            if (necessaryDependencies.has(dependency)) {
              relevantDependencies.add(dependency);
              continue;
            }
            if (!(dependency.info.moduleSideEffects || alwaysCheckedDependencies.has(dependency))) {
              continue;
            }
            if (dependency instanceof ExternalModule || dependency.hasEffects()) {
              relevantDependencies.add(dependency);
              continue;
            }
            addSideEffectDependencies(dependency.dependencies);
          }
        };
        addSideEffectDependencies(this.dependencies);
        addSideEffectDependencies(alwaysCheckedDependencies);
      }
      addSource(source, declaration) {
        const parsedAttributes = getAttributesFromImportExportDeclaration(declaration.attributes);
        const existingAttributes = this.sourcesWithAttributes.get(source);
        if (existingAttributes) {
          if (doAttributesDiffer(existingAttributes, parsedAttributes)) {
            this.log(LOGLEVEL_WARN, logInconsistentImportAttributes(existingAttributes, parsedAttributes, source, this.id), declaration.start);
          }
        } else {
          this.sourcesWithAttributes.set(source, parsedAttributes);
        }
      }
      getImportedJsxFactoryVariable(baseName, nodeStart, importSource) {
        const { id: id2 } = this.resolvedIds[importSource];
        const module = this.graph.modulesById.get(id2);
        const [variable] = module.getVariableForExportName(baseName);
        if (!variable) {
          return this.error(logMissingJsxExport(baseName, id2, this.id), nodeStart);
        }
        return variable;
      }
      getVariableFromNamespaceReexports(name, importerForSideEffects, searchedNamesAndModules) {
        let foundSyntheticDeclaration = null;
        const foundInternalDeclarations = /* @__PURE__ */ new Map();
        const foundExternalDeclarations = /* @__PURE__ */ new Set();
        for (const module of this.exportAllModules) {
          if (module.info.syntheticNamedExports === name) {
            continue;
          }
          const [variable, indirectExternal] = getVariableForExportNameRecursive(
            module,
            name,
            importerForSideEffects,
            true,
            // We are creating a copy to handle the case where the same binding is
            // imported through different namespace reexports gracefully
            copyNameToModulesMap(searchedNamesAndModules)
          );
          if (module instanceof ExternalModule || indirectExternal) {
            foundExternalDeclarations.add(variable);
          } else if (variable instanceof SyntheticNamedExportVariable) {
            if (!foundSyntheticDeclaration) {
              foundSyntheticDeclaration = variable;
            }
          } else if (variable) {
            foundInternalDeclarations.set(variable, module);
          }
        }
        if (foundInternalDeclarations.size > 0) {
          const foundDeclarationList = [...foundInternalDeclarations];
          const usedDeclaration = foundDeclarationList[0][0];
          if (foundDeclarationList.length === 1) {
            return [usedDeclaration];
          }
          this.options.onLog(LOGLEVEL_WARN, logNamespaceConflict(name, this.id, foundDeclarationList.map(([, module]) => module.id)));
          return [null];
        }
        if (foundExternalDeclarations.size > 0) {
          const foundDeclarationList = [...foundExternalDeclarations];
          const usedDeclaration = foundDeclarationList[0];
          if (foundDeclarationList.length > 1) {
            this.options.onLog(LOGLEVEL_WARN, logAmbiguousExternalNamespaces(name, this.id, usedDeclaration.module.id, foundDeclarationList.map((declaration) => declaration.module.id)));
          }
          return [usedDeclaration, true];
        }
        if (foundSyntheticDeclaration) {
          return [foundSyntheticDeclaration];
        }
        return [null];
      }
      includeAndGetAdditionalMergedNamespaces() {
        const externalNamespaces = /* @__PURE__ */ new Set();
        const syntheticNamespaces = /* @__PURE__ */ new Set();
        for (const module of [this, ...this.exportAllModules]) {
          if (module instanceof ExternalModule) {
            const [externalVariable] = module.getVariableForExportName("*");
            externalVariable.includePath(UNKNOWN_PATH, createInclusionContext());
            this.includedImports.add(externalVariable);
            externalNamespaces.add(externalVariable);
          } else if (module.info.syntheticNamedExports) {
            const syntheticNamespace = module.getSyntheticNamespace();
            syntheticNamespace.includePath(UNKNOWN_PATH, createInclusionContext());
            this.includedImports.add(syntheticNamespace);
            syntheticNamespaces.add(syntheticNamespace);
          }
        }
        return [...syntheticNamespaces, ...externalNamespaces];
      }
      includeDynamicImport(node) {
        const resolution = this.dynamicImports.find((dynamicImport) => dynamicImport.node === node).resolution;
        if (resolution instanceof _Module) {
          if (!resolution.includedDynamicImporters.includes(this)) {
            resolution.includedDynamicImporters.push(this);
            if (node.isFollowingTopLevelAwait) {
              resolution.includedDirectTopLevelAwaitingDynamicImporters.add(this);
            }
          }
          const importedNames = this.options.treeshake ? node.getDeterministicImportedNames() : void 0;
          if (importedNames) {
            resolution.includeExportsByNames(importedNames);
          } else {
            resolution.includeAllExports(true);
          }
        }
      }
      includeVariable(variable, path3, context8) {
        const { included, module: variableModule } = variable;
        variable.includePath(path3, context8);
        if (included) {
          if (variableModule instanceof _Module && variableModule !== this) {
            getAndExtendSideEffectModules(variable, this);
          }
        } else {
          this.graph.needsTreeshakingPass = true;
          if (variableModule instanceof _Module) {
            if (!variableModule.isExecuted) {
              markModuleAndImpureDependenciesAsExecuted(variableModule);
            }
            if (variableModule !== this) {
              const sideEffectModules = getAndExtendSideEffectModules(variable, this);
              for (const module of sideEffectModules) {
                if (!module.isExecuted) {
                  markModuleAndImpureDependenciesAsExecuted(module);
                }
              }
            }
          }
        }
      }
      includeVariableInModule(variable, path3, context8) {
        this.includeVariable(variable, path3, context8);
        const variableModule = variable.module;
        if (variableModule && variableModule !== this) {
          this.includedImports.add(variable);
        }
      }
      shimMissingExport(name) {
        this.options.onLog(LOGLEVEL_WARN, logShimmedExport(this.id, name));
        this.exports.set(name, MISSING_EXPORT_SHIM_DESCRIPTION);
      }
      tryParse() {
        try {
          return parseAst(this.info.code, { jsx: this.options.jsx !== false });
        } catch (error_) {
          return this.error(logModuleParseError(error_, this.id), error_.pos);
        }
      }
    };
    copyNameToModulesMap = (searchedNamesAndModules) => searchedNamesAndModules && new Map(Array.from(searchedNamesAndModules, ([name, modules]) => [name, new Set(modules)]));
    concatSeparator = (out, next) => next ? `${out}
${next}` : out;
    concatDblSeparator = (out, next) => next ? `${out}

${next}` : out;
    DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT = {
      amd: deconflictImportsOther,
      cjs: deconflictImportsOther,
      es: deconflictImportsEsmOrSystem,
      iife: deconflictImportsOther,
      system: deconflictImportsEsmOrSystem,
      umd: deconflictImportsOther
    };
    hashPlaceholderLeft = "!~{";
    hashPlaceholderRight = "}~";
    hashPlaceholderOverhead = hashPlaceholderLeft.length + hashPlaceholderRight.length;
    MAX_HASH_SIZE = 21;
    DEFAULT_HASH_SIZE = 8;
    getHashPlaceholderGenerator = () => {
      let nextIndex = 0;
      return (optionName, hashSize) => {
        if (hashSize > MAX_HASH_SIZE) {
          return error3(logFailedValidation(`Hashes cannot be longer than ${MAX_HASH_SIZE} characters, received ${hashSize}. Check the "${optionName}" option.`));
        }
        const placeholder = `${hashPlaceholderLeft}${toBase64(++nextIndex).padStart(hashSize - hashPlaceholderOverhead, "0")}${hashPlaceholderRight}`;
        if (placeholder.length > hashSize) {
          return error3(logFailedValidation(`To generate hashes for this number of chunks (currently ${nextIndex}), you need a minimum hash size of ${placeholder.length}, received ${hashSize}. Check the "${optionName}" option.`));
        }
        return placeholder;
      };
    };
    REPLACER_REGEX = new RegExp(`${hashPlaceholderLeft}[0-9a-zA-Z_$]{1,${MAX_HASH_SIZE - hashPlaceholderOverhead}}${hashPlaceholderRight}`, "g");
    replacePlaceholders = (code, hashesByPlaceholder) => code.replace(REPLACER_REGEX, (placeholder) => hashesByPlaceholder.get(placeholder) || placeholder);
    replaceSinglePlaceholder = (code, placeholder, value) => code.replace(REPLACER_REGEX, (match18) => match18 === placeholder ? value : match18);
    replacePlaceholdersWithDefaultAndGetContainedPlaceholders = (code, placeholders) => {
      const containedPlaceholders = /* @__PURE__ */ new Set();
      const transformedCode = code.replace(REPLACER_REGEX, (placeholder) => {
        if (placeholders.has(placeholder)) {
          containedPlaceholders.add(placeholder);
          return `${hashPlaceholderLeft}${"0".repeat(placeholder.length - hashPlaceholderOverhead)}${hashPlaceholderRight}`;
        }
        return placeholder;
      });
      return { containedPlaceholders, transformedCode };
    };
    lowercaseBundleKeys = Symbol("bundleKeys");
    FILE_PLACEHOLDER = {
      type: "placeholder"
    };
    getOutputBundle = (outputBundleBase) => {
      const reservedLowercaseBundleKeys = /* @__PURE__ */ new Set();
      return new Proxy(outputBundleBase, {
        deleteProperty(target, key) {
          if (typeof key === "string") {
            reservedLowercaseBundleKeys.delete(key.toLowerCase());
          }
          return Reflect.deleteProperty(target, key);
        },
        get(target, key) {
          if (key === lowercaseBundleKeys) {
            return reservedLowercaseBundleKeys;
          }
          return Reflect.get(target, key);
        },
        set(target, key, value) {
          if (typeof key === "string") {
            reservedLowercaseBundleKeys.add(key.toLowerCase());
          }
          return Reflect.set(target, key, value);
        }
      });
    };
    removeUnreferencedAssets = (outputBundle) => {
      const unreferencedAssets = /* @__PURE__ */ new Set();
      const bundleEntries = Object.values(outputBundle);
      for (const asset of bundleEntries) {
        if (asset.type === "asset" && asset.needsCodeReference) {
          unreferencedAssets.add(asset.fileName);
        }
      }
      for (const chunk5 of bundleEntries) {
        if (chunk5.type === "chunk") {
          for (const referencedFile of chunk5.referencedFiles) {
            if (unreferencedAssets.has(referencedFile)) {
              unreferencedAssets.delete(referencedFile);
            }
          }
        }
      }
      for (const file of unreferencedAssets) {
        delete outputBundle[file];
      }
    };
    NON_ASSET_EXTENSIONS = /* @__PURE__ */ new Set([
      ".js",
      ".jsx",
      ".ts",
      ".tsx",
      ".mjs",
      ".mts",
      ".cjs",
      ".cts"
    ]);
    Chunk2 = class _Chunk {
      constructor(orderedModules, inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, externalChunkByModule, facadeChunkByModule, includedNamespaces, manualChunkAlias, getPlaceholder, bundle, inputBase, snippets) {
        this.orderedModules = orderedModules;
        this.inputOptions = inputOptions;
        this.outputOptions = outputOptions;
        this.unsetOptions = unsetOptions;
        this.pluginDriver = pluginDriver;
        this.modulesById = modulesById;
        this.chunkByModule = chunkByModule;
        this.externalChunkByModule = externalChunkByModule;
        this.facadeChunkByModule = facadeChunkByModule;
        this.includedNamespaces = includedNamespaces;
        this.manualChunkAlias = manualChunkAlias;
        this.getPlaceholder = getPlaceholder;
        this.bundle = bundle;
        this.inputBase = inputBase;
        this.snippets = snippets;
        this.dependencies = /* @__PURE__ */ new Set();
        this.entryModules = [];
        this.exportMode = "named";
        this.facadeModule = null;
        this.namespaceVariableName = "";
        this.variableName = "";
        this.accessedGlobalsByScope = /* @__PURE__ */ new Map();
        this.dynamicEntryModules = [];
        this.dynamicName = null;
        this.exportNamesByVariable = /* @__PURE__ */ new Map();
        this.exports = /* @__PURE__ */ new Set();
        this.exportsByName = /* @__PURE__ */ new Map();
        this.fileName = null;
        this.implicitEntryModules = [];
        this.implicitlyLoadedBefore = /* @__PURE__ */ new Set();
        this.imports = /* @__PURE__ */ new Set();
        this.includedDynamicImports = null;
        this.includedReexportsByModule = /* @__PURE__ */ new Map();
        this.isEmpty = true;
        this.name = null;
        this.needsExportsShim = false;
        this.preRenderedChunkInfo = null;
        this.preliminaryFileName = null;
        this.preliminarySourcemapFileName = null;
        this.renderedChunkInfo = null;
        this.renderedDependencies = null;
        this.renderedModules = /* @__PURE__ */ Object.create(null);
        this.sortedExportNames = null;
        this.strictFacade = false;
        this.execIndex = orderedModules.length > 0 ? orderedModules[0].execIndex : Infinity;
        const chunkModules = new Set(orderedModules);
        for (const module of orderedModules) {
          chunkByModule.set(module, this);
          if (module.namespace.included && !outputOptions.preserveModules) {
            includedNamespaces.add(module);
          }
          if (this.isEmpty && module.isIncluded()) {
            this.isEmpty = false;
          }
          if (module.info.isEntry || outputOptions.preserveModules) {
            this.entryModules.push(module);
          }
          for (const importer of module.includedDynamicImporters) {
            if (!chunkModules.has(importer)) {
              this.dynamicEntryModules.push(module);
              if (module.info.syntheticNamedExports) {
                includedNamespaces.add(module);
                this.exports.add(module.namespace);
              }
            }
          }
          if (module.implicitlyLoadedAfter.size > 0) {
            this.implicitEntryModules.push(module);
          }
        }
        this.suggestedVariableName = makeLegal(this.generateVariableName());
      }
      static generateFacade(inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, externalChunkByModule, facadeChunkByModule, includedNamespaces, facadedModule, facadeName, getPlaceholder, bundle, inputBase, snippets) {
        const chunk5 = new _Chunk([], inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, externalChunkByModule, facadeChunkByModule, includedNamespaces, null, getPlaceholder, bundle, inputBase, snippets);
        chunk5.assignFacadeName(facadeName, facadedModule);
        if (!facadeChunkByModule.has(facadedModule)) {
          facadeChunkByModule.set(facadedModule, chunk5);
        }
        for (const dependency of facadedModule.getDependenciesToBeIncluded()) {
          chunk5.dependencies.add(dependency instanceof Module ? chunkByModule.get(dependency) : externalChunkByModule.get(dependency));
        }
        if (!chunk5.dependencies.has(chunkByModule.get(facadedModule)) && facadedModule.info.moduleSideEffects && facadedModule.hasEffects()) {
          chunk5.dependencies.add(chunkByModule.get(facadedModule));
        }
        chunk5.ensureReexportsAreAvailableForModule(facadedModule);
        chunk5.facadeModule = facadedModule;
        chunk5.strictFacade = true;
        return chunk5;
      }
      canModuleBeFacade(module, exposedVariables) {
        const moduleExportNamesByVariable = module.getExportNamesByVariable();
        for (const exposedVariable of this.exports) {
          if (!moduleExportNamesByVariable.has(exposedVariable)) {
            return false;
          }
        }
        for (const exposedVariable of exposedVariables) {
          if (!(exposedVariable.module === module || moduleExportNamesByVariable.has(exposedVariable) || exposedVariable instanceof SyntheticNamedExportVariable && moduleExportNamesByVariable.has(exposedVariable.getBaseVariable()))) {
            return false;
          }
        }
        return true;
      }
      finalizeChunk(code, map26, sourcemapFileName, hashesByPlaceholder) {
        const renderedChunkInfo = this.getRenderedChunkInfo();
        const finalize = (code2) => replacePlaceholders(code2, hashesByPlaceholder);
        const preliminaryFileName = renderedChunkInfo.fileName;
        const fileName = this.fileName = finalize(preliminaryFileName);
        return {
          ...renderedChunkInfo,
          code,
          dynamicImports: renderedChunkInfo.dynamicImports.map(finalize),
          fileName,
          implicitlyLoadedBefore: renderedChunkInfo.implicitlyLoadedBefore.map(finalize),
          importedBindings: Object.fromEntries(Object.entries(renderedChunkInfo.importedBindings).map(([fileName2, bindings]) => [
            finalize(fileName2),
            bindings
          ])),
          imports: renderedChunkInfo.imports.map(finalize),
          map: map26,
          preliminaryFileName,
          referencedFiles: renderedChunkInfo.referencedFiles.map(finalize),
          sourcemapFileName
        };
      }
      generateExports() {
        this.sortedExportNames = null;
        const remainingExports = new Set(this.exports);
        if (this.facadeModule !== null && (this.facadeModule.preserveSignature !== false || this.strictFacade)) {
          const exportNamesByVariable = this.facadeModule.getExportNamesByVariable();
          for (const [variable, exportNames] of exportNamesByVariable) {
            this.exportNamesByVariable.set(variable, [...exportNames]);
            for (const exportName of exportNames) {
              this.exportsByName.set(exportName, variable);
            }
            remainingExports.delete(variable);
          }
        }
        if (this.outputOptions.minifyInternalExports) {
          assignExportsToMangledNames(remainingExports, this.exportsByName, this.exportNamesByVariable);
        } else {
          assignExportsToNames(remainingExports, this.exportsByName, this.exportNamesByVariable);
        }
        if (this.outputOptions.preserveModules || this.facadeModule && this.facadeModule.info.isEntry)
          this.exportMode = getExportMode(this, this.outputOptions, this.facadeModule.id, this.inputOptions.onLog);
      }
      generateFacades() {
        const facades = [];
        const entryModules = /* @__PURE__ */ new Set([...this.entryModules, ...this.implicitEntryModules]);
        const exposedVariables = new Set(this.dynamicEntryModules.map(({ namespace }) => namespace));
        for (const module of entryModules) {
          if (module.preserveSignature) {
            for (const exportedVariable of module.getExportNamesByVariable().keys()) {
              if (this.chunkByModule.get(exportedVariable.module) === this) {
                exposedVariables.add(exportedVariable);
              }
            }
          }
        }
        for (const module of entryModules) {
          const requiredFacades = Array.from(
            new Set(module.chunkNames.filter(({ isUserDefined }) => isUserDefined).map(({ name }) => name)),
            // mapping must run after Set 'name' dedupe
            (name) => ({
              name
            })
          );
          if (requiredFacades.length === 0 && module.isUserDefinedEntryPoint) {
            requiredFacades.push({});
          }
          requiredFacades.push(...Array.from(module.chunkFileNames, (fileName) => ({ fileName })));
          if (requiredFacades.length === 0) {
            requiredFacades.push({});
          }
          if (!this.facadeModule) {
            const needsStrictFacade = !this.outputOptions.preserveModules && (module.preserveSignature === "strict" || module.preserveSignature === "exports-only" && module.getExportNamesByVariable().size > 0);
            if (!needsStrictFacade || this.canModuleBeFacade(module, exposedVariables)) {
              this.facadeModule = module;
              this.facadeChunkByModule.set(module, this);
              if (module.preserveSignature) {
                this.strictFacade = needsStrictFacade;
              }
              this.assignFacadeName(requiredFacades.shift(), module, this.outputOptions.preserveModules);
            }
          }
          for (const facadeName of requiredFacades) {
            facades.push(_Chunk.generateFacade(this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.modulesById, this.chunkByModule, this.externalChunkByModule, this.facadeChunkByModule, this.includedNamespaces, module, facadeName, this.getPlaceholder, this.bundle, this.inputBase, this.snippets));
          }
        }
        for (const module of this.dynamicEntryModules) {
          if (module.info.syntheticNamedExports)
            continue;
          if (!this.facadeModule && this.canModuleBeFacade(module, exposedVariables)) {
            this.facadeModule = module;
            this.facadeChunkByModule.set(module, this);
            this.strictFacade = true;
            this.dynamicName = getChunkNameFromModule(module);
          } else if (this.facadeModule === module && !this.strictFacade && this.canModuleBeFacade(module, exposedVariables)) {
            this.strictFacade = true;
          } else if (!this.facadeChunkByModule.get(module)?.strictFacade) {
            this.includedNamespaces.add(module);
            this.exports.add(module.namespace);
          }
        }
        if (!this.outputOptions.preserveModules) {
          this.addNecessaryImportsForFacades();
        }
        return facades;
      }
      getChunkName() {
        return this.name ??= this.outputOptions.sanitizeFileName(this.getFallbackChunkName());
      }
      getExportNames() {
        return this.sortedExportNames ??= [...this.exportsByName.keys()].sort();
      }
      getFileName() {
        return this.fileName || this.getPreliminaryFileName().fileName;
      }
      getImportPath(importer) {
        return escapeId(getImportPath(importer, this.getFileName(), this.outputOptions.format === "amd" && !this.outputOptions.amd.forceJsExtensionForImports, true));
      }
      getPreliminaryFileName() {
        if (this.preliminaryFileName) {
          return this.preliminaryFileName;
        }
        let fileName;
        let hashPlaceholder = null;
        const { chunkFileNames, entryFileNames, file, format: format5, preserveModules } = this.outputOptions;
        if (file) {
          fileName = p2.basename(file);
        } else if (this.fileName === null) {
          const [pattern, patternName] = preserveModules || this.facadeModule?.isUserDefinedEntryPoint ? [entryFileNames, "output.entryFileNames"] : [chunkFileNames, "output.chunkFileNames"];
          fileName = renderNamePattern(typeof pattern === "function" ? pattern(this.getPreRenderedChunkInfo()) : pattern, patternName, {
            format: () => format5,
            hash: (size16) => hashPlaceholder || (hashPlaceholder = this.getPlaceholder(patternName, size16 || DEFAULT_HASH_SIZE)),
            name: () => this.getChunkName()
          });
          if (!hashPlaceholder) {
            fileName = makeUnique(fileName, this.bundle);
          }
        } else {
          fileName = this.fileName;
        }
        if (!hashPlaceholder) {
          this.bundle[fileName] = FILE_PLACEHOLDER;
        }
        return this.preliminaryFileName = { fileName, hashPlaceholder };
      }
      getPreliminarySourcemapFileName() {
        if (this.preliminarySourcemapFileName) {
          return this.preliminarySourcemapFileName;
        }
        let sourcemapFileName = null;
        let hashPlaceholder = null;
        const { sourcemapFileNames, format: format5 } = this.outputOptions;
        if (sourcemapFileNames) {
          const [pattern, patternName] = [sourcemapFileNames, "output.sourcemapFileNames"];
          sourcemapFileName = renderNamePattern(typeof pattern === "function" ? pattern(this.getPreRenderedChunkInfo()) : pattern, patternName, {
            chunkhash: () => this.getPreliminaryFileName().hashPlaceholder || "",
            format: () => format5,
            hash: (size16) => hashPlaceholder || (hashPlaceholder = this.getPlaceholder(patternName, size16 || DEFAULT_HASH_SIZE)),
            name: () => this.getChunkName()
          });
          if (!hashPlaceholder) {
            sourcemapFileName = makeUnique(sourcemapFileName, this.bundle);
          }
        } else {
          return null;
        }
        return this.preliminarySourcemapFileName = { fileName: sourcemapFileName, hashPlaceholder };
      }
      getRenderedChunkInfo() {
        if (this.renderedChunkInfo) {
          return this.renderedChunkInfo;
        }
        return this.renderedChunkInfo = {
          ...this.getPreRenderedChunkInfo(),
          dynamicImports: this.getDynamicDependencies().map(resolveFileName),
          fileName: this.getFileName(),
          implicitlyLoadedBefore: Array.from(this.implicitlyLoadedBefore, resolveFileName),
          importedBindings: getImportedBindingsPerDependency(this.getRenderedDependencies(), resolveFileName),
          imports: Array.from(this.dependencies, resolveFileName),
          modules: this.renderedModules,
          referencedFiles: this.getReferencedFiles()
        };
      }
      getVariableExportName(variable) {
        if (this.outputOptions.preserveModules && variable instanceof NamespaceVariable) {
          return "*";
        }
        return this.exportNamesByVariable.get(variable)[0];
      }
      link() {
        this.dependencies = getStaticDependencies(this, this.orderedModules, this.chunkByModule, this.externalChunkByModule);
        for (const module of this.orderedModules) {
          this.addImplicitlyLoadedBeforeFromModule(module);
          this.setUpChunkImportsAndExportsForModule(module);
        }
      }
      inlineTransitiveImports() {
        const { facadeModule, dependencies, outputOptions } = this;
        const { hoistTransitiveImports, preserveModules } = outputOptions;
        if (hoistTransitiveImports && !preserveModules && facadeModule !== null) {
          for (const dep of dependencies) {
            if (dep instanceof _Chunk)
              this.inlineChunkDependencies(dep);
          }
        }
      }
      async render() {
        const { exportMode, facadeModule, inputOptions: { onLog }, outputOptions, pluginDriver, snippets } = this;
        const { format: format5, preserveModules } = outputOptions;
        const preliminaryFileName = this.getPreliminaryFileName();
        const preliminarySourcemapFileName = this.getPreliminarySourcemapFileName();
        const { accessedGlobals, indent, magicString, renderedSource, usedModules, usesTopLevelAwait } = this.renderModules(preliminaryFileName.fileName);
        const renderedDependencies = [...this.getRenderedDependencies().values()];
        const renderedExports = exportMode === "none" ? [] : this.getChunkExportDeclarations(format5);
        let hasExports = renderedExports.length > 0;
        let hasDefaultExport = false;
        for (const renderedDependency of renderedDependencies) {
          const { reexports } = renderedDependency;
          if (reexports?.length) {
            hasExports = true;
            if (!hasDefaultExport && reexports.some((reexport) => reexport.reexported === "default")) {
              hasDefaultExport = true;
            }
            if (format5 === "es") {
              renderedDependency.reexports = reexports.filter(({ reexported }) => !renderedExports.find(({ exported }) => exported === reexported));
            }
          }
        }
        if (!hasDefaultExport) {
          for (const { exported } of renderedExports) {
            if (exported === "default") {
              hasDefaultExport = true;
              break;
            }
          }
        }
        const { intro, outro, banner, footer } = await createAddons(outputOptions, pluginDriver, this.getRenderedChunkInfo());
        finalisers[format5](renderedSource, {
          accessedGlobals,
          dependencies: renderedDependencies,
          exports: renderedExports,
          hasDefaultExport,
          hasExports,
          id: preliminaryFileName.fileName,
          indent,
          intro,
          isEntryFacade: preserveModules || facadeModule !== null && facadeModule.info.isEntry,
          isModuleFacade: facadeModule !== null,
          log: onLog,
          namedExportsMode: exportMode !== "default",
          outro,
          snippets,
          usesTopLevelAwait
        }, outputOptions);
        if (banner)
          magicString.prepend(banner);
        if (format5 === "es" || format5 === "cjs") {
          const shebang = facadeModule !== null && facadeModule.info.isEntry && facadeModule.shebang;
          if (shebang) {
            magicString.prepend(`#!${shebang}
`);
          }
        }
        if (footer)
          magicString.append(footer);
        return {
          chunk: this,
          magicString,
          preliminaryFileName,
          preliminarySourcemapFileName,
          usedModules
        };
      }
      addImplicitlyLoadedBeforeFromModule(baseModule) {
        const { chunkByModule, implicitlyLoadedBefore } = this;
        for (const module of baseModule.implicitlyLoadedBefore) {
          const chunk5 = chunkByModule.get(module);
          if (chunk5 && chunk5 !== this) {
            implicitlyLoadedBefore.add(chunk5);
          }
        }
      }
      addNecessaryImportsForFacades() {
        for (const [module, variables] of this.includedReexportsByModule) {
          if (this.includedNamespaces.has(module)) {
            for (const variable of variables) {
              this.imports.add(variable);
            }
          }
        }
      }
      assignFacadeName({ fileName, name }, facadedModule, preservePath) {
        if (fileName) {
          this.fileName = fileName;
        } else {
          this.name = this.outputOptions.sanitizeFileName(name || (preservePath ? this.getPreserveModulesChunkNameFromModule(facadedModule) : getChunkNameFromModule(facadedModule)));
        }
      }
      checkCircularDependencyImport(variable, importingModule) {
        const variableModule = variable.module;
        if (variableModule instanceof Module) {
          const exportChunk = this.chunkByModule.get(variableModule);
          let alternativeReexportModule;
          do {
            alternativeReexportModule = importingModule.alternativeReexportModules.get(variable);
            if (alternativeReexportModule) {
              const exportingChunk = this.chunkByModule.get(alternativeReexportModule);
              if (exportingChunk !== exportChunk) {
                this.inputOptions.onLog(LOGLEVEL_WARN, logCyclicCrossChunkReexport(
                  // Namespaces do not have an export name
                  variableModule.getExportNamesByVariable().get(variable)?.[0] || "*",
                  variableModule.id,
                  alternativeReexportModule.id,
                  importingModule.id,
                  this.outputOptions.preserveModules
                ));
              }
              importingModule = alternativeReexportModule;
            }
          } while (alternativeReexportModule);
        }
      }
      ensureReexportsAreAvailableForModule(module) {
        const includedReexports = [];
        const map26 = module.getExportNamesByVariable();
        for (const exportedVariable of map26.keys()) {
          const isSynthetic = exportedVariable instanceof SyntheticNamedExportVariable;
          const importedVariable = isSynthetic ? exportedVariable.getBaseVariable() : exportedVariable;
          this.checkCircularDependencyImport(importedVariable, module);
          if (!(importedVariable instanceof NamespaceVariable && this.outputOptions.preserveModules)) {
            const exportingModule = importedVariable.module;
            if (exportingModule instanceof Module) {
              const chunk5 = this.chunkByModule.get(exportingModule);
              if (chunk5 && chunk5 !== this) {
                chunk5.exports.add(importedVariable);
                includedReexports.push(importedVariable);
                if (isSynthetic) {
                  this.imports.add(importedVariable);
                }
              }
            }
          }
        }
        if (includedReexports.length > 0) {
          this.includedReexportsByModule.set(module, includedReexports);
        }
      }
      generateVariableName() {
        if (this.manualChunkAlias) {
          return this.manualChunkAlias;
        }
        const moduleForNaming = this.entryModules[0] || this.implicitEntryModules[0] || this.dynamicEntryModules[0] || this.orderedModules[this.orderedModules.length - 1];
        if (moduleForNaming) {
          return getChunkNameFromModule(moduleForNaming);
        }
        return "chunk";
      }
      getChunkExportDeclarations(format5) {
        const exports = [];
        for (const exportName of this.getExportNames()) {
          if (exportName[0] === "*")
            continue;
          const variable = this.exportsByName.get(exportName);
          if (!(variable instanceof SyntheticNamedExportVariable)) {
            const module = variable.module;
            if (module) {
              const chunk5 = this.chunkByModule.get(module);
              if (chunk5 !== this) {
                if (!chunk5 || format5 !== "es") {
                  continue;
                }
                const chunkDep = this.renderedDependencies.get(chunk5);
                if (!chunkDep) {
                  continue;
                }
                const { imports, reexports } = chunkDep;
                const importedByReexported = reexports?.find(({ reexported }) => reexported === exportName);
                const isImported = imports?.find(({ imported }) => imported === importedByReexported?.imported);
                if (!isImported) {
                  continue;
                }
              }
            }
          }
          let expression = null;
          let hoisted = false;
          let local = variable.getName(this.snippets.getPropertyAccess);
          if (variable instanceof LocalVariable) {
            for (const declaration of variable.declarations) {
              if (declaration.parent instanceof FunctionDeclaration || declaration instanceof ExportDefaultDeclaration2 && declaration.declaration instanceof FunctionDeclaration) {
                hoisted = true;
                break;
              }
            }
          } else if (variable instanceof SyntheticNamedExportVariable) {
            expression = local;
            if (format5 === "es") {
              local = variable.renderName;
            }
          }
          exports.push({
            exported: exportName,
            expression,
            hoisted,
            local
          });
        }
        return exports;
      }
      getDependenciesToBeDeconflicted(addNonNamespacesAndInteropHelpers, addDependenciesWithoutBindings, interop) {
        const dependencies = /* @__PURE__ */ new Set();
        const deconflictedDefault = /* @__PURE__ */ new Set();
        const deconflictedNamespace = /* @__PURE__ */ new Set();
        for (const variable of [...this.exportNamesByVariable.keys(), ...this.imports]) {
          if (addNonNamespacesAndInteropHelpers || variable.isNamespace) {
            const module = variable.module;
            if (module instanceof ExternalModule) {
              const chunk5 = this.externalChunkByModule.get(module);
              dependencies.add(chunk5);
              if (addNonNamespacesAndInteropHelpers) {
                if (variable.name === "default") {
                  if (defaultInteropHelpersByInteropType[interop(module.id)]) {
                    deconflictedDefault.add(chunk5);
                  }
                } else if (variable.isNamespace && namespaceInteropHelpersByInteropType[interop(module.id)] && (this.imports.has(variable) || !this.exportNamesByVariable.get(variable)?.every((name) => name.startsWith("*")))) {
                  deconflictedNamespace.add(chunk5);
                }
              }
            } else {
              const chunk5 = this.chunkByModule.get(module);
              if (chunk5 !== this) {
                dependencies.add(chunk5);
                if (addNonNamespacesAndInteropHelpers && chunk5.exportMode === "default" && variable.isNamespace) {
                  deconflictedNamespace.add(chunk5);
                }
              }
            }
          }
        }
        if (addDependenciesWithoutBindings) {
          for (const dependency of this.dependencies) {
            dependencies.add(dependency);
          }
        }
        return { deconflictedDefault, deconflictedNamespace, dependencies };
      }
      getDynamicDependencies() {
        return this.getIncludedDynamicImports().map((resolvedDynamicImport) => resolvedDynamicImport.facadeChunk || resolvedDynamicImport.chunk || resolvedDynamicImport.externalChunk || resolvedDynamicImport.resolution).filter((resolution) => resolution !== this && (resolution instanceof _Chunk || resolution instanceof ExternalChunk));
      }
      getDynamicImportStringAndAttributes(resolution, fileName, node) {
        if (resolution instanceof ExternalModule) {
          const chunk5 = this.externalChunkByModule.get(resolution);
          return [`'${chunk5.getImportPath(fileName)}'`, chunk5.getImportAttributes(this.snippets)];
        }
        let attributes = null;
        if (["es", "cjs"].includes(this.outputOptions.format) && this.outputOptions.externalImportAttributes) {
          const attributesFromImportAttributes = getAttributesFromImportExpression(node);
          attributes = attributesFromImportAttributes === EMPTY_OBJECT ? true : formatAttributes2(attributesFromImportAttributes, this.snippets);
        }
        return [resolution || "", attributes];
      }
      getFallbackChunkName() {
        if (this.manualChunkAlias) {
          return this.manualChunkAlias;
        }
        if (this.dynamicName) {
          return this.dynamicName;
        }
        if (this.fileName) {
          return getAliasName(this.fileName);
        }
        return getAliasName(this.orderedModules[this.orderedModules.length - 1].id);
      }
      getImportSpecifiers() {
        const { interop } = this.outputOptions;
        const importsByDependency = /* @__PURE__ */ new Map();
        for (const variable of this.imports) {
          const module = variable.module;
          let dependency;
          let imported;
          if (module instanceof ExternalModule) {
            dependency = this.externalChunkByModule.get(module);
            imported = variable.name;
            if (imported !== "default" && imported !== "*" && interop(module.id) === "defaultOnly") {
              return error3(logUnexpectedNamedImport(module.id, imported, false));
            }
          } else {
            dependency = this.chunkByModule.get(module);
            imported = dependency.getVariableExportName(variable);
          }
          getOrCreate(importsByDependency, dependency, getNewArray).push({
            imported,
            local: variable.getName(this.snippets.getPropertyAccess)
          });
        }
        return importsByDependency;
      }
      getIncludedDynamicImports() {
        if (this.includedDynamicImports) {
          return this.includedDynamicImports;
        }
        const includedDynamicImports = [];
        for (const module of this.orderedModules) {
          for (const { node, resolution } of module.dynamicImports) {
            if (!node.included) {
              continue;
            }
            includedDynamicImports.push(resolution instanceof Module ? {
              chunk: this.chunkByModule.get(resolution),
              externalChunk: null,
              facadeChunk: this.facadeChunkByModule.get(resolution),
              node,
              resolution
            } : resolution instanceof ExternalModule ? {
              chunk: null,
              externalChunk: this.externalChunkByModule.get(resolution),
              facadeChunk: null,
              node,
              resolution
            } : { chunk: null, externalChunk: null, facadeChunk: null, node, resolution });
          }
        }
        return this.includedDynamicImports = includedDynamicImports;
      }
      getPreRenderedChunkInfo() {
        if (this.preRenderedChunkInfo) {
          return this.preRenderedChunkInfo;
        }
        const { dynamicEntryModules, facadeModule, implicitEntryModules, orderedModules } = this;
        return this.preRenderedChunkInfo = {
          exports: this.getExportNames(),
          facadeModuleId: facadeModule && facadeModule.id,
          isDynamicEntry: dynamicEntryModules.length > 0,
          isEntry: !!facadeModule?.info.isEntry,
          isImplicitEntry: implicitEntryModules.length > 0,
          moduleIds: orderedModules.map(({ id: id2 }) => id2),
          name: this.getChunkName(),
          type: "chunk"
        };
      }
      getPreserveModulesChunkNameFromModule(module) {
        const predefinedChunkName = getPredefinedChunkNameFromModule(module);
        if (predefinedChunkName)
          return predefinedChunkName;
        const { preserveModulesRoot, sanitizeFileName: sanitizeFileName2 } = this.outputOptions;
        const sanitizedId = sanitizeFileName2(normalize2(module.id.split(QUERY_HASH_REGEX, 1)[0]));
        const extensionName = p2.extname(sanitizedId);
        const idWithoutExtension = NON_ASSET_EXTENSIONS.has(extensionName) ? sanitizedId.slice(0, -extensionName.length) : sanitizedId;
        if (isAbsolute2(idWithoutExtension)) {
          if (preserveModulesRoot && p2.resolve(idWithoutExtension).startsWith(preserveModulesRoot)) {
            return idWithoutExtension.slice(preserveModulesRoot.length).replace(/^[/\\]/, "");
          } else {
            if (this.inputBase === "/" && !idWithoutExtension.startsWith("/")) {
              return relative(this.inputBase, idWithoutExtension.replace(/^[a-zA-Z]:[/\\]/, "/"));
            }
            return relative(this.inputBase, idWithoutExtension);
          }
        } else {
          return this.outputOptions.virtualDirname.replace(/\/$/, "") + "/" + p2.basename(idWithoutExtension);
        }
      }
      getReexportSpecifiers() {
        const { externalLiveBindings, interop } = this.outputOptions;
        const reexportSpecifiers = /* @__PURE__ */ new Map();
        for (let exportName of this.getExportNames()) {
          let dependency;
          let imported;
          let needsLiveBinding = false;
          if (exportName[0] === "*") {
            const id2 = exportName.slice(1);
            if (interop(id2) === "defaultOnly") {
              this.inputOptions.onLog(LOGLEVEL_WARN, logUnexpectedNamespaceReexport(id2));
            }
            needsLiveBinding = externalLiveBindings;
            dependency = this.externalChunkByModule.get(this.modulesById.get(id2));
            imported = exportName = "*";
          } else {
            const variable = this.exportsByName.get(exportName);
            if (variable instanceof SyntheticNamedExportVariable)
              continue;
            const module = variable.module;
            if (module instanceof Module) {
              dependency = this.chunkByModule.get(module);
              if (dependency === this)
                continue;
              imported = dependency.getVariableExportName(variable);
              needsLiveBinding = variable.isReassigned;
            } else {
              dependency = this.externalChunkByModule.get(module);
              imported = variable.name;
              if (imported !== "default" && imported !== "*" && interop(module.id) === "defaultOnly") {
                return error3(logUnexpectedNamedImport(module.id, imported, true));
              }
              needsLiveBinding = externalLiveBindings && (imported !== "default" || isDefaultAProperty(interop(module.id), true));
            }
          }
          getOrCreate(reexportSpecifiers, dependency, getNewArray).push({
            imported,
            needsLiveBinding,
            reexported: exportName
          });
        }
        return reexportSpecifiers;
      }
      getReferencedFiles() {
        const referencedFiles = /* @__PURE__ */ new Set();
        for (const module of this.orderedModules) {
          for (const meta of module.importMetas) {
            const fileName = meta.getReferencedFileName(this.pluginDriver);
            if (fileName) {
              referencedFiles.add(fileName);
            }
          }
        }
        return [...referencedFiles];
      }
      getRenderedDependencies() {
        if (this.renderedDependencies) {
          return this.renderedDependencies;
        }
        const importSpecifiers = this.getImportSpecifiers();
        const reexportSpecifiers = this.getReexportSpecifiers();
        const renderedDependencies = /* @__PURE__ */ new Map();
        const fileName = this.getFileName();
        for (const dependency of this.dependencies) {
          const imports = importSpecifiers.get(dependency) || null;
          const reexports = reexportSpecifiers.get(dependency) || null;
          const namedExportsMode = dependency instanceof ExternalChunk || dependency.exportMode !== "default";
          const importPath = dependency.getImportPath(fileName);
          renderedDependencies.set(dependency, {
            attributes: dependency instanceof ExternalChunk ? dependency.getImportAttributes(this.snippets) : null,
            defaultVariableName: dependency.defaultVariableName,
            globalName: dependency instanceof ExternalChunk && (this.outputOptions.format === "umd" || this.outputOptions.format === "iife") && getGlobalName(dependency, this.outputOptions.globals, (imports || reexports) !== null, this.inputOptions.onLog),
            importPath,
            imports,
            isChunk: dependency instanceof _Chunk,
            name: dependency.variableName,
            namedExportsMode,
            namespaceVariableName: dependency.namespaceVariableName,
            reexports
          });
        }
        return this.renderedDependencies = renderedDependencies;
      }
      inlineChunkDependencies(chunk5) {
        for (const dep of chunk5.dependencies) {
          if (this.dependencies.has(dep))
            continue;
          this.dependencies.add(dep);
          if (dep instanceof _Chunk) {
            this.inlineChunkDependencies(dep);
          }
        }
      }
      // This method changes properties on the AST before rendering and must not be async
      renderModules(fileName) {
        const { accessedGlobalsByScope, dependencies, exportNamesByVariable, includedNamespaces, inputOptions: { onLog }, isEmpty: isEmpty15, orderedModules, outputOptions, pluginDriver, renderedModules, snippets } = this;
        const { compact: compact2, format: format5, freeze, generatedCode: { symbols }, importAttributesKey } = outputOptions;
        const { _: _2, cnst, n: n2 } = snippets;
        this.setDynamicImportResolutions(fileName);
        this.setImportMetaResolutions(fileName);
        this.setIdentifierRenderResolutions();
        const magicString = new Bundle$1({ separator: `${n2}${n2}` });
        const indent = getIndentString(orderedModules, outputOptions);
        const usedModules = [];
        let hoistedSource = "";
        const accessedGlobals = /* @__PURE__ */ new Set();
        const renderedModuleSources = /* @__PURE__ */ new Map();
        const renderOptions = {
          accessedDocumentCurrentScript: false,
          exportNamesByVariable,
          format: format5,
          freeze,
          importAttributesKey,
          indent,
          pluginDriver,
          snippets,
          symbols,
          useOriginalName: null
        };
        let usesTopLevelAwait = false;
        for (const module of orderedModules) {
          let renderedLength = 0;
          let source;
          if (module.isIncluded() || includedNamespaces.has(module)) {
            const rendered = module.render(renderOptions);
            if (!renderOptions.accessedDocumentCurrentScript && formatsMaybeAccessDocumentCurrentScript.includes(format5)) {
              this.accessedGlobalsByScope.get(module.scope)?.delete(DOCUMENT_CURRENT_SCRIPT);
            }
            renderOptions.accessedDocumentCurrentScript = false;
            ({ source } = rendered);
            usesTopLevelAwait ||= rendered.usesTopLevelAwait;
            renderedLength = source.length();
            if (renderedLength) {
              if (compact2 && source.lastLine().includes("//"))
                source.append("\n");
              renderedModuleSources.set(module, source);
              magicString.addSource(source);
              usedModules.push(module);
            }
            const namespace = module.namespace;
            if (includedNamespaces.has(module)) {
              const rendered2 = namespace.renderBlock(renderOptions);
              if (namespace.renderFirst())
                hoistedSource += n2 + rendered2;
              else
                magicString.addSource(new MagicString(rendered2));
            }
            const accessedGlobalVariables = accessedGlobalsByScope.get(module.scope);
            if (accessedGlobalVariables) {
              for (const name of accessedGlobalVariables) {
                accessedGlobals.add(name);
              }
            }
          }
          const { renderedExports, removedExports } = module.getRenderedExports();
          renderedModules[module.id] = {
            get code() {
              return source?.toString() ?? null;
            },
            originalLength: module.originalCode.length,
            removedExports,
            renderedExports,
            renderedLength
          };
        }
        if (hoistedSource)
          magicString.prepend(hoistedSource + n2 + n2);
        if (this.needsExportsShim) {
          magicString.prepend(`${n2}${cnst} ${MISSING_EXPORT_SHIM_VARIABLE}${_2}=${_2}void 0;${n2}${n2}`);
        }
        const renderedSource = compact2 ? magicString : magicString.trim();
        if (isEmpty15 && this.getExportNames().length === 0 && dependencies.size === 0) {
          onLog(LOGLEVEL_WARN, logEmptyChunk(this.getChunkName()));
        }
        return { accessedGlobals, indent, magicString, renderedSource, usedModules, usesTopLevelAwait };
      }
      setDynamicImportResolutions(fileName) {
        const { accessedGlobalsByScope, outputOptions, pluginDriver, snippets } = this;
        for (const resolvedDynamicImport of this.getIncludedDynamicImports()) {
          if (resolvedDynamicImport.chunk) {
            const { chunk: chunk5, facadeChunk, node, resolution } = resolvedDynamicImport;
            if (chunk5 === this) {
              node.setInternalResolution(resolution.namespace);
            } else {
              node.setExternalResolution((facadeChunk || chunk5).exportMode, resolution, outputOptions, snippets, pluginDriver, accessedGlobalsByScope, `'${(facadeChunk || chunk5).getImportPath(fileName)}'`, !facadeChunk?.strictFacade && chunk5.exportNamesByVariable.get(resolution.namespace)[0], null, this, facadeChunk || chunk5);
            }
          } else {
            const { node, resolution } = resolvedDynamicImport;
            const [resolutionString, attributes] = this.getDynamicImportStringAndAttributes(resolution, fileName, node);
            node.setExternalResolution("external", resolution, outputOptions, snippets, pluginDriver, accessedGlobalsByScope, resolutionString, false, attributes, this, null);
          }
        }
      }
      setIdentifierRenderResolutions() {
        const { format: format5, generatedCode: { symbols }, interop, preserveModules, externalLiveBindings } = this.outputOptions;
        const syntheticExports = /* @__PURE__ */ new Set();
        for (const exportName of this.getExportNames()) {
          const exportVariable = this.exportsByName.get(exportName);
          if (format5 !== "es" && format5 !== "system" && exportVariable.isReassigned && !exportVariable.isId) {
            exportVariable.setRenderNames("exports", exportName);
          } else if (exportVariable instanceof SyntheticNamedExportVariable) {
            syntheticExports.add(exportVariable);
          } else {
            exportVariable.setRenderNames(null, null);
          }
        }
        for (const module of this.orderedModules) {
          if (module.needsExportShim) {
            this.needsExportsShim = true;
            break;
          }
        }
        const usedNames = /* @__PURE__ */ new Set(["Object", "Promise"]);
        if (this.needsExportsShim) {
          usedNames.add(MISSING_EXPORT_SHIM_VARIABLE);
        }
        if (symbols) {
          usedNames.add("Symbol");
        }
        switch (format5) {
          case "system": {
            usedNames.add("module").add("exports");
            break;
          }
          case "es": {
            break;
          }
          case "cjs": {
            usedNames.add("module").add("require").add("__filename").add("__dirname");
          }
          // fallthrough
          default: {
            usedNames.add("exports");
            for (const helper of HELPER_NAMES) {
              usedNames.add(helper);
            }
          }
        }
        deconflictChunk(this.orderedModules, this.getDependenciesToBeDeconflicted(format5 !== "es" && format5 !== "system", format5 === "amd" || format5 === "umd" || format5 === "iife", interop), this.imports, usedNames, format5, interop, preserveModules, externalLiveBindings, this.chunkByModule, this.externalChunkByModule, syntheticExports, this.exportNamesByVariable, this.accessedGlobalsByScope, this.includedNamespaces);
      }
      setImportMetaResolutions(fileName) {
        const { accessedGlobalsByScope, includedNamespaces, orderedModules, outputOptions: { format: format5 } } = this;
        for (const module of orderedModules) {
          for (const importMeta of module.importMetas) {
            importMeta.setResolution(format5, accessedGlobalsByScope, fileName);
          }
          if (includedNamespaces.has(module)) {
            module.namespace.prepare(accessedGlobalsByScope);
          }
        }
      }
      setUpChunkImportsAndExportsForModule(module) {
        const moduleImports = new Set(module.includedImports);
        if (!this.outputOptions.preserveModules && this.includedNamespaces.has(module)) {
          const memberVariables = module.namespace.getMemberVariables();
          for (const variable of Object.values(memberVariables)) {
            if (variable.included) {
              moduleImports.add(variable);
            }
          }
        }
        for (let variable of moduleImports) {
          if (variable instanceof ExportDefaultVariable) {
            variable = variable.getOriginalVariable();
          }
          if (variable instanceof SyntheticNamedExportVariable) {
            variable = variable.getBaseVariable();
          }
          const chunk5 = this.chunkByModule.get(variable.module);
          if (chunk5 !== this) {
            this.imports.add(variable);
            if (variable.module instanceof Module) {
              this.checkCircularDependencyImport(variable, module);
              if (!(variable instanceof NamespaceVariable && this.outputOptions.preserveModules)) {
                chunk5.exports.add(variable);
              }
            }
          }
        }
        if (this.includedNamespaces.has(module) || module.info.isEntry && module.preserveSignature !== false || module.includedDynamicImporters.some((importer) => this.chunkByModule.get(importer) !== this)) {
          this.ensureReexportsAreAvailableForModule(module);
        }
        for (const { node, resolution } of module.dynamicImports) {
          if (node.included && resolution instanceof Module && this.chunkByModule.get(resolution) === this && !this.includedNamespaces.has(resolution)) {
            this.includedNamespaces.add(resolution);
            this.ensureReexportsAreAvailableForModule(resolution);
          }
        }
      }
    };
    QUERY_HASH_REGEX = /[#?]/;
    resolveFileName = (dependency) => dependency.getFileName();
    compareExecIndex = (unitA, unitB) => unitA.execIndex > unitB.execIndex ? 1 : -1;
    wrapIfNeeded = (code, needsParens) => needsParens ? `(${code})` : code;
    Source = class {
      constructor(filename, content) {
        this.isOriginal = true;
        this.filename = filename;
        this.content = content;
      }
      traceSegment(line, column, name) {
        return { column, line, name, source: this };
      }
    };
    Link = class {
      constructor(map26, sources) {
        this.sources = sources;
        this.names = map26.names;
        this.mappings = map26.mappings;
      }
      traceMappings() {
        const sources = [];
        const sourceIndexMap = /* @__PURE__ */ new Map();
        const sourcesContent = [];
        const names = [];
        const nameIndexMap = /* @__PURE__ */ new Map();
        const mappings = [];
        for (const line of this.mappings) {
          const tracedLine = [];
          for (const segment of line) {
            if (segment.length === 1)
              continue;
            const source = this.sources[segment[1]];
            if (!source)
              continue;
            const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : "");
            if (traced) {
              const { column, line: line2, name, source: { content, filename } } = traced;
              let sourceIndex2 = sourceIndexMap.get(filename);
              if (sourceIndex2 === void 0) {
                sourceIndex2 = sources.length;
                sources.push(filename);
                sourceIndexMap.set(filename, sourceIndex2);
                sourcesContent[sourceIndex2] = content;
              } else if (sourcesContent[sourceIndex2] == null) {
                sourcesContent[sourceIndex2] = content;
              } else if (content != null && sourcesContent[sourceIndex2] !== content) {
                return error3(logConflictingSourcemapSources(filename));
              }
              const tracedSegment = [segment[0], sourceIndex2, line2, column];
              if (name) {
                let nameIndex = nameIndexMap.get(name);
                if (nameIndex === void 0) {
                  nameIndex = names.length;
                  names.push(name);
                  nameIndexMap.set(name, nameIndex);
                }
                tracedSegment[4] = nameIndex;
              }
              tracedLine.push(tracedSegment);
            }
          }
          mappings.push(tracedLine);
        }
        return { mappings, names, sources, sourcesContent };
      }
      traceSegment(line, column, name) {
        const segments = this.mappings[line];
        if (!segments)
          return null;
        let searchStart = 0;
        let searchEnd = segments.length - 1;
        while (searchStart <= searchEnd) {
          const m2 = searchStart + searchEnd >> 1;
          const segment = segments[m2];
          if (segment[0] === column || searchStart === searchEnd) {
            if (segment.length == 1)
              return null;
            const source = this.sources[segment[1]];
            if (!source)
              return null;
            return source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : name);
          }
          if (segment[0] > column) {
            searchEnd = m2 - 1;
          } else {
            searchStart = m2 + 1;
          }
        }
        return null;
      }
    };
    getHash64 = (input2) => (0, import_native2.xxhashBase64Url)(ensureBuffer(input2));
    getHash36 = (input2) => (0, import_native2.xxhashBase36)(ensureBuffer(input2));
    getHash16 = (input2) => (0, import_native2.xxhashBase16)(ensureBuffer(input2));
    hasherByType = {
      base36: getHash36,
      base64: getHash64,
      hex: getHash16
    };
    SOURCEMAPPING_URL = "sourceMa";
    SOURCEMAPPING_URL += "ppingURL";
    Bundle2 = class {
      constructor(outputOptions, unsetOptions, inputOptions, pluginDriver, graph) {
        this.outputOptions = outputOptions;
        this.unsetOptions = unsetOptions;
        this.inputOptions = inputOptions;
        this.pluginDriver = pluginDriver;
        this.graph = graph;
        this.facadeChunkByModule = /* @__PURE__ */ new Map();
        this.includedNamespaces = /* @__PURE__ */ new Set();
      }
      async generate(isWrite) {
        timeStart("GENERATE", 1);
        const outputBundleBase = /* @__PURE__ */ Object.create(null);
        const outputBundle = getOutputBundle(outputBundleBase);
        this.pluginDriver.setOutputBundle(outputBundle, this.outputOptions);
        try {
          timeStart("initialize render", 2);
          await this.pluginDriver.hookParallel("renderStart", [this.outputOptions, this.inputOptions]);
          timeEnd("initialize render", 2);
          timeStart("generate chunks", 2);
          const getHashPlaceholder = getHashPlaceholderGenerator();
          const chunks3 = await this.generateChunks(outputBundle, getHashPlaceholder);
          if (chunks3.length > 1) {
            validateOptionsForMultiChunkOutput(this.outputOptions, this.inputOptions.onLog);
          }
          this.pluginDriver.setChunkInformation(this.facadeChunkByModule);
          for (const chunk5 of chunks3) {
            chunk5.generateExports();
            chunk5.inlineTransitiveImports();
          }
          timeEnd("generate chunks", 2);
          await renderChunks(chunks3, outputBundle, this.pluginDriver, this.outputOptions, this.inputOptions.onLog);
        } catch (error_) {
          await this.pluginDriver.hookParallel("renderError", [error_]);
          throw error_;
        }
        removeUnreferencedAssets(outputBundle);
        timeStart("generate bundle", 2);
        await this.pluginDriver.hookSeq("generateBundle", [
          this.outputOptions,
          outputBundle,
          isWrite
        ]);
        this.finaliseAssets(outputBundle);
        timeEnd("generate bundle", 2);
        timeEnd("GENERATE", 1);
        return outputBundleBase;
      }
      async addManualChunks(manualChunks) {
        const manualChunkAliasByEntry = /* @__PURE__ */ new Map();
        const chunkEntries = await Promise.all(Object.entries(manualChunks).map(async ([alias, files]) => ({
          alias,
          entries: await this.graph.moduleLoader.addAdditionalModules(files, true)
        })));
        for (const { alias, entries: entries2 } of chunkEntries) {
          for (const entry of entries2) {
            addModuleToManualChunk(alias, entry, manualChunkAliasByEntry);
          }
        }
        return manualChunkAliasByEntry;
      }
      assignManualChunks(getManualChunk) {
        const manualChunkAliasesWithEntry = [];
        const manualChunksApi = {
          getModuleIds: () => this.graph.modulesById.keys(),
          getModuleInfo: this.graph.getModuleInfo
        };
        for (const module of this.graph.modulesById.values()) {
          if (module instanceof Module) {
            const manualChunkAlias = getManualChunk(module.id, manualChunksApi);
            if (typeof manualChunkAlias === "string") {
              manualChunkAliasesWithEntry.push([manualChunkAlias, module]);
            }
          }
        }
        manualChunkAliasesWithEntry.sort(([aliasA], [aliasB]) => aliasA > aliasB ? 1 : aliasA < aliasB ? -1 : 0);
        const manualChunkAliasByEntry = /* @__PURE__ */ new Map();
        for (const [alias, module] of manualChunkAliasesWithEntry) {
          addModuleToManualChunk(alias, module, manualChunkAliasByEntry);
        }
        return manualChunkAliasByEntry;
      }
      finaliseAssets(bundle) {
        if (this.outputOptions.validate) {
          for (const file of Object.values(bundle)) {
            if ("code" in file) {
              try {
                parseAst(file.code, { jsx: this.inputOptions.jsx !== false });
              } catch (error_) {
                this.inputOptions.onLog(LOGLEVEL_WARN, logChunkInvalid(file, error_));
              }
            }
          }
        }
        this.pluginDriver.finaliseAssets();
      }
      async generateChunks(bundle, getHashPlaceholder) {
        const { experimentalMinChunkSize, inlineDynamicImports, manualChunks, preserveModules } = this.outputOptions;
        const manualChunkAliasByEntry = typeof manualChunks === "object" ? await this.addManualChunks(manualChunks) : this.assignManualChunks(manualChunks);
        const snippets = getGenerateCodeSnippets(this.outputOptions);
        const includedModules = getIncludedModules(this.graph.modulesById);
        const inputBase = commondir(getAbsoluteEntryModulePaths(includedModules, preserveModules));
        const externalChunkByModule = getExternalChunkByModule(this.graph.modulesById, this.outputOptions, inputBase);
        const executableModule = inlineDynamicImports ? [{ alias: null, modules: includedModules }] : preserveModules ? includedModules.map((module) => ({ alias: null, modules: [module] })) : getChunkAssignments(this.graph.entryModules, manualChunkAliasByEntry, experimentalMinChunkSize, this.inputOptions.onLog);
        const chunks3 = new Array(executableModule.length);
        const chunkByModule = /* @__PURE__ */ new Map();
        let index = 0;
        for (const { alias, modules } of executableModule) {
          sortByExecutionOrder(modules);
          const chunk5 = new Chunk2(modules, this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.graph.modulesById, chunkByModule, externalChunkByModule, this.facadeChunkByModule, this.includedNamespaces, alias, getHashPlaceholder, bundle, inputBase, snippets);
          chunks3[index++] = chunk5;
        }
        for (const chunk5 of chunks3) {
          chunk5.link();
        }
        const facades = [];
        for (const chunk5 of chunks3) {
          facades.push(...chunk5.generateFacades());
        }
        return [...chunks3, ...facades];
      }
    };
    GlobalScope = class extends Scope2 {
      constructor() {
        super();
        this.parent = null;
        this.variables.set("undefined", new UndefinedVariable());
      }
      findVariable(name) {
        let variable = this.variables.get(name);
        if (!variable) {
          variable = new GlobalVariable(name);
          this.variables.set(name, variable);
        }
        return variable;
      }
    };
    ANONYMOUS_PLUGIN_PREFIX = "at position ";
    ANONYMOUS_OUTPUT_PLUGIN_PREFIX = "at output position ";
    NO_CACHE = {
      delete() {
        return false;
      },
      get() {
        return void 0;
      },
      has() {
        return false;
      },
      set() {
      }
    };
    getOnLog = (config2, logLevel3, printLog = defaultPrintLog) => {
      const { onwarn, onLog } = config2;
      const defaultOnLog = getDefaultOnLog(printLog, onwarn);
      if (onLog) {
        const minimalPriority = logLevelPriority[logLevel3];
        return (level, log5) => onLog(level, addLogToString(log5), (level2, handledLog) => {
          if (level2 === LOGLEVEL_ERROR) {
            return error3(normalizeLog(handledLog));
          }
          if (logLevelPriority[level2] >= minimalPriority) {
            defaultOnLog(level2, normalizeLog(handledLog));
          }
        });
      }
      return defaultOnLog;
    };
    getDefaultOnLog = (printLog, onwarn) => onwarn ? (level, log5) => {
      if (level === LOGLEVEL_WARN) {
        onwarn(addLogToString(log5), (warning) => printLog(LOGLEVEL_WARN, normalizeLog(warning)));
      } else {
        printLog(level, log5);
      }
    } : printLog;
    addLogToString = (log5) => {
      Object.defineProperty(log5, "toString", {
        value: () => log5.message,
        writable: true
      });
      return log5;
    };
    normalizeLog = (log5) => typeof log5 === "string" ? { message: log5 } : typeof log5 === "function" ? normalizeLog(log5()) : log5;
    defaultPrintLog = (level, { message }) => {
      switch (level) {
        case LOGLEVEL_WARN: {
          return console.warn(message);
        }
        case LOGLEVEL_DEBUG: {
          return console.debug(message);
        }
        default: {
          return console.info(message);
        }
      }
    };
    treeshakePresets = {
      recommended: {
        annotations: true,
        correctVarValueBeforeDeclaration: false,
        manualPureFunctions: EMPTY_ARRAY,
        moduleSideEffects: () => true,
        propertyReadSideEffects: true,
        tryCatchDeoptimization: true,
        unknownGlobalSideEffects: false
      },
      safest: {
        annotations: true,
        correctVarValueBeforeDeclaration: true,
        manualPureFunctions: EMPTY_ARRAY,
        moduleSideEffects: () => true,
        propertyReadSideEffects: true,
        tryCatchDeoptimization: true,
        unknownGlobalSideEffects: true
      },
      smallest: {
        annotations: true,
        correctVarValueBeforeDeclaration: false,
        manualPureFunctions: EMPTY_ARRAY,
        moduleSideEffects: () => false,
        propertyReadSideEffects: false,
        tryCatchDeoptimization: false,
        unknownGlobalSideEffects: false
      }
    };
    jsxPresets = {
      preserve: {
        factory: null,
        fragment: null,
        importSource: null,
        mode: "preserve"
      },
      "preserve-react": {
        factory: "React.createElement",
        fragment: "React.Fragment",
        importSource: "react",
        mode: "preserve"
      },
      react: {
        factory: "React.createElement",
        fragment: "React.Fragment",
        importSource: "react",
        mode: "classic"
      },
      "react-jsx": {
        factory: "React.createElement",
        importSource: "react",
        jsxImportSource: "react/jsx-runtime",
        mode: "automatic"
      }
    };
    generatedCodePresets = {
      es2015: {
        arrowFunctions: true,
        constBindings: true,
        objectShorthand: true,
        reservedNamesAsProps: true,
        symbols: true
      },
      es5: {
        arrowFunctions: false,
        constBindings: false,
        objectShorthand: false,
        reservedNamesAsProps: true,
        symbols: false
      }
    };
    objectifyOption = (value) => value && typeof value === "object" ? value : {};
    objectifyOptionWithPresets = (presets, optionName, urlSnippet, additionalValues) => (value) => {
      if (typeof value === "string") {
        const preset = presets[value];
        if (preset) {
          return preset;
        }
        error3(logInvalidOption(optionName, urlSnippet, `valid values are ${additionalValues}${printQuotedStringList(Object.keys(presets))}. You can also supply an object for more fine-grained control`, value));
      }
      return objectifyOption(value);
    };
    getOptionWithPreset = (value, presets, optionName, urlSnippet, additionalValues) => {
      const presetName = value?.preset;
      if (presetName) {
        const preset = presets[presetName];
        if (preset) {
          return { ...preset, ...value };
        } else {
          error3(logInvalidOption(`${optionName}.preset`, urlSnippet, `valid values are ${printQuotedStringList(Object.keys(presets))}`, presetName));
        }
      }
      return objectifyOptionWithPresets(presets, optionName, urlSnippet, additionalValues)(value);
    };
    normalizePluginOption = async (plugins) => (await asyncFlatten([plugins])).filter(Boolean);
    RESOLVE_DEPENDENCIES = "resolveDependencies";
    ModuleLoader = class {
      constructor(graph, modulesById, options, pluginDriver) {
        this.graph = graph;
        this.modulesById = modulesById;
        this.options = options;
        this.pluginDriver = pluginDriver;
        this.implicitEntryModules = /* @__PURE__ */ new Set();
        this.indexedEntryModules = [];
        this.latestLoadModulesPromise = Promise.resolve();
        this.moduleLoadPromises = /* @__PURE__ */ new Map();
        this.modulesWithLoadedDependencies = /* @__PURE__ */ new Set();
        this.nextChunkNamePriority = 0;
        this.nextEntryModuleIndex = 0;
        this.resolveId = async (source, importer, customOptions, isEntry, attributes, skip = null) => this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(this.options.external(source, importer, false) ? false : await resolveId(source, importer, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, skip, customOptions, typeof isEntry === "boolean" ? isEntry : !importer, attributes), importer, source), attributes);
        this.hasModuleSideEffects = options.treeshake ? options.treeshake.moduleSideEffects : () => true;
      }
      async addAdditionalModules(unresolvedModules, isAddForManualChunks) {
        const result = this.extendLoadModulesPromise(Promise.all(unresolvedModules.map((id2) => this.loadEntryModule(id2, false, void 0, null, isAddForManualChunks))));
        await this.awaitLoadModulesPromise();
        return result;
      }
      async addEntryModules(unresolvedEntryModules, isUserDefined) {
        const firstEntryModuleIndex = this.nextEntryModuleIndex;
        this.nextEntryModuleIndex += unresolvedEntryModules.length;
        const firstChunkNamePriority = this.nextChunkNamePriority;
        this.nextChunkNamePriority += unresolvedEntryModules.length;
        const newEntryModules = await this.extendLoadModulesPromise(Promise.all(unresolvedEntryModules.map(({ id: id2, importer }) => this.loadEntryModule(id2, true, importer, null))).then((entryModules) => {
          for (const [index, entryModule] of entryModules.entries()) {
            entryModule.isUserDefinedEntryPoint = entryModule.isUserDefinedEntryPoint || isUserDefined;
            addChunkNamesToModule(entryModule, unresolvedEntryModules[index], isUserDefined, firstChunkNamePriority + index);
            const existingIndexedModule = this.indexedEntryModules.find((indexedModule) => indexedModule.module === entryModule);
            if (existingIndexedModule) {
              existingIndexedModule.index = Math.min(existingIndexedModule.index, firstEntryModuleIndex + index);
            } else {
              this.indexedEntryModules.push({
                index: firstEntryModuleIndex + index,
                module: entryModule
              });
            }
          }
          this.indexedEntryModules.sort(({ index: indexA }, { index: indexB }) => indexA > indexB ? 1 : -1);
          return entryModules;
        }));
        await this.awaitLoadModulesPromise();
        return {
          entryModules: this.indexedEntryModules.map(({ module }) => module),
          implicitEntryModules: [...this.implicitEntryModules],
          newEntryModules
        };
      }
      async emitChunk({ fileName, id: id2, importer, name, implicitlyLoadedAfterOneOf, preserveSignature }) {
        const unresolvedModule = {
          fileName: fileName || null,
          id: id2,
          importer,
          name: name || null
        };
        const module = implicitlyLoadedAfterOneOf ? await this.addEntryWithImplicitDependants(unresolvedModule, implicitlyLoadedAfterOneOf) : (await this.addEntryModules([unresolvedModule], false)).newEntryModules[0];
        if (preserveSignature != null) {
          module.preserveSignature = preserveSignature;
        }
        return module;
      }
      async preloadModule(resolvedId) {
        const module = await this.fetchModule(this.getResolvedIdWithDefaults(resolvedId, EMPTY_OBJECT), void 0, false, resolvedId.resolveDependencies ? RESOLVE_DEPENDENCIES : true);
        return module.info;
      }
      addEntryWithImplicitDependants(unresolvedModule, implicitlyLoadedAfter) {
        const chunkNamePriority = this.nextChunkNamePriority++;
        return this.extendLoadModulesPromise(this.loadEntryModule(unresolvedModule.id, false, unresolvedModule.importer, null).then(async (entryModule) => {
          addChunkNamesToModule(entryModule, unresolvedModule, false, chunkNamePriority);
          if (!entryModule.info.isEntry) {
            const implicitlyLoadedAfterModules = await Promise.all(implicitlyLoadedAfter.map((id2) => this.loadEntryModule(id2, false, unresolvedModule.importer, entryModule.id)));
            if (!entryModule.info.isEntry) {
              this.implicitEntryModules.add(entryModule);
              for (const module of implicitlyLoadedAfterModules) {
                entryModule.implicitlyLoadedAfter.add(module);
              }
              for (const dependant of entryModule.implicitlyLoadedAfter) {
                dependant.implicitlyLoadedBefore.add(entryModule);
              }
            }
          }
          return entryModule;
        }));
      }
      async addModuleSource(id2, importer, module) {
        let source;
        try {
          source = await this.graph.fileOperationQueue.run(async () => {
            const content = await this.pluginDriver.hookFirst("load", [id2]);
            if (content !== null)
              return content;
            this.graph.watchFiles[id2] = true;
            return await promises.readFile(id2, "utf8");
          });
        } catch (error_) {
          let message = `Could not load ${id2}`;
          if (importer)
            message += ` (imported by ${relativeId(importer)})`;
          message += `: ${error_.message}`;
          error_.message = message;
          throw error_;
        }
        const sourceDescription = typeof source === "string" ? { code: source } : source != null && typeof source === "object" && typeof source.code === "string" ? source : error3(logBadLoader(id2));
        sourceDescription.code = stripBom(sourceDescription.code);
        const cachedModule = this.graph.cachedModules.get(id2);
        if (cachedModule && !cachedModule.customTransformCache && cachedModule.originalCode === sourceDescription.code && !await this.pluginDriver.hookFirst("shouldTransformCachedModule", [
          {
            ast: cachedModule.ast,
            code: cachedModule.code,
            id: cachedModule.id,
            meta: cachedModule.meta,
            moduleSideEffects: cachedModule.moduleSideEffects,
            resolvedSources: cachedModule.resolvedIds,
            syntheticNamedExports: cachedModule.syntheticNamedExports
          }
        ])) {
          if (cachedModule.transformFiles) {
            for (const emittedFile of cachedModule.transformFiles)
              this.pluginDriver.emitFile(emittedFile);
          }
          await module.setSource(cachedModule);
        } else {
          module.updateOptions(sourceDescription);
          await module.setSource(await transform2(sourceDescription, module, this.pluginDriver, this.options.onLog));
        }
      }
      async awaitLoadModulesPromise() {
        let startingPromise;
        do {
          startingPromise = this.latestLoadModulesPromise;
          await startingPromise;
        } while (startingPromise !== this.latestLoadModulesPromise);
      }
      extendLoadModulesPromise(loadNewModulesPromise) {
        this.latestLoadModulesPromise = Promise.all([
          loadNewModulesPromise,
          this.latestLoadModulesPromise
        ]);
        this.latestLoadModulesPromise.catch(() => {
        });
        return loadNewModulesPromise;
      }
      async fetchDynamicDependencies(module, resolveDynamicImportPromises) {
        const dependencies = await Promise.all(resolveDynamicImportPromises.map((resolveDynamicImportPromise) => resolveDynamicImportPromise.then(async ([dynamicImport, resolvedId]) => {
          if (resolvedId === null)
            return null;
          if (typeof resolvedId === "string") {
            dynamicImport.resolution = resolvedId;
            return null;
          }
          return dynamicImport.resolution = await this.fetchResolvedDependency(relativeId(resolvedId.id), module.id, resolvedId);
        })));
        for (const dependency of dependencies) {
          if (dependency) {
            module.dynamicDependencies.add(dependency);
            dependency.dynamicImporters.push(module.id);
          }
        }
      }
      // If this is a preload, then this method always waits for the dependencies of
      // the module to be resolved.
      // Otherwise, if the module does not exist, it waits for the module and all
      // its dependencies to be loaded.
      // Otherwise, it returns immediately.
      async fetchModule({ attributes, id: id2, meta, moduleSideEffects, syntheticNamedExports }, importer, isEntry, isPreload) {
        const existingModule = this.modulesById.get(id2);
        if (existingModule instanceof Module) {
          if (importer && doAttributesDiffer(attributes, existingModule.info.attributes)) {
            this.options.onLog(LOGLEVEL_WARN, logInconsistentImportAttributes(existingModule.info.attributes, attributes, id2, importer));
          }
          await this.handleExistingModule(existingModule, isEntry, isPreload);
          return existingModule;
        }
        if (existingModule instanceof ExternalModule) {
          return error3(logExternalModulesCannotBeTransformedToModules(existingModule.id));
        }
        const module = new Module(this.graph, id2, this.options, isEntry, moduleSideEffects, syntheticNamedExports, meta, attributes);
        this.modulesById.set(id2, module);
        const loadPromise = this.addModuleSource(id2, importer, module).then(() => [
          this.getResolveStaticDependencyPromises(module),
          this.getResolveDynamicImportPromises(module),
          loadAndResolveDependenciesPromise
        ]);
        const loadAndResolveDependenciesPromise = waitForDependencyResolution(loadPromise).then(() => this.pluginDriver.hookParallel("moduleParsed", [module.info]));
        loadAndResolveDependenciesPromise.catch(() => {
        });
        this.moduleLoadPromises.set(module, loadPromise);
        const resolveDependencyPromises = await loadPromise;
        if (!isPreload) {
          await this.fetchModuleDependencies(module, ...resolveDependencyPromises);
        } else if (isPreload === RESOLVE_DEPENDENCIES) {
          await loadAndResolveDependenciesPromise;
        }
        return module;
      }
      async fetchModuleDependencies(module, resolveStaticDependencyPromises, resolveDynamicDependencyPromises, loadAndResolveDependenciesPromise) {
        if (this.modulesWithLoadedDependencies.has(module)) {
          return;
        }
        this.modulesWithLoadedDependencies.add(module);
        await Promise.all([
          this.fetchStaticDependencies(module, resolveStaticDependencyPromises),
          this.fetchDynamicDependencies(module, resolveDynamicDependencyPromises)
        ]);
        module.linkImports();
        await loadAndResolveDependenciesPromise;
      }
      fetchResolvedDependency(source, importer, resolvedId) {
        if (resolvedId.external) {
          const { attributes, external, id: id2, moduleSideEffects, meta } = resolvedId;
          let externalModule = this.modulesById.get(id2);
          if (!externalModule) {
            externalModule = new ExternalModule(this.options, id2, moduleSideEffects, meta, external !== "absolute" && isAbsolute2(id2), attributes);
            this.modulesById.set(id2, externalModule);
          } else if (!(externalModule instanceof ExternalModule)) {
            return error3(logInternalIdCannotBeExternal(source, importer));
          } else if (doAttributesDiffer(externalModule.info.attributes, attributes)) {
            this.options.onLog(LOGLEVEL_WARN, logInconsistentImportAttributes(externalModule.info.attributes, attributes, source, importer));
          }
          return Promise.resolve(externalModule);
        }
        return this.fetchModule(resolvedId, importer, false, false);
      }
      async fetchStaticDependencies(module, resolveStaticDependencyPromises) {
        for (const dependency of await Promise.all(resolveStaticDependencyPromises.map((resolveStaticDependencyPromise) => resolveStaticDependencyPromise.then(([source, resolvedId]) => this.fetchResolvedDependency(source, module.id, resolvedId))))) {
          module.dependencies.add(dependency);
          dependency.importers.push(module.id);
        }
        if (!this.options.treeshake || module.info.moduleSideEffects === "no-treeshake") {
          for (const dependency of module.dependencies) {
            if (dependency instanceof Module) {
              dependency.importedFromNotTreeshaken = true;
            }
          }
        }
      }
      getNormalizedResolvedIdWithoutDefaults(resolveIdResult, importer, source) {
        const { makeAbsoluteExternalsRelative } = this.options;
        if (resolveIdResult) {
          if (typeof resolveIdResult === "object") {
            const external2 = resolveIdResult.external || this.options.external(resolveIdResult.id, importer, true);
            return {
              ...resolveIdResult,
              external: external2 && (external2 === "relative" || !isAbsolute2(resolveIdResult.id) || external2 === true && isNotAbsoluteExternal(resolveIdResult.id, source, makeAbsoluteExternalsRelative) || "absolute")
            };
          }
          const external = this.options.external(resolveIdResult, importer, true);
          return {
            external: external && (isNotAbsoluteExternal(resolveIdResult, source, makeAbsoluteExternalsRelative) || "absolute"),
            id: external && makeAbsoluteExternalsRelative ? normalizeRelativeExternalId(resolveIdResult, importer) : resolveIdResult
          };
        }
        const id2 = makeAbsoluteExternalsRelative ? normalizeRelativeExternalId(source, importer) : source;
        if (resolveIdResult !== false && !this.options.external(id2, importer, true)) {
          return null;
        }
        return {
          external: isNotAbsoluteExternal(id2, source, makeAbsoluteExternalsRelative) || "absolute",
          id: id2
        };
      }
      getResolveDynamicImportPromises(module) {
        return module.dynamicImports.map(async (dynamicImport) => {
          const resolvedId = await this.resolveDynamicImport(module, dynamicImport.argument, module.id, getAttributesFromImportExpression(dynamicImport.node));
          if (resolvedId && typeof resolvedId === "object") {
            dynamicImport.id = resolvedId.id;
          }
          return [dynamicImport, resolvedId];
        });
      }
      getResolveStaticDependencyPromises(module) {
        return Array.from(module.sourcesWithAttributes, async ([source, attributes]) => [
          source,
          module.resolvedIds[source] = module.resolvedIds[source] || this.handleInvalidResolvedId(await this.resolveId(source, module.id, EMPTY_OBJECT, false, attributes), source, module.id, attributes)
        ]);
      }
      getResolvedIdWithDefaults(resolvedId, attributes) {
        if (!resolvedId) {
          return null;
        }
        const external = resolvedId.external || false;
        return {
          attributes: resolvedId.attributes || attributes,
          external,
          id: resolvedId.id,
          meta: resolvedId.meta || {},
          moduleSideEffects: resolvedId.moduleSideEffects ?? this.hasModuleSideEffects(resolvedId.id, !!external),
          resolvedBy: resolvedId.resolvedBy ?? "rollup",
          syntheticNamedExports: resolvedId.syntheticNamedExports ?? false
        };
      }
      async handleExistingModule(module, isEntry, isPreload) {
        const loadPromise = this.moduleLoadPromises.get(module);
        if (isPreload) {
          return isPreload === RESOLVE_DEPENDENCIES ? waitForDependencyResolution(loadPromise) : loadPromise;
        }
        if (isEntry) {
          module.info.isEntry = true;
          this.implicitEntryModules.delete(module);
          for (const dependant of module.implicitlyLoadedAfter) {
            dependant.implicitlyLoadedBefore.delete(module);
          }
          module.implicitlyLoadedAfter.clear();
        }
        return this.fetchModuleDependencies(module, ...await loadPromise);
      }
      handleInvalidResolvedId(resolvedId, source, importer, attributes) {
        if (resolvedId === null) {
          if (isRelative2(source)) {
            return error3(logUnresolvedImport(source, importer));
          }
          this.options.onLog(LOGLEVEL_WARN, logUnresolvedImportTreatedAsExternal(source, importer));
          return {
            attributes,
            external: true,
            id: source,
            meta: {},
            moduleSideEffects: this.hasModuleSideEffects(source, true),
            resolvedBy: "rollup",
            syntheticNamedExports: false
          };
        } else if (resolvedId.external && resolvedId.syntheticNamedExports) {
          this.options.onLog(LOGLEVEL_WARN, logExternalSyntheticExports(source, importer));
        }
        return resolvedId;
      }
      async loadEntryModule(unresolvedId, isEntry, importer, implicitlyLoadedBefore, isLoadForManualChunks = false) {
        const resolveIdResult = await resolveId(unresolvedId, importer, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, null, EMPTY_OBJECT, true, EMPTY_OBJECT);
        if (resolveIdResult == null) {
          return error3(implicitlyLoadedBefore === null ? logUnresolvedEntry(unresolvedId) : logUnresolvedImplicitDependant(unresolvedId, implicitlyLoadedBefore));
        }
        const isExternalModules = typeof resolveIdResult === "object" && resolveIdResult.external;
        if (resolveIdResult === false || isExternalModules) {
          return error3(implicitlyLoadedBefore === null ? isExternalModules && isLoadForManualChunks ? logExternalModulesCannotBeIncludedInManualChunks(unresolvedId) : logEntryCannotBeExternal(unresolvedId) : logImplicitDependantCannotBeExternal(unresolvedId, implicitlyLoadedBefore));
        }
        return this.fetchModule(this.getResolvedIdWithDefaults(typeof resolveIdResult === "object" ? resolveIdResult : { id: resolveIdResult }, EMPTY_OBJECT), void 0, isEntry, false);
      }
      async resolveDynamicImport(module, specifier, importer, attributes) {
        const resolution = await this.pluginDriver.hookFirst("resolveDynamicImport", [
          specifier,
          importer,
          { attributes }
        ]);
        if (typeof specifier !== "string") {
          if (typeof resolution === "string") {
            return resolution;
          }
          if (!resolution) {
            return null;
          }
          return this.getResolvedIdWithDefaults(resolution, attributes);
        }
        if (resolution == null) {
          const existingResolution = module.resolvedIds[specifier];
          if (existingResolution) {
            if (doAttributesDiffer(existingResolution.attributes, attributes)) {
              this.options.onLog(LOGLEVEL_WARN, logInconsistentImportAttributes(existingResolution.attributes, attributes, specifier, importer));
            }
            return existingResolution;
          }
          return module.resolvedIds[specifier] = this.handleInvalidResolvedId(await this.resolveId(specifier, module.id, EMPTY_OBJECT, false, attributes), specifier, module.id, attributes);
        }
        return this.handleInvalidResolvedId(this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(resolution, importer, specifier), attributes), specifier, importer, attributes);
      }
    };
    emittedFileTypes = /* @__PURE__ */ new Set(["chunk", "asset", "prebuilt-chunk"]);
    FileEmitter = class {
      constructor(graph, options, baseFileEmitter) {
        this.graph = graph;
        this.options = options;
        this.facadeChunkByModule = null;
        this.nextIdBase = 1;
        this.output = null;
        this.outputFileEmitters = [];
        this.emitFile = (emittedFile) => {
          if (!hasValidType(emittedFile)) {
            return error3(logFailedValidation(`Emitted files must be of type "asset", "chunk" or "prebuilt-chunk", received "${emittedFile && emittedFile.type}".`));
          }
          if (emittedFile.type === "prebuilt-chunk") {
            return this.emitPrebuiltChunk(emittedFile);
          }
          if (!hasValidName(emittedFile)) {
            return error3(logFailedValidation(`The "fileName" or "name" properties of emitted chunks and assets must be strings that are neither absolute nor relative paths, received "${emittedFile.fileName || emittedFile.name}".`));
          }
          if (emittedFile.type === "chunk") {
            return this.emitChunk(emittedFile);
          }
          return this.emitAsset(emittedFile);
        };
        this.finaliseAssets = () => {
          for (const [referenceId, emittedFile] of this.filesByReferenceId) {
            if (emittedFile.type === "asset" && typeof emittedFile.fileName !== "string")
              return error3(logNoAssetSourceSet(emittedFile.name || referenceId));
          }
        };
        this.getFileName = (fileReferenceId) => {
          const emittedFile = this.filesByReferenceId.get(fileReferenceId);
          if (!emittedFile)
            return error3(logFileReferenceIdNotFoundForFilename(fileReferenceId));
          if (emittedFile.type === "chunk") {
            return getChunkFileName(emittedFile, this.facadeChunkByModule);
          }
          if (emittedFile.type === "prebuilt-chunk") {
            return emittedFile.fileName;
          }
          return getAssetFileName(emittedFile, fileReferenceId);
        };
        this.setAssetSource = (referenceId, requestedSource) => {
          const consumedFile = this.filesByReferenceId.get(referenceId);
          if (!consumedFile)
            return error3(logAssetReferenceIdNotFoundForSetSource(referenceId));
          if (consumedFile.type !== "asset") {
            return error3(logFailedValidation(`Asset sources can only be set for emitted assets but "${referenceId}" is an emitted chunk.`));
          }
          if (consumedFile.source !== void 0) {
            return error3(logAssetSourceAlreadySet(consumedFile.name || referenceId));
          }
          const source = getValidSource(requestedSource, consumedFile, referenceId);
          if (this.output) {
            this.finalizeAdditionalAsset(consumedFile, source, this.output);
          } else {
            consumedFile.source = source;
            for (const emitter of this.outputFileEmitters) {
              emitter.finalizeAdditionalAsset(consumedFile, source, emitter.output);
            }
          }
        };
        this.setChunkInformation = (facadeChunkByModule) => {
          this.facadeChunkByModule = facadeChunkByModule;
        };
        this.setOutputBundle = (bundle, outputOptions) => {
          const getHash2 = hasherByType[outputOptions.hashCharacters];
          const output = this.output = {
            bundle,
            fileNamesBySourceHash: /* @__PURE__ */ new Map(),
            getHash: getHash2,
            outputOptions
          };
          for (const emittedFile of this.filesByReferenceId.values()) {
            if (emittedFile.fileName) {
              reserveFileNameInBundle(emittedFile.fileName, output, this.options.onLog);
            }
          }
          const consumedAssetsByHash = /* @__PURE__ */ new Map();
          for (const consumedFile of this.filesByReferenceId.values()) {
            if (consumedFile.type === "asset" && consumedFile.source !== void 0) {
              if (consumedFile.fileName) {
                this.finalizeAdditionalAsset(consumedFile, consumedFile.source, output);
              } else {
                const sourceHash = getHash2(consumedFile.source);
                getOrCreate(consumedAssetsByHash, sourceHash, () => []).push(consumedFile);
              }
            } else if (consumedFile.type === "prebuilt-chunk") {
              this.output.bundle[consumedFile.fileName] = this.createPrebuiltChunk(consumedFile);
            }
          }
          for (const [sourceHash, consumedFiles] of consumedAssetsByHash) {
            this.finalizeAssetsWithSameSource(consumedFiles, sourceHash, output);
          }
        };
        this.filesByReferenceId = baseFileEmitter ? new Map(baseFileEmitter.filesByReferenceId) : /* @__PURE__ */ new Map();
        baseFileEmitter?.addOutputFileEmitter(this);
      }
      addOutputFileEmitter(outputFileEmitter) {
        this.outputFileEmitters.push(outputFileEmitter);
      }
      assignReferenceId(file, idBase) {
        let referenceId = idBase;
        do {
          referenceId = getHash64(referenceId).slice(0, 8).replaceAll("-", "$");
        } while (this.filesByReferenceId.has(referenceId) || this.outputFileEmitters.some(({ filesByReferenceId }) => filesByReferenceId.has(referenceId)));
        file.referenceId = referenceId;
        this.filesByReferenceId.set(referenceId, file);
        for (const { filesByReferenceId } of this.outputFileEmitters) {
          filesByReferenceId.set(referenceId, file);
        }
        return referenceId;
      }
      createPrebuiltChunk(prebuiltChunk) {
        return {
          code: prebuiltChunk.code,
          dynamicImports: [],
          exports: prebuiltChunk.exports || [],
          facadeModuleId: null,
          fileName: prebuiltChunk.fileName,
          implicitlyLoadedBefore: [],
          importedBindings: {},
          imports: [],
          isDynamicEntry: false,
          isEntry: false,
          isImplicitEntry: false,
          map: prebuiltChunk.map || null,
          moduleIds: [],
          modules: {},
          name: prebuiltChunk.fileName,
          preliminaryFileName: prebuiltChunk.fileName,
          referencedFiles: [],
          sourcemapFileName: prebuiltChunk.sourcemapFileName || null,
          type: "chunk"
        };
      }
      emitAsset(emittedAsset) {
        const source = emittedAsset.source === void 0 ? void 0 : getValidSource(emittedAsset.source, emittedAsset, null);
        const originalFileName = emittedAsset.originalFileName || null;
        if (typeof originalFileName === "string") {
          this.graph.watchFiles[originalFileName] = true;
        }
        const consumedAsset = {
          fileName: emittedAsset.fileName,
          name: emittedAsset.name,
          needsCodeReference: !!emittedAsset.needsCodeReference,
          originalFileName,
          referenceId: "",
          source,
          type: "asset"
        };
        const referenceId = this.assignReferenceId(consumedAsset, emittedAsset.fileName || emittedAsset.name || String(this.nextIdBase++));
        if (this.output) {
          this.emitAssetWithReferenceId(consumedAsset, this.output);
        } else {
          for (const fileEmitter of this.outputFileEmitters) {
            fileEmitter.emitAssetWithReferenceId(consumedAsset, fileEmitter.output);
          }
        }
        return referenceId;
      }
      emitAssetWithReferenceId(consumedAsset, output) {
        const { fileName, source } = consumedAsset;
        if (fileName) {
          reserveFileNameInBundle(fileName, output, this.options.onLog);
        }
        if (source !== void 0) {
          this.finalizeAdditionalAsset(consumedAsset, source, output);
        }
      }
      emitChunk(emittedChunk) {
        if (this.graph.phase > BuildPhase.LOAD_AND_PARSE) {
          return error3(logInvalidRollupPhaseForChunkEmission());
        }
        if (typeof emittedChunk.id !== "string") {
          return error3(logFailedValidation(`Emitted chunks need to have a valid string id, received "${emittedChunk.id}"`));
        }
        const consumedChunk = {
          fileName: emittedChunk.fileName,
          module: null,
          name: emittedChunk.name || emittedChunk.id,
          referenceId: "",
          type: "chunk"
        };
        this.graph.moduleLoader.emitChunk(emittedChunk).then((module) => consumedChunk.module = module).catch(() => {
        });
        return this.assignReferenceId(consumedChunk, emittedChunk.id);
      }
      emitPrebuiltChunk(emitPrebuiltChunk) {
        if (typeof emitPrebuiltChunk.code !== "string") {
          return error3(logFailedValidation(`Emitted prebuilt chunks need to have a valid string code, received "${emitPrebuiltChunk.code}".`));
        }
        if (typeof emitPrebuiltChunk.fileName !== "string" || isPathFragment(emitPrebuiltChunk.fileName)) {
          return error3(logFailedValidation(`The "fileName" property of emitted prebuilt chunks must be strings that are neither absolute nor relative paths, received "${emitPrebuiltChunk.fileName}".`));
        }
        const consumedPrebuiltChunk = {
          code: emitPrebuiltChunk.code,
          exports: emitPrebuiltChunk.exports,
          fileName: emitPrebuiltChunk.fileName,
          map: emitPrebuiltChunk.map,
          referenceId: "",
          type: "prebuilt-chunk"
        };
        const referenceId = this.assignReferenceId(consumedPrebuiltChunk, consumedPrebuiltChunk.fileName);
        if (this.output) {
          this.output.bundle[consumedPrebuiltChunk.fileName] = this.createPrebuiltChunk(consumedPrebuiltChunk);
        }
        return referenceId;
      }
      finalizeAdditionalAsset(consumedFile, source, { bundle, fileNamesBySourceHash, getHash: getHash2, outputOptions }) {
        let { fileName, name, needsCodeReference, originalFileName, referenceId } = consumedFile;
        if (!fileName) {
          const sourceHash = getHash2(source);
          fileName = fileNamesBySourceHash.get(sourceHash);
          if (!fileName) {
            fileName = generateAssetFileName(name, name ? [name] : [], source, originalFileName, originalFileName ? [originalFileName] : [], sourceHash, outputOptions, bundle, this.options);
            fileNamesBySourceHash.set(sourceHash, fileName);
          }
        }
        const assetWithFileName = { ...consumedFile, fileName, source };
        this.filesByReferenceId.set(referenceId, assetWithFileName);
        const existingAsset = bundle[fileName];
        if (existingAsset?.type === "asset") {
          existingAsset.needsCodeReference &&= needsCodeReference;
          if (name) {
            existingAsset.names.push(name);
          }
          if (originalFileName) {
            existingAsset.originalFileNames.push(originalFileName);
          }
        } else {
          const { options } = this;
          bundle[fileName] = {
            fileName,
            get name() {
              warnDeprecation('Accessing the "name" property of emitted assets in the bundle is deprecated. Use the "names" property instead.', URL_GENERATEBUNDLE, false, options);
              return name;
            },
            names: name ? [name] : [],
            needsCodeReference,
            get originalFileName() {
              warnDeprecation('Accessing the "originalFileName" property of emitted assets in the bundle is deprecated. Use the "originalFileNames" property instead.', URL_GENERATEBUNDLE, false, options);
              return originalFileName;
            },
            originalFileNames: originalFileName ? [originalFileName] : [],
            source,
            type: "asset"
          };
        }
      }
      finalizeAssetsWithSameSource(consumedFiles, sourceHash, { bundle, fileNamesBySourceHash, outputOptions }) {
        const { names, originalFileNames } = getNamesFromAssets(consumedFiles);
        let fileName = "";
        let usedConsumedFile;
        let needsCodeReference = true;
        for (const consumedFile of consumedFiles) {
          needsCodeReference &&= consumedFile.needsCodeReference;
          const assetFileName = generateAssetFileName(consumedFile.name, names, consumedFile.source, consumedFile.originalFileName, originalFileNames, sourceHash, outputOptions, bundle, this.options);
          if (!fileName || assetFileName.length < fileName.length || assetFileName.length === fileName.length && assetFileName < fileName) {
            fileName = assetFileName;
            usedConsumedFile = consumedFile;
          }
        }
        fileNamesBySourceHash.set(sourceHash, fileName);
        for (const consumedFile of consumedFiles) {
          const assetWithFileName = { ...consumedFile, fileName };
          this.filesByReferenceId.set(consumedFile.referenceId, assetWithFileName);
        }
        const { options } = this;
        bundle[fileName] = {
          fileName,
          get name() {
            warnDeprecation('Accessing the "name" property of emitted assets in the bundle is deprecated. Use the "names" property instead.', URL_GENERATEBUNDLE, false, options);
            return usedConsumedFile.name;
          },
          names,
          needsCodeReference,
          get originalFileName() {
            warnDeprecation('Accessing the "originalFileName" property of emitted assets in the bundle is deprecated. Use the "originalFileNames" property instead.', URL_GENERATEBUNDLE, false, options);
            return usedConsumedFile.originalFileName;
          },
          originalFileNames,
          source: usedConsumedFile.source,
          type: "asset"
        };
      }
    };
    inputHookNames = {
      buildEnd: 1,
      buildStart: 1,
      closeBundle: 1,
      closeWatcher: 1,
      load: 1,
      moduleParsed: 1,
      onLog: 1,
      options: 1,
      resolveDynamicImport: 1,
      resolveId: 1,
      shouldTransformCachedModule: 1,
      transform: 1,
      watchChange: 1
    };
    inputHooks = Object.keys(inputHookNames);
    PluginDriver = class _PluginDriver {
      constructor(graph, options, userPlugins, pluginCache, basePluginDriver) {
        this.graph = graph;
        this.options = options;
        this.pluginCache = pluginCache;
        this.sortedPlugins = /* @__PURE__ */ new Map();
        this.unfulfilledActions = /* @__PURE__ */ new Set();
        this.fileEmitter = new FileEmitter(graph, options, basePluginDriver && basePluginDriver.fileEmitter);
        this.emitFile = this.fileEmitter.emitFile.bind(this.fileEmitter);
        this.getFileName = this.fileEmitter.getFileName.bind(this.fileEmitter);
        this.finaliseAssets = this.fileEmitter.finaliseAssets.bind(this.fileEmitter);
        this.setChunkInformation = this.fileEmitter.setChunkInformation.bind(this.fileEmitter);
        this.setOutputBundle = this.fileEmitter.setOutputBundle.bind(this.fileEmitter);
        this.plugins = [...basePluginDriver ? basePluginDriver.plugins : [], ...userPlugins];
        const existingPluginNames = /* @__PURE__ */ new Set();
        this.pluginContexts = new Map(this.plugins.map((plugin) => [
          plugin,
          getPluginContext(plugin, pluginCache, graph, options, this.fileEmitter, existingPluginNames)
        ]));
        if (basePluginDriver) {
          for (const plugin of userPlugins) {
            for (const hook of inputHooks) {
              if (hook in plugin) {
                options.onLog(LOGLEVEL_WARN, logInputHookInOutputPlugin(plugin.name, hook));
              }
            }
          }
        }
      }
      createOutputPluginDriver(plugins) {
        return new _PluginDriver(this.graph, this.options, plugins, this.pluginCache, this);
      }
      getUnfulfilledHookActions() {
        return this.unfulfilledActions;
      }
      // chains, first non-null result stops and returns
      hookFirst(hookName, parameters, replaceContext, skipped) {
        return this.hookFirstAndGetPlugin(hookName, parameters, replaceContext, skipped).then((result) => result && result[0]);
      }
      // chains, first non-null result stops and returns result and last plugin
      async hookFirstAndGetPlugin(hookName, parameters, replaceContext, skipped) {
        for (const plugin of this.getSortedPlugins(hookName)) {
          if (skipped?.has(plugin))
            continue;
          const result = await this.runHook(hookName, parameters, plugin, replaceContext);
          if (result != null)
            return [result, plugin];
        }
        return null;
      }
      // chains synchronously, first non-null result stops and returns
      hookFirstSync(hookName, parameters, replaceContext) {
        for (const plugin of this.getSortedPlugins(hookName)) {
          const result = this.runHookSync(hookName, parameters, plugin, replaceContext);
          if (result != null)
            return result;
        }
        return null;
      }
      // parallel, ignores returns
      async hookParallel(hookName, parameters, replaceContext) {
        const parallelPromises = [];
        for (const plugin of this.getSortedPlugins(hookName)) {
          if (plugin[hookName].sequential) {
            await Promise.all(parallelPromises);
            parallelPromises.length = 0;
            await this.runHook(hookName, parameters, plugin, replaceContext);
          } else {
            parallelPromises.push(this.runHook(hookName, parameters, plugin, replaceContext));
          }
        }
        await Promise.all(parallelPromises);
      }
      // chains, reduces returned value, handling the reduced value as the first hook argument
      hookReduceArg0(hookName, [argument0, ...rest], reduce13, replaceContext) {
        let promise3 = Promise.resolve(argument0);
        for (const plugin of this.getSortedPlugins(hookName)) {
          promise3 = promise3.then((argument02) => this.runHook(hookName, [argument02, ...rest], plugin, replaceContext).then((result) => reduce13.call(this.pluginContexts.get(plugin), argument02, result, plugin)));
        }
        return promise3;
      }
      // chains synchronously, reduces returned value, handling the reduced value as the first hook argument
      hookReduceArg0Sync(hookName, [argument0, ...rest], reduce13, replaceContext) {
        for (const plugin of this.getSortedPlugins(hookName)) {
          const parameters = [argument0, ...rest];
          const result = this.runHookSync(hookName, parameters, plugin, replaceContext);
          argument0 = reduce13.call(this.pluginContexts.get(plugin), argument0, result, plugin);
        }
        return argument0;
      }
      // chains, reduces returned value to type string, handling the reduced value separately. permits hooks as values.
      async hookReduceValue(hookName, initialValue, parameters, reducer) {
        const results = [];
        const parallelResults = [];
        for (const plugin of this.getSortedPlugins(hookName, validateAddonPluginHandler)) {
          if (plugin[hookName].sequential) {
            results.push(...await Promise.all(parallelResults));
            parallelResults.length = 0;
            results.push(await this.runHook(hookName, parameters, plugin));
          } else {
            parallelResults.push(this.runHook(hookName, parameters, plugin));
          }
        }
        results.push(...await Promise.all(parallelResults));
        return results.reduce(reducer, await initialValue);
      }
      // chains synchronously, reduces returned value to type T, handling the reduced value separately. permits hooks as values.
      hookReduceValueSync(hookName, initialValue, parameters, reduce13, replaceContext) {
        let accumulator = initialValue;
        for (const plugin of this.getSortedPlugins(hookName)) {
          const result = this.runHookSync(hookName, parameters, plugin, replaceContext);
          accumulator = reduce13.call(this.pluginContexts.get(plugin), accumulator, result, plugin);
        }
        return accumulator;
      }
      // chains, ignores returns
      hookSeq(hookName, parameters, replaceContext) {
        let promise3 = Promise.resolve();
        for (const plugin of this.getSortedPlugins(hookName)) {
          promise3 = promise3.then(() => this.runHook(hookName, parameters, plugin, replaceContext));
        }
        return promise3.then(noReturn);
      }
      getSortedPlugins(hookName, validateHandler) {
        return getOrCreate(this.sortedPlugins, hookName, () => getSortedValidatedPlugins(hookName, this.plugins, validateHandler));
      }
      // Implementation signature
      runHook(hookName, parameters, plugin, replaceContext) {
        const hook = plugin[hookName];
        const handler = typeof hook === "object" ? hook.handler : hook;
        let context8 = this.pluginContexts.get(plugin);
        if (replaceContext) {
          context8 = replaceContext(context8, plugin);
        }
        let action = null;
        return Promise.resolve().then(() => {
          if (typeof handler !== "function") {
            return handler;
          }
          const hookResult = handler.apply(context8, parameters);
          if (!hookResult?.then) {
            return hookResult;
          }
          action = [plugin.name, hookName, parameters];
          this.unfulfilledActions.add(action);
          return Promise.resolve(hookResult).then((result) => {
            this.unfulfilledActions.delete(action);
            return result;
          });
        }).catch((error_) => {
          if (action !== null) {
            this.unfulfilledActions.delete(action);
          }
          return error3(logPluginError(error_, plugin.name, { hook: hookName }));
        });
      }
      /**
       * Run a sync plugin hook and return the result.
       * @param hookName Name of the plugin hook. Must be in `PluginHooks`.
       * @param args Arguments passed to the plugin hook.
       * @param plugin The acutal plugin
       * @param replaceContext When passed, the plugin context can be overridden.
       */
      runHookSync(hookName, parameters, plugin, replaceContext) {
        const hook = plugin[hookName];
        const handler = typeof hook === "object" ? hook.handler : hook;
        let context8 = this.pluginContexts.get(plugin);
        if (replaceContext) {
          context8 = replaceContext(context8, plugin);
        }
        try {
          return handler.apply(context8, parameters);
        } catch (error_) {
          return error3(logPluginError(error_, plugin.name, { hook: hookName }));
        }
      }
    };
    Queue = class {
      constructor(maxParallel) {
        this.maxParallel = maxParallel;
        this.queue = [];
        this.workerCount = 0;
      }
      run(task) {
        return new Promise((resolve9, reject) => {
          this.queue.push({ reject, resolve: resolve9, task });
          this.work();
        });
      }
      async work() {
        if (this.workerCount >= this.maxParallel)
          return;
        this.workerCount++;
        let entry;
        while (entry = this.queue.shift()) {
          const { reject, resolve: resolve9, task } = entry;
          try {
            const result = await task();
            resolve9(result);
          } catch (error4) {
            reject(error4);
          }
        }
        this.workerCount--;
      }
    };
    Graph = class {
      constructor(options, watcher) {
        this.options = options;
        this.astLru = flru(5);
        this.cachedModules = /* @__PURE__ */ new Map();
        this.deoptimizationTracker = new EntityPathTracker();
        this.entryModules = [];
        this.modulesById = /* @__PURE__ */ new Map();
        this.needsTreeshakingPass = false;
        this.newlyIncludedVariableInits = /* @__PURE__ */ new Set();
        this.phase = BuildPhase.LOAD_AND_PARSE;
        this.scope = new GlobalScope();
        this.watchFiles = /* @__PURE__ */ Object.create(null);
        this.watchMode = false;
        this.externalModules = [];
        this.implicitEntryModules = [];
        this.modules = [];
        this.getModuleInfo = (moduleId) => {
          const foundModule = this.modulesById.get(moduleId);
          if (!foundModule)
            return null;
          return foundModule.info;
        };
        if (options.cache !== false) {
          if (options.cache?.modules) {
            for (const module of options.cache.modules)
              this.cachedModules.set(module.id, module);
          }
          this.pluginCache = options.cache?.plugins || /* @__PURE__ */ Object.create(null);
          for (const name in this.pluginCache) {
            const cache3 = this.pluginCache[name];
            for (const value of Object.values(cache3))
              value[0]++;
          }
        }
        if (watcher) {
          this.watchMode = true;
          const handleChange = (...parameters) => this.pluginDriver.hookParallel("watchChange", parameters);
          const handleClose = () => this.pluginDriver.hookParallel("closeWatcher", []);
          watcher.onCurrentRun("change", handleChange);
          watcher.onCurrentRun("close", handleClose);
        }
        this.pluginDriver = new PluginDriver(this, options, options.plugins, this.pluginCache);
        this.moduleLoader = new ModuleLoader(this, this.modulesById, this.options, this.pluginDriver);
        this.fileOperationQueue = new Queue(options.maxParallelFileOps);
        this.pureFunctions = getPureFunctions(options);
      }
      async build() {
        timeStart("generate module graph", 2);
        await this.generateModuleGraph();
        timeEnd("generate module graph", 2);
        timeStart("sort and bind modules", 2);
        this.phase = BuildPhase.ANALYSE;
        this.sortModules();
        timeEnd("sort and bind modules", 2);
        timeStart("mark included statements", 2);
        this.includeStatements();
        timeEnd("mark included statements", 2);
        this.phase = BuildPhase.GENERATE;
      }
      getCache() {
        for (const name in this.pluginCache) {
          const cache3 = this.pluginCache[name];
          let allDeleted = true;
          for (const [key, value] of Object.entries(cache3)) {
            if (value[0] >= this.options.experimentalCacheExpiry)
              delete cache3[key];
            else
              allDeleted = false;
          }
          if (allDeleted)
            delete this.pluginCache[name];
        }
        return {
          modules: this.modules.map((module) => module.toJSON()),
          plugins: this.pluginCache
        };
      }
      async generateModuleGraph() {
        ({ entryModules: this.entryModules, implicitEntryModules: this.implicitEntryModules } = await this.moduleLoader.addEntryModules(normalizeEntryModules(this.options.input), true));
        if (this.entryModules.length === 0) {
          throw new Error("You must supply options.input to rollup");
        }
        for (const module of this.modulesById.values()) {
          module.cacheInfoGetters();
          if (module instanceof Module) {
            this.modules.push(module);
          } else {
            this.externalModules.push(module);
          }
        }
      }
      includeStatements() {
        const entryModules = [...this.entryModules, ...this.implicitEntryModules];
        for (const module of entryModules) {
          markModuleAndImpureDependenciesAsExecuted(module);
        }
        if (this.options.treeshake) {
          let treeshakingPass = 1;
          this.newlyIncludedVariableInits.clear();
          do {
            timeStart(`treeshaking pass ${treeshakingPass}`, 3);
            this.needsTreeshakingPass = false;
            for (const module of this.modules) {
              if (module.isExecuted) {
                module.hasTreeShakingPassStarted = true;
                if (module.info.moduleSideEffects === "no-treeshake") {
                  module.includeAllInBundle();
                } else {
                  module.include();
                }
                for (const entity of this.newlyIncludedVariableInits) {
                  this.newlyIncludedVariableInits.delete(entity);
                  entity.include(createInclusionContext(), false);
                }
              }
            }
            if (treeshakingPass === 1) {
              for (const module of entryModules) {
                if (module.preserveSignature !== false) {
                  module.includeAllExports(false);
                  this.needsTreeshakingPass = true;
                }
              }
            }
            timeEnd(`treeshaking pass ${treeshakingPass++}`, 3);
          } while (this.needsTreeshakingPass);
        } else {
          for (const module of this.modules)
            module.includeAllInBundle();
        }
        for (const externalModule of this.externalModules)
          externalModule.warnUnusedImports();
        for (const module of this.implicitEntryModules) {
          for (const dependant of module.implicitlyLoadedAfter) {
            if (!(dependant.info.isEntry || dependant.isIncluded())) {
              error3(logImplicitDependantIsNotIncluded(dependant));
            }
          }
        }
      }
      sortModules() {
        const { orderedModules, cyclePaths } = analyseModuleExecution(this.entryModules);
        for (const cyclePath of cyclePaths) {
          this.options.onLog(LOGLEVEL_WARN, logCircularDependency(cyclePath));
        }
        this.modules = orderedModules;
        for (const module of this.modules) {
          module.bindReferences();
        }
        this.warnForMissingExports();
      }
      warnForMissingExports() {
        for (const module of this.modules) {
          for (const importDescription of module.importDescriptions.values()) {
            if (importDescription.name !== "*" && !importDescription.module.getVariableForExportName(importDescription.name)[0]) {
              module.log(LOGLEVEL_WARN, logMissingExport(importDescription.name, module.id, importDescription.module.id), importDescription.start);
            }
          }
        }
      }
    };
    handleBeforeExit = null;
    rejectByPluginDriver = /* @__PURE__ */ new Map();
    getCache = (config2) => config2.cache === true ? void 0 : config2.cache?.cache || config2.cache;
    getIdMatcher = (option5) => {
      if (option5 === true) {
        return () => true;
      }
      if (typeof option5 === "function") {
        return (id2, ...parameters) => !id2.startsWith("\0") && option5(id2, ...parameters) || false;
      }
      if (option5) {
        const ids3 = /* @__PURE__ */ new Set();
        const matchers = [];
        for (const value of ensureArray2(option5)) {
          if (value instanceof RegExp) {
            matchers.push(value);
          } else {
            ids3.add(value);
          }
        }
        return (id2, ..._arguments) => ids3.has(id2) || matchers.some((matcher) => matcher.test(id2));
      }
      return () => false;
    };
    getInput = (config2) => {
      const configInput = config2.input;
      return configInput == null ? [] : typeof configInput === "string" ? [configInput] : configInput;
    };
    getJsx = (config2) => {
      const configJsx = config2.jsx;
      if (!configJsx)
        return false;
      const configWithPreset = getOptionWithPreset(configJsx, jsxPresets, "jsx", URL_JSX, "false, ");
      const { factory, importSource, mode } = configWithPreset;
      switch (mode) {
        case "automatic": {
          return {
            factory: factory || "React.createElement",
            importSource: importSource || "react",
            jsxImportSource: configWithPreset.jsxImportSource || "react/jsx-runtime",
            mode: "automatic"
          };
        }
        case "preserve": {
          if (importSource && !(factory || configWithPreset.fragment)) {
            error3(logInvalidOption("jsx", URL_JSX, "when preserving JSX and specifying an importSource, you also need to specify a factory or fragment"));
          }
          return {
            factory: factory || null,
            fragment: configWithPreset.fragment || null,
            importSource: importSource || null,
            mode: "preserve"
          };
        }
        // case 'classic':
        default: {
          if (mode && mode !== "classic") {
            error3(logInvalidOption("jsx.mode", URL_JSX, 'mode must be "automatic", "classic" or "preserve"', mode));
          }
          return {
            factory: factory || "React.createElement",
            fragment: configWithPreset.fragment || "React.Fragment",
            importSource: importSource || null,
            mode: "classic"
          };
        }
      }
    };
    getMaxParallelFileOps = (config2) => {
      const maxParallelFileOps = config2.maxParallelFileOps;
      if (typeof maxParallelFileOps === "number") {
        if (maxParallelFileOps <= 0)
          return Infinity;
        return maxParallelFileOps;
      }
      return 20;
    };
    getModuleContext = (config2, context8) => {
      const configModuleContext = config2.moduleContext;
      if (typeof configModuleContext === "function") {
        return (id2) => configModuleContext(id2) ?? context8;
      }
      if (configModuleContext) {
        const contextByModuleId = /* @__PURE__ */ Object.create(null);
        for (const [key, moduleContext] of Object.entries(configModuleContext)) {
          contextByModuleId[p2.resolve(key)] = moduleContext;
        }
        return (id2) => contextByModuleId[id2] ?? context8;
      }
      return () => context8;
    };
    getTreeshake = (config2) => {
      const configTreeshake = config2.treeshake;
      if (configTreeshake === false) {
        return false;
      }
      const configWithPreset = getOptionWithPreset(config2.treeshake, treeshakePresets, "treeshake", URL_TREESHAKE, "false, true, ");
      return {
        annotations: configWithPreset.annotations !== false,
        correctVarValueBeforeDeclaration: configWithPreset.correctVarValueBeforeDeclaration === true,
        manualPureFunctions: configWithPreset.manualPureFunctions ?? EMPTY_ARRAY,
        moduleSideEffects: getHasModuleSideEffects(configWithPreset.moduleSideEffects),
        propertyReadSideEffects: configWithPreset.propertyReadSideEffects === "always" ? "always" : configWithPreset.propertyReadSideEffects !== false,
        tryCatchDeoptimization: configWithPreset.tryCatchDeoptimization !== false,
        unknownGlobalSideEffects: configWithPreset.unknownGlobalSideEffects !== false
      };
    };
    getHasModuleSideEffects = (moduleSideEffectsOption) => {
      if (typeof moduleSideEffectsOption === "boolean") {
        return () => moduleSideEffectsOption;
      }
      if (moduleSideEffectsOption === "no-external") {
        return (_id, external) => !external;
      }
      if (typeof moduleSideEffectsOption === "function") {
        return (id2, external) => id2.startsWith("\0") ? true : moduleSideEffectsOption(id2, external) !== false;
      }
      if (Array.isArray(moduleSideEffectsOption)) {
        const ids3 = new Set(moduleSideEffectsOption);
        return (id2) => ids3.has(id2);
      }
      if (moduleSideEffectsOption) {
        error3(logInvalidOption("treeshake.moduleSideEffects", URL_TREESHAKE_MODULESIDEEFFECTS, 'please use one of false, "no-external", a function or an array'));
      }
      return () => true;
    };
    INVALID_CHAR_REGEX = /[\u0000-\u001F"#$%&*+,:;<=>?[\]^`{|}\u007F]/g;
    DRIVE_LETTER_REGEX = /^[a-z]:/i;
    getFile = (config2, preserveModules, inputOptions) => {
      const { file } = config2;
      if (typeof file === "string") {
        if (preserveModules) {
          return error3(logInvalidOption("output.file", URL_OUTPUT_DIR, 'you must set "output.dir" instead of "output.file" when using the "output.preserveModules" option'));
        }
        if (!Array.isArray(inputOptions.input))
          return error3(logInvalidOption("output.file", URL_OUTPUT_DIR, 'you must set "output.dir" instead of "output.file" when providing named inputs'));
      }
      return file;
    };
    getFormat = (config2) => {
      const configFormat = config2.format;
      switch (configFormat) {
        case void 0:
        case "es":
        case "esm":
        case "module": {
          return "es";
        }
        case "cjs":
        case "commonjs": {
          return "cjs";
        }
        case "system":
        case "systemjs": {
          return "system";
        }
        case "amd":
        case "iife":
        case "umd": {
          return configFormat;
        }
        default: {
          return error3(logInvalidOption("output.format", URL_OUTPUT_FORMAT, `Valid values are "amd", "cjs", "system", "es", "iife" or "umd"`, configFormat));
        }
      }
    };
    getInlineDynamicImports = (config2, inputOptions) => {
      const inlineDynamicImports = config2.inlineDynamicImports || false;
      const { input: input2 } = inputOptions;
      if (inlineDynamicImports && (Array.isArray(input2) ? input2 : Object.keys(input2)).length > 1) {
        return error3(logInvalidOption("output.inlineDynamicImports", URL_OUTPUT_INLINEDYNAMICIMPORTS, 'multiple inputs are not supported when "output.inlineDynamicImports" is true'));
      }
      return inlineDynamicImports;
    };
    getPreserveModules = (config2, inlineDynamicImports, inputOptions) => {
      const preserveModules = config2.preserveModules || false;
      if (preserveModules) {
        if (inlineDynamicImports) {
          return error3(logInvalidOption("output.inlineDynamicImports", URL_OUTPUT_INLINEDYNAMICIMPORTS, `this option is not supported for "output.preserveModules"`));
        }
        if (inputOptions.preserveEntrySignatures === false) {
          return error3(logInvalidOption("preserveEntrySignatures", URL_PRESERVEENTRYSIGNATURES, 'setting this option to false is not supported for "output.preserveModules"'));
        }
      }
      return preserveModules;
    };
    getPreserveModulesRoot = (config2) => {
      const { preserveModulesRoot } = config2;
      if (preserveModulesRoot === null || preserveModulesRoot === void 0) {
        return void 0;
      }
      return p2.resolve(preserveModulesRoot);
    };
    getAmd = (config2) => {
      const mergedOption = {
        autoId: false,
        basePath: "",
        define: "define",
        forceJsExtensionForImports: false,
        ...config2.amd
      };
      if ((mergedOption.autoId || mergedOption.basePath) && mergedOption.id) {
        return error3(logInvalidOption("output.amd.id", URL_OUTPUT_AMD_ID, 'this option cannot be used together with "output.amd.autoId"/"output.amd.basePath"'));
      }
      if (mergedOption.basePath && !mergedOption.autoId) {
        return error3(logInvalidOption("output.amd.basePath", URL_OUTPUT_AMD_BASEPATH, 'this option only works with "output.amd.autoId"'));
      }
      return mergedOption.autoId ? {
        autoId: true,
        basePath: mergedOption.basePath,
        define: mergedOption.define,
        forceJsExtensionForImports: mergedOption.forceJsExtensionForImports
      } : {
        autoId: false,
        define: mergedOption.define,
        forceJsExtensionForImports: mergedOption.forceJsExtensionForImports,
        id: mergedOption.id
      };
    };
    getAddon = (config2, name) => {
      const configAddon = config2[name];
      if (typeof configAddon === "function") {
        return configAddon;
      }
      return () => configAddon || "";
    };
    getDir = (config2, file) => {
      const { dir: dir3 } = config2;
      if (typeof dir3 === "string" && typeof file === "string") {
        return error3(logInvalidOption("output.dir", URL_OUTPUT_DIR, 'you must set either "output.file" for a single-file build or "output.dir" when generating multiple chunks'));
      }
      return dir3;
    };
    getEntryFileNames = (config2, unsetOptions) => {
      const configEntryFileNames = config2.entryFileNames;
      if (configEntryFileNames == null) {
        unsetOptions.add("entryFileNames");
      }
      return configEntryFileNames ?? "[name].js";
    };
    getExternalImportAttributes = (config2, inputOptions) => {
      if (config2.externalImportAssertions != void 0) {
        warnDeprecation(`The "output.externalImportAssertions" option is deprecated. Use the "output.externalImportAttributes" option instead.`, URL_OUTPUT_EXTERNALIMPORTATTRIBUTES, true, inputOptions);
      }
      return config2.externalImportAttributes ?? config2.externalImportAssertions ?? true;
    };
    getGeneratedCode = (config2) => {
      const configWithPreset = getOptionWithPreset(config2.generatedCode, generatedCodePresets, "output.generatedCode", URL_OUTPUT_GENERATEDCODE, "");
      return {
        arrowFunctions: configWithPreset.arrowFunctions === true,
        constBindings: configWithPreset.constBindings === true,
        objectShorthand: configWithPreset.objectShorthand === true,
        reservedNamesAsProps: configWithPreset.reservedNamesAsProps !== false,
        symbols: configWithPreset.symbols === true
      };
    };
    getIndent = (config2, compact2) => {
      if (compact2) {
        return "";
      }
      const configIndent = config2.indent;
      return configIndent === false ? "" : configIndent ?? true;
    };
    ALLOWED_INTEROP_TYPES = /* @__PURE__ */ new Set([
      "compat",
      "auto",
      "esModule",
      "default",
      "defaultOnly"
    ]);
    getInterop = (config2) => {
      const configInterop = config2.interop;
      if (typeof configInterop === "function") {
        const interopPerId = /* @__PURE__ */ Object.create(null);
        let defaultInterop = null;
        return (id2) => id2 === null ? defaultInterop || validateInterop(defaultInterop = configInterop(id2)) : id2 in interopPerId ? interopPerId[id2] : validateInterop(interopPerId[id2] = configInterop(id2));
      }
      return configInterop === void 0 ? () => "default" : () => validateInterop(configInterop);
    };
    validateInterop = (interop) => {
      if (!ALLOWED_INTEROP_TYPES.has(interop)) {
        return error3(logInvalidOption("output.interop", URL_OUTPUT_INTEROP, `use one of ${Array.from(ALLOWED_INTEROP_TYPES, (value) => JSON.stringify(value)).join(", ")}`, interop));
      }
      return interop;
    };
    getManualChunks = (config2, inlineDynamicImports, preserveModules) => {
      const configManualChunks = config2.manualChunks;
      if (configManualChunks) {
        if (inlineDynamicImports) {
          return error3(logInvalidOption("output.manualChunks", URL_OUTPUT_MANUALCHUNKS, 'this option is not supported for "output.inlineDynamicImports"'));
        }
        if (preserveModules) {
          return error3(logInvalidOption("output.manualChunks", URL_OUTPUT_MANUALCHUNKS, 'this option is not supported for "output.preserveModules"'));
        }
      }
      return configManualChunks || {};
    };
    getMinifyInternalExports = (config2, format5, compact2) => config2.minifyInternalExports ?? (compact2 || format5 === "es" || format5 === "system");
    getSourcemapFileNames = (config2, unsetOptions) => {
      const configSourcemapFileNames = config2.sourcemapFileNames;
      if (configSourcemapFileNames == null) {
        unsetOptions.add("sourcemapFileNames");
      }
      return configSourcemapFileNames;
    };
    getSourcemapBaseUrl = (config2) => {
      const { sourcemapBaseUrl } = config2;
      if (sourcemapBaseUrl) {
        if (isValidUrl(sourcemapBaseUrl)) {
          return addTrailingSlashIfMissed(sourcemapBaseUrl);
        }
        return error3(logInvalidOption("output.sourcemapBaseUrl", URL_OUTPUT_SOURCEMAPBASEURL, `must be a valid URL, received ${JSON.stringify(sourcemapBaseUrl)}`));
      }
    };
    Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");
    (function(SortingFileType2) {
      SortingFileType2[SortingFileType2["ENTRY_CHUNK"] = 0] = "ENTRY_CHUNK";
      SortingFileType2[SortingFileType2["SECONDARY_CHUNK"] = 1] = "SECONDARY_CHUNK";
      SortingFileType2[SortingFileType2["ASSET"] = 2] = "ASSET";
    })(SortingFileType || (SortingFileType = {}));
    picocolors = { exports: {} };
    picocolorsExports = /* @__PURE__ */ requirePicocolors();
    pc = /* @__PURE__ */ getDefaultExportFromCjs(picocolorsExports);
    ({ bold, cyan, dim, red } = pc.createColors(process$1.env.FORCE_COLOR !== "0" && !process$1.env.NO_COLOR));
  }
});

// node_modules/.pnpm/esbuild@0.25.1/node_modules/esbuild/lib/main.js
var require_main = __commonJS({
  "node_modules/.pnpm/esbuild@0.25.1/node_modules/esbuild/lib/main.js"(exports, module) {
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames3 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export3 = (target, all8) => {
      for (var name in all8)
        __defProp3(target, name, { get: all8[name], enumerable: true });
    };
    var __copyProps3 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames3(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc3(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps3(__defProp3({}, "__esModule", { value: true }), mod);
    var node_exports3 = {};
    __export3(node_exports3, {
      analyzeMetafile: () => analyzeMetafile,
      analyzeMetafileSync: () => analyzeMetafileSync,
      build: () => build4,
      buildSync: () => buildSync,
      context: () => context8,
      default: () => node_default,
      formatMessages: () => formatMessages2,
      formatMessagesSync: () => formatMessagesSync,
      initialize: () => initialize,
      stop: () => stop2,
      transform: () => transform4,
      transformSync: () => transformSync,
      version: () => version3
    });
    module.exports = __toCommonJS2(node_exports3);
    function encodePacket(packet) {
      let visit = (value) => {
        if (value === null) {
          bb.write8(0);
        } else if (typeof value === "boolean") {
          bb.write8(1);
          bb.write8(+value);
        } else if (typeof value === "number") {
          bb.write8(2);
          bb.write32(value | 0);
        } else if (typeof value === "string") {
          bb.write8(3);
          bb.write(encodeUTF8(value));
        } else if (value instanceof Uint8Array) {
          bb.write8(4);
          bb.write(value);
        } else if (value instanceof Array) {
          bb.write8(5);
          bb.write32(value.length);
          for (let item of value) {
            visit(item);
          }
        } else {
          let keys5 = Object.keys(value);
          bb.write8(6);
          bb.write32(keys5.length);
          for (let key of keys5) {
            bb.write(encodeUTF8(key));
            visit(value[key]);
          }
        }
      };
      let bb = new ByteBuffer();
      bb.write32(0);
      bb.write32(packet.id << 1 | +!packet.isRequest);
      visit(packet.value);
      writeUInt32LE(bb.buf, bb.len - 4, 0);
      return bb.buf.subarray(0, bb.len);
    }
    function decodePacket(bytes) {
      let visit = () => {
        switch (bb.read8()) {
          case 0:
            return null;
          case 1:
            return !!bb.read8();
          case 2:
            return bb.read32();
          case 3:
            return decodeUTF8(bb.read());
          case 4:
            return bb.read();
          case 5: {
            let count5 = bb.read32();
            let value2 = [];
            for (let i = 0; i < count5; i++) {
              value2.push(visit());
            }
            return value2;
          }
          case 6: {
            let count5 = bb.read32();
            let value2 = {};
            for (let i = 0; i < count5; i++) {
              value2[decodeUTF8(bb.read())] = visit();
            }
            return value2;
          }
          default:
            throw new Error("Invalid packet");
        }
      };
      let bb = new ByteBuffer(bytes);
      let id2 = bb.read32();
      let isRequest3 = (id2 & 1) === 0;
      id2 >>>= 1;
      let value = visit();
      if (bb.ptr !== bytes.length) {
        throw new Error("Invalid packet");
      }
      return { id: id2, isRequest: isRequest3, value };
    }
    var ByteBuffer = class {
      constructor(buf = new Uint8Array(1024)) {
        this.buf = buf;
        this.len = 0;
        this.ptr = 0;
      }
      _write(delta) {
        if (this.len + delta > this.buf.length) {
          let clone4 = new Uint8Array((this.len + delta) * 2);
          clone4.set(this.buf);
          this.buf = clone4;
        }
        this.len += delta;
        return this.len - delta;
      }
      write8(value) {
        let offset = this._write(1);
        this.buf[offset] = value;
      }
      write32(value) {
        let offset = this._write(4);
        writeUInt32LE(this.buf, value, offset);
      }
      write(bytes) {
        let offset = this._write(4 + bytes.length);
        writeUInt32LE(this.buf, bytes.length, offset);
        this.buf.set(bytes, offset + 4);
      }
      _read(delta) {
        if (this.ptr + delta > this.buf.length) {
          throw new Error("Invalid packet");
        }
        this.ptr += delta;
        return this.ptr - delta;
      }
      read8() {
        return this.buf[this._read(1)];
      }
      read32() {
        return readUInt32LE(this.buf, this._read(4));
      }
      read() {
        let length3 = this.read32();
        let bytes = new Uint8Array(length3);
        let ptr = this._read(bytes.length);
        bytes.set(this.buf.subarray(ptr, ptr + length3));
        return bytes;
      }
    };
    var encodeUTF8;
    var decodeUTF8;
    var encodeInvariant;
    if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
      let encoder = new TextEncoder();
      let decoder = new TextDecoder();
      encodeUTF8 = (text) => encoder.encode(text);
      decodeUTF8 = (bytes) => decoder.decode(bytes);
      encodeInvariant = 'new TextEncoder().encode("")';
    } else if (typeof Buffer !== "undefined") {
      encodeUTF8 = (text) => Buffer.from(text);
      decodeUTF8 = (bytes) => {
        let { buffer: buffer4, byteOffset, byteLength } = bytes;
        return Buffer.from(buffer4, byteOffset, byteLength).toString();
      };
      encodeInvariant = 'Buffer.from("")';
    } else {
      throw new Error("No UTF-8 codec found");
    }
    if (!(encodeUTF8("") instanceof Uint8Array))
      throw new Error(`Invariant violation: "${encodeInvariant} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);
    function readUInt32LE(buffer4, offset) {
      return buffer4[offset++] | buffer4[offset++] << 8 | buffer4[offset++] << 16 | buffer4[offset++] << 24;
    }
    function writeUInt32LE(buffer4, value, offset) {
      buffer4[offset++] = value;
      buffer4[offset++] = value >> 8;
      buffer4[offset++] = value >> 16;
      buffer4[offset++] = value >> 24;
    }
    var quote = JSON.stringify;
    var buildLogLevelDefault = "warning";
    var transformLogLevelDefault = "silent";
    function validateTarget(target) {
      validateStringValue(target, "target");
      if (target.indexOf(",") >= 0) throw new Error(`Invalid target: ${target}`);
      return target;
    }
    var canBeAnything = () => null;
    var mustBeBoolean = (value) => typeof value === "boolean" ? null : "a boolean";
    var mustBeString = (value) => typeof value === "string" ? null : "a string";
    var mustBeRegExp = (value) => value instanceof RegExp ? null : "a RegExp object";
    var mustBeInteger = (value) => typeof value === "number" && value === (value | 0) ? null : "an integer";
    var mustBeValidPortNumber = (value) => typeof value === "number" && value === (value | 0) && value >= 0 && value <= 65535 ? null : "a valid port number";
    var mustBeFunction = (value) => typeof value === "function" ? null : "a function";
    var mustBeArray = (value) => Array.isArray(value) ? null : "an array";
    var mustBeObject = (value) => typeof value === "object" && value !== null && !Array.isArray(value) ? null : "an object";
    var mustBeEntryPoints = (value) => typeof value === "object" && value !== null ? null : "an array or an object";
    var mustBeWebAssemblyModule = (value) => value instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
    var mustBeObjectOrNull = (value) => typeof value === "object" && !Array.isArray(value) ? null : "an object or null";
    var mustBeStringOrBoolean = (value) => typeof value === "string" || typeof value === "boolean" ? null : "a string or a boolean";
    var mustBeStringOrObject = (value) => typeof value === "string" || typeof value === "object" && value !== null && !Array.isArray(value) ? null : "a string or an object";
    var mustBeStringOrArray = (value) => typeof value === "string" || Array.isArray(value) ? null : "a string or an array";
    var mustBeStringOrUint8Array = (value) => typeof value === "string" || value instanceof Uint8Array ? null : "a string or a Uint8Array";
    var mustBeStringOrURL = (value) => typeof value === "string" || value instanceof URL ? null : "a string or a URL";
    function getFlag(object, keys5, key, mustBeFn) {
      let value = object[key];
      keys5[key + ""] = true;
      if (value === void 0) return void 0;
      let mustBe = mustBeFn(value);
      if (mustBe !== null) throw new Error(`${quote(key)} must be ${mustBe}`);
      return value;
    }
    function checkForInvalidFlags(object, keys5, where) {
      for (let key in object) {
        if (!(key in keys5)) {
          throw new Error(`Invalid option ${where}: ${quote(key)}`);
        }
      }
    }
    function validateInitializeOptions(options) {
      let keys5 = /* @__PURE__ */ Object.create(null);
      let wasmURL = getFlag(options, keys5, "wasmURL", mustBeStringOrURL);
      let wasmModule = getFlag(options, keys5, "wasmModule", mustBeWebAssemblyModule);
      let worker = getFlag(options, keys5, "worker", mustBeBoolean);
      checkForInvalidFlags(options, keys5, "in initialize() call");
      return {
        wasmURL,
        wasmModule,
        worker
      };
    }
    function validateMangleCache(mangleCache) {
      let validated;
      if (mangleCache !== void 0) {
        validated = /* @__PURE__ */ Object.create(null);
        for (let key in mangleCache) {
          let value = mangleCache[key];
          if (typeof value === "string" || value === false) {
            validated[key] = value;
          } else {
            throw new Error(`Expected ${quote(key)} in mangle cache to map to either a string or false`);
          }
        }
      }
      return validated;
    }
    function pushLogFlags(flags, options, keys5, isTTY2, logLevelDefault) {
      let color = getFlag(options, keys5, "color", mustBeBoolean);
      let logLevel3 = getFlag(options, keys5, "logLevel", mustBeString);
      let logLimit = getFlag(options, keys5, "logLimit", mustBeInteger);
      if (color !== void 0) flags.push(`--color=${color}`);
      else if (isTTY2) flags.push(`--color=true`);
      flags.push(`--log-level=${logLevel3 || logLevelDefault}`);
      flags.push(`--log-limit=${logLimit || 0}`);
    }
    function validateStringValue(value, what, key) {
      if (typeof value !== "string") {
        throw new Error(`Expected value for ${what}${key !== void 0 ? " " + quote(key) : ""} to be a string, got ${typeof value} instead`);
      }
      return value;
    }
    function pushCommonFlags(flags, options, keys5) {
      let legalComments = getFlag(options, keys5, "legalComments", mustBeString);
      let sourceRoot = getFlag(options, keys5, "sourceRoot", mustBeString);
      let sourcesContent = getFlag(options, keys5, "sourcesContent", mustBeBoolean);
      let target = getFlag(options, keys5, "target", mustBeStringOrArray);
      let format5 = getFlag(options, keys5, "format", mustBeString);
      let globalName = getFlag(options, keys5, "globalName", mustBeString);
      let mangleProps = getFlag(options, keys5, "mangleProps", mustBeRegExp);
      let reserveProps = getFlag(options, keys5, "reserveProps", mustBeRegExp);
      let mangleQuoted = getFlag(options, keys5, "mangleQuoted", mustBeBoolean);
      let minify2 = getFlag(options, keys5, "minify", mustBeBoolean);
      let minifySyntax = getFlag(options, keys5, "minifySyntax", mustBeBoolean);
      let minifyWhitespace = getFlag(options, keys5, "minifyWhitespace", mustBeBoolean);
      let minifyIdentifiers = getFlag(options, keys5, "minifyIdentifiers", mustBeBoolean);
      let lineLimit = getFlag(options, keys5, "lineLimit", mustBeInteger);
      let drop5 = getFlag(options, keys5, "drop", mustBeArray);
      let dropLabels = getFlag(options, keys5, "dropLabels", mustBeArray);
      let charset = getFlag(options, keys5, "charset", mustBeString);
      let treeShaking = getFlag(options, keys5, "treeShaking", mustBeBoolean);
      let ignoreAnnotations = getFlag(options, keys5, "ignoreAnnotations", mustBeBoolean);
      let jsx = getFlag(options, keys5, "jsx", mustBeString);
      let jsxFactory = getFlag(options, keys5, "jsxFactory", mustBeString);
      let jsxFragment3 = getFlag(options, keys5, "jsxFragment", mustBeString);
      let jsxImportSource = getFlag(options, keys5, "jsxImportSource", mustBeString);
      let jsxDev = getFlag(options, keys5, "jsxDev", mustBeBoolean);
      let jsxSideEffects = getFlag(options, keys5, "jsxSideEffects", mustBeBoolean);
      let define = getFlag(options, keys5, "define", mustBeObject);
      let logOverride = getFlag(options, keys5, "logOverride", mustBeObject);
      let supported = getFlag(options, keys5, "supported", mustBeObject);
      let pure = getFlag(options, keys5, "pure", mustBeArray);
      let keepNames = getFlag(options, keys5, "keepNames", mustBeBoolean);
      let platform = getFlag(options, keys5, "platform", mustBeString);
      let tsconfigRaw = getFlag(options, keys5, "tsconfigRaw", mustBeStringOrObject);
      if (legalComments) flags.push(`--legal-comments=${legalComments}`);
      if (sourceRoot !== void 0) flags.push(`--source-root=${sourceRoot}`);
      if (sourcesContent !== void 0) flags.push(`--sources-content=${sourcesContent}`);
      if (target) {
        if (Array.isArray(target)) flags.push(`--target=${Array.from(target).map(validateTarget).join(",")}`);
        else flags.push(`--target=${validateTarget(target)}`);
      }
      if (format5) flags.push(`--format=${format5}`);
      if (globalName) flags.push(`--global-name=${globalName}`);
      if (platform) flags.push(`--platform=${platform}`);
      if (tsconfigRaw) flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
      if (minify2) flags.push("--minify");
      if (minifySyntax) flags.push("--minify-syntax");
      if (minifyWhitespace) flags.push("--minify-whitespace");
      if (minifyIdentifiers) flags.push("--minify-identifiers");
      if (lineLimit) flags.push(`--line-limit=${lineLimit}`);
      if (charset) flags.push(`--charset=${charset}`);
      if (treeShaking !== void 0) flags.push(`--tree-shaking=${treeShaking}`);
      if (ignoreAnnotations) flags.push(`--ignore-annotations`);
      if (drop5) for (let what of drop5) flags.push(`--drop:${validateStringValue(what, "drop")}`);
      if (dropLabels) flags.push(`--drop-labels=${Array.from(dropLabels).map((what) => validateStringValue(what, "dropLabels")).join(",")}`);
      if (mangleProps) flags.push(`--mangle-props=${mangleProps.source}`);
      if (reserveProps) flags.push(`--reserve-props=${reserveProps.source}`);
      if (mangleQuoted !== void 0) flags.push(`--mangle-quoted=${mangleQuoted}`);
      if (jsx) flags.push(`--jsx=${jsx}`);
      if (jsxFactory) flags.push(`--jsx-factory=${jsxFactory}`);
      if (jsxFragment3) flags.push(`--jsx-fragment=${jsxFragment3}`);
      if (jsxImportSource) flags.push(`--jsx-import-source=${jsxImportSource}`);
      if (jsxDev) flags.push(`--jsx-dev`);
      if (jsxSideEffects) flags.push(`--jsx-side-effects`);
      if (define) {
        for (let key in define) {
          if (key.indexOf("=") >= 0) throw new Error(`Invalid define: ${key}`);
          flags.push(`--define:${key}=${validateStringValue(define[key], "define", key)}`);
        }
      }
      if (logOverride) {
        for (let key in logOverride) {
          if (key.indexOf("=") >= 0) throw new Error(`Invalid log override: ${key}`);
          flags.push(`--log-override:${key}=${validateStringValue(logOverride[key], "log override", key)}`);
        }
      }
      if (supported) {
        for (let key in supported) {
          if (key.indexOf("=") >= 0) throw new Error(`Invalid supported: ${key}`);
          const value = supported[key];
          if (typeof value !== "boolean") throw new Error(`Expected value for supported ${quote(key)} to be a boolean, got ${typeof value} instead`);
          flags.push(`--supported:${key}=${value}`);
        }
      }
      if (pure) for (let fn2 of pure) flags.push(`--pure:${validateStringValue(fn2, "pure")}`);
      if (keepNames) flags.push(`--keep-names`);
    }
    function flagsForBuildOptions(callName, options, isTTY2, logLevelDefault, writeDefault) {
      var _a22;
      let flags = [];
      let entries2 = [];
      let keys5 = /* @__PURE__ */ Object.create(null);
      let stdinContents = null;
      let stdinResolveDir = null;
      pushLogFlags(flags, options, keys5, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options, keys5);
      let sourcemap = getFlag(options, keys5, "sourcemap", mustBeStringOrBoolean);
      let bundle = getFlag(options, keys5, "bundle", mustBeBoolean);
      let splitting = getFlag(options, keys5, "splitting", mustBeBoolean);
      let preserveSymlinks = getFlag(options, keys5, "preserveSymlinks", mustBeBoolean);
      let metafile = getFlag(options, keys5, "metafile", mustBeBoolean);
      let outfile = getFlag(options, keys5, "outfile", mustBeString);
      let outdir = getFlag(options, keys5, "outdir", mustBeString);
      let outbase = getFlag(options, keys5, "outbase", mustBeString);
      let tsconfig = getFlag(options, keys5, "tsconfig", mustBeString);
      let resolveExtensions = getFlag(options, keys5, "resolveExtensions", mustBeArray);
      let nodePathsInput = getFlag(options, keys5, "nodePaths", mustBeArray);
      let mainFields = getFlag(options, keys5, "mainFields", mustBeArray);
      let conditions = getFlag(options, keys5, "conditions", mustBeArray);
      let external = getFlag(options, keys5, "external", mustBeArray);
      let packages = getFlag(options, keys5, "packages", mustBeString);
      let alias = getFlag(options, keys5, "alias", mustBeObject);
      let loader = getFlag(options, keys5, "loader", mustBeObject);
      let outExtension = getFlag(options, keys5, "outExtension", mustBeObject);
      let publicPath = getFlag(options, keys5, "publicPath", mustBeString);
      let entryNames = getFlag(options, keys5, "entryNames", mustBeString);
      let chunkNames = getFlag(options, keys5, "chunkNames", mustBeString);
      let assetNames = getFlag(options, keys5, "assetNames", mustBeString);
      let inject = getFlag(options, keys5, "inject", mustBeArray);
      let banner = getFlag(options, keys5, "banner", mustBeObject);
      let footer = getFlag(options, keys5, "footer", mustBeObject);
      let entryPoints = getFlag(options, keys5, "entryPoints", mustBeEntryPoints);
      let absWorkingDir = getFlag(options, keys5, "absWorkingDir", mustBeString);
      let stdin = getFlag(options, keys5, "stdin", mustBeObject);
      let write3 = (_a22 = getFlag(options, keys5, "write", mustBeBoolean)) != null ? _a22 : writeDefault;
      let allowOverwrite = getFlag(options, keys5, "allowOverwrite", mustBeBoolean);
      let mangleCache = getFlag(options, keys5, "mangleCache", mustBeObject);
      keys5.plugins = true;
      checkForInvalidFlags(options, keys5, `in ${callName}() call`);
      if (sourcemap) flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
      if (bundle) flags.push("--bundle");
      if (allowOverwrite) flags.push("--allow-overwrite");
      if (splitting) flags.push("--splitting");
      if (preserveSymlinks) flags.push("--preserve-symlinks");
      if (metafile) flags.push(`--metafile`);
      if (outfile) flags.push(`--outfile=${outfile}`);
      if (outdir) flags.push(`--outdir=${outdir}`);
      if (outbase) flags.push(`--outbase=${outbase}`);
      if (tsconfig) flags.push(`--tsconfig=${tsconfig}`);
      if (packages) flags.push(`--packages=${packages}`);
      if (resolveExtensions) {
        let values3 = [];
        for (let value of resolveExtensions) {
          validateStringValue(value, "resolve extension");
          if (value.indexOf(",") >= 0) throw new Error(`Invalid resolve extension: ${value}`);
          values3.push(value);
        }
        flags.push(`--resolve-extensions=${values3.join(",")}`);
      }
      if (publicPath) flags.push(`--public-path=${publicPath}`);
      if (entryNames) flags.push(`--entry-names=${entryNames}`);
      if (chunkNames) flags.push(`--chunk-names=${chunkNames}`);
      if (assetNames) flags.push(`--asset-names=${assetNames}`);
      if (mainFields) {
        let values3 = [];
        for (let value of mainFields) {
          validateStringValue(value, "main field");
          if (value.indexOf(",") >= 0) throw new Error(`Invalid main field: ${value}`);
          values3.push(value);
        }
        flags.push(`--main-fields=${values3.join(",")}`);
      }
      if (conditions) {
        let values3 = [];
        for (let value of conditions) {
          validateStringValue(value, "condition");
          if (value.indexOf(",") >= 0) throw new Error(`Invalid condition: ${value}`);
          values3.push(value);
        }
        flags.push(`--conditions=${values3.join(",")}`);
      }
      if (external) for (let name of external) flags.push(`--external:${validateStringValue(name, "external")}`);
      if (alias) {
        for (let old in alias) {
          if (old.indexOf("=") >= 0) throw new Error(`Invalid package name in alias: ${old}`);
          flags.push(`--alias:${old}=${validateStringValue(alias[old], "alias", old)}`);
        }
      }
      if (banner) {
        for (let type in banner) {
          if (type.indexOf("=") >= 0) throw new Error(`Invalid banner file type: ${type}`);
          flags.push(`--banner:${type}=${validateStringValue(banner[type], "banner", type)}`);
        }
      }
      if (footer) {
        for (let type in footer) {
          if (type.indexOf("=") >= 0) throw new Error(`Invalid footer file type: ${type}`);
          flags.push(`--footer:${type}=${validateStringValue(footer[type], "footer", type)}`);
        }
      }
      if (inject) for (let path32 of inject) flags.push(`--inject:${validateStringValue(path32, "inject")}`);
      if (loader) {
        for (let ext in loader) {
          if (ext.indexOf("=") >= 0) throw new Error(`Invalid loader extension: ${ext}`);
          flags.push(`--loader:${ext}=${validateStringValue(loader[ext], "loader", ext)}`);
        }
      }
      if (outExtension) {
        for (let ext in outExtension) {
          if (ext.indexOf("=") >= 0) throw new Error(`Invalid out extension: ${ext}`);
          flags.push(`--out-extension:${ext}=${validateStringValue(outExtension[ext], "out extension", ext)}`);
        }
      }
      if (entryPoints) {
        if (Array.isArray(entryPoints)) {
          for (let i = 0, n2 = entryPoints.length; i < n2; i++) {
            let entryPoint = entryPoints[i];
            if (typeof entryPoint === "object" && entryPoint !== null) {
              let entryPointKeys = /* @__PURE__ */ Object.create(null);
              let input2 = getFlag(entryPoint, entryPointKeys, "in", mustBeString);
              let output = getFlag(entryPoint, entryPointKeys, "out", mustBeString);
              checkForInvalidFlags(entryPoint, entryPointKeys, "in entry point at index " + i);
              if (input2 === void 0) throw new Error('Missing property "in" for entry point at index ' + i);
              if (output === void 0) throw new Error('Missing property "out" for entry point at index ' + i);
              entries2.push([output, input2]);
            } else {
              entries2.push(["", validateStringValue(entryPoint, "entry point at index " + i)]);
            }
          }
        } else {
          for (let key in entryPoints) {
            entries2.push([key, validateStringValue(entryPoints[key], "entry point", key)]);
          }
        }
      }
      if (stdin) {
        let stdinKeys = /* @__PURE__ */ Object.create(null);
        let contents = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
        let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
        let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
        let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
        checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
        if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);
        if (loader2) flags.push(`--loader=${loader2}`);
        if (resolveDir) stdinResolveDir = resolveDir;
        if (typeof contents === "string") stdinContents = encodeUTF8(contents);
        else if (contents instanceof Uint8Array) stdinContents = contents;
      }
      let nodePaths = [];
      if (nodePathsInput) {
        for (let value of nodePathsInput) {
          value += "";
          nodePaths.push(value);
        }
      }
      return {
        entries: entries2,
        flags,
        write: write3,
        stdinContents,
        stdinResolveDir,
        absWorkingDir,
        nodePaths,
        mangleCache: validateMangleCache(mangleCache)
      };
    }
    function flagsForTransformOptions(callName, options, isTTY2, logLevelDefault) {
      let flags = [];
      let keys5 = /* @__PURE__ */ Object.create(null);
      pushLogFlags(flags, options, keys5, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options, keys5);
      let sourcemap = getFlag(options, keys5, "sourcemap", mustBeStringOrBoolean);
      let sourcefile = getFlag(options, keys5, "sourcefile", mustBeString);
      let loader = getFlag(options, keys5, "loader", mustBeString);
      let banner = getFlag(options, keys5, "banner", mustBeString);
      let footer = getFlag(options, keys5, "footer", mustBeString);
      let mangleCache = getFlag(options, keys5, "mangleCache", mustBeObject);
      checkForInvalidFlags(options, keys5, `in ${callName}() call`);
      if (sourcemap) flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
      if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);
      if (loader) flags.push(`--loader=${loader}`);
      if (banner) flags.push(`--banner=${banner}`);
      if (footer) flags.push(`--footer=${footer}`);
      return {
        flags,
        mangleCache: validateMangleCache(mangleCache)
      };
    }
    function createChannel(streamIn) {
      const requestCallbacksByKey = {};
      const closeData = { didClose: false, reason: "" };
      let responseCallbacks = {};
      let nextRequestID = 0;
      let nextBuildKey = 0;
      let stdout = new Uint8Array(16 * 1024);
      let stdoutUsed = 0;
      let readFromStdout = (chunk5) => {
        let limit = stdoutUsed + chunk5.length;
        if (limit > stdout.length) {
          let swap3 = new Uint8Array(limit * 2);
          swap3.set(stdout);
          stdout = swap3;
        }
        stdout.set(chunk5, stdoutUsed);
        stdoutUsed += chunk5.length;
        let offset = 0;
        while (offset + 4 <= stdoutUsed) {
          let length3 = readUInt32LE(stdout, offset);
          if (offset + 4 + length3 > stdoutUsed) {
            break;
          }
          offset += 4;
          handleIncomingPacket(stdout.subarray(offset, offset + length3));
          offset += length3;
        }
        if (offset > 0) {
          stdout.copyWithin(0, offset, stdoutUsed);
          stdoutUsed -= offset;
        }
      };
      let afterClose = (error4) => {
        closeData.didClose = true;
        if (error4) closeData.reason = ": " + (error4.message || error4);
        const text = "The service was stopped" + closeData.reason;
        for (let id2 in responseCallbacks) {
          responseCallbacks[id2](text, null);
        }
        responseCallbacks = {};
      };
      let sendRequest = (refs, value, callback) => {
        if (closeData.didClose) return callback("The service is no longer running" + closeData.reason, null);
        let id2 = nextRequestID++;
        responseCallbacks[id2] = (error4, response) => {
          try {
            callback(error4, response);
          } finally {
            if (refs) refs.unref();
          }
        };
        if (refs) refs.ref();
        streamIn.writeToStdin(encodePacket({ id: id2, isRequest: true, value }));
      };
      let sendResponse = (id2, value) => {
        if (closeData.didClose) throw new Error("The service is no longer running" + closeData.reason);
        streamIn.writeToStdin(encodePacket({ id: id2, isRequest: false, value }));
      };
      let handleRequest = async (id2, request2) => {
        try {
          if (request2.command === "ping") {
            sendResponse(id2, {});
            return;
          }
          if (typeof request2.key === "number") {
            const requestCallbacks = requestCallbacksByKey[request2.key];
            if (!requestCallbacks) {
              return;
            }
            const callback = requestCallbacks[request2.command];
            if (callback) {
              await callback(id2, request2);
              return;
            }
          }
          throw new Error(`Invalid command: ` + request2.command);
        } catch (e) {
          const errors = [extractErrorMessageV8(e, streamIn, null, void 0, "")];
          try {
            sendResponse(id2, { errors });
          } catch {
          }
        }
      };
      let isFirstPacket = true;
      let handleIncomingPacket = (bytes) => {
        if (isFirstPacket) {
          isFirstPacket = false;
          let binaryVersion = String.fromCharCode(...bytes);
          if (binaryVersion !== "0.25.1") {
            throw new Error(`Cannot start service: Host version "${"0.25.1"}" does not match binary version ${quote(binaryVersion)}`);
          }
          return;
        }
        let packet = decodePacket(bytes);
        if (packet.isRequest) {
          handleRequest(packet.id, packet.value);
        } else {
          let callback = responseCallbacks[packet.id];
          delete responseCallbacks[packet.id];
          if (packet.value.error) callback(packet.value.error, {});
          else callback(null, packet.value);
        }
      };
      let buildOrContext = ({ callName, refs, options, isTTY: isTTY2, defaultWD: defaultWD2, callback }) => {
        let refCount = 0;
        const buildKey = nextBuildKey++;
        const requestCallbacks = {};
        const buildRefs = {
          ref() {
            if (++refCount === 1) {
              if (refs) refs.ref();
            }
          },
          unref() {
            if (--refCount === 0) {
              delete requestCallbacksByKey[buildKey];
              if (refs) refs.unref();
            }
          }
        };
        requestCallbacksByKey[buildKey] = requestCallbacks;
        buildRefs.ref();
        buildOrContextImpl(
          callName,
          buildKey,
          sendRequest,
          sendResponse,
          buildRefs,
          streamIn,
          requestCallbacks,
          options,
          isTTY2,
          defaultWD2,
          (err, res) => {
            try {
              callback(err, res);
            } finally {
              buildRefs.unref();
            }
          }
        );
      };
      let transform23 = ({ callName, refs, input: input2, options, isTTY: isTTY2, fs: fs32, callback }) => {
        const details = createObjectStash();
        let start3 = (inputPath) => {
          try {
            if (typeof input2 !== "string" && !(input2 instanceof Uint8Array))
              throw new Error('The input to "transform" must be a string or a Uint8Array');
            let {
              flags,
              mangleCache
            } = flagsForTransformOptions(callName, options, isTTY2, transformLogLevelDefault);
            let request2 = {
              command: "transform",
              flags,
              inputFS: inputPath !== null,
              input: inputPath !== null ? encodeUTF8(inputPath) : typeof input2 === "string" ? encodeUTF8(input2) : input2
            };
            if (mangleCache) request2.mangleCache = mangleCache;
            sendRequest(refs, request2, (error4, response) => {
              if (error4) return callback(new Error(error4), null);
              let errors = replaceDetailsInMessages(response.errors, details);
              let warnings = replaceDetailsInMessages(response.warnings, details);
              let outstanding = 1;
              let next = () => {
                if (--outstanding === 0) {
                  let result = {
                    warnings,
                    code: response.code,
                    map: response.map,
                    mangleCache: void 0,
                    legalComments: void 0
                  };
                  if ("legalComments" in response) result.legalComments = response == null ? void 0 : response.legalComments;
                  if (response.mangleCache) result.mangleCache = response == null ? void 0 : response.mangleCache;
                  callback(null, result);
                }
              };
              if (errors.length > 0) return callback(failureErrorWithLog("Transform failed", errors, warnings), null);
              if (response.codeFS) {
                outstanding++;
                fs32.readFile(response.code, (err, contents) => {
                  if (err !== null) {
                    callback(err, null);
                  } else {
                    response.code = contents;
                    next();
                  }
                });
              }
              if (response.mapFS) {
                outstanding++;
                fs32.readFile(response.map, (err, contents) => {
                  if (err !== null) {
                    callback(err, null);
                  } else {
                    response.map = contents;
                    next();
                  }
                });
              }
              next();
            });
          } catch (e) {
            let flags = [];
            try {
              pushLogFlags(flags, options, {}, isTTY2, transformLogLevelDefault);
            } catch {
            }
            const error4 = extractErrorMessageV8(e, streamIn, details, void 0, "");
            sendRequest(refs, { command: "error", flags, error: error4 }, () => {
              error4.detail = details.load(error4.detail);
              callback(failureErrorWithLog("Transform failed", [error4], []), null);
            });
          }
        };
        if ((typeof input2 === "string" || input2 instanceof Uint8Array) && input2.length > 1024 * 1024) {
          let next = start3;
          start3 = () => fs32.writeFile(input2, next);
        }
        start3(null);
      };
      let formatMessages22 = ({ callName, refs, messages, options, callback }) => {
        if (!options) throw new Error(`Missing second argument in ${callName}() call`);
        let keys5 = {};
        let kind = getFlag(options, keys5, "kind", mustBeString);
        let color = getFlag(options, keys5, "color", mustBeBoolean);
        let terminalWidth = getFlag(options, keys5, "terminalWidth", mustBeInteger);
        checkForInvalidFlags(options, keys5, `in ${callName}() call`);
        if (kind === void 0) throw new Error(`Missing "kind" in ${callName}() call`);
        if (kind !== "error" && kind !== "warning") throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
        let request2 = {
          command: "format-msgs",
          messages: sanitizeMessages(messages, "messages", null, "", terminalWidth),
          isWarning: kind === "warning"
        };
        if (color !== void 0) request2.color = color;
        if (terminalWidth !== void 0) request2.terminalWidth = terminalWidth;
        sendRequest(refs, request2, (error4, response) => {
          if (error4) return callback(new Error(error4), null);
          callback(null, response.messages);
        });
      };
      let analyzeMetafile2 = ({ callName, refs, metafile, options, callback }) => {
        if (options === void 0) options = {};
        let keys5 = {};
        let color = getFlag(options, keys5, "color", mustBeBoolean);
        let verbose = getFlag(options, keys5, "verbose", mustBeBoolean);
        checkForInvalidFlags(options, keys5, `in ${callName}() call`);
        let request2 = {
          command: "analyze-metafile",
          metafile
        };
        if (color !== void 0) request2.color = color;
        if (verbose !== void 0) request2.verbose = verbose;
        sendRequest(refs, request2, (error4, response) => {
          if (error4) return callback(new Error(error4), null);
          callback(null, response.result);
        });
      };
      return {
        readFromStdout,
        afterClose,
        service: {
          buildOrContext,
          transform: transform23,
          formatMessages: formatMessages22,
          analyzeMetafile: analyzeMetafile2
        }
      };
    }
    function buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, isTTY2, defaultWD2, callback) {
      const details = createObjectStash();
      const isContext3 = callName === "context";
      const handleError = (e, pluginName) => {
        const flags = [];
        try {
          pushLogFlags(flags, options, {}, isTTY2, buildLogLevelDefault);
        } catch {
        }
        const message = extractErrorMessageV8(e, streamIn, details, void 0, pluginName);
        sendRequest(refs, { command: "error", flags, error: message }, () => {
          message.detail = details.load(message.detail);
          callback(failureErrorWithLog(isContext3 ? "Context failed" : "Build failed", [message], []), null);
        });
      };
      let plugins;
      if (typeof options === "object") {
        const value = options.plugins;
        if (value !== void 0) {
          if (!Array.isArray(value)) return handleError(new Error(`"plugins" must be an array`), "");
          plugins = value;
        }
      }
      if (plugins && plugins.length > 0) {
        if (streamIn.isSync) return handleError(new Error("Cannot use plugins in synchronous API calls"), "");
        handlePlugins(
          buildKey,
          sendRequest,
          sendResponse,
          refs,
          streamIn,
          requestCallbacks,
          options,
          plugins,
          details
        ).then(
          (result) => {
            if (!result.ok) return handleError(result.error, result.pluginName);
            try {
              buildOrContextContinue(result.requestPlugins, result.runOnEndCallbacks, result.scheduleOnDisposeCallbacks);
            } catch (e) {
              handleError(e, "");
            }
          },
          (e) => handleError(e, "")
        );
        return;
      }
      try {
        buildOrContextContinue(null, (result, done11) => done11([], []), () => {
        });
      } catch (e) {
        handleError(e, "");
      }
      function buildOrContextContinue(requestPlugins, runOnEndCallbacks, scheduleOnDisposeCallbacks) {
        const writeDefault = streamIn.hasFS;
        const {
          entries: entries2,
          flags,
          write: write3,
          stdinContents,
          stdinResolveDir,
          absWorkingDir,
          nodePaths,
          mangleCache
        } = flagsForBuildOptions(callName, options, isTTY2, buildLogLevelDefault, writeDefault);
        if (write3 && !streamIn.hasFS) throw new Error(`The "write" option is unavailable in this environment`);
        const request2 = {
          command: "build",
          key: buildKey,
          entries: entries2,
          flags,
          write: write3,
          stdinContents,
          stdinResolveDir,
          absWorkingDir: absWorkingDir || defaultWD2,
          nodePaths,
          context: isContext3
        };
        if (requestPlugins) request2.plugins = requestPlugins;
        if (mangleCache) request2.mangleCache = mangleCache;
        const buildResponseToResult = (response, callback2) => {
          const result = {
            errors: replaceDetailsInMessages(response.errors, details),
            warnings: replaceDetailsInMessages(response.warnings, details),
            outputFiles: void 0,
            metafile: void 0,
            mangleCache: void 0
          };
          const originalErrors = result.errors.slice();
          const originalWarnings = result.warnings.slice();
          if (response.outputFiles) result.outputFiles = response.outputFiles.map(convertOutputFiles);
          if (response.metafile) result.metafile = JSON.parse(response.metafile);
          if (response.mangleCache) result.mangleCache = response.mangleCache;
          if (response.writeToStdout !== void 0) console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
          runOnEndCallbacks(result, (onEndErrors, onEndWarnings) => {
            if (originalErrors.length > 0 || onEndErrors.length > 0) {
              const error4 = failureErrorWithLog("Build failed", originalErrors.concat(onEndErrors), originalWarnings.concat(onEndWarnings));
              return callback2(error4, null, onEndErrors, onEndWarnings);
            }
            callback2(null, result, onEndErrors, onEndWarnings);
          });
        };
        let latestResultPromise;
        let provideLatestResult;
        if (isContext3)
          requestCallbacks["on-end"] = (id2, request22) => new Promise((resolve9) => {
            buildResponseToResult(request22, (err, result, onEndErrors, onEndWarnings) => {
              const response = {
                errors: onEndErrors,
                warnings: onEndWarnings
              };
              if (provideLatestResult) provideLatestResult(err, result);
              latestResultPromise = void 0;
              provideLatestResult = void 0;
              sendResponse(id2, response);
              resolve9();
            });
          });
        sendRequest(refs, request2, (error4, response) => {
          if (error4) return callback(new Error(error4), null);
          if (!isContext3) {
            return buildResponseToResult(response, (err, res) => {
              scheduleOnDisposeCallbacks();
              return callback(err, res);
            });
          }
          if (response.errors.length > 0) {
            return callback(failureErrorWithLog("Context failed", response.errors, response.warnings), null);
          }
          let didDispose = false;
          const result = {
            rebuild: () => {
              if (!latestResultPromise) latestResultPromise = new Promise((resolve9, reject) => {
                let settlePromise;
                provideLatestResult = (err, result2) => {
                  if (!settlePromise) settlePromise = () => err ? reject(err) : resolve9(result2);
                };
                const triggerAnotherBuild = () => {
                  const request22 = {
                    command: "rebuild",
                    key: buildKey
                  };
                  sendRequest(refs, request22, (error22, response2) => {
                    if (error22) {
                      reject(new Error(error22));
                    } else if (settlePromise) {
                      settlePromise();
                    } else {
                      triggerAnotherBuild();
                    }
                  });
                };
                triggerAnotherBuild();
              });
              return latestResultPromise;
            },
            watch: (options2 = {}) => new Promise((resolve9, reject) => {
              if (!streamIn.hasFS) throw new Error(`Cannot use the "watch" API in this environment`);
              const keys5 = {};
              checkForInvalidFlags(options2, keys5, `in watch() call`);
              const request22 = {
                command: "watch",
                key: buildKey
              };
              sendRequest(refs, request22, (error22) => {
                if (error22) reject(new Error(error22));
                else resolve9(void 0);
              });
            }),
            serve: (options2 = {}) => new Promise((resolve9, reject) => {
              if (!streamIn.hasFS) throw new Error(`Cannot use the "serve" API in this environment`);
              const keys5 = {};
              const port = getFlag(options2, keys5, "port", mustBeValidPortNumber);
              const host = getFlag(options2, keys5, "host", mustBeString);
              const servedir = getFlag(options2, keys5, "servedir", mustBeString);
              const keyfile = getFlag(options2, keys5, "keyfile", mustBeString);
              const certfile = getFlag(options2, keys5, "certfile", mustBeString);
              const fallback = getFlag(options2, keys5, "fallback", mustBeString);
              const onRequest = getFlag(options2, keys5, "onRequest", mustBeFunction);
              checkForInvalidFlags(options2, keys5, `in serve() call`);
              const request22 = {
                command: "serve",
                key: buildKey,
                onRequest: !!onRequest
              };
              if (port !== void 0) request22.port = port;
              if (host !== void 0) request22.host = host;
              if (servedir !== void 0) request22.servedir = servedir;
              if (keyfile !== void 0) request22.keyfile = keyfile;
              if (certfile !== void 0) request22.certfile = certfile;
              if (fallback !== void 0) request22.fallback = fallback;
              sendRequest(refs, request22, (error22, response2) => {
                if (error22) return reject(new Error(error22));
                if (onRequest) {
                  requestCallbacks["serve-request"] = (id2, request3) => {
                    onRequest(request3.args);
                    sendResponse(id2, {});
                  };
                }
                resolve9(response2);
              });
            }),
            cancel: () => new Promise((resolve9) => {
              if (didDispose) return resolve9();
              const request22 = {
                command: "cancel",
                key: buildKey
              };
              sendRequest(refs, request22, () => {
                resolve9();
              });
            }),
            dispose: () => new Promise((resolve9) => {
              if (didDispose) return resolve9();
              didDispose = true;
              const request22 = {
                command: "dispose",
                key: buildKey
              };
              sendRequest(refs, request22, () => {
                resolve9();
                scheduleOnDisposeCallbacks();
                refs.unref();
              });
            })
          };
          refs.ref();
          callback(null, result);
        });
      }
    }
    var handlePlugins = async (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins, details) => {
      let onStartCallbacks = [];
      let onEndCallbacks = [];
      let onResolveCallbacks = {};
      let onLoadCallbacks = {};
      let onDisposeCallbacks = [];
      let nextCallbackID = 0;
      let i = 0;
      let requestPlugins = [];
      let isSetupDone = false;
      plugins = [...plugins];
      for (let item of plugins) {
        let keys5 = {};
        if (typeof item !== "object") throw new Error(`Plugin at index ${i} must be an object`);
        const name = getFlag(item, keys5, "name", mustBeString);
        if (typeof name !== "string" || name === "") throw new Error(`Plugin at index ${i} is missing a name`);
        try {
          let setup = getFlag(item, keys5, "setup", mustBeFunction);
          if (typeof setup !== "function") throw new Error(`Plugin is missing a setup function`);
          checkForInvalidFlags(item, keys5, `on plugin ${quote(name)}`);
          let plugin = {
            name,
            onStart: false,
            onEnd: false,
            onResolve: [],
            onLoad: []
          };
          i++;
          let resolve9 = (path32, options = {}) => {
            if (!isSetupDone) throw new Error('Cannot call "resolve" before plugin setup has completed');
            if (typeof path32 !== "string") throw new Error(`The path to resolve must be a string`);
            let keys22 = /* @__PURE__ */ Object.create(null);
            let pluginName = getFlag(options, keys22, "pluginName", mustBeString);
            let importer = getFlag(options, keys22, "importer", mustBeString);
            let namespace = getFlag(options, keys22, "namespace", mustBeString);
            let resolveDir = getFlag(options, keys22, "resolveDir", mustBeString);
            let kind = getFlag(options, keys22, "kind", mustBeString);
            let pluginData = getFlag(options, keys22, "pluginData", canBeAnything);
            let importAttributes = getFlag(options, keys22, "with", mustBeObject);
            checkForInvalidFlags(options, keys22, "in resolve() call");
            return new Promise((resolve22, reject) => {
              const request2 = {
                command: "resolve",
                path: path32,
                key: buildKey,
                pluginName: name
              };
              if (pluginName != null) request2.pluginName = pluginName;
              if (importer != null) request2.importer = importer;
              if (namespace != null) request2.namespace = namespace;
              if (resolveDir != null) request2.resolveDir = resolveDir;
              if (kind != null) request2.kind = kind;
              else throw new Error(`Must specify "kind" when calling "resolve"`);
              if (pluginData != null) request2.pluginData = details.store(pluginData);
              if (importAttributes != null) request2.with = sanitizeStringMap(importAttributes, "with");
              sendRequest(refs, request2, (error4, response) => {
                if (error4 !== null) reject(new Error(error4));
                else resolve22({
                  errors: replaceDetailsInMessages(response.errors, details),
                  warnings: replaceDetailsInMessages(response.warnings, details),
                  path: response.path,
                  external: response.external,
                  sideEffects: response.sideEffects,
                  namespace: response.namespace,
                  suffix: response.suffix,
                  pluginData: details.load(response.pluginData)
                });
              });
            });
          };
          let promise3 = setup({
            initialOptions,
            resolve: resolve9,
            onStart(callback) {
              let registeredText = `This error came from the "onStart" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
              onStartCallbacks.push({ name, callback, note: registeredNote });
              plugin.onStart = true;
            },
            onEnd(callback) {
              let registeredText = `This error came from the "onEnd" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
              onEndCallbacks.push({ name, callback, note: registeredNote });
              plugin.onEnd = true;
            },
            onResolve(options, callback) {
              let registeredText = `This error came from the "onResolve" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
              let keys22 = {};
              let filter10 = getFlag(options, keys22, "filter", mustBeRegExp);
              let namespace = getFlag(options, keys22, "namespace", mustBeString);
              checkForInvalidFlags(options, keys22, `in onResolve() call for plugin ${quote(name)}`);
              if (filter10 == null) throw new Error(`onResolve() call is missing a filter`);
              let id2 = nextCallbackID++;
              onResolveCallbacks[id2] = { name, callback, note: registeredNote };
              plugin.onResolve.push({ id: id2, filter: filter10.source, namespace: namespace || "" });
            },
            onLoad(options, callback) {
              let registeredText = `This error came from the "onLoad" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
              let keys22 = {};
              let filter10 = getFlag(options, keys22, "filter", mustBeRegExp);
              let namespace = getFlag(options, keys22, "namespace", mustBeString);
              checkForInvalidFlags(options, keys22, `in onLoad() call for plugin ${quote(name)}`);
              if (filter10 == null) throw new Error(`onLoad() call is missing a filter`);
              let id2 = nextCallbackID++;
              onLoadCallbacks[id2] = { name, callback, note: registeredNote };
              plugin.onLoad.push({ id: id2, filter: filter10.source, namespace: namespace || "" });
            },
            onDispose(callback) {
              onDisposeCallbacks.push(callback);
            },
            esbuild: streamIn.esbuild
          });
          if (promise3) await promise3;
          requestPlugins.push(plugin);
        } catch (e) {
          return { ok: false, error: e, pluginName: name };
        }
      }
      requestCallbacks["on-start"] = async (id2, request2) => {
        details.clear();
        let response = { errors: [], warnings: [] };
        await Promise.all(onStartCallbacks.map(async ({ name, callback, note }) => {
          try {
            let result = await callback();
            if (result != null) {
              if (typeof result !== "object") throw new Error(`Expected onStart() callback in plugin ${quote(name)} to return an object`);
              let keys5 = {};
              let errors = getFlag(result, keys5, "errors", mustBeArray);
              let warnings = getFlag(result, keys5, "warnings", mustBeArray);
              checkForInvalidFlags(result, keys5, `from onStart() callback in plugin ${quote(name)}`);
              if (errors != null) response.errors.push(...sanitizeMessages(errors, "errors", details, name, void 0));
              if (warnings != null) response.warnings.push(...sanitizeMessages(warnings, "warnings", details, name, void 0));
            }
          } catch (e) {
            response.errors.push(extractErrorMessageV8(e, streamIn, details, note && note(), name));
          }
        }));
        sendResponse(id2, response);
      };
      requestCallbacks["on-resolve"] = async (id2, request2) => {
        let response = {}, name = "", callback, note;
        for (let id22 of request2.ids) {
          try {
            ({ name, callback, note } = onResolveCallbacks[id22]);
            let result = await callback({
              path: request2.path,
              importer: request2.importer,
              namespace: request2.namespace,
              resolveDir: request2.resolveDir,
              kind: request2.kind,
              pluginData: details.load(request2.pluginData),
              with: request2.with
            });
            if (result != null) {
              if (typeof result !== "object") throw new Error(`Expected onResolve() callback in plugin ${quote(name)} to return an object`);
              let keys5 = {};
              let pluginName = getFlag(result, keys5, "pluginName", mustBeString);
              let path32 = getFlag(result, keys5, "path", mustBeString);
              let namespace = getFlag(result, keys5, "namespace", mustBeString);
              let suffix = getFlag(result, keys5, "suffix", mustBeString);
              let external = getFlag(result, keys5, "external", mustBeBoolean);
              let sideEffects = getFlag(result, keys5, "sideEffects", mustBeBoolean);
              let pluginData = getFlag(result, keys5, "pluginData", canBeAnything);
              let errors = getFlag(result, keys5, "errors", mustBeArray);
              let warnings = getFlag(result, keys5, "warnings", mustBeArray);
              let watchFiles = getFlag(result, keys5, "watchFiles", mustBeArray);
              let watchDirs = getFlag(result, keys5, "watchDirs", mustBeArray);
              checkForInvalidFlags(result, keys5, `from onResolve() callback in plugin ${quote(name)}`);
              response.id = id22;
              if (pluginName != null) response.pluginName = pluginName;
              if (path32 != null) response.path = path32;
              if (namespace != null) response.namespace = namespace;
              if (suffix != null) response.suffix = suffix;
              if (external != null) response.external = external;
              if (sideEffects != null) response.sideEffects = sideEffects;
              if (pluginData != null) response.pluginData = details.store(pluginData);
              if (errors != null) response.errors = sanitizeMessages(errors, "errors", details, name, void 0);
              if (warnings != null) response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
              if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
              if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
              break;
            }
          } catch (e) {
            response = { id: id22, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
            break;
          }
        }
        sendResponse(id2, response);
      };
      requestCallbacks["on-load"] = async (id2, request2) => {
        let response = {}, name = "", callback, note;
        for (let id22 of request2.ids) {
          try {
            ({ name, callback, note } = onLoadCallbacks[id22]);
            let result = await callback({
              path: request2.path,
              namespace: request2.namespace,
              suffix: request2.suffix,
              pluginData: details.load(request2.pluginData),
              with: request2.with
            });
            if (result != null) {
              if (typeof result !== "object") throw new Error(`Expected onLoad() callback in plugin ${quote(name)} to return an object`);
              let keys5 = {};
              let pluginName = getFlag(result, keys5, "pluginName", mustBeString);
              let contents = getFlag(result, keys5, "contents", mustBeStringOrUint8Array);
              let resolveDir = getFlag(result, keys5, "resolveDir", mustBeString);
              let pluginData = getFlag(result, keys5, "pluginData", canBeAnything);
              let loader = getFlag(result, keys5, "loader", mustBeString);
              let errors = getFlag(result, keys5, "errors", mustBeArray);
              let warnings = getFlag(result, keys5, "warnings", mustBeArray);
              let watchFiles = getFlag(result, keys5, "watchFiles", mustBeArray);
              let watchDirs = getFlag(result, keys5, "watchDirs", mustBeArray);
              checkForInvalidFlags(result, keys5, `from onLoad() callback in plugin ${quote(name)}`);
              response.id = id22;
              if (pluginName != null) response.pluginName = pluginName;
              if (contents instanceof Uint8Array) response.contents = contents;
              else if (contents != null) response.contents = encodeUTF8(contents);
              if (resolveDir != null) response.resolveDir = resolveDir;
              if (pluginData != null) response.pluginData = details.store(pluginData);
              if (loader != null) response.loader = loader;
              if (errors != null) response.errors = sanitizeMessages(errors, "errors", details, name, void 0);
              if (warnings != null) response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
              if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
              if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
              break;
            }
          } catch (e) {
            response = { id: id22, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
            break;
          }
        }
        sendResponse(id2, response);
      };
      let runOnEndCallbacks = (result, done11) => done11([], []);
      if (onEndCallbacks.length > 0) {
        runOnEndCallbacks = (result, done11) => {
          (async () => {
            const onEndErrors = [];
            const onEndWarnings = [];
            for (const { name, callback, note } of onEndCallbacks) {
              let newErrors;
              let newWarnings;
              try {
                const value = await callback(result);
                if (value != null) {
                  if (typeof value !== "object") throw new Error(`Expected onEnd() callback in plugin ${quote(name)} to return an object`);
                  let keys5 = {};
                  let errors = getFlag(value, keys5, "errors", mustBeArray);
                  let warnings = getFlag(value, keys5, "warnings", mustBeArray);
                  checkForInvalidFlags(value, keys5, `from onEnd() callback in plugin ${quote(name)}`);
                  if (errors != null) newErrors = sanitizeMessages(errors, "errors", details, name, void 0);
                  if (warnings != null) newWarnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
                }
              } catch (e) {
                newErrors = [extractErrorMessageV8(e, streamIn, details, note && note(), name)];
              }
              if (newErrors) {
                onEndErrors.push(...newErrors);
                try {
                  result.errors.push(...newErrors);
                } catch {
                }
              }
              if (newWarnings) {
                onEndWarnings.push(...newWarnings);
                try {
                  result.warnings.push(...newWarnings);
                } catch {
                }
              }
            }
            done11(onEndErrors, onEndWarnings);
          })();
        };
      }
      let scheduleOnDisposeCallbacks = () => {
        for (const cb of onDisposeCallbacks) {
          setTimeout(() => cb(), 0);
        }
      };
      isSetupDone = true;
      return {
        ok: true,
        requestPlugins,
        runOnEndCallbacks,
        scheduleOnDisposeCallbacks
      };
    };
    function createObjectStash() {
      const map26 = /* @__PURE__ */ new Map();
      let nextID = 0;
      return {
        clear() {
          map26.clear();
        },
        load(id2) {
          return map26.get(id2);
        },
        store(value) {
          if (value === void 0) return -1;
          const id2 = nextID++;
          map26.set(id2, value);
          return id2;
        }
      };
    }
    function extractCallerV8(e, streamIn, ident) {
      let note;
      let tried = false;
      return () => {
        if (tried) return note;
        tried = true;
        try {
          let lines = (e.stack + "").split("\n");
          lines.splice(1, 1);
          let location = parseStackLinesV8(streamIn, lines, ident);
          if (location) {
            note = { text: e.message, location };
            return note;
          }
        } catch {
        }
      };
    }
    function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {
      let text = "Internal error";
      let location = null;
      try {
        text = (e && e.message || e) + "";
      } catch {
      }
      try {
        location = parseStackLinesV8(streamIn, (e.stack + "").split("\n"), "");
      } catch {
      }
      return { id: "", pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };
    }
    function parseStackLinesV8(streamIn, lines, ident) {
      let at = "    at ";
      if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {
        for (let i = 1; i < lines.length; i++) {
          let line = lines[i];
          if (!line.startsWith(at)) continue;
          line = line.slice(at.length);
          while (true) {
            let match18 = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);
            if (match18) {
              line = match18[1];
              continue;
            }
            match18 = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);
            if (match18) {
              line = match18[1];
              continue;
            }
            match18 = /^(\S+):(\d+):(\d+)$/.exec(line);
            if (match18) {
              let contents;
              try {
                contents = streamIn.readFileSync(match18[1], "utf8");
              } catch {
                break;
              }
              let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match18[2] - 1] || "";
              let column = +match18[3] - 1;
              let length3 = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;
              return {
                file: match18[1],
                namespace: "file",
                line: +match18[2],
                column: encodeUTF8(lineText.slice(0, column)).length,
                length: encodeUTF8(lineText.slice(column, column + length3)).length,
                lineText: lineText + "\n" + lines.slice(1).join("\n"),
                suggestion: ""
              };
            }
            break;
          }
        }
      }
      return null;
    }
    function failureErrorWithLog(text, errors, warnings) {
      let limit = 5;
      text += errors.length < 1 ? "" : ` with ${errors.length} error${errors.length < 2 ? "" : "s"}:` + errors.slice(0, limit + 1).map((e, i) => {
        if (i === limit) return "\n...";
        if (!e.location) return `
error: ${e.text}`;
        let { file, line, column } = e.location;
        let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : "";
        return `
${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;
      }).join("");
      let error4 = new Error(text);
      for (const [key, value] of [["errors", errors], ["warnings", warnings]]) {
        Object.defineProperty(error4, key, {
          configurable: true,
          enumerable: true,
          get: () => value,
          set: (value2) => Object.defineProperty(error4, key, {
            configurable: true,
            enumerable: true,
            value: value2
          })
        });
      }
      return error4;
    }
    function replaceDetailsInMessages(messages, stash) {
      for (const message of messages) {
        message.detail = stash.load(message.detail);
      }
      return messages;
    }
    function sanitizeLocation(location, where, terminalWidth) {
      if (location == null) return null;
      let keys5 = {};
      let file = getFlag(location, keys5, "file", mustBeString);
      let namespace = getFlag(location, keys5, "namespace", mustBeString);
      let line = getFlag(location, keys5, "line", mustBeInteger);
      let column = getFlag(location, keys5, "column", mustBeInteger);
      let length3 = getFlag(location, keys5, "length", mustBeInteger);
      let lineText = getFlag(location, keys5, "lineText", mustBeString);
      let suggestion = getFlag(location, keys5, "suggestion", mustBeString);
      checkForInvalidFlags(location, keys5, where);
      if (lineText) {
        const relevantASCII = lineText.slice(
          0,
          (column && column > 0 ? column : 0) + (length3 && length3 > 0 ? length3 : 0) + (terminalWidth && terminalWidth > 0 ? terminalWidth : 80)
        );
        if (!/[\x7F-\uFFFF]/.test(relevantASCII) && !/\n/.test(lineText)) {
          lineText = relevantASCII;
        }
      }
      return {
        file: file || "",
        namespace: namespace || "",
        line: line || 0,
        column: column || 0,
        length: length3 || 0,
        lineText: lineText || "",
        suggestion: suggestion || ""
      };
    }
    function sanitizeMessages(messages, property3, stash, fallbackPluginName, terminalWidth) {
      let messagesClone = [];
      let index = 0;
      for (const message of messages) {
        let keys5 = {};
        let id2 = getFlag(message, keys5, "id", mustBeString);
        let pluginName = getFlag(message, keys5, "pluginName", mustBeString);
        let text = getFlag(message, keys5, "text", mustBeString);
        let location = getFlag(message, keys5, "location", mustBeObjectOrNull);
        let notes = getFlag(message, keys5, "notes", mustBeArray);
        let detail = getFlag(message, keys5, "detail", canBeAnything);
        let where = `in element ${index} of "${property3}"`;
        checkForInvalidFlags(message, keys5, where);
        let notesClone = [];
        if (notes) {
          for (const note of notes) {
            let noteKeys = {};
            let noteText = getFlag(note, noteKeys, "text", mustBeString);
            let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
            checkForInvalidFlags(note, noteKeys, where);
            notesClone.push({
              text: noteText || "",
              location: sanitizeLocation(noteLocation, where, terminalWidth)
            });
          }
        }
        messagesClone.push({
          id: id2 || "",
          pluginName: pluginName || fallbackPluginName,
          text: text || "",
          location: sanitizeLocation(location, where, terminalWidth),
          notes: notesClone,
          detail: stash ? stash.store(detail) : -1
        });
        index++;
      }
      return messagesClone;
    }
    function sanitizeStringArray(values3, property3) {
      const result = [];
      for (const value of values3) {
        if (typeof value !== "string") throw new Error(`${quote(property3)} must be an array of strings`);
        result.push(value);
      }
      return result;
    }
    function sanitizeStringMap(map26, property3) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const key in map26) {
        const value = map26[key];
        if (typeof value !== "string") throw new Error(`key ${quote(key)} in object ${quote(property3)} must be a string`);
        result[key] = value;
      }
      return result;
    }
    function convertOutputFiles({ path: path32, contents, hash: hash2 }) {
      let text = null;
      return {
        path: path32,
        contents,
        hash: hash2,
        get text() {
          const binary = this.contents;
          if (text === null || binary !== contents) {
            contents = binary;
            text = decodeUTF8(binary);
          }
          return text;
        }
      };
    }
    var fs3 = __require("fs");
    var os = __require("os");
    var path3 = __require("path");
    var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
    var isValidBinaryPath = (x2) => !!x2 && x2 !== "/usr/bin/esbuild";
    var packageDarwin_arm64 = "@esbuild/darwin-arm64";
    var packageDarwin_x64 = "@esbuild/darwin-x64";
    var knownWindowsPackages = {
      "win32 arm64 LE": "@esbuild/win32-arm64",
      "win32 ia32 LE": "@esbuild/win32-ia32",
      "win32 x64 LE": "@esbuild/win32-x64"
    };
    var knownUnixlikePackages = {
      "aix ppc64 BE": "@esbuild/aix-ppc64",
      "android arm64 LE": "@esbuild/android-arm64",
      "darwin arm64 LE": "@esbuild/darwin-arm64",
      "darwin x64 LE": "@esbuild/darwin-x64",
      "freebsd arm64 LE": "@esbuild/freebsd-arm64",
      "freebsd x64 LE": "@esbuild/freebsd-x64",
      "linux arm LE": "@esbuild/linux-arm",
      "linux arm64 LE": "@esbuild/linux-arm64",
      "linux ia32 LE": "@esbuild/linux-ia32",
      "linux mips64el LE": "@esbuild/linux-mips64el",
      "linux ppc64 LE": "@esbuild/linux-ppc64",
      "linux riscv64 LE": "@esbuild/linux-riscv64",
      "linux s390x BE": "@esbuild/linux-s390x",
      "linux x64 LE": "@esbuild/linux-x64",
      "linux loong64 LE": "@esbuild/linux-loong64",
      "netbsd arm64 LE": "@esbuild/netbsd-arm64",
      "netbsd x64 LE": "@esbuild/netbsd-x64",
      "openbsd arm64 LE": "@esbuild/openbsd-arm64",
      "openbsd x64 LE": "@esbuild/openbsd-x64",
      "sunos x64 LE": "@esbuild/sunos-x64"
    };
    var knownWebAssemblyFallbackPackages = {
      "android arm LE": "@esbuild/android-arm",
      "android x64 LE": "@esbuild/android-x64"
    };
    function pkgAndSubpathForCurrentPlatform() {
      let pkg;
      let subpath;
      let isWASM = false;
      let platformKey = `${process.platform} ${os.arch()} ${os.endianness()}`;
      if (platformKey in knownWindowsPackages) {
        pkg = knownWindowsPackages[platformKey];
        subpath = "esbuild.exe";
      } else if (platformKey in knownUnixlikePackages) {
        pkg = knownUnixlikePackages[platformKey];
        subpath = "bin/esbuild";
      } else if (platformKey in knownWebAssemblyFallbackPackages) {
        pkg = knownWebAssemblyFallbackPackages[platformKey];
        subpath = "bin/esbuild";
        isWASM = true;
      } else {
        throw new Error(`Unsupported platform: ${platformKey}`);
      }
      return { pkg, subpath, isWASM };
    }
    function pkgForSomeOtherPlatform() {
      const libMainJS = __require.resolve("esbuild");
      const nodeModulesDirectory = path3.dirname(path3.dirname(path3.dirname(libMainJS)));
      if (path3.basename(nodeModulesDirectory) === "node_modules") {
        for (const unixKey in knownUnixlikePackages) {
          try {
            const pkg = knownUnixlikePackages[unixKey];
            if (fs3.existsSync(path3.join(nodeModulesDirectory, pkg))) return pkg;
          } catch {
          }
        }
        for (const windowsKey in knownWindowsPackages) {
          try {
            const pkg = knownWindowsPackages[windowsKey];
            if (fs3.existsSync(path3.join(nodeModulesDirectory, pkg))) return pkg;
          } catch {
          }
        }
      }
      return null;
    }
    function downloadedBinPath(pkg, subpath) {
      const esbuildLibDir = path3.dirname(__require.resolve("esbuild"));
      return path3.join(esbuildLibDir, `downloaded-${pkg.replace("/", "-")}-${path3.basename(subpath)}`);
    }
    function generateBinPath() {
      if (isValidBinaryPath(ESBUILD_BINARY_PATH)) {
        if (!fs3.existsSync(ESBUILD_BINARY_PATH)) {
          console.warn(`[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=${ESBUILD_BINARY_PATH}`);
        } else {
          return { binPath: ESBUILD_BINARY_PATH, isWASM: false };
        }
      }
      const { pkg, subpath, isWASM } = pkgAndSubpathForCurrentPlatform();
      let binPath;
      try {
        binPath = __require.resolve(`${pkg}/${subpath}`);
      } catch (e) {
        binPath = downloadedBinPath(pkg, subpath);
        if (!fs3.existsSync(binPath)) {
          try {
            __require.resolve(pkg);
          } catch {
            const otherPkg = pkgForSomeOtherPlatform();
            if (otherPkg) {
              let suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead of npm which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
              if (pkg === packageDarwin_x64 && otherPkg === packageDarwin_arm64 || pkg === packageDarwin_arm64 && otherPkg === packageDarwin_x64) {
                suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild with npm running inside of Rosetta 2 and then
trying to use it with node running outside of Rosetta 2, or vice versa (Rosetta
2 is Apple's on-the-fly x86_64-to-arm64 translation service).

If you are installing with npm, you can try ensuring that both npm and node are
not running under Rosetta 2 and then reinstalling esbuild. This likely involves
changing how you installed npm and/or node. For example, installing node with
the universal installer here should work: https://nodejs.org/en/download/. Or
you could consider using yarn instead of npm which has built-in support for
installing a package on multiple platforms simultaneously.

If you are installing with yarn, you can try listing both "arm64" and "x64"
in your ".yarnrc.yml" file using the "supportedArchitectures" feature:
https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
              }
              throw new Error(`
You installed esbuild for another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.
${suggestions}
Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
            }
            throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" or "--omit=optional" flags. The "optionalDependencies" feature
of "package.json" is used by esbuild to install the correct binary executable
for your current platform.`);
          }
          throw e;
        }
      }
      if (/\.zip\//.test(binPath)) {
        let pnpapi;
        try {
          pnpapi = __require("pnpapi");
        } catch (e) {
        }
        if (pnpapi) {
          const root = pnpapi.getPackageInformation(pnpapi.topLevel).packageLocation;
          const binTargetPath = path3.join(
            root,
            "node_modules",
            ".cache",
            "esbuild",
            `pnpapi-${pkg.replace("/", "-")}-${"0.25.1"}-${path3.basename(subpath)}`
          );
          if (!fs3.existsSync(binTargetPath)) {
            fs3.mkdirSync(path3.dirname(binTargetPath), { recursive: true });
            fs3.copyFileSync(binPath, binTargetPath);
            fs3.chmodSync(binTargetPath, 493);
          }
          return { binPath: binTargetPath, isWASM };
        }
      }
      return { binPath, isWASM };
    }
    var child_process = __require("child_process");
    var crypto = __require("crypto");
    var path22 = __require("path");
    var fs22 = __require("fs");
    var os2 = __require("os");
    var tty = __require("tty");
    var worker_threads;
    if (process.env.ESBUILD_WORKER_THREADS !== "0") {
      try {
        worker_threads = __require("worker_threads");
      } catch {
      }
      let [major, minor] = process.versions.node.split(".");
      if (
        // <v12.17.0 does not work
        +major < 12 || +major === 12 && +minor < 17 || +major === 13 && +minor < 13
      ) {
        worker_threads = void 0;
      }
    }
    var _a2;
    var isInternalWorkerThread = ((_a2 = worker_threads == null ? void 0 : worker_threads.workerData) == null ? void 0 : _a2.esbuildVersion) === "0.25.1";
    var esbuildCommandAndArgs = () => {
      if ((!ESBUILD_BINARY_PATH || false) && (path22.basename(__filename) !== "main.js" || path22.basename(__dirname) !== "lib")) {
        throw new Error(
          `The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

More information: The file containing the code for esbuild's JavaScript API (${__filename}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`
        );
      }
      {
        const { binPath, isWASM } = generateBinPath();
        if (isWASM) {
          return ["node", [binPath]];
        } else {
          return [binPath, []];
        }
      }
    };
    var isTTY = () => tty.isatty(2);
    var fsSync = {
      readFile(tempFile, callback) {
        try {
          let contents = fs22.readFileSync(tempFile, "utf8");
          try {
            fs22.unlinkSync(tempFile);
          } catch {
          }
          callback(null, contents);
        } catch (err) {
          callback(err, null);
        }
      },
      writeFile(contents, callback) {
        try {
          let tempFile = randomFileName();
          fs22.writeFileSync(tempFile, contents);
          callback(tempFile);
        } catch {
          callback(null);
        }
      }
    };
    var fsAsync = {
      readFile(tempFile, callback) {
        try {
          fs22.readFile(tempFile, "utf8", (err, contents) => {
            try {
              fs22.unlink(tempFile, () => callback(err, contents));
            } catch {
              callback(err, contents);
            }
          });
        } catch (err) {
          callback(err, null);
        }
      },
      writeFile(contents, callback) {
        try {
          let tempFile = randomFileName();
          fs22.writeFile(tempFile, contents, (err) => err !== null ? callback(null) : callback(tempFile));
        } catch {
          callback(null);
        }
      }
    };
    var version3 = "0.25.1";
    var build4 = (options) => ensureServiceIsRunning().build(options);
    var context8 = (buildOptions2) => ensureServiceIsRunning().context(buildOptions2);
    var transform4 = (input2, options) => ensureServiceIsRunning().transform(input2, options);
    var formatMessages2 = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);
    var analyzeMetafile = (messages, options) => ensureServiceIsRunning().analyzeMetafile(messages, options);
    var buildSync = (options) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.buildSync(options);
      }
      let result;
      runServiceSync((service3) => service3.buildOrContext({
        callName: "buildSync",
        refs: null,
        options,
        isTTY: isTTY(),
        defaultWD,
        callback: (err, res) => {
          if (err) throw err;
          result = res;
        }
      }));
      return result;
    };
    var transformSync = (input2, options) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.transformSync(input2, options);
      }
      let result;
      runServiceSync((service3) => service3.transform({
        callName: "transformSync",
        refs: null,
        input: input2,
        options: options || {},
        isTTY: isTTY(),
        fs: fsSync,
        callback: (err, res) => {
          if (err) throw err;
          result = res;
        }
      }));
      return result;
    };
    var formatMessagesSync = (messages, options) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.formatMessagesSync(messages, options);
      }
      let result;
      runServiceSync((service3) => service3.formatMessages({
        callName: "formatMessagesSync",
        refs: null,
        messages,
        options,
        callback: (err, res) => {
          if (err) throw err;
          result = res;
        }
      }));
      return result;
    };
    var analyzeMetafileSync = (metafile, options) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.analyzeMetafileSync(metafile, options);
      }
      let result;
      runServiceSync((service3) => service3.analyzeMetafile({
        callName: "analyzeMetafileSync",
        refs: null,
        metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
        options,
        callback: (err, res) => {
          if (err) throw err;
          result = res;
        }
      }));
      return result;
    };
    var stop2 = () => {
      if (stopService) stopService();
      if (workerThreadService) workerThreadService.stop();
      return Promise.resolve();
    };
    var initializeWasCalled = false;
    var initialize = (options) => {
      options = validateInitializeOptions(options || {});
      if (options.wasmURL) throw new Error(`The "wasmURL" option only works in the browser`);
      if (options.wasmModule) throw new Error(`The "wasmModule" option only works in the browser`);
      if (options.worker) throw new Error(`The "worker" option only works in the browser`);
      if (initializeWasCalled) throw new Error('Cannot call "initialize" more than once');
      ensureServiceIsRunning();
      initializeWasCalled = true;
      return Promise.resolve();
    };
    var defaultWD = process.cwd();
    var longLivedService;
    var stopService;
    var ensureServiceIsRunning = () => {
      if (longLivedService) return longLivedService;
      let [command, args2] = esbuildCommandAndArgs();
      let child = child_process.spawn(command, args2.concat(`--service=${"0.25.1"}`, "--ping"), {
        windowsHide: true,
        stdio: ["pipe", "pipe", "inherit"],
        cwd: defaultWD
      });
      let { readFromStdout, afterClose, service: service3 } = createChannel({
        writeToStdin(bytes) {
          child.stdin.write(bytes, (err) => {
            if (err) afterClose(err);
          });
        },
        readFileSync: fs22.readFileSync,
        isSync: false,
        hasFS: true,
        esbuild: node_exports3
      });
      child.stdin.on("error", afterClose);
      child.on("error", afterClose);
      const stdin = child.stdin;
      const stdout = child.stdout;
      stdout.on("data", readFromStdout);
      stdout.on("end", afterClose);
      stopService = () => {
        stdin.destroy();
        stdout.destroy();
        child.kill();
        initializeWasCalled = false;
        longLivedService = void 0;
        stopService = void 0;
      };
      let refCount = 0;
      child.unref();
      if (stdin.unref) {
        stdin.unref();
      }
      if (stdout.unref) {
        stdout.unref();
      }
      const refs = {
        ref() {
          if (++refCount === 1) child.ref();
        },
        unref() {
          if (--refCount === 0) child.unref();
        }
      };
      longLivedService = {
        build: (options) => new Promise((resolve9, reject) => {
          service3.buildOrContext({
            callName: "build",
            refs,
            options,
            isTTY: isTTY(),
            defaultWD,
            callback: (err, res) => err ? reject(err) : resolve9(res)
          });
        }),
        context: (options) => new Promise((resolve9, reject) => service3.buildOrContext({
          callName: "context",
          refs,
          options,
          isTTY: isTTY(),
          defaultWD,
          callback: (err, res) => err ? reject(err) : resolve9(res)
        })),
        transform: (input2, options) => new Promise((resolve9, reject) => service3.transform({
          callName: "transform",
          refs,
          input: input2,
          options: options || {},
          isTTY: isTTY(),
          fs: fsAsync,
          callback: (err, res) => err ? reject(err) : resolve9(res)
        })),
        formatMessages: (messages, options) => new Promise((resolve9, reject) => service3.formatMessages({
          callName: "formatMessages",
          refs,
          messages,
          options,
          callback: (err, res) => err ? reject(err) : resolve9(res)
        })),
        analyzeMetafile: (metafile, options) => new Promise((resolve9, reject) => service3.analyzeMetafile({
          callName: "analyzeMetafile",
          refs,
          metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
          options,
          callback: (err, res) => err ? reject(err) : resolve9(res)
        }))
      };
      return longLivedService;
    };
    var runServiceSync = (callback) => {
      let [command, args2] = esbuildCommandAndArgs();
      let stdin = new Uint8Array();
      let { readFromStdout, afterClose, service: service3 } = createChannel({
        writeToStdin(bytes) {
          if (stdin.length !== 0) throw new Error("Must run at most one command");
          stdin = bytes;
        },
        isSync: true,
        hasFS: true,
        esbuild: node_exports3
      });
      callback(service3);
      let stdout = child_process.execFileSync(command, args2.concat(`--service=${"0.25.1"}`), {
        cwd: defaultWD,
        windowsHide: true,
        input: stdin,
        // We don't know how large the output could be. If it's too large, the
        // command will fail with ENOBUFS. Reserve 16mb for now since that feels
        // like it should be enough. Also allow overriding this with an environment
        // variable.
        maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
      });
      readFromStdout(stdout);
      afterClose(null);
    };
    var randomFileName = () => {
      return path22.join(os2.tmpdir(), `esbuild-${crypto.randomBytes(32).toString("hex")}`);
    };
    var workerThreadService = null;
    var startWorkerThreadService = (worker_threads2) => {
      let { port1: mainPort, port2: workerPort } = new worker_threads2.MessageChannel();
      let worker = new worker_threads2.Worker(__filename, {
        workerData: { workerPort, defaultWD, esbuildVersion: "0.25.1" },
        transferList: [workerPort],
        // From node's documentation: https://nodejs.org/api/worker_threads.html
        //
        //   Take care when launching worker threads from preload scripts (scripts loaded
        //   and run using the `-r` command line flag). Unless the `execArgv` option is
        //   explicitly set, new Worker threads automatically inherit the command line flags
        //   from the running process and will preload the same preload scripts as the main
        //   thread. If the preload script unconditionally launches a worker thread, every
        //   thread spawned will spawn another until the application crashes.
        //
        execArgv: []
      });
      let nextID = 0;
      let fakeBuildError = (text) => {
        let error4 = new Error(`Build failed with 1 error:
error: ${text}`);
        let errors = [{ id: "", pluginName: "", text, location: null, notes: [], detail: void 0 }];
        error4.errors = errors;
        error4.warnings = [];
        return error4;
      };
      let validateBuildSyncOptions = (options) => {
        if (!options) return;
        let plugins = options.plugins;
        if (plugins && plugins.length > 0) throw fakeBuildError(`Cannot use plugins in synchronous API calls`);
      };
      let applyProperties = (object, properties) => {
        for (let key in properties) {
          object[key] = properties[key];
        }
      };
      let runCallSync = (command, args2) => {
        let id2 = nextID++;
        let sharedBuffer = new SharedArrayBuffer(8);
        let sharedBufferView = new Int32Array(sharedBuffer);
        let msg = { sharedBuffer, id: id2, command, args: args2 };
        worker.postMessage(msg);
        let status2 = Atomics.wait(sharedBufferView, 0, 0);
        if (status2 !== "ok" && status2 !== "not-equal") throw new Error("Internal error: Atomics.wait() failed: " + status2);
        let { message: { id: id22, resolve: resolve9, reject, properties } } = worker_threads2.receiveMessageOnPort(mainPort);
        if (id2 !== id22) throw new Error(`Internal error: Expected id ${id2} but got id ${id22}`);
        if (reject) {
          applyProperties(reject, properties);
          throw reject;
        }
        return resolve9;
      };
      worker.unref();
      return {
        buildSync(options) {
          validateBuildSyncOptions(options);
          return runCallSync("build", [options]);
        },
        transformSync(input2, options) {
          return runCallSync("transform", [input2, options]);
        },
        formatMessagesSync(messages, options) {
          return runCallSync("formatMessages", [messages, options]);
        },
        analyzeMetafileSync(metafile, options) {
          return runCallSync("analyzeMetafile", [metafile, options]);
        },
        stop() {
          worker.terminate();
          workerThreadService = null;
        }
      };
    };
    var startSyncServiceWorker = () => {
      let workerPort = worker_threads.workerData.workerPort;
      let parentPort2 = worker_threads.parentPort;
      let extractProperties = (object) => {
        let properties = {};
        if (object && typeof object === "object") {
          for (let key in object) {
            properties[key] = object[key];
          }
        }
        return properties;
      };
      try {
        let service3 = ensureServiceIsRunning();
        defaultWD = worker_threads.workerData.defaultWD;
        parentPort2.on("message", (msg) => {
          (async () => {
            let { sharedBuffer, id: id2, command, args: args2 } = msg;
            let sharedBufferView = new Int32Array(sharedBuffer);
            try {
              switch (command) {
                case "build":
                  workerPort.postMessage({ id: id2, resolve: await service3.build(args2[0]) });
                  break;
                case "transform":
                  workerPort.postMessage({ id: id2, resolve: await service3.transform(args2[0], args2[1]) });
                  break;
                case "formatMessages":
                  workerPort.postMessage({ id: id2, resolve: await service3.formatMessages(args2[0], args2[1]) });
                  break;
                case "analyzeMetafile":
                  workerPort.postMessage({ id: id2, resolve: await service3.analyzeMetafile(args2[0], args2[1]) });
                  break;
                default:
                  throw new Error(`Invalid command: ${command}`);
              }
            } catch (reject) {
              workerPort.postMessage({ id: id2, reject, properties: extractProperties(reject) });
            }
            Atomics.add(sharedBufferView, 0, 1);
            Atomics.notify(sharedBufferView, 0, Infinity);
          })();
        });
      } catch (reject) {
        parentPort2.on("message", (msg) => {
          let { sharedBuffer, id: id2 } = msg;
          let sharedBufferView = new Int32Array(sharedBuffer);
          workerPort.postMessage({ id: id2, reject, properties: extractProperties(reject) });
          Atomics.add(sharedBufferView, 0, 1);
          Atomics.notify(sharedBufferView, 0, Infinity);
        });
      }
    };
    if (isInternalWorkerThread) {
      startSyncServiceWorker();
    }
    var node_default = node_exports3;
  }
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Function.js
var isFunction = (input2) => typeof input2 === "function";
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self2) => body(self2, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a2, b) {
        if (arguments.length >= 2) {
          return body(a2, b);
        }
        return function(self2) {
          return body(self2, a2);
        };
      };
    case 3:
      return function(a2, b, c) {
        if (arguments.length >= 3) {
          return body(a2, b, c);
        }
        return function(self2) {
          return body(self2, a2, b);
        };
      };
    case 4:
      return function(a2, b, c, d2) {
        if (arguments.length >= 4) {
          return body(a2, b, c, d2);
        }
        return function(self2) {
          return body(self2, a2, b, c);
        };
      };
    case 5:
      return function(a2, b, c, d2, e) {
        if (arguments.length >= 5) {
          return body(a2, b, c, d2, e);
        }
        return function(self2) {
          return body(self2, a2, b, c, d2);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args2 = arguments;
        return function(self2) {
          return body(self2, ...args2);
        };
      };
  }
};
var identity = (a2) => a2;
var constant = (value) => () => value;
var constTrue = /* @__PURE__ */ constant(true);
var constFalse = /* @__PURE__ */ constant(false);
var constUndefined = /* @__PURE__ */ constant(void 0);
var constVoid = constUndefined;
function pipe(a2, ab, bc, cd, de2, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a2;
    case 2:
      return ab(a2);
    case 3:
      return bc(ab(a2));
    case 4:
      return cd(bc(ab(a2)));
    case 5:
      return de2(cd(bc(ab(a2))));
    case 6:
      return ef(de2(cd(bc(ab(a2)))));
    case 7:
      return fg(ef(de2(cd(bc(ab(a2))))));
    case 8:
      return gh(fg(ef(de2(cd(bc(ab(a2)))))));
    case 9:
      return hi(gh(fg(ef(de2(cd(bc(ab(a2))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Equivalence.js
var make = (isEquivalent) => (self2, that) => self2 === that || isEquivalent(self2, that);
var mapInput = /* @__PURE__ */ dual(2, (self2, f2) => make((x2, y) => self2(f2(x2), f2(y))));
var array = (item) => make((self2, that) => {
  if (self2.length !== that.length) {
    return false;
  }
  for (let i = 0; i < self2.length; i++) {
    const isEq = item(self2[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/doNotation.js
var let_ = (map26) => dual(3, (self2, name, f2) => map26(self2, (a2) => Object.assign({}, a2, {
  [name]: f2(a2)
})));
var bindTo = (map26) => dual(2, (self2, name) => map26(self2, (a2) => ({
  [name]: a2
})));
var bind = (map26, flatMap19) => dual(3, (self2, name, f2) => flatMap19(self2, (a2) => map26(f2(a2), (b) => Object.assign({}, a2, {
  [name]: b
}))));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.14.2";
var getCurrentVersion = () => moduleVersion;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = `effect/GlobalValue/globalStoreId/${/* @__PURE__ */ getCurrentVersion()}`;
var globalStore;
var globalValue = (id2, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= /* @__PURE__ */ new Map();
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id2)) {
    globalStore.set(id2, compute());
  }
  return globalStore.get(id2);
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Predicate.js
var isString = (input2) => typeof input2 === "string";
var isNumber = (input2) => typeof input2 === "number";
var isBoolean = (input2) => typeof input2 === "boolean";
var isBigInt = (input2) => typeof input2 === "bigint";
var isFunction2 = isFunction;
var isRecordOrArray = (input2) => typeof input2 === "object" && input2 !== null;
var isObject = (input2) => isRecordOrArray(input2) || isFunction2(input2);
var hasProperty = /* @__PURE__ */ dual(2, (self2, property3) => isObject(self2) && property3 in self2);
var isTagged = /* @__PURE__ */ dual(2, (self2, tag) => hasProperty(self2, "_tag") && self2["_tag"] === tag);
var isNullable = (input2) => input2 === null || input2 === void 0;
var isNotNullable = (input2) => input2 !== null && input2 !== void 0;
var isIterable = (input2) => hasProperty(input2, Symbol.iterator);
var isPromiseLike = (input2) => hasProperty(input2, "then") && isFunction2(input2.then);

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;
var SingleShotGen = class _SingleShotGen {
  self;
  called = false;
  constructor(self2) {
    this.self = self2;
  }
  /**
   * @since 2.0.0
   */
  next(a2) {
    return this.called ? {
      value: a2,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a2) {
    return {
      value: a2,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;
var PCGRandom = class {
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
   * Returns a copy of the internal state of this random number generator as a
   * JavaScript Array.
   *
   * @category getters
   * @since 2.0.0
   */
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
   * Restore state previously retrieved using `getState()`.
   *
   * @since 2.0.0
   */
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  /**
   * Get a uniformly distributed 32 bit integer between [0, max).
   *
   * @category getter
   * @since 2.0.0
   */
  integer(max5) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max5;
  }
  /**
   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
   * 53 bits of precision (every bit of the mantissa is randomized).
   *
   * @category getters
   * @since 2.0.0
   */
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  /** @internal */
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
};
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
var YieldWrap = class {
  /**
   * @since 3.0.6
   */
  #value;
  constructor(value) {
    this.#value = value;
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId]() {
    return this.#value;
  }
};
function yieldWrapGet(self2) {
  if (typeof self2 === "object" && self2 !== null && YieldWrapTypeId in self2) {
    return self2[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: void 0
}));
var tracingFunction = (name) => {
  const wrap = {
    [name](body) {
      return body();
    }
  };
  return function(fn2) {
    return wrap[name](fn2);
  };
};
var internalCall = /* @__PURE__ */ tracingFunction("effect_internal_function");
var genConstructor = function* () {
}.constructor;
var isGeneratorFunction = (u2) => isObject(u2) && u2.constructor === genConstructor;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Hash.js
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash = (self2) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self2) {
    case "number":
      return number(self2);
    case "bigint":
      return string(self2.toString(10));
    case "boolean":
      return string(String(self2));
    case "symbol":
      return string(String(self2));
    case "string":
      return string(self2);
    case "undefined":
      return string("undefined");
    case "function":
    case "object": {
      if (self2 === null) {
        return string("null");
      } else if (self2 instanceof Date) {
        return hash(self2.toISOString());
      } else if (isHash(self2)) {
        return self2[symbol]();
      } else {
        return random(self2);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self2} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random = (self2) => {
  if (!randomHashCache.has(self2)) {
    randomHashCache.set(self2, number(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self2);
};
var combine = (b) => (self2) => self2 * 53 ^ b;
var optimize = (n2) => n2 & 3221225471 | n2 >>> 1 & 1073741824;
var isHash = (u2) => hasProperty(u2, symbol);
var number = (n2) => {
  if (n2 !== n2 || n2 === Infinity) {
    return 0;
  }
  let h3 = n2 | 0;
  if (h3 !== n2) {
    h3 ^= n2 * 4294967295;
  }
  while (n2 > 4294967295) {
    h3 ^= n2 /= 4294967295;
  }
  return optimize(h3);
};
var string = (str) => {
  let h3 = 5381, i = str.length;
  while (i) {
    h3 = h3 * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h3);
};
var structureKeys = (o2, keys5) => {
  let h3 = 12289;
  for (let i = 0; i < keys5.length; i++) {
    h3 ^= pipe(string(keys5[i]), combine(hash(o2[keys5[i]])));
  }
  return optimize(h3);
};
var structure = (o2) => structureKeys(o2, Object.keys(o2));
var array2 = (arr) => {
  let h3 = 6151;
  for (let i = 0; i < arr.length; i++) {
    h3 = pipe(h3, combine(hash(arr[i])));
  }
  return optimize(h3);
};
var cached = function() {
  if (arguments.length === 1) {
    const self3 = arguments[0];
    return function(hash3) {
      Object.defineProperty(self3, symbol, {
        value() {
          return hash3;
        },
        enumerable: false
      });
      return hash3;
    };
  }
  const self2 = arguments[0];
  const hash2 = arguments[1];
  Object.defineProperty(self2, symbol, {
    value() {
      return hash2;
    },
    enumerable: false
  });
  return hash2;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Equal.js
var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self2) => compareBoth(self2, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self2, that) {
  if (self2 === that) {
    return true;
  }
  const selfType = typeof self2;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self2 !== null && that !== null) {
      if (isEqual(self2) && isEqual(that)) {
        if (hash(self2) === hash(that) && self2[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
        }
      } else if (self2 instanceof Date && that instanceof Date) {
        return self2.toISOString() === that.toISOString();
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self2) && Array.isArray(that)) {
        return self2.length === that.length && self2.every((v2, i) => compareBoth(v2, that[i]));
      }
      if (Object.getPrototypeOf(self2) === Object.prototype && Object.getPrototypeOf(self2) === Object.prototype) {
        const keysSelf = Object.keys(self2);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!(key in that && compareBoth(self2[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
}
var isEqual = (u2) => hasProperty(u2, symbol2);
var equivalence = () => equals;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x2) => {
  try {
    if (hasProperty(x2, "toJSON") && isFunction2(x2["toJSON"]) && x2["toJSON"].length === 0) {
      return x2.toJSON();
    } else if (Array.isArray(x2)) {
      return x2.map(toJSON);
    }
  } catch (_2) {
    return {};
  }
  return redact(x2);
};
var format = (x2) => JSON.stringify(x2, null, 2);
var toStringUnknown = (u2, whitespace = 2) => {
  if (typeof u2 === "string") {
    return u2;
  }
  try {
    return typeof u2 === "object" ? stringifyCircular(u2, whitespace) : String(u2);
  } catch (_2) {
    return String(u2);
  }
};
var stringifyCircular = (obj, whitespace) => {
  let cache3 = [];
  const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache3.includes(value) ? void 0 : cache3.push(value) && (redactableState.fiberRefs !== void 0 && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);
  cache3 = void 0;
  return retVal;
};
var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable = (u2) => typeof u2 === "object" && u2 !== null && symbolRedactable in u2;
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: void 0
}));
var withRedactableContext = (context8, f2) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context8;
  try {
    return f2();
  } finally {
    redactableState.fiberRefs = prev;
  }
};
var redact = (u2) => {
  if (isRedactable(u2) && redactableState.fiberRefs !== void 0) {
    return u2[symbolRedactable](redactableState.fiberRefs);
  }
  return u2;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Pipeable.js
var pipeArguments = (self2, args2) => {
  switch (args2.length) {
    case 0:
      return self2;
    case 1:
      return args2[0](self2);
    case 2:
      return args2[1](args2[0](self2));
    case 3:
      return args2[2](args2[1](args2[0](self2)));
    case 4:
      return args2[3](args2[2](args2[1](args2[0](self2))));
    case 5:
      return args2[4](args2[3](args2[2](args2[1](args2[0](self2)))));
    case 6:
      return args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2))))));
    case 7:
      return args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2)))))));
    case 8:
      return args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2))))))));
    case 9:
      return args2[8](args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2)))))))));
    default: {
      let ret = self2;
      for (let i = 0, len = args2.length; i < len; i++) {
        ret = args2[i](ret);
      }
      return ret;
    }
  }
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC = "Async";
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_ON_FAILURE = "OnFailure";
var OP_ON_SUCCESS = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
var OP_SUCCESS = "Success";
var OP_SYNC = "Sync";
var OP_TAG = "Tag";
var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
var OP_WHILE = "While";
var OP_ITERATOR = "Iterator";
var OP_WITH_RUNTIME = "WithRuntime";
var OP_YIELD = "Yield";
var OP_REVERT_FLAGS = "RevertFlags";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance = {
  /* c8 ignore next */
  _R: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _A: (_2) => _2,
  _V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
  /* c8 ignore next */
  _A: (_2) => _2,
  /* c8 ignore next */
  _In: (_2) => _2,
  /* c8 ignore next */
  _L: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _R: (_2) => _2
};
var channelVariance = {
  /* c8 ignore next */
  _Env: (_2) => _2,
  /* c8 ignore next */
  _InErr: (_2) => _2,
  /* c8 ignore next */
  _InElem: (_2) => _2,
  /* c8 ignore next */
  _InDone: (_2) => _2,
  /* c8 ignore next */
  _OutErr: (_2) => _2,
  /* c8 ignore next */
  _OutElem: (_2) => _2,
  /* c8 ignore next */
  _OutDone: (_2) => _2
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol2](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [symbol2](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
var Base = /* @__PURE__ */ function() {
  function Base3() {
  }
  Base3.prototype = CommitPrototype;
  return Base3;
}();

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/option.js
var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_2) => _2
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol2](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol]() {
    return cached(this, combine(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol2](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input2) => hasProperty(input2, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = /* @__PURE__ */ Object.create(NoneProto);
var some = (value) => {
  const a2 = Object.create(SomeProto);
  a2.value = value;
  return a2;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/either.js
var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: (_2) => _2
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input2) => hasProperty(input2, TypeId2);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left3) => {
  const a2 = Object.create(LeftProto);
  a2.left = left3;
  return a2;
};
var right = (right3) => {
  const a2 = Object.create(RightProto);
  a2.right = right3;
  return a2;
};
var fromOption = /* @__PURE__ */ dual(2, (self2, onNone) => isNone(self2) ? left(onNone()) : right(self2.value));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Either.js
var right2 = right;
var left2 = left;
var fromOption2 = fromOption;
var try_ = (evaluate3) => {
  if (isFunction2(evaluate3)) {
    try {
      return right2(evaluate3());
    } catch (e) {
      return left2(e);
    }
  } else {
    try {
      return right2(evaluate3.try());
    } catch (e) {
      return left2(evaluate3.catch(e));
    }
  }
};
var isLeft2 = isLeft;
var isRight2 = isRight;
var match = /* @__PURE__ */ dual(2, (self2, {
  onLeft,
  onRight
}) => isLeft2(self2) ? onLeft(self2.left) : onRight(self2.right));
var liftPredicate = /* @__PURE__ */ dual(3, (a2, predicate, orLeftWith) => predicate(a2) ? right2(a2) : left2(orLeftWith(a2)));
var merge = /* @__PURE__ */ match({
  onLeft: identity,
  onRight: identity
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self2) => self2.length > 0;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Order.js
var make2 = (compare) => (self2, that) => self2 === that ? 0 : compare(self2, that);
var number2 = /* @__PURE__ */ make2((self2, that) => self2 < that ? -1 : 1);
var mapInput2 = /* @__PURE__ */ dual(2, (self2, f2) => make2((b1, b2) => self2(f2(b1), f2(b2))));
var greaterThan = (O4) => dual(2, (self2, that) => O4(self2, that) === 1);

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Option.js
var none2 = () => none;
var some2 = some;
var isNone2 = isNone;
var isSome2 = isSome;
var match2 = /* @__PURE__ */ dual(2, (self2, {
  onNone,
  onSome
}) => isNone2(self2) ? onNone() : onSome(self2.value));
var getOrElse = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? onNone() : self2.value);
var orElse = /* @__PURE__ */ dual(2, (self2, that) => isNone2(self2) ? that() : self2);
var orElseSome = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? some2(onNone()) : self2);
var fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);
var getOrUndefined = /* @__PURE__ */ getOrElse(constUndefined);
var liftThrowable = (f2) => (...a2) => {
  try {
    return some2(f2(...a2));
  } catch (e) {
    return none2();
  }
};
var getOrThrowWith = /* @__PURE__ */ dual(2, (self2, onNone) => {
  if (isSome2(self2)) {
    return self2.value;
  }
  throw onNone();
});
var getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a None"));
var map = /* @__PURE__ */ dual(2, (self2, f2) => isNone2(self2) ? none2() : some2(f2(self2.value)));
var flatMap = /* @__PURE__ */ dual(2, (self2, f2) => isNone2(self2) ? none2() : f2(self2.value));
var all = (input2) => {
  if (Symbol.iterator in input2) {
    const out2 = [];
    for (const o2 of input2) {
      if (isNone2(o2)) {
        return none2();
      }
      out2.push(o2.value);
    }
    return some2(out2);
  }
  const out = {};
  for (const key of Object.keys(input2)) {
    const o2 = input2[key];
    if (isNone2(o2)) {
      return none2();
    }
    out[key] = o2.value;
  }
  return some2(out);
};
var containsWith = (isEquivalent) => dual(2, (self2, a2) => isNone2(self2) ? false : isEquivalent(self2.value, a2));
var _equivalence = /* @__PURE__ */ equivalence();
var contains = /* @__PURE__ */ containsWith(_equivalence);
var mergeWith = (f2) => (o1, o2) => {
  if (isNone2(o1)) {
    return o2;
  } else if (isNone2(o2)) {
    return o1;
  }
  return some2(f2(o1.value, o2.value));
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Tuple.js
var make3 = (...elements) => elements;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Iterable.js
var unsafeHead = (self2) => {
  const iterator = self2[Symbol.iterator]();
  const result = iterator.next();
  if (result.done) throw new Error("unsafeHead: empty iterable");
  return result.value;
};
var findFirst = /* @__PURE__ */ dual(2, (self2, f2) => {
  let i = 0;
  for (const a2 of self2) {
    const o2 = f2(a2, i);
    if (isBoolean(o2)) {
      if (o2) {
        return some2(a2);
      }
    } else {
      if (isSome2(o2)) {
        return o2;
      }
    }
    i++;
  }
  return none2();
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Array.js
var make4 = (...elements) => elements;
var allocate = (n2) => new Array(n2);
var makeBy = /* @__PURE__ */ dual(2, (n2, f2) => {
  const max5 = Math.max(1, Math.floor(n2));
  const out = new Array(max5);
  for (let i = 0; i < max5; i++) {
    out[i] = f2(i);
  }
  return out;
});
var fromIterable = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var ensure = (self2) => Array.isArray(self2) ? self2 : [self2];
var match3 = /* @__PURE__ */ dual(2, (self2, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(self2) : onEmpty());
var prepend = /* @__PURE__ */ dual(2, (self2, head6) => [head6, ...self2]);
var append = /* @__PURE__ */ dual(2, (self2, last6) => [...self2, last6]);
var appendAll = /* @__PURE__ */ dual(2, (self2, that) => fromIterable(self2).concat(fromIterable(that)));
var isArray = Array.isArray;
var isEmptyArray = (self2) => self2.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyArray2 = isNonEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var isOutOfBounds = (i, as10) => i < 0 || i >= as10.length;
var clamp = (i, as10) => Math.floor(Math.min(Math.max(0, i), as10.length));
var get = /* @__PURE__ */ dual(2, (self2, index) => {
  const i = Math.floor(index);
  return isOutOfBounds(i, self2) ? none2() : some2(self2[i]);
});
var unsafeGet = /* @__PURE__ */ dual(2, (self2, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds(i, self2)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self2[i];
});
var head = /* @__PURE__ */ get(0);
var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
var last = (self2) => isNonEmptyReadonlyArray(self2) ? some2(lastNonEmpty(self2)) : none2();
var lastNonEmpty = (self2) => self2[self2.length - 1];
var tailNonEmpty = (self2) => self2.slice(1);
var spanIndex = (self2, predicate) => {
  let i = 0;
  for (const a2 of self2) {
    if (!predicate(a2, i)) {
      break;
    }
    i++;
  }
  return i;
};
var span = /* @__PURE__ */ dual(2, (self2, predicate) => splitAt(self2, spanIndex(self2, predicate)));
var drop = /* @__PURE__ */ dual(2, (self2, n2) => {
  const input2 = fromIterable(self2);
  return input2.slice(clamp(n2, input2), input2.length);
});
var findFirst2 = findFirst;
var reverse = (self2) => Array.from(self2).reverse();
var sort = /* @__PURE__ */ dual(2, (self2, O4) => {
  const out = Array.from(self2);
  out.sort(O4);
  return out;
});
var zip = /* @__PURE__ */ dual(2, (self2, that) => zipWith(self2, that, make3));
var zipWith = /* @__PURE__ */ dual(3, (self2, that, f2) => {
  const as10 = fromIterable(self2);
  const bs = fromIterable(that);
  if (isNonEmptyReadonlyArray(as10) && isNonEmptyReadonlyArray(bs)) {
    const out = [f2(headNonEmpty(as10), headNonEmpty(bs))];
    const len = Math.min(as10.length, bs.length);
    for (let i = 1; i < len; i++) {
      out[i] = f2(as10[i], bs[i]);
    }
    return out;
  }
  return [];
});
var _equivalence2 = /* @__PURE__ */ equivalence();
var splitAt = /* @__PURE__ */ dual(2, (self2, n2) => {
  const input2 = Array.from(self2);
  const _n = Math.floor(n2);
  if (isNonEmptyReadonlyArray(input2)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input2, _n);
    }
    return [[], input2];
  }
  return [input2, []];
});
var splitNonEmptyAt = /* @__PURE__ */ dual(2, (self2, n2) => {
  const _n = Math.max(1, Math.floor(n2));
  return _n >= self2.length ? [copy(self2), []] : [prepend(self2.slice(1, _n), headNonEmpty(self2)), self2.slice(_n)];
});
var copy = (self2) => self2.slice();
var unionWith = /* @__PURE__ */ dual(3, (self2, that, isEquivalent) => {
  const a2 = fromIterable(self2);
  const b = fromIterable(that);
  if (isNonEmptyReadonlyArray(a2)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe2 = dedupeWith(isEquivalent);
      return dedupe2(appendAll(a2, b));
    }
    return a2;
  }
  return b;
});
var union = /* @__PURE__ */ dual(2, (self2, that) => unionWith(self2, that, _equivalence2));
var empty = () => [];
var of = (a2) => [a2];
var map2 = /* @__PURE__ */ dual(2, (self2, f2) => self2.map(f2));
var flatMap2 = /* @__PURE__ */ dual(2, (self2, f2) => {
  if (isEmptyReadonlyArray(self2)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self2.length; i++) {
    const inner = f2(self2[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten = /* @__PURE__ */ flatMap2(identity);
var filterMap = /* @__PURE__ */ dual(2, (self2, f2) => {
  const as10 = fromIterable(self2);
  const out = [];
  for (let i = 0; i < as10.length; i++) {
    const o2 = f2(as10[i], i);
    if (isSome2(o2)) {
      out.push(o2.value);
    }
  }
  return out;
});
var filterMapWhile = /* @__PURE__ */ dual(2, (self2, f2) => {
  let i = 0;
  const out = [];
  for (const a2 of self2) {
    const b = f2(a2, i);
    if (isSome2(b)) {
      out.push(b.value);
    } else {
      break;
    }
    i++;
  }
  return out;
});
var partitionMap = /* @__PURE__ */ dual(2, (self2, f2) => {
  const left3 = [];
  const right3 = [];
  const as10 = fromIterable(self2);
  for (let i = 0; i < as10.length; i++) {
    const e = f2(as10[i], i);
    if (isLeft2(e)) {
      left3.push(e.left);
    } else {
      right3.push(e.right);
    }
  }
  return [left3, right3];
});
var getSomes = /* @__PURE__ */ filterMap(identity);
var filter = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const as10 = fromIterable(self2);
  const out = [];
  for (let i = 0; i < as10.length; i++) {
    if (predicate(as10[i], i)) {
      out.push(as10[i]);
    }
  }
  return out;
});
var reduce = /* @__PURE__ */ dual(3, (self2, b, f2) => fromIterable(self2).reduce((b2, a2, i) => f2(b2, a2, i), b));
var reduceRight = /* @__PURE__ */ dual(3, (self2, b, f2) => fromIterable(self2).reduceRight((b2, a2, i) => f2(b2, a2, i), b));
var unfold = (b, f2) => {
  const out = [];
  let next = b;
  let o2;
  while (isSome2(o2 = f2(next))) {
    const [a2, b2] = o2.value;
    out.push(a2);
    next = b2;
  }
  return out;
};
var getEquivalence = array;
var dedupeWith = /* @__PURE__ */ dual(2, (self2, isEquivalent) => {
  const input2 = fromIterable(self2);
  if (isNonEmptyReadonlyArray(input2)) {
    const out = [headNonEmpty(input2)];
    const rest = tailNonEmpty(input2);
    for (const r of rest) {
      if (out.every((a2) => !isEquivalent(r, a2))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = (self2) => dedupeWith(self2, equivalence());
var join = /* @__PURE__ */ dual(2, (self2, sep3) => fromIterable(self2).join(sep3));
var mapAccum = /* @__PURE__ */ dual(3, (self2, s2, f2) => {
  let i = 0;
  let s1 = s2;
  const out = [];
  for (const a2 of self2) {
    const r = f2(s1, a2, i);
    s1 = r[0];
    out.push(r[1]);
    i++;
  }
  return [s1, out];
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Chunk.js
var TypeId3 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy2(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
var emptyArray = [];
var getEquivalence2 = (isEquivalent) => make((self2, that) => self2.length === that.length && toReadonlyArray(self2).every((value, i) => isEquivalent(value, unsafeGet2(that, i))));
var _equivalence3 = /* @__PURE__ */ getEquivalence2(equals);
var ChunkProto = {
  [TypeId3]: {
    _A: (_2) => _2
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isChunk(that) && _equivalence3(this, that);
  },
  [symbol]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = (backing) => {
  const chunk5 = Object.create(ChunkProto);
  chunk5.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk5.length = 0;
      chunk5.depth = 0;
      chunk5.left = chunk5;
      chunk5.right = chunk5;
      break;
    }
    case "IConcat": {
      chunk5.length = backing.left.length + backing.right.length;
      chunk5.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk5.left = backing.left;
      chunk5.right = backing.right;
      break;
    }
    case "IArray": {
      chunk5.length = backing.array.length;
      chunk5.depth = 0;
      chunk5.left = _empty;
      chunk5.right = _empty;
      break;
    }
    case "ISingleton": {
      chunk5.length = 1;
      chunk5.depth = 0;
      chunk5.left = _empty;
      chunk5.right = _empty;
      break;
    }
    case "ISlice": {
      chunk5.length = backing.length;
      chunk5.depth = backing.chunk.depth + 1;
      chunk5.left = _empty;
      chunk5.right = _empty;
      break;
    }
  }
  return chunk5;
};
var isChunk = (u2) => hasProperty(u2, TypeId3);
var _empty = /* @__PURE__ */ makeChunk({
  _tag: "IEmpty"
});
var empty2 = () => _empty;
var make5 = (...as10) => unsafeFromNonEmptyArray(as10);
var of2 = (a2) => makeChunk({
  _tag: "ISingleton",
  a: a2
});
var fromIterable2 = (self2) => isChunk(self2) ? self2 : unsafeFromArray(fromIterable(self2));
var copyToArray = (self2, array6, initial) => {
  switch (self2.backing._tag) {
    case "IArray": {
      copy2(self2.backing.array, 0, array6, initial, self2.length);
      break;
    }
    case "IConcat": {
      copyToArray(self2.left, array6, initial);
      copyToArray(self2.right, array6, initial + self2.left.length);
      break;
    }
    case "ISingleton": {
      array6[initial] = self2.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self2.length) {
        array6[j] = unsafeGet2(self2, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
};
var toArray_ = (self2) => toReadonlyArray(self2).slice();
var toArray2 = toArray_;
var toReadonlyArray_ = (self2) => {
  switch (self2.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self2.backing.array;
    }
    default: {
      const arr = new Array(self2.length);
      copyToArray(self2, arr, 0);
      self2.backing = {
        _tag: "IArray",
        array: arr
      };
      self2.left = _empty;
      self2.right = _empty;
      self2.depth = 0;
      return arr;
    }
  }
};
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = (self2) => {
  switch (self2.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self2;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse(self2.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse2(self2.backing.right),
        right: reverse2(self2.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse(toReadonlyArray(self2)));
  }
};
var reverse2 = reverseChunk;
var get2 = /* @__PURE__ */ dual(2, (self2, index) => index < 0 || index >= self2.length ? none2() : some2(unsafeGet2(self2, index)));
var unsafeFromArray = (self2) => self2.length === 0 ? empty2() : self2.length === 1 ? of2(self2[0]) : makeChunk({
  _tag: "IArray",
  array: self2
});
var unsafeFromNonEmptyArray = (self2) => unsafeFromArray(self2);
var unsafeGet2 = /* @__PURE__ */ dual(2, (self2, index) => {
  switch (self2.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self2.backing.a;
    }
    case "IArray": {
      if (index >= self2.length || index < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self2.backing.array[index];
    }
    case "IConcat": {
      return index < self2.left.length ? unsafeGet2(self2.left, index) : unsafeGet2(self2.right, index - self2.left.length);
    }
    case "ISlice": {
      return unsafeGet2(self2.backing.chunk, index + self2.backing.offset);
    }
  }
});
var append2 = /* @__PURE__ */ dual(2, (self2, a2) => appendAll2(self2, of2(a2)));
var prepend2 = /* @__PURE__ */ dual(2, (self2, elem) => appendAll2(of2(elem), self2));
var take = /* @__PURE__ */ dual(2, (self2, n2) => {
  if (n2 <= 0) {
    return _empty;
  } else if (n2 >= self2.length) {
    return self2;
  } else {
    switch (self2.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2.backing.chunk,
          length: n2,
          offset: self2.backing.offset
        });
      }
      case "IConcat": {
        if (n2 > self2.left.length) {
          return makeChunk({
            _tag: "IConcat",
            left: self2.left,
            right: take(self2.right, n2 - self2.left.length)
          });
        }
        return take(self2.left, n2);
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2,
          offset: 0,
          length: n2
        });
      }
    }
  }
});
var drop2 = /* @__PURE__ */ dual(2, (self2, n2) => {
  if (n2 <= 0) {
    return self2;
  } else if (n2 >= self2.length) {
    return _empty;
  } else {
    switch (self2.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2.backing.chunk,
          offset: self2.backing.offset + n2,
          length: self2.backing.length - n2
        });
      }
      case "IConcat": {
        if (n2 > self2.left.length) {
          return drop2(self2.right, n2 - self2.left.length);
        }
        return makeChunk({
          _tag: "IConcat",
          left: drop2(self2.left, n2),
          right: self2.right
        });
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2,
          offset: n2,
          length: self2.length - n2
        });
      }
    }
  }
});
var dropWhile = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const arr = toReadonlyArray(self2);
  const len = arr.length;
  let i = 0;
  while (i < len && predicate(arr[i])) {
    i++;
  }
  return drop2(self2, i);
});
var appendAll2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self2;
  }
  const diff8 = that.depth - self2.depth;
  if (Math.abs(diff8) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self2,
      right: that
    });
  } else if (diff8 < -1) {
    if (self2.left.depth >= self2.right.depth) {
      const nr = appendAll2(self2.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self2.left,
        right: nr
      });
    } else {
      const nrr = appendAll2(self2.right.right, that);
      if (nrr.depth === self2.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self2.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self2.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self2.left,
          right: self2.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll2(self2, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll2(self2, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var filterMap2 = /* @__PURE__ */ dual(2, (self2, f2) => unsafeFromArray(filterMap(self2, f2)));
var filter2 = /* @__PURE__ */ dual(2, (self2, predicate) => unsafeFromArray(filter(self2, predicate)));
var filterMapWhile2 = /* @__PURE__ */ dual(2, (self2, f2) => unsafeFromArray(filterMapWhile(self2, f2)));
var flatMap3 = /* @__PURE__ */ dual(2, (self2, f2) => {
  if (self2.backing._tag === "ISingleton") {
    return f2(self2.backing.a, 0);
  }
  let out = _empty;
  let i = 0;
  for (const k of self2) {
    out = appendAll2(out, f2(k, i++));
  }
  return out;
});
var flatten2 = /* @__PURE__ */ flatMap3(identity);
var isEmpty = (self2) => self2.length === 0;
var isNonEmpty = (self2) => self2.length > 0;
var head2 = /* @__PURE__ */ get2(0);
var unsafeHead2 = (self2) => unsafeGet2(self2, 0);
var headNonEmpty2 = unsafeHead2;
var last2 = (self2) => get2(self2, self2.length - 1);
var unsafeLast = (self2) => unsafeGet2(self2, self2.length - 1);
var map3 = /* @__PURE__ */ dual(2, (self2, f2) => self2.backing._tag === "ISingleton" ? of2(f2(self2.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self2), map2((a2, i) => f2(a2, i)))));
var mapAccum2 = /* @__PURE__ */ dual(3, (self2, s2, f2) => {
  const [s1, as10] = mapAccum(self2, s2, f2);
  return [s1, unsafeFromArray(as10)];
});
var splitAt2 = /* @__PURE__ */ dual(2, (self2, n2) => [take(self2, n2), drop2(self2, n2)]);
var splitWhere = /* @__PURE__ */ dual(2, (self2, predicate) => {
  let i = 0;
  for (const a2 of toReadonlyArray(self2)) {
    if (predicate(a2)) {
      break;
    } else {
      i++;
    }
  }
  return splitAt2(self2, i);
});
var tailNonEmpty2 = (self2) => drop2(self2, 1);
var takeRight = /* @__PURE__ */ dual(2, (self2, n2) => drop2(self2, self2.length - n2));
var takeWhile = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const out = [];
  for (const a2 of toReadonlyArray(self2)) {
    if (predicate(a2)) {
      out.push(a2);
    } else {
      break;
    }
  }
  return unsafeFromArray(out);
});
var zipWith2 = /* @__PURE__ */ dual(3, (self2, that, f2) => unsafeFromArray(zipWith(self2, that, f2)));
var makeBy2 = /* @__PURE__ */ dual(2, (n2, f2) => fromIterable2(makeBy(n2, f2)));
var range = (start3, end6) => start3 <= end6 ? makeBy2(end6 - start3 + 1, (i) => start3 + i) : of2(start3);
var findFirst3 = findFirst2;
var reduce2 = reduce;
var reduceRight2 = reduceRight;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/context.js
var TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
var ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
var STMSymbolKey = "effect/STM";
var STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
var TagProto = {
  ...EffectPrototype,
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: (_2) => _2,
    _Identifier: (_2) => _2
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self2) {
    return self2;
  },
  context(self2) {
    return make6(this, self2);
  }
};
var ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
var makeGenericTag = (key) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  const tag = Object.create(TagProto);
  Object.defineProperty(tag, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag.key = key;
  return tag;
};
var Reference = () => (id2, options) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function ReferenceClass() {
  }
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id2;
  ReferenceClass.defaultValue = options.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
};
var TypeId4 = /* @__PURE__ */ Symbol.for("effect/Context");
var ContextProto = {
  [TypeId4]: {
    _Services: (_2) => _2
  },
  [symbol2](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol]() {
    return cached(this, number(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var makeContext = (unsafeMap) => {
  const context8 = Object.create(ContextProto);
  context8.unsafeMap = unsafeMap;
  return context8;
};
var serviceNotFoundError = (tag) => {
  const error4 = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
  if (tag.stack) {
    const lines = tag.stack.split("\n");
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error4.message = error4.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error4.stack) {
    const lines = error4.stack.split("\n");
    lines.splice(1, 3);
    error4.stack = lines.join("\n");
  }
  return error4;
};
var isContext = (u2) => hasProperty(u2, TypeId4);
var isTag = (u2) => hasProperty(u2, TagTypeId);
var isReference = (u2) => hasProperty(u2, ReferenceTypeId);
var _empty2 = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map());
var empty3 = () => _empty2;
var make6 = (tag, service3) => makeContext(/* @__PURE__ */ new Map([[tag.key, service3]]));
var add = /* @__PURE__ */ dual(3, (self2, tag, service3) => {
  const map26 = new Map(self2.unsafeMap);
  map26.set(tag.key, service3);
  return makeContext(map26);
});
var defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => /* @__PURE__ */ new Map());
var getDefaultValue = (tag) => {
  if (defaultValueCache.has(tag.key)) {
    return defaultValueCache.get(tag.key);
  }
  const value = tag.defaultValue();
  defaultValueCache.set(tag.key, value);
  return value;
};
var unsafeGetReference = (self2, tag) => {
  return self2.unsafeMap.has(tag.key) ? self2.unsafeMap.get(tag.key) : getDefaultValue(tag);
};
var unsafeGet3 = /* @__PURE__ */ dual(2, (self2, tag) => {
  if (!self2.unsafeMap.has(tag.key)) {
    if (ReferenceTypeId in tag) return getDefaultValue(tag);
    throw serviceNotFoundError(tag);
  }
  return self2.unsafeMap.get(tag.key);
});
var get3 = unsafeGet3;
var getOption = /* @__PURE__ */ dual(2, (self2, tag) => {
  if (!self2.unsafeMap.has(tag.key)) {
    return isReference(tag) ? some(getDefaultValue(tag)) : none;
  }
  return some(self2.unsafeMap.get(tag.key));
});
var merge2 = /* @__PURE__ */ dual(2, (self2, that) => {
  const map26 = new Map(self2.unsafeMap);
  for (const [tag, s2] of that.unsafeMap) {
    map26.set(tag, s2);
  }
  return makeContext(map26);
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Context.js
var GenericTag = makeGenericTag;
var isContext2 = isContext;
var isTag2 = isTag;
var empty4 = empty3;
var make7 = make6;
var add2 = add;
var get4 = get3;
var unsafeGet4 = unsafeGet3;
var getOption2 = getOption;
var merge3 = merge2;
var Reference2 = Reference;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Effect.js
var Effect_exports = {};
__export(Effect_exports, {
  Do: () => Do2,
  EffectTypeId: () => EffectTypeId3,
  Service: () => Service,
  Tag: () => Tag2,
  acquireRelease: () => acquireRelease2,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
  acquireUseRelease: () => acquireUseRelease2,
  addFinalizer: () => addFinalizer3,
  all: () => all4,
  allSuccesses: () => allSuccesses2,
  allWith: () => allWith2,
  allowInterrupt: () => allowInterrupt2,
  andThen: () => andThen5,
  annotateCurrentSpan: () => annotateCurrentSpan2,
  annotateLogs: () => annotateLogs3,
  annotateLogsScoped: () => annotateLogsScoped2,
  annotateSpans: () => annotateSpans3,
  ap: () => ap,
  as: () => as4,
  asSome: () => asSome2,
  asSomeError: () => asSomeError2,
  asVoid: () => asVoid2,
  async: () => async2,
  asyncEffect: () => asyncEffect2,
  awaitAllChildren: () => awaitAllChildren2,
  bind: () => bind3,
  bindAll: () => bindAll2,
  bindTo: () => bindTo3,
  blocked: () => blocked2,
  cacheRequestResult: () => cacheRequestResult,
  cached: () => cached3,
  cachedFunction: () => cachedFunction2,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
  cachedWithTTL: () => cachedWithTTL,
  catch: () => _catch2,
  catchAll: () => catchAll3,
  catchAllCause: () => catchAllCause3,
  catchAllDefect: () => catchAllDefect2,
  catchIf: () => catchIf2,
  catchSome: () => catchSome2,
  catchSomeCause: () => catchSomeCause2,
  catchSomeDefect: () => catchSomeDefect2,
  catchTag: () => catchTag2,
  catchTags: () => catchTags2,
  cause: () => cause2,
  checkInterruptible: () => checkInterruptible2,
  clock: () => clock2,
  clockWith: () => clockWith4,
  configProviderWith: () => configProviderWith2,
  console: () => console3,
  consoleWith: () => consoleWith2,
  context: () => context3,
  contextWith: () => contextWith2,
  contextWithEffect: () => contextWithEffect2,
  currentParentSpan: () => currentParentSpan2,
  currentSpan: () => currentSpan2,
  custom: () => custom2,
  daemonChildren: () => daemonChildren2,
  delay: () => delay2,
  descriptor: () => descriptor2,
  descriptorWith: () => descriptorWith2,
  die: () => die6,
  dieMessage: () => dieMessage2,
  dieSync: () => dieSync3,
  diffFiberRefs: () => diffFiberRefs2,
  disconnect: () => disconnect2,
  dropUntil: () => dropUntil2,
  dropWhile: () => dropWhile3,
  either: () => either3,
  ensuring: () => ensuring2,
  ensuringChild: () => ensuringChild2,
  ensuringChildren: () => ensuringChildren2,
  eventually: () => eventually2,
  every: () => every6,
  exists: () => exists2,
  exit: () => exit3,
  fail: () => fail9,
  failCause: () => failCause8,
  failCauseSync: () => failCauseSync3,
  failSync: () => failSync3,
  fiberId: () => fiberId2,
  fiberIdWith: () => fiberIdWith2,
  filter: () => filter7,
  filterEffectOrElse: () => filterEffectOrElse2,
  filterEffectOrFail: () => filterEffectOrFail2,
  filterMap: () => filterMap5,
  filterOrDie: () => filterOrDie2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrElse: () => filterOrElse2,
  filterOrFail: () => filterOrFail2,
  finalizersMask: () => finalizersMask2,
  findFirst: () => findFirst7,
  firstSuccessOf: () => firstSuccessOf2,
  flatMap: () => flatMap11,
  flatten: () => flatten8,
  flip: () => flip2,
  flipWith: () => flipWith2,
  fn: () => fn,
  fnUntraced: () => fnUntraced2,
  forEach: () => forEach9,
  forever: () => forever3,
  fork: () => fork3,
  forkAll: () => forkAll2,
  forkDaemon: () => forkDaemon2,
  forkIn: () => forkIn2,
  forkScoped: () => forkScoped2,
  forkWithErrorHandler: () => forkWithErrorHandler2,
  fromFiber: () => fromFiber2,
  fromFiberEffect: () => fromFiberEffect2,
  fromNullable: () => fromNullable3,
  functionWithSpan: () => functionWithSpan2,
  gen: () => gen2,
  getFiberRefs: () => getFiberRefs,
  getRuntimeFlags: () => getRuntimeFlags,
  head: () => head4,
  if: () => if_2,
  ignore: () => ignore2,
  ignoreLogged: () => ignoreLogged2,
  inheritFiberRefs: () => inheritFiberRefs2,
  interrupt: () => interrupt7,
  interruptWith: () => interruptWith2,
  interruptible: () => interruptible4,
  interruptibleMask: () => interruptibleMask2,
  intoDeferred: () => intoDeferred2,
  isEffect: () => isEffect2,
  isFailure: () => isFailure4,
  isSuccess: () => isSuccess3,
  iterate: () => iterate2,
  labelMetrics: () => labelMetrics2,
  labelMetricsScoped: () => labelMetricsScoped2,
  let: () => let_3,
  liftPredicate: () => liftPredicate3,
  linkSpanCurrent: () => linkSpanCurrent2,
  linkSpans: () => linkSpans2,
  locally: () => locally,
  locallyScoped: () => locallyScoped,
  locallyScopedWith: () => locallyScopedWith,
  locallyWith: () => locallyWith,
  log: () => log3,
  logAnnotations: () => logAnnotations2,
  logDebug: () => logDebug2,
  logError: () => logError2,
  logFatal: () => logFatal2,
  logInfo: () => logInfo2,
  logTrace: () => logTrace2,
  logWarning: () => logWarning2,
  logWithLevel: () => logWithLevel2,
  loop: () => loop2,
  makeLatch: () => makeLatch2,
  makeSemaphore: () => makeSemaphore2,
  makeSpan: () => makeSpan2,
  makeSpanScoped: () => makeSpanScoped2,
  map: () => map16,
  mapAccum: () => mapAccum4,
  mapBoth: () => mapBoth3,
  mapError: () => mapError3,
  mapErrorCause: () => mapErrorCause2,
  mapInputContext: () => mapInputContext2,
  match: () => match12,
  matchCause: () => matchCause4,
  matchCauseEffect: () => matchCauseEffect3,
  matchEffect: () => matchEffect2,
  merge: () => merge7,
  mergeAll: () => mergeAll4,
  metricLabels: () => metricLabels2,
  negate: () => negate2,
  never: () => never3,
  none: () => none9,
  onError: () => onError2,
  onExit: () => onExit3,
  onInterrupt: () => onInterrupt2,
  once: () => once2,
  option: () => option2,
  optionFromOptional: () => optionFromOptional2,
  orDie: () => orDie3,
  orDieWith: () => orDieWith2,
  orElse: () => orElse6,
  orElseFail: () => orElseFail2,
  orElseSucceed: () => orElseSucceed2,
  parallelErrors: () => parallelErrors2,
  parallelFinalizers: () => parallelFinalizers2,
  partition: () => partition4,
  patchFiberRefs: () => patchFiberRefs2,
  patchRuntimeFlags: () => patchRuntimeFlags,
  promise: () => promise2,
  provide: () => provide2,
  provideService: () => provideService2,
  provideServiceEffect: () => provideServiceEffect2,
  race: () => race2,
  raceAll: () => raceAll2,
  raceFirst: () => raceFirst2,
  raceWith: () => raceWith2,
  random: () => random3,
  randomWith: () => randomWith2,
  reduce: () => reduce11,
  reduceEffect: () => reduceEffect2,
  reduceRight: () => reduceRight4,
  reduceWhile: () => reduceWhile2,
  repeat: () => repeat,
  repeatN: () => repeatN2,
  repeatOrElse: () => repeatOrElse,
  replicate: () => replicate2,
  replicateEffect: () => replicateEffect2,
  request: () => request,
  retry: () => retry2,
  retryOrElse: () => retryOrElse,
  runCallback: () => runCallback,
  runFork: () => runFork2,
  runPromise: () => runPromise,
  runPromiseExit: () => runPromiseExit,
  runRequestBlock: () => runRequestBlock2,
  runSync: () => runSync,
  runSyncExit: () => runSyncExit,
  runtime: () => runtime3,
  sandbox: () => sandbox2,
  schedule: () => schedule,
  scheduleForked: () => scheduleForked2,
  scheduleFrom: () => scheduleFrom,
  scope: () => scope3,
  scopeWith: () => scopeWith2,
  scoped: () => scoped2,
  scopedWith: () => scopedWith2,
  sequentialFinalizers: () => sequentialFinalizers2,
  serviceConstants: () => serviceConstants2,
  serviceFunction: () => serviceFunction2,
  serviceFunctionEffect: () => serviceFunctionEffect2,
  serviceFunctions: () => serviceFunctions2,
  serviceMembers: () => serviceMembers2,
  serviceOption: () => serviceOption2,
  serviceOptional: () => serviceOptional2,
  setFiberRefs: () => setFiberRefs2,
  sleep: () => sleep4,
  spanAnnotations: () => spanAnnotations2,
  spanLinks: () => spanLinks2,
  step: () => step3,
  succeed: () => succeed8,
  succeedNone: () => succeedNone2,
  succeedSome: () => succeedSome2,
  summarized: () => summarized2,
  supervised: () => supervised2,
  suspend: () => suspend4,
  sync: () => sync4,
  tagMetrics: () => tagMetrics2,
  tagMetricsScoped: () => tagMetricsScoped2,
  takeUntil: () => takeUntil2,
  takeWhile: () => takeWhile3,
  tap: () => tap3,
  tapBoth: () => tapBoth2,
  tapDefect: () => tapDefect2,
  tapError: () => tapError3,
  tapErrorCause: () => tapErrorCause3,
  tapErrorTag: () => tapErrorTag2,
  timed: () => timed2,
  timedWith: () => timedWith2,
  timeout: () => timeout2,
  timeoutFail: () => timeoutFail2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutOption: () => timeoutOption2,
  timeoutTo: () => timeoutTo2,
  tracer: () => tracer2,
  tracerWith: () => tracerWith4,
  transplant: () => transplant2,
  transposeMapOption: () => transposeMapOption,
  transposeOption: () => transposeOption,
  try: () => try_3,
  tryMap: () => tryMap2,
  tryMapPromise: () => tryMapPromise2,
  tryPromise: () => tryPromise2,
  uninterruptible: () => uninterruptible2,
  uninterruptibleMask: () => uninterruptibleMask3,
  unless: () => unless2,
  unlessEffect: () => unlessEffect2,
  unsafeMakeLatch: () => unsafeMakeLatch2,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
  unsandbox: () => unsandbox2,
  updateFiberRefs: () => updateFiberRefs2,
  updateService: () => updateService2,
  useSpan: () => useSpan2,
  using: () => using2,
  validate: () => validate2,
  validateAll: () => validateAll2,
  validateFirst: () => validateFirst2,
  validateWith: () => validateWith2,
  void: () => _void,
  when: () => when2,
  whenEffect: () => whenEffect2,
  whenFiberRef: () => whenFiberRef2,
  whenLogLevel: () => whenLogLevel2,
  whenRef: () => whenRef2,
  whileLoop: () => whileLoop3,
  withClock: () => withClock2,
  withClockScoped: () => withClockScoped2,
  withConcurrency: () => withConcurrency2,
  withConfigProvider: () => withConfigProvider2,
  withConfigProviderScoped: () => withConfigProviderScoped2,
  withConsole: () => withConsole2,
  withConsoleScoped: () => withConsoleScoped2,
  withEarlyRelease: () => withEarlyRelease2,
  withFiberRuntime: () => withFiberRuntime2,
  withLogSpan: () => withLogSpan2,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
  withMetric: () => withMetric2,
  withParentSpan: () => withParentSpan3,
  withRandom: () => withRandom2,
  withRandomScoped: () => withRandomScoped2,
  withRequestBatching: () => withRequestBatching2,
  withRequestCache: () => withRequestCache2,
  withRequestCaching: () => withRequestCaching2,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
  withScheduler: () => withScheduler2,
  withSchedulingPriority: () => withSchedulingPriority2,
  withSpan: () => withSpan3,
  withSpanScoped: () => withSpanScoped2,
  withTracer: () => withTracer2,
  withTracerEnabled: () => withTracerEnabled2,
  withTracerScoped: () => withTracerScoped2,
  withTracerTiming: () => withTracerTiming2,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
  yieldNow: () => yieldNow4,
  zip: () => zip5,
  zipLeft: () => zipLeft2,
  zipRight: () => zipRight3,
  zipWith: () => zipWith5
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5;
var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x2) {
  x2 -= x2 >> 1 & 1431655765;
  x2 = (x2 & 858993459) + (x2 >> 2 & 858993459);
  x2 = x2 + (x2 >> 4) & 252645135;
  x2 += x2 >> 8;
  x2 += x2 >> 16;
  return x2 & 127;
}
function hashFragment(shift2, h3) {
  return h3 >>> shift2 & MASK;
}
function toBitmap(x2) {
  return 1 << x2;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stack.js
var make8 = (value, previous2) => ({
  value,
  previous: previous2
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate4, at, v2, arr) {
  let out = arr;
  if (!mutate4) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0; i < len; ++i) out[i] = arr[i];
  }
  out[at] = v2;
  return out;
}
function arraySpliceOut(mutate4, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate4) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at) out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen) out[g++] = arr[i++];
  if (mutate4) {
    out.length = newLen;
  }
  return out;
}
function arraySpliceIn(mutate4, at, v2, arr) {
  const len = arr.length;
  if (mutate4) {
    let i2 = len;
    while (i2 >= at) arr[i2--] = arr[i2];
    arr[at] = v2;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at) out[g++] = arr[i++];
  out[at] = v2;
  while (i < len) out[++g] = arr[i++];
  return out;
}

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/hashMap/node.js
var EmptyNode = class _EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f2, hash2, key, size16) {
    const v2 = f2(none2());
    if (isNone2(v2)) return new _EmptyNode();
    ++size16.value;
    return new LeafNode(edit, hash2, key, v2);
  }
};
function isEmptyNode(a2) {
  return isTagged(a2, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
var LeafNode = class _LeafNode {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash2, key, value) {
    this.edit = edit;
    this.hash = hash2;
    this.key = key;
    this.value = value;
  }
  modify(edit, shift2, f2, hash2, key, size16) {
    if (equals(key, this.key)) {
      const v3 = f2(this.value);
      if (v3 === this.value) return this;
      else if (isNone2(v3)) {
        --size16.value;
        return new EmptyNode();
      }
      if (canEditNode(this, edit)) {
        this.value = v3;
        return this;
      }
      return new _LeafNode(edit, hash2, key, v3);
    }
    const v2 = f2(none2());
    if (isNone2(v2)) return this;
    ++size16.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash2, new _LeafNode(edit, hash2, key, v2));
  }
};
var CollisionNode = class _CollisionNode {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash2, children2) {
    this.edit = edit;
    this.hash = hash2;
    this.children = children2;
  }
  modify(edit, shift2, f2, hash2, key, size16) {
    if (hash2 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f2, key, size16);
      if (list === this.children) return this;
      return list.length > 1 ? new _CollisionNode(edit, this.hash, list) : list[0];
    }
    const v2 = f2(none2());
    if (isNone2(v2)) return this;
    ++size16.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash2, new LeafNode(edit, hash2, key, v2));
  }
  updateCollisionList(mutate4, edit, hash2, list, f2, key, size16) {
    const len = list.length;
    for (let i = 0; i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value = child.value;
        const newValue2 = f2(value);
        if (newValue2 === value) return list;
        if (isNone2(newValue2)) {
          --size16.value;
          return arraySpliceOut(mutate4, i, list);
        }
        return arrayUpdate(mutate4, i, new LeafNode(edit, hash2, key, newValue2), list);
      }
    }
    const newValue = f2(none2());
    if (isNone2(newValue)) return list;
    ++size16.value;
    return arrayUpdate(mutate4, len, new LeafNode(edit, hash2, key, newValue), list);
  }
};
var IndexedNode = class _IndexedNode {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children2) {
    this.edit = edit;
    this.mask = mask;
    this.children = children2;
  }
  modify(edit, shift2, f2, hash2, key, size16) {
    const mask = this.mask;
    const children2 = this.children;
    const frag = hashFragment(shift2, hash2);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists4 = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists4) {
      const _newChild = new EmptyNode().modify(edit, shift2 + SIZE, f2, hash2, key, size16);
      if (!_newChild) return this;
      return children2.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children2) : new _IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children2));
    }
    const current2 = children2[indx];
    const child = current2.modify(edit, shift2 + SIZE, f2, hash2, key, size16);
    if (current2 === child) return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap) return new EmptyNode();
      if (children2.length <= 2 && isLeafNode(children2[indx ^ 1])) {
        return children2[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children2);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children2);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new _IndexedNode(edit, bitmap, newChildren);
  }
};
var ArrayNode = class _ArrayNode {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size16, children2) {
    this.edit = edit;
    this.size = size16;
    this.children = children2;
  }
  modify(edit, shift2, f2, hash2, key, size16) {
    let count5 = this.size;
    const children2 = this.children;
    const frag = hashFragment(shift2, hash2);
    const child = children2[frag];
    const newChild = (child || new EmptyNode()).modify(edit, shift2 + SIZE, f2, hash2, key, size16);
    if (child === newChild) return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count5;
      newChildren = arrayUpdate(canEdit, frag, newChild, children2);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count5;
      if (count5 <= MIN_ARRAY_NODE) {
        return pack(edit, count5, frag, children2);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children2);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children2);
    }
    if (canEdit) {
      this.size = count5;
      this.children = newChildren;
      return this;
    }
    return new _ArrayNode(edit, count5, newChildren);
  }
};
function pack(edit, count5, removed, elements) {
  const children2 = new Array(count5 - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children2[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children2);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count5 = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1) arr[i] = subNodes[count5++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count5 + 1, arr);
}
function mergeLeavesInner(edit, shift2, h1, n1, h22, n2) {
  if (h1 === h22) return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift2, h1);
  const subH2 = hashFragment(shift2, h22);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children2 = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children2);
  }
}
function mergeLeaves(edit, shift2, h1, n1, h22, n2) {
  let stack = void 0;
  let currentShift = shift2;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h22, n2);
    if (typeof res === "function") {
      stack = make8(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v2) => [k, v2]);
  },
  [symbol]() {
    let hash2 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = (editable, edit, root, size16) => {
  const map26 = Object.create(HashMapProto);
  map26._editable = editable;
  map26._edit = edit;
  map26._root = root;
  map26._size = size16;
  return map26;
};
var HashMapIterator = class _HashMapIterator {
  map;
  f;
  v;
  constructor(map26, f2) {
    this.map = map26;
    this.f = f2;
    this.v = visitLazy(this.map._root, this.f, void 0);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: void 0
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new _HashMapIterator(this.map, this.f);
  }
};
var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
var visitLazy = (node, f2, cont = void 0) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some2({
          value: f2(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children2 = node.children;
      return visitLazyChildren(children2.length, children2, 0, f2, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
};
var visitLazyChildren = (len, children2, i, f2, cont) => {
  while (i < len) {
    const child = children2[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f2, [len, children2, i, f2, cont]);
    }
  }
  return applyCont(cont);
};
var _empty3 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode(), 0);
var empty5 = () => _empty3;
var fromIterable3 = (entries2) => {
  const map26 = beginMutation(empty5());
  for (const entry of entries2) {
    set(map26, entry[0], entry[1]);
  }
  return endMutation(map26);
};
var isHashMap = (u2) => hasProperty(u2, HashMapTypeId);
var isEmpty2 = (self2) => self2 && isEmptyNode(self2._root);
var get5 = /* @__PURE__ */ dual(2, (self2, key) => getHash(self2, key, hash(key)));
var getHash = /* @__PURE__ */ dual(3, (self2, key, hash2) => {
  let node = self2._root;
  let shift2 = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash2 === node.hash) {
          const children2 = node.children;
          for (let i = 0, len = children2.length; i < len; ++i) {
            const child = children2[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift2, hash2);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift2, hash2)];
        if (node) {
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var has = /* @__PURE__ */ dual(2, (self2, key) => isSome2(getHash(self2, key, hash(key))));
var set = /* @__PURE__ */ dual(3, (self2, key, value) => modifyAt(self2, key, () => some2(value)));
var setTree = /* @__PURE__ */ dual(3, (self2, newRoot, newSize) => {
  if (self2._editable) {
    self2._root = newRoot;
    self2._size = newSize;
    return self2;
  }
  return newRoot === self2._root ? self2 : makeImpl(self2._editable, self2._edit, newRoot, newSize);
});
var keys = (self2) => new HashMapIterator(self2, (key) => key);
var size = (self2) => self2._size;
var beginMutation = (self2) => makeImpl(true, self2._edit + 1, self2._root, self2._size);
var endMutation = (self2) => {
  self2._editable = false;
  return self2;
};
var mutate = /* @__PURE__ */ dual(2, (self2, f2) => {
  const transient = beginMutation(self2);
  f2(transient);
  return endMutation(transient);
});
var modifyAt = /* @__PURE__ */ dual(3, (self2, key, f2) => modifyHash(self2, key, hash(key), f2));
var modifyHash = /* @__PURE__ */ dual(4, (self2, key, hash2, f2) => {
  const size16 = {
    value: self2._size
  };
  const newRoot = self2._root.modify(self2._editable ? self2._edit : NaN, 0, f2, hash2, key, size16);
  return pipe(self2, setTree(newRoot, size16.value));
});
var remove2 = /* @__PURE__ */ dual(2, (self2, key) => modifyAt(self2, key, none2));
var map4 = /* @__PURE__ */ dual(2, (self2, f2) => reduce3(self2, empty5(), (map26, value, key) => set(map26, key, f2(value, key))));
var forEach = /* @__PURE__ */ dual(2, (self2, f2) => reduce3(self2, void 0, (_2, value, key) => f2(value, key)));
var reduce3 = /* @__PURE__ */ dual(3, (self2, zero2, f2) => {
  const root = self2._root;
  if (root._tag === "LeafNode") {
    return isSome2(root.value) ? f2(zero2, root.value.value, root.key) : zero2;
  }
  if (root._tag === "EmptyNode") {
    return zero2;
  }
  const toVisit = [root.children];
  let children2;
  while (children2 = toVisit.pop()) {
    for (let i = 0, len = children2.length; i < len; ) {
      const child = children2[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero2 = f2(zero2, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero2;
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys(this._keyMap);
  },
  [symbol]() {
    return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol2](that) {
    if (isHashSet(that)) {
      return size(this._keyMap) === size(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = (keyMap) => {
  const set8 = Object.create(HashSetProto);
  set8._keyMap = keyMap;
  return set8;
};
var isHashSet = (u2) => hasProperty(u2, HashSetTypeId);
var _empty4 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty5());
var empty6 = () => _empty4;
var fromIterable4 = (elements) => {
  const set8 = beginMutation2(empty6());
  for (const value of elements) {
    add3(set8, value);
  }
  return endMutation2(set8);
};
var make9 = (...elements) => {
  const set8 = beginMutation2(empty6());
  for (const value of elements) {
    add3(set8, value);
  }
  return endMutation2(set8);
};
var has2 = /* @__PURE__ */ dual(2, (self2, value) => has(self2._keyMap, value));
var size2 = (self2) => size(self2._keyMap);
var beginMutation2 = (self2) => makeImpl2(beginMutation(self2._keyMap));
var endMutation2 = (self2) => {
  self2._keyMap._editable = false;
  return self2;
};
var mutate2 = /* @__PURE__ */ dual(2, (self2, f2) => {
  const transient = beginMutation2(self2);
  f2(transient);
  return endMutation2(transient);
});
var add3 = /* @__PURE__ */ dual(2, (self2, value) => self2._keyMap._editable ? (set(value, true)(self2._keyMap), self2) : makeImpl2(set(value, true)(self2._keyMap)));
var remove3 = /* @__PURE__ */ dual(2, (self2, value) => self2._keyMap._editable ? (remove2(value)(self2._keyMap), self2) : makeImpl2(remove2(value)(self2._keyMap)));
var difference2 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(self2, (set8) => {
  for (const value of that) {
    remove3(set8, value);
  }
}));
var union2 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(empty6(), (set8) => {
  forEach2(self2, (value) => add3(set8, value));
  for (const value of that) {
    add3(set8, value);
  }
}));
var forEach2 = /* @__PURE__ */ dual(2, (self2, f2) => forEach(self2._keyMap, (_2, k) => f2(k)));
var reduce4 = /* @__PURE__ */ dual(3, (self2, zero2, f2) => reduce3(self2._keyMap, zero2, (z2, _2, a2) => f2(z2, a2)));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/HashSet.js
var empty7 = empty6;
var fromIterable5 = fromIterable4;
var make10 = make9;
var has3 = has2;
var size3 = size2;
var add4 = add3;
var remove4 = remove3;
var difference3 = difference2;
var union3 = union2;
var reduce5 = reduce4;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
var variance = {
  /* c8 ignore next */
  _E: (_2) => _2
};
var proto = {
  [CauseTypeId]: variance,
  [symbol]() {
    return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
  },
  [symbol2](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var empty8 = /* @__PURE__ */ (() => {
  const o2 = /* @__PURE__ */ Object.create(proto);
  o2._tag = OP_EMPTY;
  return o2;
})();
var fail = (error4) => {
  const o2 = Object.create(proto);
  o2._tag = OP_FAIL;
  o2.error = error4;
  return o2;
};
var die = (defect) => {
  const o2 = Object.create(proto);
  o2._tag = OP_DIE;
  o2.defect = defect;
  return o2;
};
var interrupt = (fiberId3) => {
  const o2 = Object.create(proto);
  o2._tag = OP_INTERRUPT;
  o2.fiberId = fiberId3;
  return o2;
};
var parallel = (left3, right3) => {
  const o2 = Object.create(proto);
  o2._tag = OP_PARALLEL;
  o2.left = left3;
  o2.right = right3;
  return o2;
};
var sequential = (left3, right3) => {
  const o2 = Object.create(proto);
  o2._tag = OP_SEQUENTIAL;
  o2.left = left3;
  o2.right = right3;
  return o2;
};
var isCause = (u2) => hasProperty(u2, CauseTypeId);
var isEmptyType = (self2) => self2._tag === OP_EMPTY;
var isDieType = (self2) => self2._tag === OP_DIE;
var isEmpty3 = (self2) => {
  if (self2._tag === OP_EMPTY) {
    return true;
  }
  return reduce6(self2, true, (acc, cause3) => {
    switch (cause3._tag) {
      case OP_EMPTY: {
        return some2(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some2(false);
      }
      default: {
        return none2();
      }
    }
  });
};
var isInterrupted = (self2) => isSome2(interruptOption(self2));
var isInterruptedOnly = (self2) => reduceWithContext(void 0, IsInterruptedOnlyCauseReducer)(self2);
var failures = (self2) => reverse2(reduce6(self2, empty2(), (list, cause3) => cause3._tag === OP_FAIL ? some2(pipe(list, prepend2(cause3.error))) : none2()));
var defects = (self2) => reverse2(reduce6(self2, empty2(), (list, cause3) => cause3._tag === OP_DIE ? some2(pipe(list, prepend2(cause3.defect))) : none2()));
var interruptors = (self2) => reduce6(self2, empty7(), (set8, cause3) => cause3._tag === OP_INTERRUPT ? some2(pipe(set8, add4(cause3.fiberId))) : none2());
var failureOption = (self2) => find(self2, (cause3) => cause3._tag === OP_FAIL ? some2(cause3.error) : none2());
var failureOrCause = (self2) => {
  const option5 = failureOption(self2);
  switch (option5._tag) {
    case "None": {
      return right2(self2);
    }
    case "Some": {
      return left2(option5.value);
    }
  }
};
var flipCauseOption = (self2) => match4(self2, {
  onEmpty: some2(empty8),
  onFail: map(fail),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: (fiberId3) => some2(interrupt(fiberId3)),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var interruptOption = (self2) => find(self2, (cause3) => cause3._tag === OP_INTERRUPT ? some2(cause3.fiberId) : none2());
var keepDefects = (self2) => match4(self2, {
  onEmpty: none2(),
  onFail: () => none2(),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var keepDefectsAndElectFailures = (self2) => match4(self2, {
  onEmpty: none2(),
  onFail: (failure) => some2(die(failure)),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var stripFailures = (self2) => match4(self2, {
  onEmpty: empty8,
  onFail: () => empty8,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var electFailures = (self2) => match4(self2, {
  onEmpty: empty8,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var map7 = /* @__PURE__ */ dual(2, (self2, f2) => flatMap6(self2, (e) => fail(f2(e))));
var flatMap6 = /* @__PURE__ */ dual(2, (self2, f2) => match4(self2, {
  onEmpty: empty8,
  onFail: (error4) => f2(error4),
  onDie: (defect) => die(defect),
  onInterrupt: (fiberId3) => interrupt(fiberId3),
  onSequential: (left3, right3) => sequential(left3, right3),
  onParallel: (left3, right3) => parallel(left3, right3)
}));
var flatten3 = (self2) => flatMap6(self2, identity);
var causeEquals = (left3, right3) => {
  let leftStack = of2(left3);
  let rightStack = of2(right3);
  while (isNonEmpty(leftStack) && isNonEmpty(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce6([empty7(), empty2()], ([parallel4, sequential4], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return some2([pipe(parallel4, union3(par2)), pipe(sequential4, appendAll2(seq2))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce6([empty7(), empty2()], ([parallel4, sequential4], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return some2([pipe(parallel4, union3(par2)), pipe(sequential4, appendAll2(seq2))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
var flattenCause = (cause3) => {
  return flattenCauseLoop(of2(cause3), empty2());
};
var flattenCauseLoop = (causes, flattened) => {
  while (1) {
    const [parallel4, sequential4] = pipe(causes, reduce([empty7(), empty2()], ([parallel5, sequential5], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return [pipe(parallel5, union3(par2)), pipe(sequential5, appendAll2(seq2))];
    }));
    const updated = size3(parallel4) > 0 ? pipe(flattened, prepend2(parallel4)) : flattened;
    if (isEmpty(sequential4)) {
      return reverse2(updated);
    }
    causes = sequential4;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
var find = /* @__PURE__ */ dual(2, (self2, pf) => {
  const stack = [self2];
  while (stack.length > 0) {
    const item = stack.pop();
    const option5 = pf(item);
    switch (option5._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL:
          case OP_PARALLEL: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option5;
      }
    }
  }
  return none2();
});
var evaluateCause = (self2) => {
  let cause3 = self2;
  const stack = [];
  let _parallel = empty7();
  let _sequential = empty2();
  while (cause3 !== void 0) {
    switch (cause3._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add4(_parallel, make5(cause3._tag, cause3.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add4(_parallel, make5(cause3._tag, cause3.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add4(_parallel, make5(cause3._tag, cause3.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause3.left._tag) {
          case OP_EMPTY: {
            cause3 = cause3.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause3 = sequential(cause3.left.left, sequential(cause3.left.right, cause3.right));
            break;
          }
          case OP_PARALLEL: {
            cause3 = parallel(sequential(cause3.left.left, cause3.right), sequential(cause3.left.right, cause3.right));
            break;
          }
          default: {
            _sequential = prepend2(_sequential, cause3.right);
            cause3 = cause3.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_2, left3, right3) => left3 && right3,
  parallelCase: (_2, left3, right3) => left3 && right3
};
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var match4 = /* @__PURE__ */ dual(2, (self2, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt: onInterrupt3,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self2, void 0, {
    emptyCase: () => onEmpty,
    failCase: (_2, error4) => onFail(error4),
    dieCase: (_2, defect) => onDie(defect),
    interruptCase: (_2, fiberId3) => onInterrupt3(fiberId3),
    sequentialCase: (_2, left3, right3) => onSequential(left3, right3),
    parallelCase: (_2, left3, right3) => onParallel(left3, right3)
  });
});
var reduce6 = /* @__PURE__ */ dual(3, (self2, zero2, pf) => {
  let accumulator = zero2;
  let cause3 = self2;
  const causes = [];
  while (cause3 !== void 0) {
    const option5 = pf(accumulator, cause3);
    accumulator = isSome2(option5) ? option5.value : accumulator;
    switch (cause3._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
      default: {
        cause3 = void 0;
        break;
      }
    }
    if (cause3 === void 0 && causes.length > 0) {
      cause3 = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext = /* @__PURE__ */ dual(3, (self2, context8, reducer) => {
  const input2 = [self2];
  const output = [];
  while (input2.length > 0) {
    const cause3 = input2.pop();
    switch (cause3._tag) {
      case OP_EMPTY: {
        output.push(right2(reducer.emptyCase(context8)));
        break;
      }
      case OP_FAIL: {
        output.push(right2(reducer.failCase(context8, cause3.error)));
        break;
      }
      case OP_DIE: {
        output.push(right2(reducer.dieCase(context8, cause3.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right2(reducer.interruptCase(context8, cause3.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input2.push(cause3.right);
        input2.push(cause3.left);
        output.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input2.push(cause3.right);
        input2.push(cause3.left);
        output.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either7 = output.pop();
    switch (either7._tag) {
      case "Left": {
        switch (either7.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.sequentialCase(context8, left3, right3);
            accumulator.push(value);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.parallelCase(context8, left3, right3);
            accumulator.push(value);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either7.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = (cause3, options) => {
  if (isInterruptedOnly(cause3)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause3).map(function(e) {
    if (options?.renderErrorCause !== true || e.cause === void 0) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join("\n");
};
var renderErrorCause = (cause3, prefix) => {
  const lines = cause3.stack.split("\n");
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length; i < len; i++) {
    stack += `
${prefix}${lines[i]}`;
  }
  if (cause3.cause) {
    stack += ` {
${renderErrorCause(cause3.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
};
var PrettyError = class _PrettyError extends globalThis.Error {
  span = void 0;
  constructor(originalError) {
    const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
      cause: new _PrettyError(originalError.cause)
    } : void 0);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError instanceof Error ? originalError.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError) {
        this.span = originalError[spanSymbol];
      }
      Object.keys(originalError).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
  }
};
var prettyErrorMessage = (u2) => {
  if (typeof u2 === "string") {
    return u2;
  }
  if (typeof u2 === "object" && u2 !== null && u2 instanceof Error) {
    return u2.message;
  }
  try {
    if (hasProperty(u2, "toString") && isFunction2(u2["toString"]) && u2["toString"] !== Object.prototype.toString && u2["toString"] !== globalThis.Array.prototype.toString) {
      return u2["toString"]();
    }
  } catch {
  }
  return stringifyCircular(u2);
};
var locationRegex = /\((.*)\)/g;
var spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
var prettyErrorStack = (message, stack, span4) => {
  const out = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].includes("Generator.next")) {
      break;
    }
    if (lines[i].includes("effect_internal_function")) {
      out.pop();
      break;
    }
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span4) {
    let current2 = span4;
    let i = 0;
    while (current2 && current2._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current2);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match18 = false;
          for (const [, location] of locationMatchAll) {
            match18 = true;
            out.push(`    at ${current2.name} (${location})`);
          }
          if (!match18) {
            out.push(`    at ${current2.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current2.name}`);
        }
      } else {
        out.push(`    at ${current2.name}`);
      }
      current2 = getOrUndefined(current2.parent);
      i++;
    }
  }
  return out.join("\n");
};
var spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
var prettyErrors = (cause3) => reduceWithContext(cause3, void 0, {
  emptyCase: () => [],
  dieCase: (_2, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_2, error4) => {
    return [new PrettyError(error4)];
  },
  interruptCase: () => [],
  parallelCase: (_2, l, r) => [...l, ...r],
  sequentialCase: (_2, l, r) => [...l, ...r]
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Duration.js
var TypeId5 = /* @__PURE__ */ Symbol.for("effect/Duration");
var bigint0 = /* @__PURE__ */ BigInt(0);
var bigint24 = /* @__PURE__ */ BigInt(24);
var bigint60 = /* @__PURE__ */ BigInt(60);
var bigint1e3 = /* @__PURE__ */ BigInt(1e3);
var bigint1e6 = /* @__PURE__ */ BigInt(1e6);
var bigint1e9 = /* @__PURE__ */ BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode = (input2) => {
  if (isDuration(input2)) {
    return input2;
  } else if (isNumber(input2)) {
    return millis(input2);
  } else if (isBigInt(input2)) {
    return nanos(input2);
  } else if (Array.isArray(input2) && input2.length === 2 && input2.every(isNumber)) {
    if (input2[0] === -Infinity || input2[1] === -Infinity || Number.isNaN(input2[0]) || Number.isNaN(input2[1])) {
      return zero;
    }
    if (input2[0] === Infinity || input2[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input2[0] * 1e9)) + BigInt(Math.round(input2[1])));
  } else if (isString(input2)) {
    const match18 = DURATION_REGEX.exec(input2);
    if (match18) {
      const [_2, valueStr, unit] = match18;
      const value = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value);
        case "second":
        case "seconds":
          return seconds(value);
        case "minute":
        case "minutes":
          return minutes(value);
        case "hour":
        case "hours":
          return hours(value);
        case "day":
        case "days":
          return days(value);
        case "week":
        case "weeks":
          return weeks(value);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
var decodeUnknown = /* @__PURE__ */ liftThrowable(decode);
var zeroValue = {
  _tag: "Millis",
  millis: 0
};
var infinityValue = {
  _tag: "Infinity"
};
var DurationProto = {
  [TypeId5]: TypeId5,
  [symbol]() {
    return cached(this, structure(this.value));
  },
  [symbol2](that) {
    return isDuration(that) && equals2(this, that);
  },
  toString() {
    return `Duration(${format2(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make11 = (input2) => {
  const duration4 = Object.create(DurationProto);
  if (isNumber(input2)) {
    if (isNaN(input2) || input2 <= 0) {
      duration4.value = zeroValue;
    } else if (!Number.isFinite(input2)) {
      duration4.value = infinityValue;
    } else if (!Number.isInteger(input2)) {
      duration4.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input2 * 1e6))
      };
    } else {
      duration4.value = {
        _tag: "Millis",
        millis: input2
      };
    }
  } else if (input2 <= bigint0) {
    duration4.value = zeroValue;
  } else {
    duration4.value = {
      _tag: "Nanos",
      nanos: input2
    };
  }
  return duration4;
};
var isDuration = (u2) => hasProperty(u2, TypeId5);
var isZero = (self2) => {
  switch (self2.value._tag) {
    case "Millis": {
      return self2.value.millis === 0;
    }
    case "Nanos": {
      return self2.value.nanos === bigint0;
    }
    case "Infinity": {
      return false;
    }
  }
};
var zero = /* @__PURE__ */ make11(0);
var infinity = /* @__PURE__ */ make11(Infinity);
var nanos = (nanos2) => make11(nanos2);
var micros = (micros2) => make11(micros2 * bigint1e3);
var millis = (millis2) => make11(millis2);
var seconds = (seconds2) => make11(seconds2 * 1e3);
var minutes = (minutes2) => make11(minutes2 * 6e4);
var hours = (hours2) => make11(hours2 * 36e5);
var days = (days2) => make11(days2 * 864e5);
var weeks = (weeks2) => make11(weeks2 * 6048e5);
var toMillis = (self2) => match5(self2, {
  onMillis: (millis2) => millis2,
  onNanos: (nanos2) => Number(nanos2) / 1e6
});
var unsafeToNanos = (self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
};
var toHrTime = (self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
  }
};
var match5 = /* @__PURE__ */ dual(2, (self2, options) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
var matchWith = /* @__PURE__ */ dual(3, (self2, that, options) => {
  const _self = decode(self2);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
var Equivalence = (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 === that2,
  onNanos: (self3, that2) => self3 === that2
});
var sum = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => make11(self3 + that2),
  onNanos: (self3, that2) => make11(self3 + that2)
}));
var greaterThan2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 > that2,
  onNanos: (self3, that2) => self3 > that2
}));
var greaterThanOrEqualTo = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 >= that2,
  onNanos: (self3, that2) => self3 >= that2
}));
var equals2 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence(decode(self2), decode(that)));
var parts = (self2) => {
  const duration4 = decode(self2);
  if (duration4.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos2 = unsafeToNanos(duration4);
  const ms = nanos2 / bigint1e6;
  const sec = ms / bigint1e3;
  const min3 = sec / bigint60;
  const hr = min3 / bigint60;
  const days2 = hr / bigint24;
  return {
    days: Number(days2),
    hours: Number(hr % bigint24),
    minutes: Number(min3 % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos2 % bigint1e6)
  };
};
var format2 = (self2) => {
  const duration4 = decode(self2);
  if (duration4.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero(duration4)) {
    return "0";
  }
  const fragments = parts(duration4);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/MutableRef.js
var TypeId6 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
var MutableRefProto = {
  [TypeId6]: TypeId6,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make12 = (value) => {
  const ref = Object.create(MutableRefProto);
  ref.current = value;
  return ref;
};
var compareAndSet = /* @__PURE__ */ dual(3, (self2, oldValue, newValue) => {
  if (equals(oldValue, self2.current)) {
    self2.current = newValue;
    return true;
  }
  return false;
});
var get6 = (self2) => self2.current;
var set2 = /* @__PURE__ */ dual(2, (self2, value) => {
  self2.current = value;
  return self2;
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId";
var FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = /* @__PURE__ */ string(`${FiberIdSymbolKey}-${OP_NONE}`);
var None = class {
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_NONE;
  id = -1;
  startTimeMillis = -1;
  [symbol]() {
    return emptyHash;
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var Runtime = class {
  id;
  startTimeMillis;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_RUNTIME;
  constructor(id2, startTimeMillis) {
    this.id = id2;
    this.startTimeMillis = startTimeMillis;
  }
  [symbol]() {
    return cached(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var Composite = class {
  left;
  right;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_COMPOSITE;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  _hash;
  [symbol]() {
    return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var none3 = /* @__PURE__ */ new None();
var isFiberId = (self2) => hasProperty(self2, FiberIdTypeId);
var combine2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self2;
  }
  return new Composite(self2, that);
});
var combineAll = (fiberIds) => {
  return pipe(fiberIds, reduce5(none3, (a2, b) => combine2(b)(a2)));
};
var ids = (self2) => {
  switch (self2._tag) {
    case OP_NONE: {
      return empty7();
    }
    case OP_RUNTIME: {
      return make10(self2.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self2.left), union3(ids(self2.right)));
    }
  }
};
var _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make12(0));
var threadName = (self2) => {
  const identifiers = Array.from(ids(self2)).map((n2) => `#${n2}`).join(",");
  return identifiers;
};
var unsafeMake = () => {
  const id2 = get6(_fiberCounter);
  pipe(_fiberCounter, set2(id2 + 1));
  return new Runtime(id2, Date.now());
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/FiberId.js
var none4 = none3;
var combine3 = combine2;
var combineAll2 = combineAll;
var ids2 = ids;
var threadName2 = threadName;
var unsafeMake2 = unsafeMake;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/HashMap.js
var empty9 = empty5;
var fromIterable6 = fromIterable3;
var isEmpty4 = isEmpty2;
var get7 = get5;
var set3 = set;
var keys2 = keys;
var size4 = size;
var mutate3 = mutate;
var modifyAt2 = modifyAt;
var map8 = map4;
var forEach4 = forEach;
var reduce7 = reduce3;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/List.js
var TypeId7 = /* @__PURE__ */ Symbol.for("effect/List");
var toArray3 = (self2) => fromIterable(self2);
var getEquivalence3 = (isEquivalent) => mapInput(getEquivalence(isEquivalent), toArray3);
var _equivalence4 = /* @__PURE__ */ getEquivalence3(equals);
var ConsProto = {
  [TypeId7]: TypeId7,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray3(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag && _equivalence4(this, that);
  },
  [symbol]() {
    return cached(this, array2(toArray3(this)));
  },
  [Symbol.iterator]() {
    let done11 = false;
    let self2 = this;
    return {
      next() {
        if (done11) {
          return this.return();
        }
        if (self2._tag === "Nil") {
          done11 = true;
          return this.return();
        }
        const value = self2.head;
        self2 = self2.tail;
        return {
          done: done11,
          value
        };
      },
      return(value) {
        if (!done11) {
          done11 = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeCons = (head6, tail) => {
  const cons2 = Object.create(ConsProto);
  cons2.head = head6;
  cons2.tail = tail;
  return cons2;
};
var NilHash = /* @__PURE__ */ string("Nil");
var NilProto = {
  [TypeId7]: TypeId7,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol]() {
    return NilHash;
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: void 0
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _Nil = /* @__PURE__ */ Object.create(NilProto);
var isList = (u2) => hasProperty(u2, TypeId7);
var isNil = (self2) => self2._tag === "Nil";
var isCons = (self2) => self2._tag === "Cons";
var nil = () => _Nil;
var cons = (head6, tail) => makeCons(head6, tail);
var empty10 = nil;
var of3 = (value) => makeCons(value, _Nil);
var appendAll3 = /* @__PURE__ */ dual(2, (self2, that) => prependAll(that, self2));
var prepend3 = /* @__PURE__ */ dual(2, (self2, element) => cons(element, self2));
var prependAll = /* @__PURE__ */ dual(2, (self2, prefix) => {
  if (isNil(self2)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self2;
  } else {
    const result = makeCons(prefix.head, self2);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self2);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var reduce8 = /* @__PURE__ */ dual(3, (self2, zero2, f2) => {
  let acc = zero2;
  let these = self2;
  while (!isNil(these)) {
    acc = f2(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse3 = (self2) => {
  let result = empty10();
  let these = self2;
  while (!isNil(these)) {
    result = prepend3(result, these.head);
    these = these.tail;
  }
  return result;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/data.js
var ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
  [symbol]() {
    return cached(this, array2(this));
  },
  [symbol2](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v2, i) => equals(v2, that[i]));
    } else {
      return false;
    }
  }
});
var Structural = /* @__PURE__ */ function() {
  function Structural3(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  Structural3.prototype = StructuralPrototype;
  return Structural3;
}();
var struct = (as10) => Object.assign(Object.create(StructuralPrototype), as10);

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/differ/contextPatch.js
var ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
function variance2(a2) {
  return a2;
}
var PatchProto = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance2,
    _Patch: variance2
  }
};
var EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "Empty"
});
var _empty5 = /* @__PURE__ */ Object.create(EmptyProto);
var empty11 = () => _empty5;
var AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "AndThen"
});
var makeAndThen = (first3, second) => {
  const o2 = Object.create(AndThenProto);
  o2.first = first3;
  o2.second = second;
  return o2;
};
var AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "AddService"
});
var makeAddService = (key, service3) => {
  const o2 = Object.create(AddServiceProto);
  o2.key = key;
  o2.service = service3;
  return o2;
};
var RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "RemoveService"
});
var makeRemoveService = (key) => {
  const o2 = Object.create(RemoveServiceProto);
  o2.key = key;
  return o2;
};
var UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "UpdateService"
});
var makeUpdateService = (key, update5) => {
  const o2 = Object.create(UpdateServiceProto);
  o2.key = key;
  o2.update = update5;
  return o2;
};
var diff = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch9 = empty11();
  for (const [tag, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag)) {
      const old = missingServices.get(tag);
      missingServices.delete(tag);
      if (!equals(old, newService)) {
        patch9 = combine4(makeUpdateService(tag, () => newService))(patch9);
      }
    } else {
      missingServices.delete(tag);
      patch9 = combine4(makeAddService(tag, newService))(patch9);
    }
  }
  for (const [tag] of missingServices.entries()) {
    patch9 = combine4(makeRemoveService(tag))(patch9);
  }
  return patch9;
};
var combine4 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen(self2, that));
var patch = /* @__PURE__ */ dual(2, (self2, context8) => {
  if (self2._tag === "Empty") {
    return context8;
  }
  let wasServiceUpdated = false;
  let patches = of2(self2);
  const updatedContext = new Map(context8.unsafeMap);
  while (isNonEmpty(patches)) {
    const head6 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head6._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AddService": {
        updatedContext.set(head6.key, head6.service);
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend2(prepend2(tail, head6.second), head6.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head6.key);
        patches = tail;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head6.key, head6.update(updatedContext.get(head6.key)));
        wasServiceUpdated = true;
        patches = tail;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map26 = /* @__PURE__ */ new Map();
  for (const [tag] of context8.unsafeMap) {
    if (updatedContext.has(tag)) {
      map26.set(tag, updatedContext.get(tag));
      updatedContext.delete(tag);
    }
  }
  for (const [tag, s2] of updatedContext) {
    map26.set(tag, s2);
  }
  return makeContext(map26);
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
var HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
function variance3(a2) {
  return a2;
}
var PatchProto2 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance3,
    _Key: variance3,
    _Patch: variance3
  }
};
var EmptyProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Empty"
});
var _empty6 = /* @__PURE__ */ Object.create(EmptyProto2);
var empty12 = () => _empty6;
var AndThenProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "AndThen"
});
var makeAndThen2 = (first3, second) => {
  const o2 = Object.create(AndThenProto2);
  o2.first = first3;
  o2.second = second;
  return o2;
};
var AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Add"
});
var makeAdd = (value) => {
  const o2 = Object.create(AddProto);
  o2.value = value;
  return o2;
};
var RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Remove"
});
var makeRemove = (value) => {
  const o2 = Object.create(RemoveProto);
  o2.value = value;
  return o2;
};
var diff2 = (oldValue, newValue) => {
  const [removed, patch9] = reduce5([oldValue, empty12()], ([set8, patch10], value) => {
    if (has3(value)(set8)) {
      return [remove4(value)(set8), patch10];
    }
    return [set8, combine5(makeAdd(value))(patch10)];
  })(newValue);
  return reduce5(patch9, (patch10, value) => combine5(makeRemove(value))(patch10))(removed);
};
var combine5 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen2(self2, that));
var patch2 = /* @__PURE__ */ dual(2, (self2, oldValue) => {
  if (self2._tag === "Empty") {
    return oldValue;
  }
  let set8 = oldValue;
  let patches = of2(self2);
  while (isNonEmpty(patches)) {
    const head6 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head6._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend2(head6.first)(prepend2(head6.second)(tail));
        break;
      }
      case "Add": {
        set8 = add4(head6.value)(set8);
        patches = tail;
        break;
      }
      case "Remove": {
        set8 = remove4(head6.value)(set8);
        patches = tail;
      }
    }
  }
  return set8;
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
var ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
function variance4(a2) {
  return a2;
}
var PatchProto3 = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance4,
    _Patch: variance4
  }
};
var EmptyProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Empty"
});
var _empty7 = /* @__PURE__ */ Object.create(EmptyProto3);
var empty13 = () => _empty7;
var AndThenProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "AndThen"
});
var makeAndThen3 = (first3, second) => {
  const o2 = Object.create(AndThenProto3);
  o2.first = first3;
  o2.second = second;
  return o2;
};
var AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Append"
});
var makeAppend = (values3) => {
  const o2 = Object.create(AppendProto);
  o2.values = values3;
  return o2;
};
var SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Slice"
});
var makeSlice = (from, until) => {
  const o2 = Object.create(SliceProto);
  o2.from = from;
  o2.until = until;
  return o2;
};
var UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Update"
});
var makeUpdate = (index, patch9) => {
  const o2 = Object.create(UpdateProto);
  o2.index = index;
  o2.patch = patch9;
  return o2;
};
var diff3 = (options) => {
  let i = 0;
  let patch9 = empty13();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = options.oldValue[i];
    const newElement = options.newValue[i];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch9 = combine6(patch9, makeUpdate(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch9 = combine6(patch9, makeSlice(0, i));
  }
  if (i < options.newValue.length) {
    patch9 = combine6(patch9, makeAppend(drop(i)(options.newValue)));
  }
  return patch9;
};
var combine6 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen3(self2, that));
var patch3 = /* @__PURE__ */ dual(3, (self2, oldValue, differ3) => {
  if (self2._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray2 = oldValue.slice();
  let patches = of(self2);
  while (isNonEmptyArray2(patches)) {
    const head6 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head6._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        tail.unshift(head6.first, head6.second);
        patches = tail;
        break;
      }
      case "Append": {
        for (const value of head6.values) {
          readonlyArray2.push(value);
        }
        patches = tail;
        break;
      }
      case "Slice": {
        readonlyArray2 = readonlyArray2.slice(head6.from, head6.until);
        patches = tail;
        break;
      }
      case "Update": {
        readonlyArray2[head6.index] = differ3.patch(head6.patch, readonlyArray2[head6.index]);
        patches = tail;
        break;
      }
    }
  }
  return readonlyArray2;
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
var DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make15 = (params) => {
  const differ3 = Object.create(DifferProto);
  differ3.empty = params.empty;
  differ3.diff = params.diff;
  differ3.combine = params.combine;
  differ3.patch = params.patch;
  return differ3;
};
var environment = () => make15({
  empty: empty11(),
  combine: (first3, second) => combine4(second)(first3),
  diff: (oldValue, newValue) => diff(oldValue, newValue),
  patch: (patch9, oldValue) => patch(oldValue)(patch9)
});
var hashSet = () => make15({
  empty: empty12(),
  combine: (first3, second) => combine5(second)(first3),
  diff: (oldValue, newValue) => diff2(oldValue, newValue),
  patch: (patch9, oldValue) => patch2(oldValue)(patch9)
});
var readonlyArray = (differ3) => make15({
  empty: empty13(),
  combine: (first3, second) => combine6(first3, second),
  diff: (oldValue, newValue) => diff3({
    oldValue,
    newValue,
    differ: differ3
  }),
  patch: (patch9, oldValue) => patch3(patch9, oldValue, differ3)
});
var update = () => updateWith((_2, a2) => a2);
var updateWith = (f2) => make15({
  empty: identity,
  combine: (first3, second) => {
    if (first3 === identity) {
      return second;
    }
    if (second === identity) {
      return first3;
    }
    return (a2) => second(first3(a2));
  },
  diff: (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  },
  patch: (patch9, oldValue) => f2(oldValue, patch9(oldValue))
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK = 255;
var BIT_SHIFT = 8;
var active = (patch9) => patch9 & BIT_MASK;
var enabled = (patch9) => patch9 >> BIT_SHIFT & BIT_MASK;
var make16 = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT);
var empty14 = /* @__PURE__ */ make16(0, 0);
var enable = (flag) => make16(flag, flag);
var disable = (flag) => make16(flag, 0);
var exclude = /* @__PURE__ */ dual(2, (self2, flag) => make16(active(self2) & ~flag, enabled(self2)));
var andThen = /* @__PURE__ */ dual(2, (self2, that) => self2 | that);
var invert = (n2) => ~n2 >>> 0 & BIT_MASK;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0;
var Interruption = 1 << 0;
var OpSupervision = 1 << 1;
var RuntimeMetrics = 1 << 2;
var WindDown = 1 << 4;
var CooperativeYielding = 1 << 5;
var cooperativeYielding = (self2) => isEnabled(self2, CooperativeYielding);
var enable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 | flag);
var interruptible = (self2) => interruption(self2) && !windDown(self2);
var interruption = (self2) => isEnabled(self2, Interruption);
var isEnabled = /* @__PURE__ */ dual(2, (self2, flag) => (self2 & flag) !== 0);
var make17 = (...flags) => flags.reduce((a2, b) => a2 | b, 0);
var none5 = /* @__PURE__ */ make17(None2);
var runtimeMetrics = (self2) => isEnabled(self2, RuntimeMetrics);
var windDown = (self2) => isEnabled(self2, WindDown);
var diff4 = /* @__PURE__ */ dual(2, (self2, that) => make16(self2 ^ that, that));
var patch4 = /* @__PURE__ */ dual(2, (self2, patch9) => self2 & (invert(active(patch9)) | enabled(patch9)) | active(patch9) & enabled(patch9));
var differ = /* @__PURE__ */ make15({
  empty: empty14,
  diff: (oldValue, newValue) => diff4(oldValue, newValue),
  combine: (first3, second) => andThen(second)(first3),
  patch: (_patch, oldValue) => patch4(oldValue, _patch)
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var empty15 = empty14;
var enable3 = enable;
var disable2 = disable;
var exclude2 = exclude;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/blockedRequests.js
var empty16 = {
  _tag: "Empty"
};
var par = (self2, that) => ({
  _tag: "Par",
  left: self2,
  right: that
});
var seq = (self2, that) => ({
  _tag: "Seq",
  left: self2,
  right: that
});
var single = (dataSource, blockedRequest) => ({
  _tag: "Single",
  dataSource,
  blockedRequest
});
var flatten4 = (self2) => {
  let current2 = of3(self2);
  let updated = empty10();
  while (1) {
    const [parallel4, sequential4] = reduce8(current2, [parallelCollectionEmpty(), empty10()], ([parallel5, sequential5], blockedRequest) => {
      const [par2, seq2] = step(blockedRequest);
      return [parallelCollectionCombine(parallel5, par2), appendAll3(sequential5, seq2)];
    });
    updated = merge4(updated, parallel4);
    if (isNil(sequential4)) {
      return reverse3(updated);
    }
    current2 = sequential4;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var step = (requests) => {
  let current2 = requests;
  let parallel4 = parallelCollectionEmpty();
  let stack = empty10();
  let sequential4 = empty10();
  while (1) {
    switch (current2._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel4, sequential4];
        }
        current2 = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current2.right, stack);
        current2 = current2.left;
        break;
      }
      case "Seq": {
        const left3 = current2.left;
        const right3 = current2.right;
        switch (left3._tag) {
          case "Empty": {
            current2 = right3;
            break;
          }
          case "Par": {
            const l = left3.left;
            const r = left3.right;
            current2 = par(seq(l, right3), seq(r, right3));
            break;
          }
          case "Seq": {
            const l = left3.left;
            const r = left3.right;
            current2 = seq(l, seq(r, right3));
            break;
          }
          case "Single": {
            current2 = left3;
            sequential4 = cons(right3, sequential4);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel4 = parallelCollectionAdd(parallel4, current2);
        if (isNil(stack)) {
          return [parallel4, sequential4];
        }
        current2 = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var merge4 = (sequential4, parallel4) => {
  if (isNil(sequential4)) {
    return of3(parallelCollectionToSequentialCollection(parallel4));
  }
  if (parallelCollectionIsEmpty(parallel4)) {
    return sequential4;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential4.head);
  const parKeys = parallelCollectionKeys(parallel4);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential4.head, parallelCollectionToSequentialCollection(parallel4)), sequential4.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel4), sequential4);
};
var EntryTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");
var EntryImpl = class {
  request;
  result;
  listeners;
  ownerId;
  state;
  [EntryTypeId] = blockedRequestVariance;
  constructor(request2, result, listeners, ownerId, state) {
    this.request = request2;
    this.result = result;
    this.listeners = listeners;
    this.ownerId = ownerId;
    this.state = state;
  }
};
var blockedRequestVariance = {
  /* c8 ignore next */
  _R: (_2) => _2
};
var makeEntry = (options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);
var RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = {
  /* c8 ignore next */
  _R: (_2) => _2
};
var ParallelImpl = class {
  map;
  [RequestBlockParallelTypeId] = parallelVariance;
  constructor(map26) {
    this.map = map26;
  }
};
var parallelCollectionEmpty = () => new ParallelImpl(empty9());
var parallelCollectionAdd = (self2, blockedRequest) => new ParallelImpl(modifyAt2(self2.map, blockedRequest.dataSource, (_2) => orElseSome(map(_2, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest))));
var parallelCollectionCombine = (self2, that) => new ParallelImpl(reduce7(self2.map, that.map, (map26, value, key) => set3(map26, key, match2(get7(map26, key), {
  onNone: () => value,
  onSome: (other) => appendAll2(value, other)
}))));
var parallelCollectionIsEmpty = (self2) => isEmpty4(self2.map);
var parallelCollectionKeys = (self2) => Array.from(keys2(self2.map));
var parallelCollectionToSequentialCollection = (self2) => sequentialCollectionMake(map8(self2.map, (x2) => of2(x2)));
var SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = {
  /* c8 ignore next */
  _R: (_2) => _2
};
var SequentialImpl = class {
  map;
  [SequentialCollectionTypeId] = sequentialVariance;
  constructor(map26) {
    this.map = map26;
  }
};
var sequentialCollectionMake = (map26) => new SequentialImpl(map26);
var sequentialCollectionCombine = (self2, that) => new SequentialImpl(reduce7(that.map, self2.map, (map26, value, key) => set3(map26, key, match2(get7(map26, key), {
  onNone: () => empty2(),
  onSome: (a2) => appendAll2(a2, value)
}))));
var sequentialCollectionKeys = (self2) => Array.from(keys2(self2.map));
var sequentialCollectionToChunk = (self2) => Array.from(self2.map);

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING = "Pending";
var OP_STATE_DONE = "Done";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred";
var DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
var deferredVariance = {
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _A: (_2) => _2
};
var pending = (joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
};
var done = (effect4) => {
  return {
    _tag: OP_STATE_DONE,
    effect: effect4
  };
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/singleShotGen.js
var SingleShotGen2 = class _SingleShotGen {
  self;
  called = false;
  constructor(self2) {
    this.self = self2;
  }
  next(a2) {
    return this.called ? {
      value: a2,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a2) {
    return {
      value: a2,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/core.js
var blocked = (blockedRequests, _continue3) => {
  const effect4 = new EffectPrimitive("Blocked");
  effect4.effect_instruction_i0 = blockedRequests;
  effect4.effect_instruction_i1 = _continue3;
  return effect4;
};
var runRequestBlock = (blockedRequests) => {
  const effect4 = new EffectPrimitive("RunBlocked");
  effect4.effect_instruction_i0 = blockedRequests;
  return effect4;
};
var EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");
var RevertFlags = class {
  patch;
  op;
  _op = OP_REVERT_FLAGS;
  constructor(patch9, op) {
    this.patch = patch9;
    this.op = op;
  }
};
var EffectPrimitive = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var EffectPrimitiveFailure = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Failure" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var EffectPrimitiveSuccess = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Success" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var isEffect = (u2) => hasProperty(u2, EffectTypeId2);
var withFiberRuntime = (withRuntime) => {
  const effect4 = new EffectPrimitive(OP_WITH_RUNTIME);
  effect4.effect_instruction_i0 = withRuntime;
  return effect4;
};
var acquireUseRelease = /* @__PURE__ */ dual(3, (acquire, use, release) => uninterruptibleMask((restore) => flatMap8(acquire, (a2) => flatMap8(exit(suspend(() => restore(use(a2)))), (exit4) => {
  return suspend(() => release(a2, exit4)).pipe(matchCauseEffect({
    onFailure: (cause3) => {
      switch (exit4._tag) {
        case OP_FAILURE:
          return failCause(sequential(exit4.effect_instruction_i0, cause3));
        case OP_SUCCESS:
          return failCause(cause3);
      }
    },
    onSuccess: () => exit4
  }));
}))));
var as = /* @__PURE__ */ dual(2, (self2, value) => flatMap8(self2, () => succeed(value)));
var asVoid = (self2) => as(self2, void 0);
var custom = function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
};
var unsafeAsync = (register, blockingOn = none4) => {
  const effect4 = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = void 0;
  effect4.effect_instruction_i0 = (resume2) => {
    cancelerRef = register(resume2);
  };
  effect4.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect4, (_2) => isEffect(cancelerRef) ? cancelerRef : void_);
};
var asyncInterrupt = (register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn));
var async_ = (resume2, blockingOn = none4) => {
  return custom(resume2, function() {
    let backingResume = void 0;
    let pendingEffect = void 0;
    function proxyResume(effect5) {
      if (backingResume) {
        backingResume(effect5);
      } else if (pendingEffect === void 0) {
        pendingEffect = effect5;
      }
    }
    const effect4 = new EffectPrimitive(OP_ASYNC);
    effect4.effect_instruction_i0 = (resume3) => {
      backingResume = resume3;
      if (pendingEffect) {
        resume3(pendingEffect);
      }
    };
    effect4.effect_instruction_i1 = blockingOn;
    let cancelerRef = void 0;
    let controllerRef = void 0;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController();
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect4, (_2) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_;
    }) : effect4;
  });
};
var catchAllCause = /* @__PURE__ */ dual(2, (self2, f2) => {
  const effect4 = new EffectPrimitive(OP_ON_FAILURE);
  effect4.effect_instruction_i0 = self2;
  effect4.effect_instruction_i1 = f2;
  return effect4;
});
var catchAll = /* @__PURE__ */ dual(2, (self2, f2) => matchEffect(self2, {
  onFailure: f2,
  onSuccess: succeed
}));
var catchIf = /* @__PURE__ */ dual(3, (self2, predicate, f2) => catchAllCause(self2, (cause3) => {
  const either7 = failureOrCause(cause3);
  switch (either7._tag) {
    case "Left":
      return predicate(either7.left) ? f2(either7.left) : failCause(cause3);
    case "Right":
      return failCause(either7.right);
  }
}));
var catchSome = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause3) => {
  const either7 = failureOrCause(cause3);
  switch (either7._tag) {
    case "Left":
      return pipe(pf(either7.left), getOrElse(() => failCause(cause3)));
    case "Right":
      return failCause(either7.right);
  }
}));
var checkInterruptible = (f2) => withFiberRuntime((_2, status2) => f2(interruption(status2.runtimeFlags)));
var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
var capture = (obj, span4) => {
  if (isSome2(span4)) {
    return new Proxy(obj, {
      has(target, p3) {
        return p3 === spanSymbol || p3 === originalSymbol || p3 in target;
      },
      get(target, p3) {
        if (p3 === spanSymbol) {
          return span4.value;
        }
        if (p3 === originalSymbol) {
          return obj;
        }
        return target[p3];
      }
    });
  }
  return obj;
};
var die2 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect));
var dieMessage = (message) => failCauseSync(() => die(new RuntimeException(message)));
var dieSync = (evaluate3) => flatMap8(sync(evaluate3), die2);
var either2 = (self2) => matchEffect(self2, {
  onFailure: (e) => succeed(left2(e)),
  onSuccess: (a2) => succeed(right2(a2))
});
var exit = (self2) => matchCause(self2, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
});
var fail2 = (error4) => isObject(error4) && !(spanSymbol in error4) ? withFiberRuntime((fiber) => failCause(fail(capture(error4, currentSpanFromFiber(fiber))))) : failCause(fail(error4));
var failSync = (evaluate3) => flatMap8(sync(evaluate3), fail2);
var failCause = (cause3) => {
  const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
  effect4.effect_instruction_i0 = cause3;
  return effect4;
};
var failCauseSync = (evaluate3) => flatMap8(sync(evaluate3), failCause);
var fiberId = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.id()));
var fiberIdWith = (f2) => withFiberRuntime((state) => f2(state.id()));
var flatMap8 = /* @__PURE__ */ dual(2, (self2, f2) => {
  const effect4 = new EffectPrimitive(OP_ON_SUCCESS);
  effect4.effect_instruction_i0 = self2;
  effect4.effect_instruction_i1 = f2;
  return effect4;
});
var andThen2 = /* @__PURE__ */ dual(2, (self2, f2) => flatMap8(self2, (a2) => {
  const b = typeof f2 === "function" ? f2(a2) : f2;
  if (isEffect(b)) {
    return b;
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume2) => {
      b.then((a3) => resume2(succeed(a3)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
    });
  }
  return succeed(b);
}));
var step2 = (self2) => {
  const effect4 = new EffectPrimitive("OnStep");
  effect4.effect_instruction_i0 = self2;
  return effect4;
};
var flatten5 = (self2) => flatMap8(self2, identity);
var flip = (self2) => matchEffect(self2, {
  onFailure: succeed,
  onSuccess: fail2
});
var matchCause = /* @__PURE__ */ dual(2, (self2, options) => matchCauseEffect(self2, {
  onFailure: (cause3) => succeed(options.onFailure(cause3)),
  onSuccess: (a2) => succeed(options.onSuccess(a2))
}));
var matchCauseEffect = /* @__PURE__ */ dual(2, (self2, options) => {
  const effect4 = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect4.effect_instruction_i0 = self2;
  effect4.effect_instruction_i1 = options.onFailure;
  effect4.effect_instruction_i2 = options.onSuccess;
  return effect4;
});
var matchEffect = /* @__PURE__ */ dual(2, (self2, options) => matchCauseEffect(self2, {
  onFailure: (cause3) => {
    const defects2 = defects(cause3);
    if (defects2.length > 0) {
      return failCause(electFailures(cause3));
    }
    const failures2 = failures(cause3);
    if (failures2.length > 0) {
      return options.onFailure(unsafeHead2(failures2));
    }
    return failCause(cause3);
  },
  onSuccess: options.onSuccess
}));
var forEachSequential = /* @__PURE__ */ dual(2, (self2, f2) => suspend(() => {
  const arr = fromIterable(self2);
  const ret = allocate(arr.length);
  let i = 0;
  return as(whileLoop({
    while: () => i < arr.length,
    body: () => f2(arr[i], i),
    step: (b) => {
      ret[i++] = b;
    }
  }), ret);
}));
var forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self2, f2) => suspend(() => {
  const arr = fromIterable(self2);
  let i = 0;
  return whileLoop({
    while: () => i < arr.length,
    body: () => f2(arr[i], i),
    step: () => {
      i++;
    }
  });
}));
var if_ = /* @__PURE__ */ dual((args2) => typeof args2[0] === "boolean" || isEffect(args2[0]), (self2, options) => isEffect(self2) ? flatMap8(self2, (b) => b ? options.onTrue() : options.onFalse()) : self2 ? options.onTrue() : options.onFalse());
var interrupt2 = /* @__PURE__ */ flatMap8(fiberId, (fiberId3) => interruptWith(fiberId3));
var interruptWith = (fiberId3) => failCause(interrupt(fiberId3));
var interruptible2 = (self2) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = enable3(Interruption);
  effect4.effect_instruction_i1 = () => self2;
  return effect4;
};
var interruptibleMask = (f2) => custom(f2, function() {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = enable3(Interruption);
  effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect4;
});
var intoDeferred = /* @__PURE__ */ dual(2, (self2, deferred2) => uninterruptibleMask((restore) => flatMap8(exit(restore(self2)), (exit4) => deferredDone(deferred2, exit4))));
var map9 = /* @__PURE__ */ dual(2, (self2, f2) => flatMap8(self2, (a2) => sync(() => f2(a2))));
var mapBoth = /* @__PURE__ */ dual(2, (self2, options) => matchEffect(self2, {
  onFailure: (e) => failSync(() => options.onFailure(e)),
  onSuccess: (a2) => sync(() => options.onSuccess(a2))
}));
var mapError = /* @__PURE__ */ dual(2, (self2, f2) => matchCauseEffect(self2, {
  onFailure: (cause3) => {
    const either7 = failureOrCause(cause3);
    switch (either7._tag) {
      case "Left": {
        return failSync(() => f2(either7.left));
      }
      case "Right": {
        return failCause(either7.right);
      }
    }
  },
  onSuccess: succeed
}));
var onError = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, (exit4) => exitIsSuccess(exit4) ? void_ : cleanup(exit4.effect_instruction_i0)));
var onExit = /* @__PURE__ */ dual(2, (self2, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
  onFailure: (cause1) => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: (cause22) => exitFailCause(sequential(cause1, cause22)),
      onSuccess: () => result
    });
  },
  onSuccess: (success) => {
    const result = exitSucceed(success);
    return zipRight(cleanup(result), result);
  }
})));
var onInterrupt = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, exitMatch({
  onFailure: (cause3) => isInterruptedOnly(cause3) ? asVoid(cleanup(interruptors(cause3))) : void_,
  onSuccess: () => void_
})));
var orElse2 = /* @__PURE__ */ dual(2, (self2, that) => attemptOrElse(self2, that, succeed));
var orDie = (self2) => orDieWith(self2, identity);
var orDieWith = /* @__PURE__ */ dual(2, (self2, f2) => matchEffect(self2, {
  onFailure: (e) => die2(f2(e)),
  onSuccess: succeed
}));
var partitionMap2 = partitionMap;
var runtimeFlags = /* @__PURE__ */ withFiberRuntime((_2, status2) => succeed(status2.runtimeFlags));
var succeed = (value) => {
  const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect4.effect_instruction_i0 = value;
  return effect4;
};
var suspend = (evaluate3) => {
  const effect4 = new EffectPrimitive(OP_COMMIT);
  effect4.commit = evaluate3;
  return effect4;
};
var sync = (thunk) => {
  const effect4 = new EffectPrimitive(OP_SYNC);
  effect4.effect_instruction_i0 = thunk;
  return effect4;
};
var tap = /* @__PURE__ */ dual((args2) => args2.length === 3 || args2.length === 2 && !(isObject(args2[1]) && "onlyEffect" in args2[1]), (self2, f2) => flatMap8(self2, (a2) => {
  const b = typeof f2 === "function" ? f2(a2) : f2;
  if (isEffect(b)) {
    return as(b, a2);
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume2) => {
      b.then((_2) => resume2(succeed(a2)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
    });
  }
  return succeed(a2);
}));
var transplant = (f2) => withFiberRuntime((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope5 = pipe(scopeOverride, getOrElse(() => state.scope()));
  return f2(fiberRefLocally(currentForkScopeOverride, some2(scope5)));
});
var attemptOrElse = /* @__PURE__ */ dual(3, (self2, that, onSuccess) => matchCauseEffect(self2, {
  onFailure: (cause3) => {
    const defects2 = defects(cause3);
    if (defects2.length > 0) {
      return failCause(getOrThrow(keepDefectsAndElectFailures(cause3)));
    }
    return that();
  },
  onSuccess
}));
var uninterruptible = (self2) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = disable2(Interruption);
  effect4.effect_instruction_i1 = () => self2;
  return effect4;
};
var uninterruptibleMask = (f2) => custom(f2, function() {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = disable2(Interruption);
  effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect4;
});
var void_ = /* @__PURE__ */ succeed(void 0);
var updateRuntimeFlags = (patch9) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = patch9;
  effect4.effect_instruction_i1 = void 0;
  return effect4;
};
var whenEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap8(condition, (b) => {
  if (b) {
    return pipe(self2, map9(some2));
  }
  return succeed(none2());
}));
var whileLoop = (options) => {
  const effect4 = new EffectPrimitive(OP_WHILE);
  effect4.effect_instruction_i0 = options.while;
  effect4.effect_instruction_i1 = options.body;
  effect4.effect_instruction_i2 = options.step;
  return effect4;
};
var fromIterator = (iterator) => suspend(() => {
  const effect4 = new EffectPrimitive(OP_ITERATOR);
  effect4.effect_instruction_i0 = iterator();
  return effect4;
});
var gen = function() {
  const f2 = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator(() => f2(pipe));
};
var fnUntraced = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args2) {
  return fromIterator(() => body.apply(this, args2));
} : function(...args2) {
  let effect4 = fromIterator(() => body.apply(this, args2));
  for (const x2 of pipeables) {
    effect4 = x2(effect4, ...args2);
  }
  return effect4;
}, "length", {
  value: body.length,
  configurable: true
});
var withConcurrency = /* @__PURE__ */ dual(2, (self2, concurrency) => fiberRefLocally(self2, currentConcurrency, concurrency));
var withRequestBatching = /* @__PURE__ */ dual(2, (self2, requestBatching) => fiberRefLocally(self2, currentRequestBatching, requestBatching));
var withRuntimeFlags = /* @__PURE__ */ dual(2, (self2, update5) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = update5;
  effect4.effect_instruction_i1 = () => self2;
  return effect4;
});
var withTracerEnabled = /* @__PURE__ */ dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerEnabled, enabled2));
var withTracerTiming = /* @__PURE__ */ dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerTimingEnabled, enabled2));
var yieldNow = (options) => {
  const effect4 = new EffectPrimitive(OP_YIELD);
  return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect4, options.priority) : effect4;
};
var zip2 = /* @__PURE__ */ dual(2, (self2, that) => flatMap8(self2, (a2) => map9(that, (b) => [a2, b])));
var zipLeft = /* @__PURE__ */ dual(2, (self2, that) => flatMap8(self2, (a2) => as(that, a2)));
var zipRight = /* @__PURE__ */ dual(2, (self2, that) => flatMap8(self2, () => that));
var zipWith3 = /* @__PURE__ */ dual(3, (self2, that, f2) => flatMap8(self2, (a2) => map9(that, (b) => f2(a2, b))));
var never = /* @__PURE__ */ asyncInterrupt(() => {
  const interval = setInterval(() => {
  }, 2 ** 31 - 1);
  return sync(() => clearInterval(interval));
});
var interruptFiber = (self2) => flatMap8(fiberId, (fiberId3) => pipe(self2, interruptAsFiber(fiberId3)));
var interruptAsFiber = /* @__PURE__ */ dual(2, (self2, fiberId3) => flatMap8(self2.interruptAsFork(fiberId3), () => self2.await));
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 5e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 4e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 3e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 2e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var allLogLevels = [logLevelAll, logLevelTrace, logLevelDebug, logLevelInfo, logLevelWarning, logLevelError, logLevelFatal, logLevelNone];
var FiberRefSymbolKey = "effect/FiberRef";
var FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
var fiberRefVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var fiberRefGet = (self2) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self2)));
var fiberRefGetWith = /* @__PURE__ */ dual(2, (self2, f2) => flatMap8(fiberRefGet(self2), f2));
var fiberRefSet = /* @__PURE__ */ dual(2, (self2, value) => fiberRefModify(self2, () => [void 0, value]));
var fiberRefModify = /* @__PURE__ */ dual(2, (self2, f2) => withFiberRuntime((state) => {
  const [b, a2] = f2(state.getFiberRef(self2));
  state.setFiberRef(self2, a2);
  return succeed(b);
}));
var fiberRefLocally = /* @__PURE__ */ dual(3, (use, self2, value) => acquireUseRelease(zipLeft(fiberRefGet(self2), fiberRefSet(self2, value)), () => use, (oldValue) => fiberRefSet(self2, oldValue)));
var fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use, self2, f2) => fiberRefGetWith(self2, (a2) => fiberRefLocally(use, self2, f2(a2))));
var fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
  differ: update(),
  fork: options?.fork ?? identity,
  join: options?.join
});
var fiberRefUnsafeMakeHashSet = (initial) => {
  const differ3 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
};
var fiberRefUnsafeMakeReadonlyArray = (initial) => {
  const differ3 = readonlyArray(update());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
};
var fiberRefUnsafeMakeContext = (initial) => {
  const differ3 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
};
var fiberRefUnsafeMakePatch = (initial, options) => {
  const _fiberRef = {
    ...CommitPrototype,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
    combine: (first3, second) => options.differ.combine(first3, second),
    patch: (patch9) => (oldValue) => options.differ.patch(patch9, oldValue),
    fork: options.fork,
    join: options.join ?? ((_2, n2) => n2)
  };
  return _fiberRef;
};
var fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
});
var currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty4()));
var currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
var currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
var currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty9()));
var currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
var currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty10()));
var withSchedulingPriority = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentSchedulingPriority, scheduler));
var withMaxOpsBeforeYield = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentMaxOpsBeforeYield, scheduler));
var currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
var currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
var currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelDebug)));
var withUnhandledErrorLogLevel = /* @__PURE__ */ dual(2, (self2, level) => fiberRefLocally(self2, currentUnhandledErrorLogLevel, level));
var currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty()));
var metricLabels = /* @__PURE__ */ fiberRefGet(currentMetricLabels);
var currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
  fork: () => none2(),
  join: (parent, _2) => parent
}));
var currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty8, {
  fork: () => empty8,
  join: (parent, _2) => parent
}));
var currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
var currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
var currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty9()));
var currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty2()));
var ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
var CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
var scopeAddFinalizer = (self2, finalizer3) => self2.addFinalizer(() => asVoid(finalizer3));
var scopeAddFinalizerExit = (self2, finalizer3) => self2.addFinalizer(finalizer3);
var scopeClose = (self2, exit4) => self2.close(exit4);
var scopeFork = (self2, strategy) => self2.fork(strategy);
var causeSquash = (self2) => {
  return causeSquashWith(identity)(self2);
};
var causeSquashWith = /* @__PURE__ */ dual(2, (self2, f2) => {
  const option5 = pipe(self2, failureOption, map(f2));
  switch (option5._tag) {
    case "None": {
      return pipe(defects(self2), head2, match2({
        onNone: () => {
          const interrupts = fromIterable(interruptors(self2)).flatMap((fiberId3) => fromIterable(ids2(fiberId3)).map((id2) => `#${id2}`));
          return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : void 0);
        },
        onSome: identity
      }));
    }
    case "Some": {
      return option5.value;
    }
  }
});
var YieldableError = /* @__PURE__ */ function() {
  class YieldableError2 extends globalThis.Error {
    commit() {
      return fail2(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message) obj.message = this.message;
      if (this.cause) obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError2.prototype, StructuralCommitPrototype);
  return YieldableError2;
}();
var makeException = (proto14, tag) => {
  class Base3 extends YieldableError {
    _tag = tag;
  }
  Object.assign(Base3.prototype, proto14);
  Base3.prototype.name = tag;
  return Base3;
};
var RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = /* @__PURE__ */ makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var isRuntimeException = (u2) => hasProperty(u2, RuntimeExceptionTypeId);
var InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = /* @__PURE__ */ makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var isInterruptedException = (u2) => hasProperty(u2, InterruptedExceptionTypeId);
var IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = /* @__PURE__ */ makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = /* @__PURE__ */ makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var isNoSuchElementException = (u2) => hasProperty(u2, NoSuchElementExceptionTypeId);
var InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = /* @__PURE__ */ makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var timeoutExceptionFromDuration = (duration4) => new TimeoutException(`Operation timed out after '${format2(duration4)}'`);
var UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException = /* @__PURE__ */ function() {
  class UnknownException2 extends YieldableError {
    _tag = "UnknownException";
    error;
    constructor(cause3, message) {
      super(message ?? "An unknown error occurred", {
        cause: cause3
      });
      this.error = cause3;
    }
  }
  Object.assign(UnknownException2.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException2;
}();
var exitIsExit = (u2) => isEffect(u2) && "_tag" in u2 && (u2._tag === "Success" || u2._tag === "Failure");
var exitIsFailure = (self2) => self2._tag === "Failure";
var exitIsSuccess = (self2) => self2._tag === "Success";
var exitAs = /* @__PURE__ */ dual(2, (self2, value) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return exitFailCause(self2.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return exitSucceed(value);
    }
  }
});
var exitAsVoid = (self2) => exitAs(self2, void 0);
var exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel : sequential);
var exitDie = (defect) => exitFailCause(die(defect));
var exitFail = (error4) => exitFailCause(fail(error4));
var exitFailCause = (cause3) => {
  const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
  effect4.effect_instruction_i0 = cause3;
  return effect4;
};
var exitFlatMap = /* @__PURE__ */ dual(2, (self2, f2) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return exitFailCause(self2.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return f2(self2.effect_instruction_i0);
    }
  }
});
var exitFlatten = (self2) => pipe(self2, exitFlatMap(identity));
var exitInterrupt = (fiberId3) => exitFailCause(interrupt(fiberId3));
var exitMap = /* @__PURE__ */ dual(2, (self2, f2) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return exitFailCause(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f2(self2.effect_instruction_i0));
  }
});
var exitMapBoth = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self2.effect_instruction_i0, map7(onFailure)));
    case OP_SUCCESS:
      return exitSucceed(onSuccess(self2.effect_instruction_i0));
  }
});
var exitMatch = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return onFailure(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self2.effect_instruction_i0);
  }
});
var exitMatchEffect = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return onFailure(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self2.effect_instruction_i0);
  }
});
var exitSucceed = (value) => {
  const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect4.effect_instruction_i0 = value;
  return effect4;
};
var exitVoid = /* @__PURE__ */ exitSucceed(void 0);
var exitZip = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: (a2, a22) => [a2, a22],
  onFailure: sequential
}));
var exitZipRight = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: (_2, a2) => a2,
  onFailure: sequential
}));
var exitZipWith = /* @__PURE__ */ dual(3, (self2, that, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitFailCause(self2.effect_instruction_i0);
        case OP_FAILURE: {
          return exitFailCause(onFailure(self2.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self2.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE:
          return exitFailCause(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal = (exits, combineCauses) => {
  const list = fromIterable2(exits);
  if (!isNonEmpty(list)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list), reduce(pipe(headNonEmpty2(list), exitMap(of2)), (accumulator, current2) => pipe(accumulator, exitZipWith(current2, {
    onSuccess: (list2, value) => pipe(list2, prepend2(value)),
    onFailure: combineCauses
  }))), exitMap(reverse2), exitMap((chunk5) => toReadonlyArray(chunk5)), some2);
};
var deferredUnsafeMake = (fiberId3) => {
  const _deferred = {
    ...CommitPrototype,
    [DeferredTypeId]: deferredVariance,
    state: make12(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId3
  };
  return _deferred;
};
var deferredMake = () => flatMap8(fiberId, (id2) => deferredMakeAs(id2));
var deferredMakeAs = (fiberId3) => sync(() => deferredUnsafeMake(fiberId3));
var deferredAwait = (self2) => asyncInterrupt((resume2) => {
  const state = get6(self2.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return resume2(state.effect);
    }
    case OP_STATE_PENDING: {
      state.joiners.push(resume2);
      return deferredInterruptJoiner(self2, resume2);
    }
  }
}, self2.blockingOn);
var deferredComplete = /* @__PURE__ */ dual(2, (self2, effect4) => intoDeferred(effect4, self2));
var deferredCompleteWith = /* @__PURE__ */ dual(2, (self2, effect4) => sync(() => {
  const state = get6(self2.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return false;
    }
    case OP_STATE_PENDING: {
      set2(self2.state, done(effect4));
      for (let i = 0, len = state.joiners.length; i < len; i++) {
        state.joiners[i](effect4);
      }
      return true;
    }
  }
}));
var deferredDone = /* @__PURE__ */ dual(2, (self2, exit4) => deferredCompleteWith(self2, exit4));
var deferredFail = /* @__PURE__ */ dual(2, (self2, error4) => deferredCompleteWith(self2, fail2(error4)));
var deferredFailCause = /* @__PURE__ */ dual(2, (self2, cause3) => deferredCompleteWith(self2, failCause(cause3)));
var deferredInterrupt = (self2) => flatMap8(fiberId, (fiberId3) => deferredCompleteWith(self2, interruptWith(fiberId3)));
var deferredInterruptWith = /* @__PURE__ */ dual(2, (self2, fiberId3) => deferredCompleteWith(self2, interruptWith(fiberId3)));
var deferredIsDone = (self2) => sync(() => get6(self2.state)._tag === OP_STATE_DONE);
var deferredPoll = (self2) => sync(() => {
  const state = get6(self2.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return some2(state.effect);
    }
    case OP_STATE_PENDING: {
      return none2();
    }
  }
});
var deferredSucceed = /* @__PURE__ */ dual(2, (self2, value) => deferredCompleteWith(self2, succeed(value)));
var deferredUnsafeDone = (self2, effect4) => {
  const state = get6(self2.state);
  if (state._tag === OP_STATE_PENDING) {
    set2(self2.state, done(effect4));
    for (let i = 0, len = state.joiners.length; i < len; i++) {
      state.joiners[i](effect4);
    }
  }
};
var deferredInterruptJoiner = (self2, joiner) => sync(() => {
  const state = get6(self2.state);
  if (state._tag === OP_STATE_PENDING) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      state.joiners.splice(index, 1);
    }
  }
});
var constContext = /* @__PURE__ */ withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
var context = () => constContext;
var contextWithEffect = (f2) => flatMap8(context(), f2);
var provideContext = /* @__PURE__ */ dual(2, (self2, context8) => fiberRefLocally(currentContext, context8)(self2));
var provideSomeContext = /* @__PURE__ */ dual(2, (self2, context8) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context8))(self2));
var mapInputContext = /* @__PURE__ */ dual(2, (self2, f2) => contextWithEffect((context8) => provideContext(self2, f2(context8))));
var filterEffectOrElse = /* @__PURE__ */ dual(2, (self2, options) => flatMap8(self2, (a2) => flatMap8(options.predicate(a2), (pass) => pass ? succeed(a2) : options.orElse(a2))));
var filterEffectOrFail = /* @__PURE__ */ dual(2, (self2, options) => filterEffectOrElse(self2, {
  predicate: options.predicate,
  orElse: (a2) => fail2(options.orFailWith(a2))
}));
var currentSpanFromFiber = (fiber) => {
  const span4 = fiber.currentSpan;
  return span4 !== void 0 && span4._tag === "Span" ? some2(span4) : none2();
};
var NoopSpanProto = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  sampled: false,
  status: {
    _tag: "Ended",
    startTime: /* @__PURE__ */ BigInt(0),
    endTime: /* @__PURE__ */ BigInt(0),
    exit: exitVoid
  },
  attributes: /* @__PURE__ */ new Map(),
  links: [],
  kind: "internal",
  attribute() {
  },
  event() {
  },
  end() {
  },
  addLinks() {
  }
};
var noopSpan = (options) => Object.assign(Object.create(NoopSpanProto), options);

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey = "effect/Clock";
var ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
var clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
var MAX_TIMER_MILLIS = 2 ** 31 - 1;
var globalClockScheduler = {
  unsafeSchedule(task, duration4) {
    const millis2 = toMillis(duration4);
    if (millis2 > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis2);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
var performanceNowNanos = /* @__PURE__ */ function() {
  const bigint1e62 = /* @__PURE__ */ BigInt(1e6);
  if (typeof performance === "undefined") {
    return () => BigInt(Date.now()) * bigint1e62;
  } else if (typeof performance.timeOrigin === "number" && performance.timeOrigin === 0) {
    return () => BigInt(Math.round(performance.now() * 1e6));
  }
  const origin = /* @__PURE__ */ BigInt(/* @__PURE__ */ Date.now()) * bigint1e62 - /* @__PURE__ */ BigInt(/* @__PURE__ */ Math.round(/* @__PURE__ */ performance.now() * 1e6));
  return () => origin + BigInt(Math.round(performance.now() * 1e6));
}();
var processOrPerformanceNow = /* @__PURE__ */ function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
  return () => origin + processHrtime.bigint();
}();
var ClockImpl = class {
  [ClockTypeId] = ClockTypeId;
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  currentTimeMillis = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeMillis());
  currentTimeNanos = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeNanos());
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration4) {
    return async_((resume2) => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume2(void_), duration4);
      return asVoid(sync(canceler));
    });
  }
};
var make19 = () => new ClockImpl();

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Number.js
var Order = number2;
var nextPow2 = (n2) => {
  const nextPow = Math.ceil(Math.log(n2) / Math.log(2));
  return Math.max(Math.pow(2, nextPow), 2);
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/RegExp.js
var escape2 = (string4) => string4.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND = "And";
var OP_OR = "Or";
var OP_INVALID_DATA = "InvalidData";
var OP_MISSING_DATA = "MissingData";
var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
var OP_UNSUPPORTED = "Unsupported";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError";
var ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
var proto2 = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
var And = (self2, that) => {
  const error4 = Object.create(proto2);
  error4._op = OP_AND;
  error4.left = self2;
  error4.right = that;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  return error4;
};
var Or = (self2, that) => {
  const error4 = Object.create(proto2);
  error4._op = OP_OR;
  error4.left = self2;
  error4.right = that;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  return error4;
};
var InvalidData = (path3, message, options = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_INVALID_DATA;
  error4.path = path3;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path4 = pipe(this.path, join(options.pathDelim));
      return `(Invalid data at ${path4}: "${this.message}")`;
    }
  });
  return error4;
};
var MissingData = (path3, message, options = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_MISSING_DATA;
  error4.path = path3;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path4 = pipe(this.path, join(options.pathDelim));
      return `(Missing data at ${path4}: "${this.message}")`;
    }
  });
  return error4;
};
var SourceUnavailable = (path3, message, cause3, options = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_SOURCE_UNAVAILABLE;
  error4.path = path3;
  error4.message = message;
  error4.cause = cause3;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path4 = pipe(this.path, join(options.pathDelim));
      return `(Source unavailable at ${path4}: "${this.message}")`;
    }
  });
  return error4;
};
var Unsupported = (path3, message, options = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_UNSUPPORTED;
  error4.path = path3;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path4 = pipe(this.path, join(options.pathDelim));
      return `(Unsupported operation at ${path4}: "${this.message}")`;
    }
  });
  return error4;
};
var prefixed = /* @__PURE__ */ dual(2, (self2, prefix) => {
  switch (self2._op) {
    case OP_AND: {
      return And(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
    }
    case OP_OR: {
      return Or(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
    }
    case OP_INVALID_DATA: {
      return InvalidData([...prefix, ...self2.path], self2.message);
    }
    case OP_MISSING_DATA: {
      return MissingData([...prefix, ...self2.path], self2.message);
    }
    case OP_SOURCE_UNAVAILABLE: {
      return SourceUnavailable([...prefix, ...self2.path], self2.message, self2.cause);
    }
    case OP_UNSUPPORTED: {
      return Unsupported([...prefix, ...self2.path], self2.message);
    }
  }
});
var IsMissingDataOnlyReducer = {
  andCase: (_2, left3, right3) => left3 && right3,
  orCase: (_2, left3, right3) => left3 && right3,
  invalidDataCase: constFalse,
  missingDataCase: constTrue,
  sourceUnavailableCase: constFalse,
  unsupportedCase: constFalse
};
var reduceWithContext2 = /* @__PURE__ */ dual(3, (self2, context8, reducer) => {
  const input2 = [self2];
  const output = [];
  while (input2.length > 0) {
    const error4 = input2.pop();
    switch (error4._op) {
      case OP_AND: {
        input2.push(error4.right);
        input2.push(error4.left);
        output.push(left2({
          _op: "AndCase"
        }));
        break;
      }
      case OP_OR: {
        input2.push(error4.right);
        input2.push(error4.left);
        output.push(left2({
          _op: "OrCase"
        }));
        break;
      }
      case OP_INVALID_DATA: {
        output.push(right2(reducer.invalidDataCase(context8, error4.path, error4.message)));
        break;
      }
      case OP_MISSING_DATA: {
        output.push(right2(reducer.missingDataCase(context8, error4.path, error4.message)));
        break;
      }
      case OP_SOURCE_UNAVAILABLE: {
        output.push(right2(reducer.sourceUnavailableCase(context8, error4.path, error4.message, error4.cause)));
        break;
      }
      case OP_UNSUPPORTED: {
        output.push(right2(reducer.unsupportedCase(context8, error4.path, error4.message)));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either7 = output.pop();
    switch (either7._op) {
      case "Left": {
        switch (either7.left._op) {
          case "AndCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.andCase(context8, left3, right3);
            accumulator.push(value);
            break;
          }
          case "OrCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.orCase(context8, left3, right3);
            accumulator.push(value);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either7.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var isMissingDataOnly = (self2) => reduceWithContext2(self2, void 0, IsMissingDataOnlyReducer);

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty17 = {
  _tag: "Empty"
};
var andThen3 = /* @__PURE__ */ dual(2, (self2, that) => ({
  _tag: "AndThen",
  first: self2,
  second: that
}));
var mapName = /* @__PURE__ */ dual(2, (self2, f2) => andThen3(self2, {
  _tag: "MapName",
  f: f2
}));
var nested = /* @__PURE__ */ dual(2, (self2, name) => andThen3(self2, {
  _tag: "Nested",
  name
}));
var unnested = /* @__PURE__ */ dual(2, (self2, name) => andThen3(self2, {
  _tag: "Unnested",
  name
}));
var patch5 = /* @__PURE__ */ dual(2, (path3, patch9) => {
  let input2 = of3(patch9);
  let output = path3;
  while (isCons(input2)) {
    const patch10 = input2.head;
    switch (patch10._tag) {
      case "Empty": {
        input2 = input2.tail;
        break;
      }
      case "AndThen": {
        input2 = cons(patch10.first, cons(patch10.second, input2.tail));
        break;
      }
      case "MapName": {
        output = map2(output, patch10.f);
        input2 = input2.tail;
        break;
      }
      case "Nested": {
        output = prepend(output, patch10.name);
        input2 = input2.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe(head(output), contains(patch10.name));
        if (containsName) {
          output = tailNonEmpty(output);
          input2 = input2.tail;
        } else {
          return left2(MissingData(output, `Expected ${patch10.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right2(output);
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT = "Constant";
var OP_FAIL2 = "Fail";
var OP_FALLBACK = "Fallback";
var OP_DESCRIBED = "Described";
var OP_LAZY = "Lazy";
var OP_MAP_OR_FAIL = "MapOrFail";
var OP_NESTED = "Nested";
var OP_PRIMITIVE = "Primitive";
var OP_SEQUENCE = "Sequence";
var OP_HASHMAP = "HashMap";
var OP_ZIP_WITH = "ZipWith";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/string-utils.js
var lowerCase = (str) => str.toLowerCase();
var upperCase = (str) => str.toUpperCase();
var replace = (input2, re2, value) => re2 instanceof RegExp ? input2.replace(re2, value) : re2.reduce((input3, re3) => input3.replace(re3, value), input2);
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
var noCase = (input2, options = {}) => {
  const {
    delimiter = " ",
    splitRegexp = DEFAULT_SPLIT_REGEXP,
    stripRegexp = DEFAULT_STRIP_REGEXP,
    transform: transform4 = lowerCase
  } = options;
  const result = replace(replace(input2, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  let start3 = 0;
  let end6 = result.length;
  while (result.charAt(start3) === "\0") {
    start3++;
  }
  while (result.charAt(end6 - 1) === "\0") {
    end6--;
  }
  return result.slice(start3, end6).split("\0").map(transform4).join(delimiter);
};
var constantCase = (input2, options) => noCase(input2, {
  delimiter: "_",
  transform: upperCase,
  ...options
});
var kebabCase = (input2, options) => noCase(input2, {
  delimiter: "-",
  ...options
});
var snakeCase = (input2, options) => noCase(input2, {
  delimiter: "_",
  ...options
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/configProvider.js
var concat = (l, r) => [...l, ...r];
var ConfigProviderSymbolKey = "effect/ConfigProvider";
var ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
var configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
var make20 = (options) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var makeFlat = (options) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: (path3, config2, split3 = true) => options.load(path3, config2, split3),
  enumerateChildren: options.enumerateChildren
});
var fromFlat = (flat) => make20({
  load: (config2) => flatMap8(fromFlatLoop(flat, empty(), config2, false), (chunk5) => match2(head(chunk5), {
    onNone: () => fail2(MissingData(empty(), `Expected a single value having structure: ${config2}`)),
    onSome: succeed
  })),
  flattened: flat
});
var fromEnv = (options) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options);
  const makePathString = (path3) => pipe(path3, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {};
  const load = (path3, primitive3, split3 = true) => {
    const pathString = makePathString(path3);
    const current2 = getEnv();
    const valueOpt = pathString in current2 ? some2(current2[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path3, `Expected ${pathString} to exist in the process context`)), flatMap8((value) => parsePrimitive(value, path3, primitive3, seqDelim, split3)));
  };
  const enumerateChildren = (path3) => sync(() => {
    const current2 = getEnv();
    const keys5 = Object.keys(current2);
    const keyPaths = keys5.map((value) => unmakePathString(value.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0; i < path3.length; i++) {
        const pathComponent = pipe(path3, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === void 0 || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path3.length, path3.length + 1));
    return fromIterable5(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty17
  }));
};
var fromMap = (map26, config2) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({
    seqDelim: ",",
    pathDelim: "."
  }, config2);
  const makePathString = (path3) => pipe(path3, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const mapWithIndexSplit = splitIndexInKeys(map26, (str) => unmakePathString(str), makePathString);
  const load = (path3, primitive3, split3 = true) => {
    const pathString = makePathString(path3);
    const valueOpt = mapWithIndexSplit.has(pathString) ? some2(mapWithIndexSplit.get(pathString)) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path3, `Expected ${pathString} to exist in the provided map`)), flatMap8((value) => parsePrimitive(value, path3, primitive3, seqDelim, split3)));
  };
  const enumerateChildren = (path3) => sync(() => {
    const keyPaths = fromIterable(mapWithIndexSplit.keys()).map(unmakePathString);
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0; i < path3.length; i++) {
        const pathComponent = pipe(path3, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === void 0 || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path3.length, path3.length + 1));
    return fromIterable5(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty17
  }));
};
var extend = (leftDef, rightDef, left3, right3) => {
  const leftPad = unfold(left3.length, (index) => index >= right3.length ? none2() : some2([leftDef(index), index + 1]));
  const rightPad = unfold(right3.length, (index) => index >= left3.length ? none2() : some2([rightDef(index), index + 1]));
  const leftExtension = concat(left3, leftPad);
  const rightExtension = concat(right3, rightPad);
  return [leftExtension, rightExtension];
};
var appendConfigPath = (path3, config2) => {
  let op = config2;
  if (op._tag === "Nested") {
    const out = path3.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path3;
};
var fromFlatLoop = (flat, prefix, config2, split3) => {
  const op = config2;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config, split3));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split3)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix, op.second, split3), catchAll((error22) => fail2(Or(error1, error22))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config(), split3));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split3), flatMap8(forEachSequential((a2) => pipe(op.mapOrFail(a2), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split3));
    }
    case OP_PRIMITIVE: {
      return pipe(patch5(prefix, flat.patch), flatMap8((prefix2) => pipe(flat.load(prefix2, op, split3), flatMap8((values3) => {
        if (values3.length === 0) {
          const name = pipe(last(prefix2), getOrElse(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
        }
        return succeed(values3);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch5(prefix, flat.patch), flatMap8((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap8(indicesFrom), flatMap8((indices) => {
        if (indices.length === 0) {
          return suspend(() => map9(fromFlatLoop(flat, prefix, op.config, true), of));
        }
        return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append(prefix, `[${index}]`), op.config, true)), map9((chunkChunk) => {
          const flattened = flatten(chunkChunk);
          if (flattened.length === 0) {
            return of(empty());
          }
          return of(flattened);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch5(prefix, flat.patch), flatMap8((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap8((keys5) => {
        return pipe(keys5, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split3)), map9((matrix) => {
          if (matrix.length === 0) {
            return of(empty9());
          }
          return pipe(transpose(matrix), map2((values3) => fromIterable6(zip(fromIterable(keys5), values3))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split3), either2, flatMap8((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split3), either2, flatMap8((right3) => {
        if (isLeft2(left3) && isLeft2(right3)) {
          return fail2(And(left3.left, right3.left));
        }
        if (isLeft2(left3) && isRight2(right3)) {
          return fail2(left3.left);
        }
        if (isRight2(left3) && isLeft2(right3)) {
          return fail2(right3.left);
        }
        if (isRight2(left3) && isRight2(right3)) {
          const path3 = pipe(prefix, join("."));
          const fail19 = fromFlatLoopFail(prefix, path3);
          const [lefts, rights] = extend(fail19, fail19, pipe(left3.right, map2(right2)), pipe(right3.right, map2(right2)));
          return pipe(lefts, zip(rights), forEachSequential(([left4, right4]) => pipe(zip2(left4, right4), map9(([left5, right5]) => op.zip(left5, right5)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
};
var fromFlatLoopFail = (prefix, path3) => (index) => left2(MissingData(prefix, `The element at index ${index} in a sequence at path "${path3}" was missing`));
var mapInputPath = /* @__PURE__ */ dual(2, (self2, f2) => fromFlat(mapInputPathFlat(self2.flattened, f2)));
var mapInputPathFlat = (self2, f2) => makeFlat({
  load: (path3, config2, split3 = true) => self2.load(path3, config2, split3),
  enumerateChildren: (path3) => self2.enumerateChildren(path3),
  patch: mapName(self2.patch, f2)
});
var nested2 = /* @__PURE__ */ dual(2, (self2, name) => fromFlat(makeFlat({
  load: (path3, config2) => self2.flattened.load(path3, config2, true),
  enumerateChildren: (path3) => self2.flattened.enumerateChildren(path3),
  patch: nested(self2.flattened.patch, name)
})));
var unnested2 = /* @__PURE__ */ dual(2, (self2, name) => fromFlat(makeFlat({
  load: (path3, config2) => self2.flattened.load(path3, config2, true),
  enumerateChildren: (path3) => self2.flattened.enumerateChildren(path3),
  patch: unnested(self2.flattened.patch, name)
})));
var orElse3 = /* @__PURE__ */ dual(2, (self2, that) => fromFlat(orElseFlat(self2.flattened, () => that().flattened)));
var orElseFlat = (self2, that) => makeFlat({
  load: (path3, config2, split3) => pipe(patch5(path3, self2.patch), flatMap8((patch9) => self2.load(patch9, config2, split3)), catchAll((error1) => pipe(sync(that), flatMap8((that2) => pipe(patch5(path3, that2.patch), flatMap8((patch9) => that2.load(patch9, config2, split3)), catchAll((error22) => fail2(Or(error1, error22)))))))),
  enumerateChildren: (path3) => pipe(patch5(path3, self2.patch), flatMap8((patch9) => self2.enumerateChildren(patch9)), either2, flatMap8((left3) => pipe(sync(that), flatMap8((that2) => pipe(patch5(path3, that2.patch), flatMap8((patch9) => that2.enumerateChildren(patch9)), either2, flatMap8((right3) => {
    if (isLeft2(left3) && isLeft2(right3)) {
      return fail2(And(left3.left, right3.left));
    }
    if (isLeft2(left3) && isRight2(right3)) {
      return succeed(right3.right);
    }
    if (isRight2(left3) && isLeft2(right3)) {
      return succeed(left3.right);
    }
    if (isRight2(left3) && isRight2(right3)) {
      return succeed(pipe(left3.right, union3(right3.right)));
    }
    throw new Error("BUG: ConfigProvider.orElseFlat - please report an issue at https://github.com/Effect-TS/effect/issues");
  })))))),
  patch: empty17
});
var constantCase2 = (self2) => mapInputPath(self2, constantCase);
var kebabCase2 = (self2) => mapInputPath(self2, kebabCase);
var lowerCase2 = (self2) => mapInputPath(self2, lowerCase);
var snakeCase2 = (self2) => mapInputPath(self2, snakeCase);
var upperCase2 = (self2) => mapInputPath(self2, upperCase);
var within = /* @__PURE__ */ dual(3, (self2, path3, f2) => {
  const unnest = reduce(path3, self2, (provider, name) => unnested2(provider, name));
  const nest = reduceRight(path3, f2(unnest), (provider, name) => nested2(provider, name));
  return orElse3(nest, () => self2);
});
var splitPathString = (text, delim) => {
  const split3 = text.split(new RegExp(`\\s*${escape2(delim)}\\s*`));
  return split3;
};
var parsePrimitive = (text, path3, primitive3, delimiter, split3) => {
  if (!split3) {
    return pipe(primitive3.parse(text), mapBoth({
      onFailure: prefixed(path3),
      onSuccess: of
    }));
  }
  return pipe(splitPathString(text, delimiter), forEachSequential((char) => primitive3.parse(char.trim())), mapError(prefixed(path3)));
};
var transpose = (array6) => {
  return Object.keys(array6[0]).map((column) => array6.map((row) => row[column]));
};
var indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth({
  onFailure: () => empty(),
  onSuccess: sort(Order)
}), either2, map9(merge));
var STR_INDEX_REGEX = /(^.+)(\[(\d+)\])$/;
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = (str) => {
  const match18 = str.match(QUOTED_INDEX_REGEX);
  if (match18 !== null) {
    const matchedIndex = match18[2];
    return pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
  }
  return none2();
};
var splitIndexInKeys = (map26, unmakePathString, makePathString) => {
  const newMap = /* @__PURE__ */ new Map();
  for (const [pathString, value] of map26) {
    const keyWithIndex = pipe(unmakePathString(pathString), flatMap2((key) => match2(splitIndexFrom(key), {
      onNone: () => of(key),
      onSome: ([key2, index]) => make4(key2, `[${index}]`)
    })));
    newMap.set(makePathString(keyWithIndex), value);
  }
  return newMap;
};
var splitIndexFrom = (key) => {
  const match18 = key.match(STR_INDEX_REGEX);
  if (match18 !== null) {
    const matchedString = match18[1];
    const matchedIndex = match18[3];
    const optionalString = matchedString !== void 0 && matchedString.length > 0 ? some2(matchedString) : none2();
    const optionalIndex = pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
    return all([optionalString, optionalIndex]);
  }
  return none2();
};
var parseInteger = (str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some2(parsedIndex);
};
var keyName = (name) => ({
  _tag: "KeyName",
  name
});
var keyIndex = (index) => ({
  _tag: "KeyIndex",
  index
});
var fromJson = (json) => {
  const hiddenDelimiter = "\uFEFF";
  const indexedEntries = map2(getIndexedEntries(json), ([key, value]) => [configPathToString(key).join(hiddenDelimiter), value]);
  return fromMap(new Map(indexedEntries), {
    pathDelim: hiddenDelimiter,
    seqDelim: hiddenDelimiter
  });
};
var configPathToString = (path3) => {
  const output = [];
  let i = 0;
  while (i < path3.length) {
    const component = path3[i];
    if (component._tag === "KeyName") {
      if (i + 1 < path3.length) {
        const nextComponent = path3[i + 1];
        if (nextComponent._tag === "KeyIndex") {
          output.push(`${component.name}[${nextComponent.index}]`);
          i += 2;
        } else {
          output.push(component.name);
          i += 1;
        }
      } else {
        output.push(component.name);
        i += 1;
      }
    }
  }
  return output;
};
var getIndexedEntries = (config2) => {
  const loopAny = (path3, value) => {
    if (typeof value === "string") {
      return make4([path3, value]);
    }
    if (typeof value === "number" || typeof value === "boolean") {
      return make4([path3, String(value)]);
    }
    if (isArray(value)) {
      return loopArray(path3, value);
    }
    if (typeof value === "object" && value !== null) {
      return loopObject(path3, value);
    }
    return empty();
  };
  const loopArray = (path3, values3) => match3(values3, {
    onEmpty: () => make4([path3, "<nil>"]),
    onNonEmpty: flatMap2((value, index) => loopAny(append(path3, keyIndex(index)), value))
  });
  const loopObject = (path3, value) => Object.entries(value).filter(([, value2]) => isNotNullable(value2)).flatMap(([key, value2]) => {
    const newPath = append(path3, keyName(key));
    const result = loopAny(newPath, value2);
    if (isEmptyReadonlyArray(result)) {
      return make4([newPath, ""]);
    }
    return result;
  });
  return loopObject(empty(), config2);
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId8 = /* @__PURE__ */ Symbol.for("effect/Console");
var consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
var defaultConsole = {
  [TypeId8]: TypeId8,
  assert(condition, ...args2) {
    return sync(() => {
      console.assert(condition, ...args2);
    });
  },
  clear: /* @__PURE__ */ sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args2) {
    return sync(() => {
      console.debug(...args2);
    });
  },
  dir(item, options) {
    return sync(() => {
      console.dir(item, options);
    });
  },
  dirxml(...args2) {
    return sync(() => {
      console.dirxml(...args2);
    });
  },
  error(...args2) {
    return sync(() => {
      console.error(...args2);
    });
  },
  group(options) {
    return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));
  },
  groupEnd: /* @__PURE__ */ sync(() => {
    console.groupEnd();
  }),
  info(...args2) {
    return sync(() => {
      console.info(...args2);
    });
  },
  log(...args2) {
    return sync(() => {
      console.log(...args2);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args2) {
    return sync(() => {
      console.timeLog(label, ...args2);
    });
  },
  trace(...args2) {
    return sync(() => {
      console.trace(...args2);
    });
  },
  warn(...args2) {
    return sync(() => {
      console.warn(...args2);
    });
  },
  unsafe: console
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey = "effect/Random";
var RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
var randomTag = /* @__PURE__ */ GenericTag("effect/Random");
var RandomImpl = class {
  seed;
  [RandomTypeId] = RandomTypeId;
  PRNG;
  constructor(seed) {
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map9(this.next, (n2) => n2 > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min3, max5) {
    return map9(this.next, (n2) => (max5 - min3) * n2 + min3);
  }
  nextIntBetween(min3, max5) {
    return sync(() => this.PRNG.integer(max5 - min3) + min3);
  }
  shuffle(elements) {
    return shuffleWith(elements, (n2) => this.nextIntBetween(0, n2));
  }
};
var shuffleWith = (elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap8((buffer4) => {
    const numbers = [];
    for (let i = buffer4.length; i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard((n2) => pipe(nextIntBounded(n2), map9((k) => swap(buffer4, n2 - 1, k)))), as(fromIterable2(buffer4)));
  })));
};
var swap = (buffer4, index1, index2) => {
  const tmp = buffer4[index1];
  buffer4[index1] = buffer4[index2];
  buffer4[index2] = tmp;
  return buffer4;
};
var make21 = (seed) => new RandomImpl(hash(seed));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/tracer.js
var TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
var make22 = (options) => ({
  [TracerTypeId]: TracerTypeId,
  ...options
});
var tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
var spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
var randomHexString = /* @__PURE__ */ function() {
  const characters2 = "abcdef0123456789";
  const charactersLength = characters2.length;
  return function(length3) {
    let result = "";
    for (let i = 0; i < length3; i++) {
      result += characters2.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
}();
var NativeSpan = class {
  name;
  parent;
  context;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  links;
  constructor(name, parent, context8, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context8;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = /* @__PURE__ */ new Map();
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit4) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit4,
      startTime: this.status.startTime
    };
  }
  attribute(key, value) {
    this.attributes.set(key, value);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
};
var nativeTracer = /* @__PURE__ */ make22({
  span: (name, parent, context8, links, startTime, kind) => new NativeSpan(name, parent, context8, links, startTime, kind),
  context: (f2) => f2()
});
var addSpanStackTrace = (options) => {
  if (options?.captureStackTrace === false) {
    return options;
  } else if (options?.captureStackTrace !== void 0 && typeof options.captureStackTrace !== "boolean") {
    return options;
  }
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 3;
  const traceError = new Error();
  Error.stackTraceLimit = limit;
  let cache3 = false;
  return {
    ...options,
    captureStackTrace: () => {
      if (cache3 !== false) {
        return cache3;
      }
      if (traceError.stack !== void 0) {
        const stack = traceError.stack.split("\n");
        if (stack[3] !== void 0) {
          cache3 = stack[3].trim();
          return cache3;
        }
      }
    }
  };
};
var DisablePropagation = /* @__PURE__ */ Reference2()("effect/Tracer/DisablePropagation", {
  defaultValue: constFalse
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty4(), /* @__PURE__ */ add2(clockTag, /* @__PURE__ */ make19()), /* @__PURE__ */ add2(consoleTag, defaultConsole), /* @__PURE__ */ add2(randomTag, /* @__PURE__ */ make21(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add2(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add2(tracerTag, nativeTracer));
var currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
var sleep = (duration4) => {
  const decodedDuration = decode(duration4);
  return clockWith((clock3) => clock3.sleep(decodedDuration));
};
var defaultServicesWith = (f2) => withFiberRuntime((fiber) => f2(fiber.currentDefaultServices));
var clockWith = (f2) => defaultServicesWith((services) => f2(services.unsafeMap.get(clockTag.key)));
var currentTimeMillis = /* @__PURE__ */ clockWith((clock3) => clock3.currentTimeMillis);
var currentTimeNanos = /* @__PURE__ */ clockWith((clock3) => clock3.currentTimeNanos);
var withClock = /* @__PURE__ */ dual(2, (effect4, c) => fiberRefLocallyWith(currentServices, add2(clockTag, c))(effect4));
var withConfigProvider = /* @__PURE__ */ dual(2, (self2, provider) => fiberRefLocallyWith(currentServices, add2(configProviderTag, provider))(self2));
var configProviderWith = (f2) => defaultServicesWith((services) => f2(services.unsafeMap.get(configProviderTag.key)));
var config = (config2) => configProviderWith((_2) => _2.load(config2));
var randomWith = (f2) => defaultServicesWith((services) => f2(services.unsafeMap.get(randomTag.key)));
var withRandom = /* @__PURE__ */ dual(2, (effect4, value) => fiberRefLocallyWith(currentServices, add2(randomTag, value))(effect4));
var tracerWith = (f2) => defaultServicesWith((services) => f2(services.unsafeMap.get(tracerTag.key)));
var withTracer = /* @__PURE__ */ dual(2, (effect4, value) => fiberRefLocallyWith(currentServices, add2(tracerTag, value))(effect4));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Boolean.js
var not = (self2) => !self2;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Deferred.js
var make23 = deferredMake;
var _await = deferredAwait;
var done2 = deferredDone;
var fail3 = deferredFail;
var failCause2 = deferredFailCause;
var interrupt3 = deferredInterrupt;
var isDone = deferredIsDone;
var poll = deferredPoll;
var succeed2 = deferredSucceed;
var unsafeMake3 = deferredUnsafeMake;
var unsafeDone = deferredUnsafeDone;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Effectable.js
var EffectPrototype2 = EffectPrototype;
var CommitPrototype2 = CommitPrototype;
var Base2 = Base;
var Class2 = class extends Base2 {
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL2 = "Sequential";
var OP_PARALLEL2 = "Parallel";
var OP_PARALLEL_N = "ParallelN";
var sequential2 = {
  _tag: OP_SEQUENTIAL2
};
var parallel2 = {
  _tag: OP_PARALLEL2
};
var parallelN = (parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
});
var isSequential = (self2) => self2._tag === OP_SEQUENTIAL2;
var isParallel = (self2) => self2._tag === OP_PARALLEL2;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3 = sequential2;
var parallel3 = parallel2;
var parallelN2 = parallelN;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake4(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
function empty18() {
  return unsafeMake4(/* @__PURE__ */ new Map());
}
var FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");
var FiberRefsImpl = class {
  locals;
  [FiberRefsSym] = FiberRefsSym;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = void 0;
  while (ret === void 0) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
};
var joinAs = /* @__PURE__ */ dual(3, (self2, fiberId3, that) => {
  const parentFiberRefs = new Map(self2.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol2](fiberId3)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId3, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch9 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch9)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol2](fiberId3)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId3, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
var forkAs = /* @__PURE__ */ dual(2, (self2, childId) => {
  const map26 = /* @__PURE__ */ new Map();
  unsafeForkAs(self2, map26, childId);
  return new FiberRefsImpl(map26);
});
var unsafeForkAs = (self2, map26, fiberId3) => {
  self2.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map26.set(fiberRef, stack);
    } else {
      map26.set(fiberRef, [[fiberId3, newValue], ...stack]);
    }
  });
};
var fiberRefs = (self2) => fromIterable5(self2.locals.keys());
var setAll = (self2) => forEachSequentialDiscard(fiberRefs(self2), (fiberRef) => fiberRefSet(fiberRef, getOrDefault(self2, fiberRef)));
var delete_ = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
  const locals = new Map(self2.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
var get8 = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
  if (!self2.locals.has(fiberRef)) {
    return none2();
  }
  return some2(headNonEmpty(self2.locals.get(fiberRef))[1]);
});
var getOrDefault = /* @__PURE__ */ dual(2, (self2, fiberRef) => pipe(get8(self2, fiberRef), getOrElse(() => fiberRef.initial)));
var updateAs = /* @__PURE__ */ dual(2, (self2, {
  fiberId: fiberId3,
  fiberRef,
  value
}) => {
  if (self2.locals.size === 0) {
    return new FiberRefsImpl(/* @__PURE__ */ new Map([[fiberRef, [[fiberId3, value]]]]));
  }
  const locals = new Map(self2.locals);
  unsafeUpdateAs(locals, fiberId3, fiberRef, value);
  return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = (locals, fiberId3, fiberRef, value) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol2](fiberId3)) {
      if (equals(currentValue, value)) {
        return;
      } else {
        newStack = [[fiberId3, value], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId3, value], ...oldStack];
    }
  } else {
    newStack = [[fiberId3, value]];
  }
  locals.set(fiberRef, newStack);
};
var updateManyAs = /* @__PURE__ */ dual(2, (self2, {
  entries: entries2,
  forkAs: forkAs2
}) => {
  if (self2.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries2));
  }
  const locals = new Map(self2.locals);
  if (forkAs2 !== void 0) {
    unsafeForkAs(self2, locals, forkAs2);
  }
  entries2.forEach(([fiberRef, values3]) => {
    if (values3.length === 1) {
      unsafeUpdateAs(locals, values3[0][0], fiberRef, values3[0][1]);
    } else {
      values3.forEach(([fiberId3, value]) => {
        unsafeUpdateAs(locals, fiberId3, fiberRef, value);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/FiberRefs.js
var get9 = get8;
var getOrDefault2 = getOrDefault;
var joinAs2 = joinAs;
var setAll2 = setAll;
var updateAs2 = updateAs;
var updateManyAs2 = updateManyAs;
var empty19 = empty18;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY2 = "Empty";
var OP_ADD = "Add";
var OP_REMOVE = "Remove";
var OP_UPDATE = "Update";
var OP_AND_THEN = "AndThen";
var empty20 = {
  _tag: OP_EMPTY2
};
var diff5 = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch9 = empty20;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== void 0) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch9 = combine7({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch9);
      }
    } else {
      patch9 = combine7({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch9);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch9 = combine7({
      _tag: OP_REMOVE,
      fiberRef
    })(patch9);
  }
  return patch9;
};
var combine7 = /* @__PURE__ */ dual(2, (self2, that) => ({
  _tag: OP_AND_THEN,
  first: self2,
  second: that
}));
var patch6 = /* @__PURE__ */ dual(3, (self2, fiberId3, oldValue) => {
  let fiberRefs3 = oldValue;
  let patches = of(self2);
  while (isNonEmptyReadonlyArray(patches)) {
    const head6 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head6._tag) {
      case OP_EMPTY2: {
        patches = tail;
        break;
      }
      case OP_ADD: {
        fiberRefs3 = updateAs(fiberRefs3, {
          fiberId: fiberId3,
          fiberRef: head6.fiberRef,
          value: head6.value
        });
        patches = tail;
        break;
      }
      case OP_REMOVE: {
        fiberRefs3 = delete_(fiberRefs3, head6.fiberRef);
        patches = tail;
        break;
      }
      case OP_UPDATE: {
        const value = getOrDefault(fiberRefs3, head6.fiberRef);
        fiberRefs3 = updateAs(fiberRefs3, {
          fiberId: fiberId3,
          fiberRef: head6.fiberRef,
          value: head6.fiberRef.patch(head6.patch)(value)
        });
        patches = tail;
        break;
      }
      case OP_AND_THEN: {
        patches = prepend(head6.first)(prepend(head6.second)(tail));
        break;
      }
    }
  }
  return fiberRefs3;
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/FiberRefsPatch.js
var diff6 = diff5;
var patch7 = patch6;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey = "effect/FiberStatus";
var FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
var OP_DONE = "Done";
var OP_RUNNING = "Running";
var OP_SUSPENDED = "Suspended";
var DoneHash = /* @__PURE__ */ string(`${FiberStatusSymbolKey}-${OP_DONE}`);
var Done = class {
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_DONE;
  [symbol]() {
    return DoneHash;
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
};
var Running = class {
  runtimeFlags;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_RUNNING;
  constructor(runtimeFlags2) {
    this.runtimeFlags = runtimeFlags2;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
};
var Suspended = class {
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_SUSPENDED;
  constructor(runtimeFlags2, blockingOn) {
    this.runtimeFlags = runtimeFlags2;
    this.blockingOn = blockingOn;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
};
var done3 = /* @__PURE__ */ new Done();
var running = (runtimeFlags2) => new Running(runtimeFlags2);
var suspended = (runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn);
var isFiberStatus = (u2) => hasProperty(u2, FiberStatusTypeId);
var isDone2 = (self2) => self2._tag === OP_DONE;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/FiberStatus.js
var done4 = done3;
var running2 = running;
var suspended2 = suspended;
var isDone3 = isDone2;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/LogLevel.js
var All = logLevelAll;
var Fatal = logLevelFatal;
var Error2 = logLevelError;
var Warning = logLevelWarning;
var Info = logLevelInfo;
var Debug = logLevelDebug;
var Trace = logLevelTrace;
var None3 = logLevelNone;
var Order2 = /* @__PURE__ */ pipe(Order, /* @__PURE__ */ mapInput2((level) => level.ordinal));
var greaterThan3 = /* @__PURE__ */ greaterThan(Order2);
var fromLiteral = (literal3) => {
  switch (literal3) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Micro.js
var TypeId9 = /* @__PURE__ */ Symbol.for("effect/Micro");
var MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
var MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
var microCauseVariance = {
  _E: identity
};
var MicroCauseImpl = class extends globalThis.Error {
  _tag;
  traces;
  [MicroCauseTypeId];
  constructor(_tag, originalError, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError instanceof globalThis.Error) {
      name = `(${causeName}) ${originalError.name}`;
      message = originalError.message;
      const messageLines = message.split("\n").length;
      stack = originalError.stack ? `(${causeName}) ${originalError.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
    } else {
      name = causeName;
      message = toStringUnknown(originalError, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `
    ${traces.join("\n    ")}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [NodeInspectSymbol]() {
    return this.stack;
  }
};
var Die = class extends MicroCauseImpl {
  defect;
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    this.defect = defect;
  }
};
var causeDie = (defect, traces = []) => new Die(defect, traces);
var Interrupt = class extends MicroCauseImpl {
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
};
var causeInterrupt = (traces = []) => new Interrupt(traces);
var causeIsInterrupt = (self2) => self2._tag === "Interrupt";
var MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
var fiberVariance = {
  _A: identity,
  _E: identity
};
var MicroFiberImpl = class {
  context;
  interruptible;
  [MicroFiberTypeId];
  _stack = [];
  _observers = [];
  _exit;
  _children;
  currentOpCount = 0;
  constructor(context8, interruptible5 = true) {
    this.context = context8;
    this.interruptible = interruptible5;
    this[MicroFiberTypeId] = fiberVariance;
  }
  getRef(ref) {
    return unsafeGetReference(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index = this._observers.indexOf(cb);
      if (index >= 0) {
        this._observers.splice(index, 1);
      }
    };
  }
  _interrupted = false;
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt2);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect4) {
    if (this._exit) {
      return;
    } else if (this._yielded !== void 0) {
      const yielded = this._yielded;
      this._yielded = void 0;
      yielded();
    }
    const exit4 = this.runLoop(effect4);
    if (exit4 === Yield) {
      return;
    }
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== void 0) {
      return this.evaluate(flatMap9(interruptChildren, () => exit4));
    }
    this._exit = exit4;
    for (let i = 0; i < this._observers.length; i++) {
      this._observers[i](exit4);
    }
    this._observers.length = 0;
  }
  runLoop(effect4) {
    let yielding = false;
    let current2 = effect4;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current2;
          current2 = flatMap9(yieldNow2, () => prev);
        }
        current2 = current2[evaluate](this);
        if (current2 === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = void 0;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error4) {
      if (!hasProperty(current2, evaluate)) {
        return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current2)}`);
      }
      return exitDie2(error4);
    }
  }
  getCont(symbol3) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return void 0;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont) return {
        [symbol3]: cont
      };
      if (op[symbol3]) return op;
    }
  }
  // cancel the yielded operation, or for the yielded exit value
  _yielded = void 0;
  yieldWith(value) {
    this._yielded = value;
    return Yield;
  }
  children() {
    return this._children ??= /* @__PURE__ */ new Set();
  }
};
var fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: void 0
}));
var identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
var args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
var evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
var successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
var failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
var ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
var Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
var microVariance = {
  _A: identity,
  _E: identity,
  _R: identity
};
var MicroProto = {
  ...EffectPrototype2,
  _op: "Micro",
  [TypeId9]: microVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier],
      ...args in this ? {
        args: this[args]
      } : void 0
    };
  },
  toString() {
    return format(this);
  },
  [NodeInspectSymbol]() {
    return format(this);
  }
};
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}
var makePrimitiveProto = (options) => ({
  ...MicroProto,
  [identifier]: options.op,
  [evaluate]: options.eval ?? defaultEvaluate,
  [successCont]: options.contA,
  [failureCont]: options.contE,
  [ensureCont]: options.ensure
});
var makePrimitive = (options) => {
  const Proto2 = makePrimitiveProto(options);
  return function() {
    const self2 = Object.create(Proto2);
    self2[args] = options.single === false ? arguments : arguments[0];
    return self2;
  };
};
var makeExit = (options) => {
  const Proto2 = {
    ...makePrimitiveProto(options),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options.op,
    get [options.prop]() {
      return this[args];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options.op,
        [options.prop]: this[args]
      };
    },
    [symbol2](that) {
      return isMicroExit(that) && that._tag === options.op && equals(this[args], that[args]);
    },
    [symbol]() {
      return cached(this, combine(string(options.op))(hash(this[args])));
    }
  };
  return function(value) {
    const self2 = Object.create(Proto2);
    self2[args] = value;
    self2[successCont] = void 0;
    self2[failureCont] = void 0;
    self2[ensureCont] = void 0;
    return self2;
  };
};
var succeed3 = /* @__PURE__ */ makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var failCause3 = /* @__PURE__ */ makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var yieldNowWith = /* @__PURE__ */ makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed) return;
      fiber.evaluate(exitVoid2);
    }, this[args] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
var yieldNow2 = /* @__PURE__ */ yieldNowWith(0);
var void_2 = /* @__PURE__ */ succeed3(void 0);
var withMicroFiber = /* @__PURE__ */ makePrimitive({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args](fiber);
  }
});
var flatMap9 = /* @__PURE__ */ dual(2, (self2, f2) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args] = self2;
  onSuccess[successCont] = f2;
  return onSuccess;
});
var OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var isMicroExit = (u2) => hasProperty(u2, MicroExitTypeId);
var exitSucceed2 = succeed3;
var exitFailCause2 = failCause3;
var exitInterrupt2 = /* @__PURE__ */ exitFailCause2(/* @__PURE__ */ causeInterrupt());
var exitDie2 = (defect) => exitFailCause2(causeDie(defect));
var exitVoid2 = /* @__PURE__ */ exitSucceed2(void 0);
var setImmediate2 = "setImmediate" in globalThis ? globalThis.setImmediate : (f2) => setTimeout(f2, 0);
var MicroSchedulerDefault = class {
  tasks = [];
  running = false;
  /**
   * @since 3.5.9
   */
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate2(this.afterScheduled);
    }
  }
  /**
   * @since 3.5.9
   */
  afterScheduled = () => {
    this.running = false;
    this.runTasks();
  };
  /**
   * @since 3.5.9
   */
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length; i < len; i++) {
      tasks[i]();
    }
  }
  /**
   * @since 3.5.9
   */
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  /**
   * @since 3.5.9
   */
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
};
var updateContext = /* @__PURE__ */ dual(2, (self2, f2) => withMicroFiber((fiber) => {
  const prev = fiber.context;
  fiber.context = f2(prev);
  return onExit2(self2, () => {
    fiber.context = prev;
    return void_2;
  });
}));
var provideContext2 = /* @__PURE__ */ dual(2, (self2, provided) => updateContext(self2, merge3(provided)));
var MaxOpsBeforeYield = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: () => 2048
})) {
};
var CurrentScheduler = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentScheduler", {
  defaultValue: () => new MicroSchedulerDefault()
})) {
};
var matchCauseEffect2 = /* @__PURE__ */ dual(2, (self2, options) => {
  const primitive3 = Object.create(OnSuccessAndFailureProto);
  primitive3[args] = self2;
  primitive3[successCont] = options.onSuccess;
  primitive3[failureCont] = options.onFailure;
  return primitive3;
});
var OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var onExit2 = /* @__PURE__ */ dual(2, (self2, f2) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self2), {
  onFailure: (cause3) => flatMap9(f2(exitFailCause2(cause3)), () => failCause3(cause3)),
  onSuccess: (a2) => flatMap9(f2(exitSucceed2(a2)), () => succeed3(a2))
})));
var setInterruptible = /* @__PURE__ */ makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt2;
    }
  }
});
var interruptible3 = (self2) => withMicroFiber((fiber) => {
  if (fiber.interruptible) return self2;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted) return exitInterrupt2;
  return self2;
});
var uninterruptibleMask2 = (f2) => withMicroFiber((fiber) => {
  if (!fiber.interruptible) return f2(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f2(interruptible3);
});
var runFork = (effect4, options) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context(new MicroSchedulerDefault()));
  fiber.evaluate(effect4);
  return fiber;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Readable.js
var TypeId10 = /* @__PURE__ */ Symbol.for("effect/Readable");

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/ref.js
var RefTypeId = /* @__PURE__ */ Symbol.for("effect/Ref");
var refVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var RefImpl = class extends Class2 {
  ref;
  commit() {
    return this.get;
  }
  [RefTypeId] = refVariance;
  [TypeId10] = TypeId10;
  constructor(ref) {
    super();
    this.ref = ref;
    this.get = sync(() => get6(this.ref));
  }
  get;
  modify(f2) {
    return sync(() => {
      const current2 = get6(this.ref);
      const [b, a2] = f2(current2);
      if (current2 !== a2) {
        set2(a2)(this.ref);
      }
      return b;
    });
  }
};
var unsafeMake5 = (value) => new RefImpl(make12(value));
var make24 = (value) => sync(() => unsafeMake5(value));
var get10 = (self2) => self2.get;
var set4 = /* @__PURE__ */ dual(2, (self2, value) => self2.modify(() => [void 0, value]));
var getAndSet = /* @__PURE__ */ dual(2, (self2, value) => self2.modify((a2) => [a2, value]));
var modify2 = /* @__PURE__ */ dual(2, (self2, f2) => self2.modify(f2));
var update2 = /* @__PURE__ */ dual(2, (self2, f2) => self2.modify((a2) => [void 0, f2(a2)]));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Ref.js
var make25 = make24;
var get11 = get10;
var getAndSet2 = getAndSet;
var modify3 = modify2;
var set5 = set4;
var update3 = update2;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Scheduler.js
var PriorityBuckets = class {
  /**
   * @since 2.0.0
   */
  buckets = [];
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    const length3 = this.buckets.length;
    let bucket = void 0;
    let index = 0;
    for (; index < length3; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index === length3) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index, 0, [priority, [task]]);
    }
  }
};
var MixedScheduler = class {
  maxNextTickBeforeTimer;
  /**
   * @since 2.0.0
   */
  running = false;
  /**
   * @since 2.0.0
   */
  tasks = /* @__PURE__ */ new PriorityBuckets();
  constructor(maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  /**
   * @since 2.0.0
   */
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_2, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  /**
   * @since 2.0.0
   */
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
};
var defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
var SyncScheduler = class {
  /**
   * @since 2.0.0
   */
  tasks = /* @__PURE__ */ new PriorityBuckets();
  /**
   * @since 2.0.0
   */
  deferred = false;
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_2, toRun] of tasks) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
};
var currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
var withScheduler = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentScheduler, scheduler));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(/* @__PURE__ */ new Map()));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/concurrency.js
var match7 = (concurrency, sequential4, unbounded8, bounded8) => {
  switch (concurrency) {
    case void 0:
      return sequential4();
    case "unbounded":
      return unbounded8();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded8() : concurrency2 > 1 ? bounded8(concurrency2) : sequential4());
    default:
      return concurrency > 1 ? bounded8(concurrency) : sequential4();
  }
};
var matchSimple = (concurrency, sequential4, concurrent) => {
  switch (concurrency) {
    case void 0:
      return sequential4();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential4());
    default:
      return concurrency > 1 ? concurrent() : sequential4();
  }
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Clock.js
var sleep2 = sleep;
var currentTimeMillis2 = currentTimeMillis;
var currentTimeNanos2 = currentTimeNanos;
var clockWith2 = clockWith;
var Clock = clockTag;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/logSpan.js
var make26 = (label, startTime) => ({
  label,
  startTime
});
var formatLabel = (key) => key.replace(/[\s="]/g, "_");
var render = (now) => (self2) => {
  const label = formatLabel(self2.label);
  return `${label}=${now - self2.startTime}ms`;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/LogSpan.js
var make27 = make26;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Tracer.js
var tracerWith2 = tracerWith;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey = "effect/MetricLabel";
var MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);
var MetricLabelImpl = class {
  key;
  value;
  [MetricLabelTypeId] = MetricLabelTypeId;
  _hash;
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this._hash = string(MetricLabelSymbolKey + this.key + this.value);
  }
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make28 = (key, value) => {
  return new MetricLabelImpl(key, value);
};
var isMetricLabel = (u2) => hasProperty(u2, MetricLabelTypeId);

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations) => Object.entries(args2[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations));
});
var asSome = (self2) => map9(self2, some2);
var asSomeError = (self2) => mapError(self2, some2);
var try_2 = (arg) => {
  let evaluate3;
  let onFailure = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    onFailure = arg.catch;
  }
  return suspend(() => {
    try {
      return succeed(internalCall(evaluate3));
    } catch (error4) {
      return fail2(onFailure ? internalCall(() => onFailure(error4)) : new UnknownException(error4, "An unknown error occurred in Effect.try"));
    }
  });
};
var _catch = /* @__PURE__ */ dual(3, (self2, tag, options) => catchAll(self2, (e) => {
  if (hasProperty(e, tag) && e[tag] === options.failure) {
    return options.onFailure(e);
  }
  return fail2(e);
}));
var catchAllDefect = /* @__PURE__ */ dual(2, (self2, f2) => catchAllCause(self2, (cause3) => {
  const option5 = find(cause3, (_2) => isDieType(_2) ? some2(_2) : none2());
  switch (option5._tag) {
    case "None": {
      return failCause(cause3);
    }
    case "Some": {
      return f2(option5.value.defect);
    }
  }
}));
var catchSomeCause = /* @__PURE__ */ dual(2, (self2, f2) => matchCauseEffect(self2, {
  onFailure: (cause3) => {
    const option5 = f2(cause3);
    switch (option5._tag) {
      case "None": {
        return failCause(cause3);
      }
      case "Some": {
        return option5.value;
      }
    }
  },
  onSuccess: succeed
}));
var catchSomeDefect = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause3) => {
  const option5 = find(cause3, (_2) => isDieType(_2) ? some2(_2) : none2());
  switch (option5._tag) {
    case "None": {
      return failCause(cause3);
    }
    case "Some": {
      const optionEffect = pf(option5.value.defect);
      return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause3);
    }
  }
}));
var catchTag = /* @__PURE__ */ dual(3, (self2, k, f2) => catchIf(self2, isTagged(k), f2));
var catchTags = /* @__PURE__ */ dual(2, (self2, cases) => {
  let keys5;
  return catchIf(self2, (e) => {
    keys5 ??= Object.keys(cases);
    return hasProperty(e, "_tag") && isString(e["_tag"]) && keys5.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var cause = (self2) => matchCause(self2, {
  onFailure: identity,
  onSuccess: () => empty8
});
var clockWith3 = clockWith2;
var clock = /* @__PURE__ */ clockWith3(succeed);
var delay = /* @__PURE__ */ dual(2, (self2, duration4) => zipRight(sleep2(duration4), self2));
var descriptorWith = (f2) => withFiberRuntime((state, status2) => f2({
  id: state.id(),
  status: status2,
  interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
}));
var allowInterrupt = /* @__PURE__ */ descriptorWith((descriptor3) => size3(descriptor3.interruptors) > 0 ? interrupt2 : void_);
var descriptor = /* @__PURE__ */ descriptorWith(succeed);
var diffFiberRefs = (self2) => summarized(self2, fiberRefs2, diff5);
var diffFiberRefsAndRuntimeFlags = (self2) => summarized(self2, zip2(fiberRefs2, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff5(refs, refsNew), diff4(flags, flagsNew)]);
var Do = /* @__PURE__ */ succeed({});
var bind2 = /* @__PURE__ */ bind(map9, flatMap8);
var bindTo2 = /* @__PURE__ */ bindTo(map9);
var let_2 = /* @__PURE__ */ let_(map9);
var dropUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping7 = succeed(false);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a2 = next.value;
    const index = i++;
    dropping7 = flatMap8(dropping7, (bool) => {
      if (bool) {
        builder.push(a2);
        return succeed(true);
      }
      return predicate(a2, index);
    });
  }
  return map9(dropping7, () => builder);
}));
var dropWhile2 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping7 = succeed(true);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a2 = next.value;
    const index = i++;
    dropping7 = flatMap8(dropping7, (d2) => map9(d2 ? predicate(a2, index) : succeed(false), (b) => {
      if (!b) {
        builder.push(a2);
      }
      return b;
    }));
  }
  return map9(dropping7, () => builder);
}));
var contextWith = (f2) => map9(context(), f2);
var eventually = (self2) => orElse2(self2, () => flatMap8(yieldNow(), () => eventually(self2)));
var filterMap4 = /* @__PURE__ */ dual(2, (elements, pf) => map9(forEachSequential(elements, identity), filterMap(pf)));
var filterOrDie = /* @__PURE__ */ dual(3, (self2, predicate, orDieWith6) => filterOrElse(self2, predicate, (a2) => dieSync(() => orDieWith6(a2))));
var filterOrDieMessage = /* @__PURE__ */ dual(3, (self2, predicate, message) => filterOrElse(self2, predicate, () => dieMessage(message)));
var filterOrElse = /* @__PURE__ */ dual(3, (self2, predicate, orElse14) => flatMap8(self2, (a2) => predicate(a2) ? succeed(a2) : orElse14(a2)));
var liftPredicate2 = /* @__PURE__ */ dual(3, (self2, predicate, orFailWith) => suspend(() => predicate(self2) ? succeed(self2) : fail2(orFailWith(self2))));
var filterOrFail = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, predicate, orFailWith) => filterOrElse(self2, predicate, (a2) => orFailWith === void 0 ? fail2(new NoSuchElementException()) : failSync(() => orFailWith(a2))));
var findFirst5 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, 0, predicate, next.value);
  }
  return succeed(none2());
}));
var findLoop = (iterator, index, f2, value) => flatMap8(f2(value, index), (result) => {
  if (result) {
    return succeed(some2(value));
  }
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, index + 1, f2, next.value);
  }
  return succeed(none2());
});
var firstSuccessOf = (effects) => suspend(() => {
  const list = fromIterable2(effects);
  if (!isNonEmpty(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  return pipe(tailNonEmpty2(list), reduce(headNonEmpty2(list), (left3, right3) => orElse2(left3, () => right3)));
});
var flipWith = /* @__PURE__ */ dual(2, (self2, f2) => flip(f2(flip(self2))));
var match8 = /* @__PURE__ */ dual(2, (self2, options) => matchEffect(self2, {
  onFailure: (e) => succeed(options.onFailure(e)),
  onSuccess: (a2) => succeed(options.onSuccess(a2))
}));
var every5 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
var forAllLoop = (iterator, index, f2) => {
  const next = iterator.next();
  return next.done ? succeed(true) : flatMap8(f2(next.value, index), (b) => b ? forAllLoop(iterator, index + 1, f2) : succeed(b));
};
var forever = (self2) => {
  const loop3 = flatMap8(flatMap8(self2, () => yieldNow()), () => loop3);
  return loop3;
};
var fiberRefs2 = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.getFiberRefs()));
var head3 = (self2) => flatMap8(self2, (as10) => {
  const iterator = as10[Symbol.iterator]();
  const next = iterator.next();
  if (next.done) {
    return fail2(new NoSuchElementException());
  }
  return succeed(next.value);
});
var ignore = (self2) => match8(self2, {
  onFailure: constVoid,
  onSuccess: constVoid
});
var ignoreLogged = (self2) => matchCauseEffect(self2, {
  onFailure: (cause3) => logDebug(cause3, "An error was silently ignored because it is not anticipated to be useful"),
  onSuccess: () => void_
});
var inheritFiberRefs = (childFiberRefs) => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs2(parentFiberRefs, parentFiberId, childFiberRefs));
var isFailure = (self2) => match8(self2, {
  onFailure: constTrue,
  onSuccess: constFalse
});
var isSuccess = (self2) => match8(self2, {
  onFailure: constFalse,
  onSuccess: constTrue
});
var iterate = (initial, options) => suspend(() => {
  if (options.while(initial)) {
    return flatMap8(options.body(initial), (z2) => iterate(z2, options));
  }
  return succeed(initial);
});
var logWithLevel = (level) => (...message) => {
  const levelOption = fromNullable(level);
  let cause3 = void 0;
  for (let i = 0, len = message.length; i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause3 !== void 0) {
        cause3 = sequential(cause3, msg);
      } else {
        cause3 = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (cause3 === void 0) {
    cause3 = empty8;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause3, levelOption);
    return void_;
  });
};
var log = /* @__PURE__ */ logWithLevel();
var logTrace = /* @__PURE__ */ logWithLevel(Trace);
var logDebug = /* @__PURE__ */ logWithLevel(Debug);
var logInfo = /* @__PURE__ */ logWithLevel(Info);
var logWarning = /* @__PURE__ */ logWithLevel(Warning);
var logError = /* @__PURE__ */ logWithLevel(Error2);
var logFatal = /* @__PURE__ */ logWithLevel(Fatal);
var withLogSpan = /* @__PURE__ */ dual(2, (effect4, label) => flatMap8(currentTimeMillis2, (now) => fiberRefLocallyWith(effect4, currentLogSpan, prepend3(make27(label, now)))));
var logAnnotations = /* @__PURE__ */ fiberRefGet(currentLogAnnotations);
var loop = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map9(loopInternal(initial, options.while, options.step, options.body), fromIterable);
var loopInternal = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap8(body(initial), (a2) => map9(loopInternal(inc(initial), cont, inc, body), prepend3(a2))) : sync(() => empty10()));
var loopDiscard = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap8(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_);
var mapAccum3 = /* @__PURE__ */ dual(3, (elements, initial, f2) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let result = succeed(initial);
  let next;
  let i = 0;
  while (!(next = iterator.next()).done) {
    const index = i++;
    const value = next.value;
    result = flatMap8(result, (state) => map9(f2(state, value, index), ([z2, b]) => {
      builder.push(b);
      return z2;
    }));
  }
  return map9(result, (z2) => [z2, builder]);
}));
var mapErrorCause = /* @__PURE__ */ dual(2, (self2, f2) => matchCauseEffect(self2, {
  onFailure: (c) => failCauseSync(() => f2(c)),
  onSuccess: succeed
}));
var memoize = (self2) => pipe(deferredMake(), flatMap8((deferred2) => pipe(diffFiberRefsAndRuntimeFlags(self2), intoDeferred(deferred2), once, map9((complete3) => zipRight(complete3, pipe(deferredAwait(deferred2), flatMap8(([patch9, a2]) => as(zip2(patchFiberRefs(patch9[0]), updateRuntimeFlags(patch9[1])), a2))))))));
var merge5 = (self2) => matchEffect(self2, {
  onFailure: (e) => succeed(e),
  onSuccess: succeed
});
var negate = (self2) => map9(self2, (b) => !b);
var none6 = (self2) => flatMap8(self2, (option5) => {
  switch (option5._tag) {
    case "None":
      return void_;
    case "Some":
      return fail2(new NoSuchElementException());
  }
});
var once = (self2) => map9(make25(true), (ref) => asVoid(whenEffect(self2, getAndSet2(ref, false))));
var option = (self2) => matchEffect(self2, {
  onFailure: () => succeed(none2()),
  onSuccess: (a2) => succeed(some2(a2))
});
var orElseFail = /* @__PURE__ */ dual(2, (self2, evaluate3) => orElse2(self2, () => failSync(evaluate3)));
var orElseSucceed = /* @__PURE__ */ dual(2, (self2, evaluate3) => orElse2(self2, () => sync(evaluate3)));
var parallelErrors = (self2) => matchCauseEffect(self2, {
  onFailure: (cause3) => {
    const errors = fromIterable(failures(cause3));
    return errors.length === 0 ? failCause(cause3) : fail2(errors);
  },
  onSuccess: succeed
});
var patchFiberRefs = (patch9) => updateFiberRefs((fiberId3, fiberRefs3) => pipe(patch9, patch6(fiberId3, fiberRefs3)));
var promise = (evaluate3) => evaluate3.length >= 1 ? async_((resolve9, signal) => {
  try {
    evaluate3(signal).then((a2) => resolve9(exitSucceed(a2)), (e) => resolve9(exitDie(e)));
  } catch (e) {
    resolve9(exitDie(e));
  }
}) : async_((resolve9) => {
  try {
    evaluate3().then((a2) => resolve9(exitSucceed(a2)), (e) => resolve9(exitDie(e)));
  } catch (e) {
    resolve9(exitDie(e));
  }
});
var provideService = /* @__PURE__ */ dual(3, (self2, tag, service3) => contextWithEffect((env2) => provideContext(self2, add2(env2, tag, service3))));
var provideServiceEffect = /* @__PURE__ */ dual(3, (self2, tag, effect4) => contextWithEffect((env2) => flatMap8(effect4, (service3) => provideContext(self2, pipe(env2, add2(tag, service3))))));
var random2 = /* @__PURE__ */ randomWith(succeed);
var reduce9 = /* @__PURE__ */ dual(3, (elements, zero2, f2) => fromIterable(elements).reduce((acc, el, i) => flatMap8(acc, (a2) => f2(a2, el, i)), succeed(zero2)));
var reduceRight3 = /* @__PURE__ */ dual(3, (elements, zero2, f2) => fromIterable(elements).reduceRight((acc, el, i) => flatMap8(acc, (a2) => f2(el, a2, i)), succeed(zero2)));
var reduceWhile = /* @__PURE__ */ dual(3, (elements, zero2, options) => flatMap8(sync(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero2, options.while, options.body)));
var reduceWhileLoop = (iterator, index, state, predicate, f2) => {
  const next = iterator.next();
  if (!next.done && predicate(state)) {
    return flatMap8(f2(state, next.value, index), (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f2));
  }
  return succeed(state);
};
var repeatN = /* @__PURE__ */ dual(2, (self2, n2) => suspend(() => repeatNLoop(self2, n2)));
var repeatNLoop = (self2, n2) => flatMap8(self2, (a2) => n2 <= 0 ? succeed(a2) : zipRight(yieldNow(), repeatNLoop(self2, n2 - 1)));
var sandbox = (self2) => matchCauseEffect(self2, {
  onFailure: fail2,
  onSuccess: succeed
});
var setFiberRefs = (fiberRefs3) => suspend(() => setAll2(fiberRefs3));
var sleep3 = sleep2;
var succeedNone = /* @__PURE__ */ succeed(/* @__PURE__ */ none2());
var succeedSome = (value) => succeed(some2(value));
var summarized = /* @__PURE__ */ dual(3, (self2, summary5, f2) => flatMap8(summary5, (start3) => flatMap8(self2, (value) => map9(summary5, (end6) => [f2(start3, end6), value]))));
var tagMetrics = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make28(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v2]) => make28(k, v2)));
});
var labelMetrics = /* @__PURE__ */ dual(2, (self2, labels) => fiberRefLocallyWith(self2, currentMetricLabels, (old) => union(old, labels)));
var takeUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let effect4 = succeed(false);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a2 = next.value;
    const index = i++;
    effect4 = flatMap8(effect4, (bool) => {
      if (bool) {
        return succeed(true);
      }
      builder.push(a2);
      return predicate(a2, index);
    });
  }
  return map9(effect4, () => builder);
}));
var takeWhile2 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let taking = succeed(true);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a2 = next.value;
    const index = i++;
    taking = flatMap8(taking, (taking2) => pipe(taking2 ? predicate(a2, index) : succeed(false), map9((bool) => {
      if (bool) {
        builder.push(a2);
      }
      return bool;
    })));
  }
  return map9(taking, () => builder);
}));
var tapBoth = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => matchCauseEffect(self2, {
  onFailure: (cause3) => {
    const either7 = failureOrCause(cause3);
    switch (either7._tag) {
      case "Left": {
        return zipRight(onFailure(either7.left), failCause(cause3));
      }
      case "Right": {
        return failCause(cause3);
      }
    }
  },
  onSuccess: (a2) => as(onSuccess(a2), a2)
}));
var tapDefect = /* @__PURE__ */ dual(2, (self2, f2) => catchAllCause(self2, (cause3) => match2(keepDefects(cause3), {
  onNone: () => failCause(cause3),
  onSome: (a2) => zipRight(f2(a2), failCause(cause3))
})));
var tapError = /* @__PURE__ */ dual(2, (self2, f2) => matchCauseEffect(self2, {
  onFailure: (cause3) => {
    const either7 = failureOrCause(cause3);
    switch (either7._tag) {
      case "Left":
        return zipRight(f2(either7.left), failCause(cause3));
      case "Right":
        return failCause(cause3);
    }
  },
  onSuccess: succeed
}));
var tapErrorTag = /* @__PURE__ */ dual(3, (self2, k, f2) => tapError(self2, (e) => {
  if (isTagged(e, k)) {
    return f2(e);
  }
  return void_;
}));
var tapErrorCause = /* @__PURE__ */ dual(2, (self2, f2) => matchCauseEffect(self2, {
  onFailure: (cause3) => zipRight(f2(cause3), failCause(cause3)),
  onSuccess: succeed
}));
var timed = (self2) => timedWith(self2, currentTimeNanos2);
var timedWith = /* @__PURE__ */ dual(2, (self2, nanos2) => summarized(self2, nanos2, (start3, end6) => nanos(end6 - start3)));
var tracerWith3 = tracerWith2;
var tracer = /* @__PURE__ */ tracerWith3(succeed);
var tryPromise = (arg) => {
  let evaluate3;
  let catcher = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    catcher = arg.catch;
  }
  const fail19 = (e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
  if (evaluate3.length >= 1) {
    return async_((resolve9, signal) => {
      try {
        evaluate3(signal).then((a2) => resolve9(exitSucceed(a2)), (e) => resolve9(fail19(e)));
      } catch (e) {
        resolve9(fail19(e));
      }
    });
  }
  return async_((resolve9) => {
    try {
      evaluate3().then((a2) => resolve9(exitSucceed(a2)), (e) => resolve9(fail19(e)));
    } catch (e) {
      resolve9(fail19(e));
    }
  });
};
var tryMap = /* @__PURE__ */ dual(2, (self2, options) => flatMap8(self2, (a2) => try_2({
  try: () => options.try(a2),
  catch: options.catch
})));
var tryMapPromise = /* @__PURE__ */ dual(2, (self2, options) => flatMap8(self2, (a2) => tryPromise({
  try: options.try.length >= 1 ? (signal) => options.try(a2, signal) : () => options.try(a2),
  catch: options.catch
})));
var unless = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? succeedNone : asSome(self2)));
var unlessEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap8(condition, (b) => b ? succeedNone : asSome(self2)));
var unsandbox = (self2) => mapErrorCause(self2, flatten3);
var updateFiberRefs = (f2) => withFiberRuntime((state) => {
  state.setFiberRefs(f2(state.id(), state.getFiberRefs()));
  return void_;
});
var updateService = /* @__PURE__ */ dual(3, (self2, tag, f2) => mapInputContext(self2, (context8) => add2(context8, tag, f2(unsafeGet4(context8, tag)))));
var when = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? map9(self2, some2) : succeed(none2())));
var whenFiberRef = /* @__PURE__ */ dual(3, (self2, fiberRef, predicate) => flatMap8(fiberRefGet(fiberRef), (s2) => predicate(s2) ? map9(self2, (a2) => [s2, some2(a2)]) : succeed([s2, none2()])));
var whenRef = /* @__PURE__ */ dual(3, (self2, ref, predicate) => flatMap8(get11(ref), (s2) => predicate(s2) ? map9(self2, (a2) => [s2, some2(a2)]) : succeed([s2, none2()])));
var withMetric = /* @__PURE__ */ dual(2, (self2, metric) => metric(self2));
var serviceFunctionEffect = (getService, f2) => (...args2) => flatMap8(getService, (a2) => f2(a2)(...args2));
var serviceFunction = (getService, f2) => (...args2) => map9(getService, (a2) => f2(a2)(...args2));
var serviceFunctions = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return (...args2) => flatMap8(getService, (s2) => s2[prop](...args2));
  }
});
var serviceConstants = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return flatMap8(getService, (s2) => isEffect(s2[prop]) ? s2[prop] : succeed(s2[prop]));
  }
});
var serviceMembers = (getService) => ({
  functions: serviceFunctions(getService),
  constants: serviceConstants(getService)
});
var serviceOption = (tag) => map9(context(), getOption2(tag));
var serviceOptional = (tag) => flatMap8(context(), getOption2(tag));
var annotateCurrentSpan = function() {
  const args2 = arguments;
  return ignore(flatMap8(currentSpan, (span4) => sync(() => {
    if (typeof args2[0] === "string") {
      span4.attribute(args2[0], args2[1]);
    } else {
      for (const key in args2[0]) {
        span4.attribute(key, args2[0][key]);
      }
    }
  })));
};
var linkSpanCurrent = function() {
  const args2 = arguments;
  const links = Array.isArray(args2[0]) ? args2[0] : [{
    _tag: "SpanLink",
    span: args2[0],
    attributes: args2[1] ?? {}
  }];
  return ignore(flatMap8(currentSpan, (span4) => sync(() => span4.addLinks(links))));
};
var annotateSpans = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations) => Object.entries(args2[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations));
});
var currentParentSpan = /* @__PURE__ */ serviceOptional(spanTag);
var currentSpan = /* @__PURE__ */ flatMap8(/* @__PURE__ */ context(), (context8) => {
  const span4 = context8.unsafeMap.get(spanTag.key);
  return span4 !== void 0 && span4._tag === "Span" ? succeed(span4) : fail2(new NoSuchElementException());
});
var linkSpans = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, span4, attributes) => fiberRefLocallyWith(self2, currentTracerSpanLinks, append2({
  _tag: "SpanLink",
  span: span4,
  attributes: attributes ?? {}
})));
var bigint02 = /* @__PURE__ */ BigInt(0);
var filterDisablePropagation = /* @__PURE__ */ flatMap((span4) => get4(span4.context, DisablePropagation) ? span4._tag === "Span" ? filterDisablePropagation(span4.parent) : none2() : some2(span4));
var unsafeMakeSpan = (fiber, name, options) => {
  const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options.context && get4(options.context, DisablePropagation);
  const context8 = fiber.getFiberRef(currentContext);
  const parent = options.parent ? some2(options.parent) : options.root ? none2() : filterDisablePropagation(getOption2(context8, spanTag));
  let span4;
  if (disablePropagation) {
    span4 = noopSpan({
      name,
      parent,
      context: add2(options.context ?? empty4(), DisablePropagation, true)
    });
  } else {
    const services = fiber.getFiberRef(currentServices);
    const tracer3 = get4(services, tracerTag);
    const clock3 = get4(services, Clock);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const fiberRefs3 = fiber.getFiberRefs();
    const annotationsFromEnv = get9(fiberRefs3, currentTracerSpanAnnotations);
    const linksFromEnv = get9(fiberRefs3, currentTracerSpanLinks);
    const links = linksFromEnv._tag === "Some" ? options.links !== void 0 ? [...toReadonlyArray(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray(linksFromEnv.value) : options.links ?? empty();
    span4 = tracer3.span(name, parent, options.context ?? empty4(), links, timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint02, options.kind ?? "internal");
    if (annotationsFromEnv._tag === "Some") {
      forEach4(annotationsFromEnv.value, (value, key) => span4.attribute(key, value));
    }
    if (options.attributes !== void 0) {
      Object.entries(options.attributes).forEach(([k, v2]) => span4.attribute(k, v2));
    }
  }
  if (typeof options.captureStackTrace === "function") {
    spanToTrace.set(span4, options.captureStackTrace);
  }
  return span4;
};
var makeSpan = (name, options) => {
  options = addSpanStackTrace(options);
  return withFiberRuntime((fiber) => succeed(unsafeMakeSpan(fiber, name, options)));
};
var spanAnnotations = /* @__PURE__ */ fiberRefGet(currentTracerSpanAnnotations);
var spanLinks = /* @__PURE__ */ fiberRefGet(currentTracerSpanLinks);
var endSpan = (span4, exit4, clock3, timingEnabled) => sync(() => {
  if (span4.status._tag === "Ended") {
    return;
  }
  if (exitIsFailure(exit4) && spanToTrace.has(span4)) {
    span4.attribute("code.stacktrace", spanToTrace.get(span4)());
  }
  span4.end(timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint02, exit4);
});
var useSpan = (name, ...args2) => {
  const options = addSpanStackTrace(args2.length === 1 ? void 0 : args2[0]);
  const evaluate3 = args2[args2.length - 1];
  return withFiberRuntime((fiber) => {
    const span4 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock3 = get4(fiber.getFiberRef(currentServices), clockTag);
    return onExit(evaluate3(span4), (exit4) => endSpan(span4, exit4, clock3, timingEnabled));
  });
};
var withParentSpan = /* @__PURE__ */ dual(2, (self2, span4) => provideService(self2, spanTag, span4));
var withSpan = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return useSpan(name, options, (span4) => withParentSpan(self2, span4));
  }
  return (self2) => useSpan(name, options, (span4) => withParentSpan(self2, span4));
};
var functionWithSpan = (options) => function() {
  let captureStackTrace = options.captureStackTrace ?? false;
  if (options.captureStackTrace !== false) {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error4 = new Error();
    Error.stackTraceLimit = limit;
    let cache3 = false;
    captureStackTrace = () => {
      if (cache3 !== false) {
        return cache3;
      }
      if (error4.stack) {
        const stack = error4.stack.trim().split("\n");
        cache3 = stack.slice(2).join("\n").trim();
        return cache3;
      }
    };
  }
  return suspend(() => {
    const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
    return withSpan(suspend(() => internalCall(() => options.body.apply(this, arguments))), opts.name, {
      ...opts,
      captureStackTrace
    });
  });
};
var fromNullable2 = (value) => value == null ? fail2(new NoSuchElementException()) : succeed(value);
var optionFromOptional = (self2) => catchAll(map9(self2, some2), (error4) => isNoSuchElementException(error4) ? succeedNone : fail2(error4));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Exit.js
var isExit = exitIsExit;
var isFailure2 = exitIsFailure;
var isSuccess2 = exitIsSuccess;
var all2 = exitCollectAll;
var die3 = exitDie;
var fail4 = exitFail;
var failCause4 = exitFailCause;
var flatten6 = exitFlatten;
var interrupt4 = exitInterrupt;
var map11 = exitMap;
var mapBoth2 = exitMapBoth;
var match9 = exitMatch;
var succeed4 = exitSucceed;
var void_3 = exitVoid;
var zip3 = exitZip;
var zipRight2 = exitZipRight;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL = "InterruptSignal";
var OP_STATEFUL = "Stateful";
var OP_RESUME = "Resume";
var OP_YIELD_NOW = "YieldNow";
var interruptSignal = (cause3) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause: cause3
});
var stateful = (onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
});
var resume = (effect4) => ({
  _tag: OP_RESUME,
  effect: effect4
});
var yieldNow3 = () => ({
  _tag: OP_YIELD_NOW
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope";
var FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);
var Global = class {
  [FiberScopeTypeId] = FiberScopeTypeId;
  fiberId = none4;
  roots = /* @__PURE__ */ new Set();
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
};
var Local = class {
  fiberId;
  parent;
  [FiberScopeTypeId] = FiberScopeTypeId;
  constructor(fiberId3, parent) {
    this.fiberId = fiberId3;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
};
var unsafeMake6 = (fiber) => {
  return new Local(fiber.id(), fiber);
};
var globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global());

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber";
var FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
var fiberVariance2 = {
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _A: (_2) => _2
};
var RuntimeFiberSymbolKey = "effect/Fiber";
var RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
var _await2 = (self2) => self2.await;
var inheritAll = (self2) => self2.inheritAll;
var interruptAsFork = /* @__PURE__ */ dual(2, (self2, fiberId3) => self2.interruptAsFork(fiberId3));
var join2 = (self2) => zipLeft(flatten5(self2.await), self2.inheritAll);
var poll2 = (self2) => self2.poll;
var currentFiberURI = "effect/FiberCurrent";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey = "effect/Logger";
var LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
var loggerVariance = {
  /* c8 ignore next */
  _Message: (_2) => _2,
  /* c8 ignore next */
  _Output: (_2) => _2
};
var makeLogger = (log5) => ({
  [LoggerTypeId]: loggerVariance,
  log: log5,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var textOnly = /^[^\s"=]*$/;
var format3 = (quoteValue, whitespace) => ({
  annotations,
  cause: cause3,
  date: date3,
  fiberId: fiberId3,
  logLevel: logLevel3,
  message,
  spans
}) => {
  const formatValue = (value) => value.match(textOnly) ? value : quoteValue(value);
  const format5 = (label, value) => `${formatLabel(label)}=${formatValue(value)}`;
  const append6 = (label, value) => " " + format5(label, value);
  let out = format5("timestamp", date3.toISOString());
  out += append6("level", logLevel3.label);
  out += append6("fiber", threadName(fiberId3));
  const messages = ensure(message);
  for (let i = 0; i < messages.length; i++) {
    out += append6("message", toStringUnknown(messages[i], whitespace));
  }
  if (!isEmptyType(cause3)) {
    out += append6("cause", pretty(cause3, {
      renderErrorCause: true
    }));
  }
  for (const span4 of spans) {
    out += " " + render(date3.getTime())(span4);
  }
  for (const [label, value] of annotations) {
    out += append6(label, toStringUnknown(value, whitespace));
  }
  return out;
};
var escapeDoubleQuotes = (s2) => `"${s2.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
var stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format3(escapeDoubleQuotes));
var structuredMessage = (u2) => {
  switch (typeof u2) {
    case "bigint":
    case "function":
    case "symbol": {
      return String(u2);
    }
    default: {
      return toJSON(u2);
    }
  }
};
var withColor = (text, ...colors2) => {
  let out = "";
  for (let i = 0; i < colors2.length; i++) {
    out += `\x1B[${colors2[i]}m`;
  }
  return out + text + "\x1B[0m";
};
var withColorNoop = (text, ..._colors) => text;
var colors = {
  bold: "1",
  red: "31",
  green: "32",
  yellow: "33",
  blue: "34",
  cyan: "36",
  white: "37",
  gray: "90",
  black: "30",
  bgBrightRed: "101"
};
var logLevelColors = {
  None: [],
  All: [],
  Trace: [colors.gray],
  Debug: [colors.blue],
  Info: [colors.green],
  Warning: [colors.yellow],
  Error: [colors.red],
  Fatal: [colors.bgBrightRed, colors.black]
};
var logLevelStyle = {
  None: "",
  All: "",
  Trace: "color:gray",
  Debug: "color:blue",
  Info: "color:green",
  Warning: "color:orange",
  Error: "color:red",
  Fatal: "background-color:red;color:white"
};
var defaultDateFormat = (date3) => `${date3.getHours().toString().padStart(2, "0")}:${date3.getMinutes().toString().padStart(2, "0")}:${date3.getSeconds().toString().padStart(2, "0")}.${date3.getMilliseconds().toString().padStart(3, "0")}`;
var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;
var prettyLogger = (options) => {
  const mode = hasProcessStdoutOrDeno ? "tty" : "browser" ;
  const isBrowser = mode === "browser";
  const showColors = processStdoutIsTTY || isBrowser;
  const formatDate = defaultDateFormat;
  return isBrowser ? prettyLoggerBrowser({
    colors: showColors,
    formatDate
  }) : prettyLoggerTty({
    colors: showColors,
    formatDate,
    stderr: options?.stderr === true
  });
};
var prettyLoggerTty = (options) => {
  const processIsBun = typeof process === "object" && "isBun" in process && process.isBun === true;
  const color = options.colors ? withColor : withColorNoop;
  return makeLogger(({
    annotations,
    cause: cause3,
    context: context8,
    date: date3,
    fiberId: fiberId3,
    logLevel: logLevel3,
    message: message_,
    spans
  }) => {
    const services = getOrDefault2(context8, currentServices);
    const console4 = get4(services, consoleTag).unsafe;
    const log5 = options.stderr === true ? console4.error : console4.log;
    const message = ensure(message_);
    let firstLine = color(`[${options.formatDate(date3)}]`, colors.white) + ` ${color(logLevel3.label, ...logLevelColors[logLevel3._tag])} (${threadName(fiberId3)})`;
    if (isCons(spans)) {
      const now = date3.getTime();
      const render2 = render(now);
      for (const span4 of spans) {
        firstLine += " " + render2(span4);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += " " + color(firstMaybeString, colors.bold, colors.cyan);
        messageIndex++;
      }
    }
    log5(firstLine);
    if (!processIsBun) console4.group();
    if (!isEmpty3(cause3)) {
      log5(pretty(cause3, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (; messageIndex < message.length; messageIndex++) {
        log5(redact(message[messageIndex]));
      }
    }
    if (size4(annotations) > 0) {
      for (const [key, value] of annotations) {
        log5(color(`${key}:`, colors.bold, colors.white), redact(value));
      }
    }
    if (!processIsBun) console4.groupEnd();
  });
};
var prettyLoggerBrowser = (options) => {
  const color = options.colors ? "%c" : "";
  return makeLogger(({
    annotations,
    cause: cause3,
    context: context8,
    date: date3,
    fiberId: fiberId3,
    logLevel: logLevel3,
    message: message_,
    spans
  }) => {
    const services = getOrDefault2(context8, currentServices);
    const console4 = get4(services, consoleTag).unsafe;
    const message = ensure(message_);
    let firstLine = `${color}[${options.formatDate(date3)}]`;
    const firstParams = [];
    if (options.colors) {
      firstParams.push("color:gray");
    }
    firstLine += ` ${color}${logLevel3.label}${color} (${threadName(fiberId3)})`;
    if (options.colors) {
      firstParams.push(logLevelStyle[logLevel3._tag], "");
    }
    if (isCons(spans)) {
      const now = date3.getTime();
      const render2 = render(now);
      for (const span4 of spans) {
        firstLine += " " + render2(span4);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += ` ${color}${firstMaybeString}`;
        if (options.colors) {
          firstParams.push("color:deepskyblue");
        }
        messageIndex++;
      }
    }
    console4.groupCollapsed(firstLine, ...firstParams);
    if (!isEmpty3(cause3)) {
      console4.error(pretty(cause3, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (; messageIndex < message.length; messageIndex++) {
        console4.log(redact(message[messageIndex]));
      }
    }
    if (size4(annotations) > 0) {
      for (const [key, value] of annotations) {
        const redacted3 = redact(value);
        if (options.colors) {
          console4.log(`%c${key}:`, "color:gray", redacted3);
        } else {
          console4.log(`${key}:`, redacted3);
        }
      }
    }
    console4.groupEnd();
  });
};
var prettyLoggerDefault = /* @__PURE__ */ globalValue("effect/Logger/prettyLoggerDefault", () => prettyLogger());

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
var MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);
var MetricBoundariesImpl = class {
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId;
  constructor(values3) {
    this.values = values3;
    this._hash = pipe(string(MetricBoundariesSymbolKey), combine(array2(this.values)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u2) {
    return isMetricBoundaries(u2) && equals(this.values, u2.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricBoundaries = (u2) => hasProperty(u2, MetricBoundariesTypeId);
var fromIterable7 = (iterable) => {
  const values3 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values3);
};
var exponential = (options) => pipe(makeBy(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable7);

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
var MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
var metricKeyTypeVariance = {
  /* c8 ignore next */
  _In: (_2) => _2,
  /* c8 ignore next */
  _Out: (_2) => _2
};
var CounterKeyType = class {
  incremental;
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
  constructor(incremental, bigint) {
    this.incremental = incremental;
    this.bigint = bigint;
    this._hash = string(CounterKeyTypeSymbolKey);
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var HistogramKeyType = class {
  boundaries;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter = (options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
var histogram = (boundaries) => {
  return new HistogramKeyType(boundaries);
};
var isCounterKey = (u2) => hasProperty(u2, CounterKeyTypeTypeId);
var isFrequencyKey = (u2) => hasProperty(u2, FrequencyKeyTypeTypeId);
var isGaugeKey = (u2) => hasProperty(u2, GaugeKeyTypeTypeId);
var isHistogramKey = (u2) => hasProperty(u2, HistogramKeyTypeTypeId);
var isSummaryKey = (u2) => hasProperty(u2, SummaryKeyTypeTypeId);

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey";
var MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
var metricKeyVariance = {
  /* c8 ignore next */
  _Type: (_2) => _2
};
var arrayEquivilence = /* @__PURE__ */ getEquivalence(equals);
var MetricKeyImpl = class {
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId] = metricKeyVariance;
  constructor(name, keyType, description, tags = []) {
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags;
    this._hash = pipe(string(this.name + this.description), combine(hash(this.keyType)), combine(array2(this.tags)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u2) {
    return isMetricKey(u2) && this.name === u2.name && equals(this.keyType, u2.keyType) && equals(this.description, u2.description) && arrayEquivilence(this.tags, u2.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricKey = (u2) => hasProperty(u2, MetricKeyTypeId);
var counter2 = (name, options) => new MetricKeyImpl(name, counter(options), fromNullable(options?.description));
var histogram2 = (name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable(description));
var taggedWithLabels = /* @__PURE__ */ dual(2, (self2, extraTags) => extraTags.length === 0 ? self2 : new MetricKeyImpl(self2.name, self2.keyType, self2.description, union(self2.tags, extraTags)));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/MutableHashMap.js
var TypeId11 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
  [TypeId11]: TypeId11,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MutableHashMapIterator = class _MutableHashMapIterator {
  self;
  referentialIterator;
  bucketIterator;
  constructor(self2) {
    this.self = self2;
    this.referentialIterator = self2.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== void 0) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new _MutableHashMapIterator(this.self);
  }
};
var BucketIterator = class {
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === void 0) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = void 0;
      return this.next();
    }
    return result;
  }
};
var empty21 = () => {
  const self2 = Object.create(MutableHashMapProto);
  self2.referential = /* @__PURE__ */ new Map();
  self2.buckets = /* @__PURE__ */ new Map();
  self2.bucketsSize = 0;
  return self2;
};
var get12 = /* @__PURE__ */ dual(2, (self2, key) => {
  if (isEqual(key) === false) {
    return self2.referential.has(key) ? some2(self2.referential.get(key)) : none2();
  }
  const hash2 = key[symbol]();
  const bucket = self2.buckets.get(hash2);
  if (bucket === void 0) {
    return none2();
  }
  return getFromBucket(self2, bucket, key);
});
var getFromBucket = (self2, bucket, key, remove11 = false) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      const value = bucket[i][1];
      if (remove11) {
        bucket.splice(i, 1);
        self2.bucketsSize--;
      }
      return some2(value);
    }
  }
  return none2();
};
var has4 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(get12(self2, key)));
var set6 = /* @__PURE__ */ dual(3, (self2, key, value) => {
  if (isEqual(key) === false) {
    self2.referential.set(key, value);
    return self2;
  }
  const hash2 = key[symbol]();
  const bucket = self2.buckets.get(hash2);
  if (bucket === void 0) {
    self2.buckets.set(hash2, [[key, value]]);
    self2.bucketsSize++;
    return self2;
  }
  removeFromBucket(self2, bucket, key);
  bucket.push([key, value]);
  self2.bucketsSize++;
  return self2;
});
var removeFromBucket = (self2, bucket, key) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      bucket.splice(i, 1);
      self2.bucketsSize--;
      return;
    }
  }
};
var remove5 = /* @__PURE__ */ dual(2, (self2, key) => {
  if (isEqual(key) === false) {
    self2.referential.delete(key);
    return self2;
  }
  const hash2 = key[symbol]();
  const bucket = self2.buckets.get(hash2);
  if (bucket === void 0) {
    return self2;
  }
  removeFromBucket(self2, bucket, key);
  if (bucket.length === 0) {
    self2.buckets.delete(hash2);
  }
  return self2;
});
var size5 = (self2) => {
  return self2.referential.size + self2.bucketsSize;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey = "effect/MetricState";
var MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
var CounterStateSymbolKey = "effect/MetricState/Counter";
var CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
var FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
var GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
var HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
var SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var CounterState = class {
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId;
  constructor(count5) {
    this.count = count5;
  }
  [symbol]() {
    return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
  }
  [symbol2](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var arrayEquals = /* @__PURE__ */ getEquivalence(equals);
var FrequencyState = class {
  occurrences;
  [MetricStateTypeId] = metricStateVariance;
  [FrequencyStateTypeId] = FrequencyStateTypeId;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [symbol]() {
    return pipe(string(FrequencyStateSymbolKey), combine(array2(fromIterable(this.occurrences.entries()))), cached(this));
  }
  [symbol2](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable(this.occurrences.entries()), fromIterable(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GaugeState = class {
  value;
  [MetricStateTypeId] = metricStateVariance;
  [GaugeStateTypeId] = GaugeStateTypeId;
  constructor(value) {
    this.value = value;
  }
  [symbol]() {
    return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
  }
  [symbol2](u2) {
    return isGaugeState(u2) && this.value === u2.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var HistogramState = class {
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [HistogramStateTypeId] = HistogramStateTypeId;
  constructor(buckets, count5, min3, max5, sum3) {
    this.buckets = buckets;
    this.count = count5;
    this.min = min3;
    this.max = max5;
    this.sum = sum3;
  }
  [symbol]() {
    return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var SummaryState = class {
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [SummaryStateTypeId] = SummaryStateTypeId;
  constructor(error4, quantiles, count5, min3, max5, sum3) {
    this.error = error4;
    this.quantiles = quantiles;
    this.count = count5;
    this.min = min3;
    this.max = max5;
    this.sum = sum3;
  }
  [symbol]() {
    return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter3 = (count5) => new CounterState(count5);
var frequency2 = (occurrences) => {
  return new FrequencyState(occurrences);
};
var gauge2 = (count5) => new GaugeState(count5);
var histogram3 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
var summary2 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
var isCounterState = (u2) => hasProperty(u2, CounterStateTypeId);
var isFrequencyState = (u2) => hasProperty(u2, FrequencyStateTypeId);
var isGaugeState = (u2) => hasProperty(u2, GaugeStateTypeId);
var isHistogramState = (u2) => hasProperty(u2, HistogramStateTypeId);
var isSummaryState = (u2) => hasProperty(u2, SummaryStateTypeId);

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook";
var MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
var metricHookVariance = {
  /* c8 ignore next */
  _In: (_2) => _2,
  /* c8 ignore next */
  _Out: (_2) => _2
};
var make29 = (options) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var bigint03 = /* @__PURE__ */ BigInt(0);
var counter4 = (key) => {
  let sum3 = key.keyType.bigint ? bigint03 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value) => value >= bigint03 : (value) => value >= 0 : (_value) => true;
  const update5 = (value) => {
    if (canUpdate(value)) {
      sum3 = sum3 + value;
    }
  };
  return make29({
    get: () => counter3(sum3),
    update: update5,
    modify: update5
  });
};
var frequency3 = (key) => {
  const values3 = /* @__PURE__ */ new Map();
  for (const word of key.keyType.preregisteredWords) {
    values3.set(word, 0);
  }
  const update5 = (word) => {
    const slotCount = values3.get(word) ?? 0;
    values3.set(word, slotCount + 1);
  };
  return make29({
    get: () => frequency2(values3),
    update: update5,
    modify: update5
  });
};
var gauge3 = (_key, startAt) => {
  let value = startAt;
  return make29({
    get: () => gauge2(value),
    update: (v2) => {
      value = v2;
    },
    modify: (v2) => {
      value = value + v2;
    }
  });
};
var histogram4 = (key) => {
  const bounds = key.keyType.boundaries.values;
  const size16 = bounds.length;
  const values3 = new Uint32Array(size16 + 1);
  const boundaries = new Float32Array(size16);
  let count5 = 0;
  let sum3 = 0;
  let min3 = Number.MAX_VALUE;
  let max5 = Number.MIN_VALUE;
  pipe(bounds, sort(Order), map2((n2, i) => {
    boundaries[i] = n2;
  }));
  const update5 = (value) => {
    let from = 0;
    let to = size16;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values3[from] = values3[from] + 1;
    count5 = count5 + 1;
    sum3 = sum3 + value;
    if (value < min3) {
      min3 = value;
    }
    if (value > max5) {
      max5 = value;
    }
  };
  const getBuckets = () => {
    const builder = allocate(size16);
    let cumulated = 0;
    for (let i = 0; i < size16; i++) {
      const boundary = boundaries[i];
      const value = values3[i];
      cumulated = cumulated + value;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  };
  return make29({
    get: () => histogram3({
      buckets: getBuckets(),
      count: count5,
      min: min3,
      max: max5,
      sum: sum3
    }),
    update: update5,
    modify: update5
  });
};
var summary3 = (key) => {
  const {
    error: error4,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order));
  const values3 = allocate(maxSize);
  let head6 = 0;
  let count5 = 0;
  let sum3 = 0;
  let min3 = Number.MAX_VALUE;
  let max5 = Number.MIN_VALUE;
  const snapshot = (now) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values3[i];
      if (item != null) {
        const [t, v2] = item;
        const age = millis(now - t);
        if (greaterThanOrEqualTo(age, zero) && age <= maxAge) {
          builder.push(v2);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error4, sortedQuantiles, sort(builder, Order));
  };
  const observe = (value, timestamp) => {
    if (maxSize > 0) {
      head6 = head6 + 1;
      const target = head6 % maxSize;
      values3[target] = [timestamp, value];
    }
    count5 = count5 + 1;
    sum3 = sum3 + value;
    if (value < min3) {
      min3 = value;
    }
    if (value > max5) {
      max5 = value;
    }
  };
  return make29({
    get: () => summary2({
      error: error4,
      quantiles: snapshot(Date.now()),
      count: count5,
      min: min3,
      max: max5,
      sum: sum3
    }),
    update: ([value, timestamp]) => observe(value, timestamp),
    modify: ([value, timestamp]) => observe(value, timestamp)
  });
};
var calculateQuantiles = (error4, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty();
  }
  const head6 = sortedQuantiles[0];
  const tail = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error4, sampleCount, none2(), 0, head6, sortedSamples);
  const resolved = of(resolvedHead);
  tail.forEach((quantile) => {
    resolved.push(resolveQuantile(error4, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map2(resolved, (rq) => [rq.quantile, rq.value]);
};
var resolveQuantile = (error4, sampleCount, current2, consumed, quantile, rest) => {
  let error_1 = error4;
  let sampleCount_1 = sampleCount;
  let current_1 = current2;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error4;
  let sampleCount_2 = sampleCount;
  let current_2 = current2;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (1) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some2(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const sameHead = span(rest_1, (n2) => n2 <= rest_1[0]);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      return {
        quantile: quantile_1,
        value: current_1,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some2(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey = "effect/MetricPair";
var MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
var metricPairVariance = {
  /* c8 ignore next */
  _Type: (_2) => _2
};
var unsafeMake7 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry";
var MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);
var MetricRegistryImpl = class {
  [MetricRegistryTypeId] = MetricRegistryTypeId;
  map = /* @__PURE__ */ empty21();
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake7(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get12(key), getOrUndefined);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value = pipe(this.map, get12(key), getOrUndefined);
    if (value == null) {
      const counter6 = counter4(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set6(key, counter6));
      }
      value = counter6;
    }
    return value;
  }
  getFrequency(key) {
    let value = pipe(this.map, get12(key), getOrUndefined);
    if (value == null) {
      const frequency5 = frequency3(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set6(key, frequency5));
      }
      value = frequency5;
    }
    return value;
  }
  getGauge(key) {
    let value = pipe(this.map, get12(key), getOrUndefined);
    if (value == null) {
      const gauge5 = gauge3(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set6(key, gauge5));
      }
      value = gauge5;
    }
    return value;
  }
  getHistogram(key) {
    let value = pipe(this.map, get12(key), getOrUndefined);
    if (value == null) {
      const histogram6 = histogram4(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set6(key, histogram6));
      }
      value = histogram6;
    }
    return value;
  }
  getSummary(key) {
    let value = pipe(this.map, get12(key), getOrUndefined);
    if (value == null) {
      const summary5 = summary3(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set6(key, summary5));
      }
      value = summary5;
    }
    return value;
  }
};
var make30 = () => {
  return new MetricRegistryImpl();
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric";
var MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
var metricVariance = {
  /* c8 ignore next */
  _Type: (_2) => _2,
  /* c8 ignore next */
  _In: (_2) => _2,
  /* c8 ignore next */
  _Out: (_2) => _2
};
var globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make30());
var make31 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect4) => tap(effect4, (a2) => update4(metric, a2)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
};
var counter5 = (name, options) => fromMetricKey(counter2(name, options));
var fromMetricKey = (key) => {
  let untaggedHook;
  const hookCache = /* @__PURE__ */ new WeakMap();
  const hook = (extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== void 0) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== void 0) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  };
  return make31(key.keyType, (input2, extraTags) => hook(extraTags).update(input2), (extraTags) => hook(extraTags).get(), (input2, extraTags) => hook(extraTags).modify(input2));
};
var histogram5 = (name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description));
var tagged = /* @__PURE__ */ dual(3, (self2, key, value) => taggedWithLabels2(self2, [make28(key, value)]));
var taggedWithLabels2 = /* @__PURE__ */ dual(2, (self2, extraTags) => {
  return make31(self2.keyType, (input2, extraTags1) => self2.unsafeUpdate(input2, union(extraTags, extraTags1)), (extraTags1) => self2.unsafeValue(union(extraTags, extraTags1)), (input2, extraTags1) => self2.unsafeModify(input2, union(extraTags, extraTags1)));
});
var update4 = /* @__PURE__ */ dual(2, (self2, input2) => fiberRefGetWith(currentMetricLabels, (tags) => sync(() => self2.unsafeUpdate(input2, tags))));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/request.js
var RequestSymbolKey = "effect/Request";
var RequestTypeId = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
var isRequest = (u2) => hasProperty(u2, RequestTypeId);
var complete = /* @__PURE__ */ dual(2, (self2, result) => fiberRefGetWith(currentRequestMap, (map26) => sync(() => {
  if (map26.has(self2)) {
    const entry = map26.get(self2);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));
var Listeners = class {
  count = 0;
  observers = /* @__PURE__ */ new Set();
  interrupted = false;
  addObserver(f2) {
    this.observers.add(f2);
  }
  removeObserver(f2) {
    this.observers.delete(f2);
  }
  increment() {
    this.count++;
    this.observers.forEach((f2) => f2(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach((f2) => f2(this.count));
  }
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor";
var SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
var supervisorVariance = {
  /* c8 ignore next */
  _T: (_2) => _2
};
var ProxySupervisor = class _ProxySupervisor {
  underlying;
  value0;
  [SupervisorTypeId] = supervisorVariance;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context8, effect4, parent, fiber) {
    this.underlying.onStart(context8, effect4, parent, fiber);
  }
  onEnd(value, fiber) {
    this.underlying.onEnd(value, fiber);
  }
  onEffect(fiber, effect4) {
    this.underlying.onEffect(fiber, effect4);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f2) {
    return new _ProxySupervisor(this, pipe(this.value, map9(f2)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
};
var Zip = class _Zip {
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId] = supervisorVariance;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  get value() {
    return zip2(this.left.value, this.right.value);
  }
  onStart(context8, effect4, parent, fiber) {
    this.left.onStart(context8, effect4, parent, fiber);
    this.right.onStart(context8, effect4, parent, fiber);
  }
  onEnd(value, fiber) {
    this.left.onEnd(value, fiber);
    this.right.onEnd(value, fiber);
  }
  onEffect(fiber, effect4) {
    this.left.onEffect(fiber, effect4);
    this.right.onEffect(fiber, effect4);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f2) {
    return new ProxySupervisor(this, pipe(this.value, map9(f2)));
  }
  zip(right3) {
    return new _Zip(this, right3);
  }
};
var isZip = (self2) => hasProperty(self2, SupervisorTypeId) && isTagged(self2, "Zip");
var Track = class {
  [SupervisorTypeId] = supervisorVariance;
  fibers = /* @__PURE__ */ new Set();
  get value() {
    return sync(() => Array.from(this.fibers));
  }
  onStart(_context, _effect, _parent, fiber) {
    this.fibers.add(fiber);
  }
  onEnd(_value, fiber) {
    this.fibers.delete(fiber);
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f2) {
    return new ProxySupervisor(this, pipe(this.value, map9(f2)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var Const = class {
  effect;
  [SupervisorTypeId] = supervisorVariance;
  constructor(effect4) {
    this.effect = effect4;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {
  }
  onEnd(_value, _fiber) {
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f2) {
    return new ProxySupervisor(this, pipe(this.value, map9(f2)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var unsafeTrack = () => {
  return new Track();
};
var track = /* @__PURE__ */ sync(unsafeTrack);
var fromEffect = (effect4) => {
  return new Const(effect4);
};
var none8 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect(void_));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Differ.js
var make33 = make15;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty";
var OP_ADD_SUPERVISOR = "AddSupervisor";
var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
var OP_AND_THEN2 = "AndThen";
var empty24 = {
  _tag: OP_EMPTY3
};
var combine8 = (self2, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self2,
    second: that
  };
};
var patch8 = (self2, supervisor) => {
  return patchLoop(supervisor, of2(self2));
};
var patchLoop = (_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty(patches)) {
    const head6 = headNonEmpty2(patches);
    switch (head6._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head6.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head6.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend2(head6.first)(prepend2(head6.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
};
var removeSupervisor = (self2, that) => {
  if (equals(self2, that)) {
    return none8;
  } else {
    if (isZip(self2)) {
      return removeSupervisor(self2.left, that).zip(removeSupervisor(self2.right, that));
    } else {
      return self2;
    }
  }
};
var toSet2 = (self2) => {
  if (equals(self2, none8)) {
    return empty7();
  } else {
    if (isZip(self2)) {
      return pipe(toSet2(self2.left), union3(toSet2(self2.right)));
    } else {
      return make10(self2);
    }
  }
};
var diff7 = (oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty24;
  }
  const oldSupervisors = toSet2(oldValue);
  const newSupervisors = toSet2(newValue);
  const added = pipe(newSupervisors, difference3(oldSupervisors), reduce5(empty24, (patch9, supervisor) => combine8(patch9, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference3(newSupervisors), reduce5(empty24, (patch9, supervisor) => combine8(patch9, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine8(added, removed);
};
var differ2 = /* @__PURE__ */ make33({
  empty: empty24,
  patch: patch8,
  combine: combine8,
  diff: diff7
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted = /* @__PURE__ */ counter5("effect_fiber_started", {
  incremental: true
});
var fiberActive = /* @__PURE__ */ counter5("effect_fiber_active");
var fiberSuccesses = /* @__PURE__ */ counter5("effect_fiber_successes", {
  incremental: true
});
var fiberFailures = /* @__PURE__ */ counter5("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram5("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _A: (_2) => _2
};
var absurd = (_2) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_2)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
var YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess = {
  [OP_ON_SUCCESS]: (_2, cont, value) => {
    return internalCall(() => cont.effect_instruction_i1(value));
  },
  ["OnStep"]: (_2, _cont, value) => {
    return exitSucceed(exitSucceed(value));
  },
  [OP_ON_SUCCESS_AND_FAILURE]: (_2, cont, value) => {
    return internalCall(() => cont.effect_instruction_i2(value));
  },
  [OP_REVERT_FLAGS]: (self2, cont, value) => {
    self2.patchRuntimeFlags(self2.currentRuntimeFlags, cont.patch);
    if (interruptible(self2.currentRuntimeFlags) && self2.isInterrupted()) {
      return exitFailCause(self2.getInterruptedCause());
    } else {
      return exitSucceed(value);
    }
  },
  [OP_WHILE]: (self2, cont, value) => {
    internalCall(() => cont.effect_instruction_i2(value));
    if (internalCall(() => cont.effect_instruction_i0())) {
      self2.pushStack(cont);
      return internalCall(() => cont.effect_instruction_i1());
    } else {
      return void_;
    }
  },
  [OP_ITERATOR]: (self2, cont, value) => {
    const state = internalCall(() => cont.effect_instruction_i0.next(value));
    if (state.done) return exitSucceed(state.value);
    self2.pushStack(cont);
    return yieldWrapGet(state.value);
  }
};
var drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self2, runtimeFlags2, cur, message) => {
    self2.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self2, runtimeFlags2, cur, message) => {
    message.onFiber(self2, running2(runtimeFlags2));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap8(yieldNow(), () => cur);
  }
};
var runBlockedRequests = (self2) => forEachSequentialDiscard(flatten4(self2), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential4]) => {
  const map26 = /* @__PURE__ */ new Map();
  const arr = [];
  for (const block of sequential4) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map26.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map26);
}, false, false));
var _version = /* @__PURE__ */ getCurrentVersion();
var FiberRuntime = class extends Class2 {
  [FiberTypeId] = fiberVariance2;
  [RuntimeFiberTypeId] = runtimeFiberVariance;
  _fiberRefs;
  _fiberId;
  _queue = /* @__PURE__ */ new Array();
  _children = null;
  _observers = /* @__PURE__ */ new Array();
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _isYielding = false;
  currentRuntimeFlags;
  currentOpCount = 0;
  currentSupervisor;
  currentScheduler;
  currentTracer;
  currentSpan;
  currentContext;
  currentDefaultServices;
  constructor(fiberId3, fiberRefs0, runtimeFlags0) {
    super();
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId3;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics(runtimeFlags0)) {
      const tags = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags);
      fiberActive.unsafeUpdate(1, tags);
    }
    this.refreshRefCache();
  }
  commit() {
    return join2(this);
  }
  /**
   * The identity of the fiber.
   */
  id() {
    return this._fiberId;
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background. This can be called to "kick off" execution of a fiber after
   * it has been created.
   */
  resume(effect4) {
    this.tell(resume(effect4));
  }
  /**
   * The status of the fiber.
   */
  get status() {
    return this.ask((_2, status2) => status2);
  }
  /**
   * Gets the fiber runtime flags.
   */
  get runtimeFlags() {
    return this.ask((state, status2) => {
      if (isDone3(status2)) {
        return state.currentRuntimeFlags;
      }
      return status2.runtimeFlags;
    });
  }
  /**
   * Returns the current `FiberScope` for the fiber.
   */
  scope() {
    return unsafeMake6(this);
  }
  /**
   * Retrieves the immediate children of the fiber.
   */
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  /**
   * Gets the fiber's set of children.
   */
  getChildren() {
    if (this._children === null) {
      this._children = /* @__PURE__ */ new Set();
    }
    return this._children;
  }
  /**
   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
   * if the fiber has not been interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  /**
   * Retrieves the whole set of fiber refs.
   */
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  /**
   * Returns an effect that will contain information computed from the fiber
   * state and status while running on the fiber.
   *
   * This allows the outside world to interact safely with mutable fiber state
   * without locks or immutable data.
   */
  ask(f2) {
    return suspend(() => {
      const deferred2 = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status2) => {
        deferredUnsafeDone(deferred2, sync(() => f2(fiber, status2)));
      }));
      return deferredAwait(deferred2);
    });
  }
  /**
   * Adds a message to be processed by the fiber on the fiber.
   */
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_((resume2) => {
      const cb = (exit4) => resume2(succeed(exit4));
      this.tell(stateful((fiber, _2) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _2) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch9 = pipe(
        diff4(parentRuntimeFlags, updatedRuntimeFlags),
        // Do not inherit WindDown or Interruption!
        exclude2(Interruption),
        exclude2(WindDown)
      );
      return updateRuntimeFlags(patch9);
    });
  }
  /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */
  get poll() {
    return sync(() => fromNullable(this._exitValue));
  }
  /**
   * Unsafely observes the fiber, but returns immediately if it is not
   * already done.
   */
  unsafePoll() {
    return this._exitValue;
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  interruptAsFork(fiberId3) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId3))));
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  unsafeInterruptAsFork(fiberId3) {
    this.tell(interruptSignal(interrupt(fiberId3)));
  }
  /**
   * Adds an observer to the list of observers.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  /**
   * Removes the specified observer from the list of observers that will be
   * notified when the fiber exits.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeObserver(observer) {
    this._observers = this._observers.filter((o2) => o2 !== observer);
  }
  /**
   * Retrieves all fiber refs of the fiber.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  /**
   * Deletes the specified fiber ref.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  /**
   * Retrieves the state of the fiber ref, or else its initial value.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  /**
   * Sets the fiber ref to the specified value.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRef(fiberRef, value) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(currentScheduler);
    this.currentContext = this.getFiberRef(currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
  }
  /**
   * Wholesale replaces all fiber refs of this fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRefs(fiberRefs3) {
    this._fiberRefs = fiberRefs3;
    this.refreshRefCache();
  }
  /**
   * Adds a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addChild(child) {
    this.getChildren().add(child);
  }
  /**
   * Removes a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeChild(child) {
    this.getChildren().delete(child);
  }
  /**
   * Transfers all children of this fiber that are currently running to the
   * specified fiber scope.
   *
   * **NOTE**: This method must be invoked by the fiber itself after it has
   * evaluated the effects but prior to exiting.
   */
  transferChildren(scope5) {
    const children2 = this._children;
    this._children = null;
    if (children2 !== null && children2.size > 0) {
      for (const child of children2) {
        if (child._exitValue === null) {
          scope5.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  /**
   * On the current thread, executes all messages in the fiber's inbox. This
   * method may return before all work is done, in the event the fiber executes
   * an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueOnCurrentThread() {
    let recurse2 = true;
    while (recurse2) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse2 = false;
        } else {
          recurse2 = true;
        }
      } else {
        recurse2 = false;
      }
    }
  }
  /**
   * Schedules the execution of all messages in the fiber's inbox.
   *
   * This method will return immediately after the scheduling
   * operation is completed, but potentially before such messages have been
   * executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  /**
   * Drains the fiber's message queue while the fiber is actively running,
   * returning the next effect to execute, which may be the input effect if no
   * additional effect needs to be executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueWhileRunning(runtimeFlags2, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
    }
    return cur;
  }
  /**
   * Determines if the fiber is interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  isInterrupted() {
    return !isEmpty3(this.getFiberRef(currentInterruptedCause));
  }
  /**
   * Adds an interruptor to the set of interruptors that are interrupting this
   * fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addInterruptedCause(cause3) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause3));
  }
  /**
   * Processes a new incoming interrupt signal.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  processNewInterruptSignal(cause3) {
    this.addInterruptedCause(cause3);
    this.sendInterruptSignalToAllChildren();
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone7 = false;
      const body = () => {
        const next = it.next();
        if (!next.done) {
          return asVoid(next.value.await);
        } else {
          return sync(() => {
            isDone7 = true;
          });
        }
      };
      return whileLoop({
        while: () => !isDone7,
        body,
        step: () => {
        }
      });
    }
    return null;
  }
  reportExitValue(exit4) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      const tags = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
      fiberActive.unsafeUpdate(-1, tags);
      switch (exit4._tag) {
        case OP_SUCCESS: {
          fiberSuccesses.unsafeUpdate(1, tags);
          break;
        }
        case OP_FAILURE: {
          fiberFailures.unsafeUpdate(1, tags);
          break;
        }
      }
    }
    if (exit4._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit4.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit4.cause, level);
      }
    }
  }
  setExitValue(exit4) {
    this._exitValue = exit4;
    this.reportExitValue(exit4);
    for (let i = this._observers.length - 1; i >= 0; i--) {
      this._observers[i](exit4);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause3, overrideLogLevel) {
    const logLevel3 = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan3(minimumLogLevel, logLevel3)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan);
    const annotations = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size3(loggers) > 0) {
      const clockService = get4(this.getFiberRef(currentServices), clockTag);
      const date3 = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext(contextMap, () => {
        for (const logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel: logLevel3,
            message,
            cause: cause3,
            context: contextMap,
            spans,
            annotations,
            date: date3
          });
        }
      });
    }
  }
  /**
   * Evaluates a single message on the current thread, while the fiber is
   * suspended. This method should only be called while evaluation of the
   * fiber's effect is suspended due to an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW: {
        return EvaluationSignalYieldNow;
      }
      case OP_INTERRUPT_SIGNAL: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue;
      }
      case OP_RESUME: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue;
      }
      case OP_STATEFUL: {
        message.onFiber(this, this._exitValue !== null ? done4 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue;
      }
      default: {
        return absurd(message);
      }
    }
  }
  /**
   * Evaluates an effect until completion, potentially asynchronously.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect4 = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect4 !== null) {
        const eff = effect4;
        const exit4 = this.runLoop(eff);
        if (exit4 === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(yieldNow3());
              this.tell(resume(exitVoid));
              effect4 = null;
            } else {
              effect4 = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            effect4 = null;
          }
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
          const interruption2 = this.interruptAllChildren();
          if (interruption2 !== null) {
            effect4 = flatMap8(interruption2, () => exit4);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit4);
            } else {
              this.tell(resume(exit4));
            }
            effect4 = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on the current
   * thread. This can be called to "kick off" execution of a fiber after it has
   * been created, in hopes that the effect can be executed synchronously.
   *
   * This is not the normal way of starting a fiber, but it is useful when the
   * express goal of executing the fiber is to synchronously produce its exit.
   */
  start(effect4) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect4);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect4));
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background, and on the correct thread pool. This can be called to "kick
   * off" execution of a fiber after it has been created, in hopes that the
   * effect can be executed synchronously.
   */
  startFork(effect4) {
    this.tell(resume(effect4));
  }
  /**
   * Takes the current runtime flags, patches them to return the new runtime
   * flags, and then makes any changes necessary to fiber state based on the
   * specified patch.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  patchRuntimeFlags(oldRuntimeFlags, patch9) {
    const newRuntimeFlags = patch4(oldRuntimeFlags, patch9);
    globalThis[currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  /**
   * Initiates an asynchronous operation, by building a callback that will
   * resume execution, and then feeding that callback to the registration
   * function, handling error cases and repeated resumptions appropriately.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  initiateAsync(runtimeFlags2, asyncRegister) {
    let alreadyCalled = false;
    const callback = (effect4) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect4));
      }
    };
    if (interruptible(runtimeFlags2)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OP_TAG](op) {
    return sync(() => unsafeGet4(this.currentContext, op));
  }
  ["Left"](op) {
    return fail2(op.left);
  }
  ["None"](_2) {
    return fail2(new NoSuchElementException());
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync((microResume) => {
      let resume2 = microResume;
      const fiber = runFork(provideContext2(op, this.currentContext));
      fiber.addObserver((exit4) => {
        if (exit4._tag === "Success") {
          return resume2(exitSucceed(exit4.value));
        }
        switch (exit4.cause._tag) {
          case "Interrupt": {
            return resume2(exitFailCause(interrupt(none4)));
          }
          case "Fail": {
            return resume2(fail2(exit4.cause.error));
          }
          case "Die": {
            return resume2(die2(exit4.cause.defect));
          }
        }
      });
      return unsafeAsync((abortResume) => {
        resume2 = (_2) => {
          abortResume(void_);
        };
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC](op) {
    const value = internalCall(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, value);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause3 = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== void 0) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE: {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return internalCall(() => cont.effect_instruction_i1(cause3));
          } else {
            return exitFailCause(stripFailures(cause3));
          }
        }
        case "OnStep": {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return exitSucceed(exitFailCause(cause3));
          } else {
            return exitFailCause(stripFailures(cause3));
          }
        }
        case OP_REVERT_FLAGS: {
          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
          if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
            return exitFailCause(sequential(cause3, this.getInterruptedCause()));
          } else {
            return exitFailCause(cause3);
          }
        }
        default: {
          absurd(cont);
        }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause3);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff6(snap.refs, refs);
      const patchFlags = diff4(snap.flags, flags);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch7(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch4(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask((restore) => flatMap8(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch4(oldRuntimeFlags, updateFlags);
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff4(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check2 = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check2()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid;
    }
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, void 0);
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit());
  }
  /**
   * The main run-loop for evaluating effects.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap8(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        cur = this.currentTracer.context(() => {
          if (_version !== cur[EffectTypeId2]._V) {
            return dieMessage(`Cannot execute an Effect versioned ${cur[EffectTypeId2]._V} with a Runtime of version ${getCurrentVersion()}`);
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(none4)));
        } else {
          cur = die2(e);
        }
      }
    }
  }
  run = () => {
    this.drainQueueOnCurrentThread();
  };
};
var currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
var loggerWithConsoleLog = (self2) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get4(services, consoleTag).unsafe.log(self2.log(opts));
});
var defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
var tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations,
  cause: cause3,
  context: context8,
  fiberId: fiberId3,
  logLevel: logLevel3,
  message
}) => {
  const span4 = getOption2(getOrDefault(context8, currentContext), spanTag);
  if (span4._tag === "None" || span4.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet4(getOrDefault(context8, currentServices), clockTag);
  const attributes = {};
  for (const [key, value] of annotations) {
    attributes[key] = value;
  }
  attributes["effect.fiberId"] = threadName2(fiberId3);
  attributes["effect.logLevel"] = logLevel3.label;
  if (cause3 !== null && cause3._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause3, {
      renderErrorCause: true
    });
  }
  span4.value.event(toStringUnknown(Array.isArray(message) ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
var currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make10(defaultLogger, tracerLogger)));
var annotateLogsScoped = function() {
  if (typeof arguments[0] === "string") {
    return fiberRefLocallyScopedWith(currentLogAnnotations, set3(arguments[0], arguments[1]));
  }
  const entries2 = Object.entries(arguments[0]);
  return fiberRefLocallyScopedWith(currentLogAnnotations, mutate3((annotations) => {
    for (let i = 0; i < entries2.length; i++) {
      const [key, value] = entries2[i];
      set3(annotations, key, value);
    }
    return annotations;
  }));
};
var whenLogLevel = /* @__PURE__ */ dual(2, (effect4, level) => {
  const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
  return withFiberRuntime((fiberState) => {
    const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel);
    if (greaterThan3(minimumLogLevel, requiredLogLevel)) {
      return succeed(none2());
    }
    return map9(effect4, some2);
  });
});
var acquireRelease = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => uninterruptible(tap(acquire, (a2) => addFinalizer((exit4) => release(a2, exit4)))));
var acquireReleaseInterruptible = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => ensuring(acquire, addFinalizer((exit4) => release(exit4))));
var addFinalizer = (finalizer3) => withFiberRuntime((runtime4) => {
  const acquireRefs = runtime4.getFiberRefs();
  const acquireFlags = runtime4.currentRuntimeFlags;
  return flatMap8(scope, (scope5) => scopeAddFinalizerExit(scope5, (exit4) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff6(preRefs, acquireRefs);
    const patchFlags = diff4(preFlags, acquireFlags);
    const inverseRefs = diff6(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch7(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring(withRuntimeFlags(finalizer3(exit4), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch7(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
});
var daemonChildren = (self2) => {
  const forkScope = fiberRefLocally(currentForkScopeOverride, some2(globalScope));
  return forkScope(self2);
};
var _existsParFound = /* @__PURE__ */ Symbol.for("effect/Effect/existsPar/found");
var exists = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => matchSimple(options?.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect(forEach8(elements, (a2, i) => if_(predicate(a2, i), {
  onTrue: () => fail2(_existsParFound),
  onFalse: () => void_
}), options), {
  onFailure: (e) => e === _existsParFound ? succeed(true) : fail2(e),
  onSuccess: () => succeed(false)
})));
var existsLoop = (iterator, index, f2) => {
  const next = iterator.next();
  if (next.done) {
    return succeed(false);
  }
  return pipe(flatMap8(f2(next.value, index), (b) => b ? succeed(b) : existsLoop(iterator, index + 1, f2)));
};
var filter5 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => {
  const predicate_ = options?.negate ? (a2, i) => map9(predicate(a2, i), not) : predicate;
  return matchSimple(options?.concurrency, () => suspend(() => fromIterable(elements).reduceRight((effect4, a2, i) => zipWith3(effect4, suspend(() => predicate_(a2, i)), (list, b) => b ? [a2, ...list] : list), sync(() => new Array()))), () => map9(forEach8(elements, (a2, i) => map9(predicate_(a2, i), (b) => b ? some2(a2) : none2()), options), getSomes));
});
var allResolveInput = (input2) => {
  if (Array.isArray(input2) || isIterable(input2)) {
    return [input2, none2()];
  }
  const keys5 = Object.keys(input2);
  const size16 = keys5.length;
  return [keys5.map((k) => input2[k]), some2((values3) => {
    const res = {};
    for (let i = 0; i < size16; i++) {
      res[keys5[i]] = values3[i];
    }
    return res;
  })];
};
var allValidate = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect4 of effects) {
    eitherEffects.push(either2(effect4));
  }
  return flatMap8(forEach8(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => {
    const none10 = none2();
    const size16 = eithers.length;
    const errors = new Array(size16);
    const successes = new Array(size16);
    let errored = false;
    for (let i = 0; i < size16; i++) {
      const either7 = eithers[i];
      if (either7._tag === "Left") {
        errors[i] = some2(either7.left);
        errored = true;
      } else {
        successes[i] = either7.right;
        errors[i] = none10;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors)) : fail2(errors);
    } else if (options?.discard) {
      return void_;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
};
var allEither = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect4 of effects) {
    eitherEffects.push(either2(effect4));
  }
  if (options?.discard) {
    return forEach8(eitherEffects, identity, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      discard: true,
      concurrentFinalizers: options?.concurrentFinalizers
    });
  }
  return map9(forEach8(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
var all3 = (arg, options) => {
  const [effects, reconcile] = allResolveInput(arg);
  if (options?.mode === "validate") {
    return allValidate(effects, reconcile, options);
  } else if (options?.mode === "either") {
    return allEither(effects, reconcile, options);
  }
  return options?.discard !== true && reconcile._tag === "Some" ? map9(forEach8(effects, identity, options), reconcile.value) : forEach8(effects, identity, options);
};
var allWith = (options) => (arg) => all3(arg, options);
var allSuccesses = (elements, options) => map9(all3(fromIterable(elements).map(exit), options), filterMap((exit4) => exitIsSuccess(exit4) ? some2(exit4.effect_instruction_i0) : none2()));
var replicate = /* @__PURE__ */ dual(2, (self2, n2) => Array.from({
  length: n2
}, () => self2));
var replicateEffect = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, n2, options) => all3(replicate(self2, n2), options));
var forEach8 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (self2, f2, options) => withFiberRuntime((r) => {
  const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options?.discard) {
    return match7(options.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self2, (a2, i) => restore(f2(a2, i)), true, false, 1) : forEachSequentialDiscard(self2, (a2, i) => restore(f2(a2, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a2, i) => restore(f2(a2, i)), isRequestBatchingEnabled, false)), (n2) => finalizersMaskInternal(parallelN2(n2), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a2, i) => restore(f2(a2, i)), isRequestBatchingEnabled, false, n2)));
  }
  return match7(options?.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self2, 1, (a2, i) => restore(f2(a2, i)), true) : forEachSequential(self2, (a2, i) => restore(f2(a2, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self2, (a2, i) => restore(f2(a2, i)), isRequestBatchingEnabled)), (n2) => finalizersMaskInternal(parallelN2(n2), options?.concurrentFinalizers)((restore) => forEachParN(self2, n2, (a2, i) => restore(f2(a2, i)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded = (self2, f2, batching) => suspend(() => {
  const as10 = fromIterable(self2);
  const array6 = new Array(as10.length);
  const fn2 = (a2, i) => flatMap8(f2(a2, i), (b) => sync(() => array6[i] = b));
  return zipRight(forEachConcurrentDiscard(as10, fn2, batching, false), succeed(array6));
});
var forEachConcurrentDiscard = (self2, f2, batching, processAll, n2) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self2).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_;
  }
  let counter6 = 0;
  let interrupted3 = false;
  const fibersCount = n2 ? Math.min(todos.length, n2) : todos.length;
  const fibers = /* @__PURE__ */ new Set();
  const results = new Array();
  const interruptAll2 = () => fibers.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  });
  const startOrder = new Array();
  const joinOrder = new Array();
  const residual = new Array();
  const collectExits = () => {
    const exits = results.filter(({
      exit: exit4
    }) => exit4._tag === "Failure").sort((a2, b) => a2.index < b.index ? -1 : a2.index === b.index ? 0 : 1).map(({
      exit: exit4
    }) => exit4);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  };
  const runFiber = (eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  };
  const onInterruptSignal = () => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted3 = true;
    interruptAll2();
  };
  const stepOrExit = batching ? step2 : exit;
  const processingFiber = runFiber(async_((resume2) => {
    const pushResult = (res, index) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index,
          exit: res
        });
        if (res._op === "Failure" && !interrupted3) {
          onInterruptSignal();
        }
      }
    };
    const next = () => {
      if (todos.length > 0) {
        const a2 = todos.pop();
        let index = counter6++;
        const returnNextElement = () => {
          const a3 = todos.pop();
          index = counter6++;
          return flatMap8(yieldNow(), () => flatMap8(stepOrExit(restore(f2(a3, index))), onRes));
        };
        const onRes = (res) => {
          if (todos.length > 0) {
            pushResult(res, index);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        };
        const todo = flatMap8(stepOrExit(restore(f2(a2, index))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers.add(fiber);
        if (interrupted3) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit4;
          if (wrapped._op === "Failure") {
            exit4 = wrapped;
          } else {
            exit4 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers.delete(fiber);
          pushResult(exit4, index);
          if (results.length === target) {
            resume2(succeed(getOrElse(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target) {
            const exits = collectExits();
            const requests = residual.map((blocked3) => blocked3.effect_instruction_i0).reduce(par);
            resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(exits, {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked3) => blocked3.effect_instruction_i1)], (i) => i, batching, true, n2))));
          } else {
            next();
          }
        });
      }
    };
    for (let i = 0; i < fibersCount; i++) {
      next();
    }
  }));
  return asVoid(onExit(flatten5(restore(join2(processingFiber))), exitMatch({
    onFailure: (cause3) => {
      onInterruptSignal();
      const target2 = residual.length + 1;
      const concurrency = Math.min(typeof n2 === "number" ? n2 : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_((cb) => {
        let count5 = 0;
        let index = 0;
        const check2 = (index2, hitNext) => (exit4) => {
          count5++;
          if (count5 === target2) {
            cb(exitSucceed(exitFailCause(cause3)));
          }
          if (toPop.length > 0 && hitNext) {
            next();
          }
        };
        const next = () => {
          runFiber(toPop.pop(), true).addObserver(check2(index, true));
          index++;
        };
        processingFiber.addObserver(check2(index, false));
        index++;
        for (let i = 0; i < concurrency; i++) {
          next();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, (f3) => f3.inheritAll)
  })));
})));
var forEachParN = (self2, n2, f2, batching) => suspend(() => {
  const as10 = fromIterable(self2);
  const array6 = new Array(as10.length);
  const fn2 = (a2, i) => map9(f2(a2, i), (b) => array6[i] = b);
  return zipRight(forEachConcurrentDiscard(as10, fn2, batching, false, n2), succeed(array6));
});
var fork = (self2) => withFiberRuntime((state, status2) => succeed(unsafeFork2(self2, state, status2.runtimeFlags)));
var forkDaemon = (self2) => forkWithScopeOverride(self2, globalScope);
var forkWithErrorHandler = /* @__PURE__ */ dual(2, (self2, handler) => fork(onError(self2, (cause3) => {
  const either7 = failureOrCause(cause3);
  switch (either7._tag) {
    case "Left":
      return handler(either7.left);
    case "Right":
      return failCause(either7.right);
  }
})));
var unsafeFork2 = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect4);
  return childFiber;
};
var unsafeForkUnstarted = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
};
var unsafeMakeChildFiber = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake2();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect4, some2(parentFiber), childFiber);
  childFiber.addObserver((exit4) => supervisor.onEnd(exit4, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
};
var forkWithScopeOverride = (self2, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork2(self2, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
var mergeAll2 = /* @__PURE__ */ dual((args2) => isFunction2(args2[2]), (elements, zero2, f2, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a2, i) => zipWith3(acc, a2, (acc2, a3) => f2(acc2, a3, i)), succeed(zero2)), () => flatMap8(make25(zero2), (acc) => flatMap8(forEach8(elements, (effect4, i) => flatMap8(effect4, (a2) => update3(acc, (b) => f2(b, a2, i))), options), () => get11(acc)))));
var partition3 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f2, options) => pipe(forEach8(elements, (a2, i) => either2(f2(a2, i)), options), map9((chunk5) => partitionMap2(chunk5, identity))));
var validateAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f2, options) => flatMap8(partition3(elements, f2, {
  concurrency: options?.concurrency,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([es2, bs]) => isNonEmptyArray2(es2) ? fail2(es2) : options?.discard ? void_ : succeed(bs)));
var raceAll = (all8) => {
  const list = fromIterable2(all8);
  if (!isNonEmpty(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  const self2 = headNonEmpty2(list);
  const effects = tailNonEmpty2(list);
  const inheritAll3 = (res) => pipe(inheritAll(res[1]), as(res[0]));
  return pipe(deferredMake(), flatMap8((done11) => pipe(make25(effects.length), flatMap8((fails) => uninterruptibleMask((restore) => pipe(fork(interruptible2(self2)), flatMap8((head6) => pipe(effects, forEachSequential((effect4) => fork(interruptible2(effect4))), map9((fibers) => unsafeFromArray(fibers)), map9((tail) => pipe(tail, prepend2(head6))), tap((fibers) => pipe(fibers, reduce(void_, (effect4, fiber) => pipe(effect4, zipRight(pipe(_await2(fiber), flatMap8(raceAllArbiter(fibers, fiber, done11, fails)), fork, asVoid)))))), flatMap8((fibers) => pipe(restore(pipe(_await(done11), flatMap8(inheritAll3))), onInterrupt(() => pipe(fibers, reduce(void_, (effect4, fiber) => pipe(effect4, zipLeft(interruptFiber(fiber))))))))))))))));
};
var raceAllArbiter = (fibers, winner, deferred2, fails) => (exit4) => exitMatchEffect(exit4, {
  onFailure: (cause3) => pipe(modify3(fails, (fails2) => [fails2 === 0 ? pipe(deferredFailCause(deferred2, cause3), asVoid) : void_, fails2 - 1]), flatten5),
  onSuccess: (value) => pipe(deferredSucceed(deferred2, [value, winner]), flatMap8((set8) => set8 ? pipe(fromIterable2(fibers), reduce(void_, (effect4, fiber) => fiber === winner ? effect4 : pipe(effect4, zipLeft(interruptFiber(fiber))))) : void_))
});
var reduceEffect = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, zero2, f2, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a2, i) => zipWith3(acc, a2, (acc2, a3) => f2(acc2, a3, i)), zero2), () => suspend(() => pipe(mergeAll2([zero2, ...elements], none2(), (acc, elem, i) => {
  switch (acc._tag) {
    case "None": {
      return some2(elem);
    }
    case "Some": {
      return some2(f2(acc.value, elem, i));
    }
  }
}, options), map9((option5) => {
  switch (option5._tag) {
    case "None": {
      throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    case "Some": {
      return option5.value;
    }
  }
})))));
var parallelFinalizers = (self2) => contextWithEffect((context8) => match2(getOption2(context8, scopeTag), {
  onNone: () => self2,
  onSome: (scope5) => {
    switch (scope5.strategy._tag) {
      case "Parallel":
        return self2;
      case "Sequential":
      case "ParallelN":
        return flatMap8(scopeFork(scope5, parallel3), (inner) => scopeExtend(self2, inner));
    }
  }
}));
var parallelNFinalizers = (parallelism) => (self2) => contextWithEffect((context8) => match2(getOption2(context8, scopeTag), {
  onNone: () => self2,
  onSome: (scope5) => {
    if (scope5.strategy._tag === "ParallelN" && scope5.strategy.parallelism === parallelism) {
      return self2;
    }
    return flatMap8(scopeFork(scope5, parallelN2(parallelism)), (inner) => scopeExtend(self2, inner));
  }
}));
var finalizersMask = (strategy) => (self2) => finalizersMaskInternal(strategy, true)(self2);
var finalizersMaskInternal = (strategy, concurrentFinalizers) => (self2) => contextWithEffect((context8) => match2(getOption2(context8, scopeTag), {
  onNone: () => self2(identity),
  onSome: (scope5) => {
    if (concurrentFinalizers === true) {
      const patch9 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope5.strategy._tag) {
        case "Parallel":
          return patch9(self2(parallelFinalizers));
        case "Sequential":
          return patch9(self2(sequentialFinalizers));
        case "ParallelN":
          return patch9(self2(parallelNFinalizers(scope5.strategy.parallelism)));
      }
    } else {
      return self2(identity);
    }
  }
}));
var scopeWith = (f2) => flatMap8(scopeTag, f2);
var scopedWith = (f2) => flatMap8(scopeMake(), (scope5) => onExit(f2(scope5), (exit4) => scope5.close(exit4)));
var scopedEffect = (effect4) => flatMap8(scopeMake(), (scope5) => scopeUse(effect4, scope5));
var sequentialFinalizers = (self2) => contextWithEffect((context8) => match2(getOption2(context8, scopeTag), {
  onNone: () => self2,
  onSome: (scope5) => {
    switch (scope5.strategy._tag) {
      case "Sequential":
        return self2;
      case "Parallel":
      case "ParallelN":
        return flatMap8(scopeFork(scope5, sequential3), (inner) => scopeExtend(self2, inner));
    }
  }
}));
var tagMetricsScoped = (key, value) => labelMetricsScoped([make28(key, value)]);
var labelMetricsScoped = (labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union(old, labels));
var using = /* @__PURE__ */ dual(2, (self2, use) => scopedWith((scope5) => flatMap8(scopeExtend(self2, scope5), use)));
var validate = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => validateWith(self2, that, (a2, b) => [a2, b], options));
var validateWith = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, f2, options) => flatten5(zipWithOptions(exit(self2), exit(that), (ea, eb) => exitZipWith(ea, eb, {
  onSuccess: f2,
  onFailure: (ca, cb) => options?.concurrent ? parallel(ca, cb) : sequential(ca, cb)
}), options)));
var validateFirst = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f2, options) => flip(forEach8(elements, (a2, i) => flip(f2(a2, i)), options)));
var withClockScoped = (c) => fiberRefLocallyScopedWith(currentServices, add2(clockTag, c));
var withRandomScoped = (value) => fiberRefLocallyScopedWith(currentServices, add2(randomTag, value));
var withConfigProviderScoped = (provider) => fiberRefLocallyScopedWith(currentServices, add2(configProviderTag, provider));
var withEarlyRelease = (self2) => scopeWith((parent) => flatMap8(scopeFork(parent, sequential2), (child) => pipe(self2, scopeExtend(child), map9((value) => [fiberIdWith((fiberId3) => scopeClose(child, exitInterrupt(fiberId3))), value]))));
var zipOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => zipWithOptions(self2, that, (a2, b) => [a2, b], options));
var zipLeftOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => {
  if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) {
    return zipLeft(self2, that);
  }
  return zipWithOptions(self2, that, (a2, _2) => a2, options);
});
var zipRightOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => {
  if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) {
    return zipRight(self2, that);
  }
  return zipWithOptions(self2, that, (_2, b) => b, options);
});
var zipWithOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, f2, options) => map9(all3([self2, that], {
  concurrency: options?.concurrent ? 2 : 1,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([a2, a22]) => f2(a2, a22)));
var withRuntimeFlagsScoped = (update5) => {
  if (update5 === empty15) {
    return void_;
  }
  return pipe(runtimeFlags, flatMap8((runtimeFlags2) => {
    const updatedRuntimeFlags = patch4(runtimeFlags2, update5);
    const revertRuntimeFlags = diff4(updatedRuntimeFlags, runtimeFlags2);
    return pipe(updateRuntimeFlags(update5), zipRight(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid);
  }), uninterruptible);
};
var scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
var scope = scopeTag;
var scopeUnsafeAddFinalizer = (scope5, fin) => {
  if (scope5.state._tag === "Open") {
    scope5.state.finalizers.set({}, fin);
  }
};
var ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const key = {};
      const fin = (exit4) => newScope.close(exit4);
      this.state.finalizers.set(key, fin);
      scopeUnsafeAddFinalizer(newScope, (_2) => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(key);
        }
      }));
      return newScope;
    });
  },
  close(exit4) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return void_;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit4
      };
      if (finalizers.length === 0) {
        return void_;
      }
      return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit4))), flatMap8((results) => pipe(exitCollectAll(results), map(exitAsVoid), getOrElse(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit4)), false), flatMap8((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map(exitAsVoid), getOrElse(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit4)), false), flatMap8((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map(exitAsVoid), getOrElse(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.set({}, fin);
      return void_;
    });
  }
};
var scopeUnsafeMake = (strategy = sequential2) => {
  const scope5 = Object.create(ScopeImplProto);
  scope5.strategy = strategy;
  scope5.state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Map()
  };
  return scope5;
};
var scopeMake = (strategy = sequential2) => sync(() => scopeUnsafeMake(strategy));
var scopeExtend = /* @__PURE__ */ dual(2, (effect4, scope5) => mapInputContext(
  effect4,
  // @ts-expect-error
  merge3(make7(scopeTag, scope5))
));
var scopeUse = /* @__PURE__ */ dual(2, (effect4, scope5) => pipe(effect4, scopeExtend(scope5), onExit((exit4) => scope5.close(exit4))));
var fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty24
});
var fiberRefLocallyScoped = /* @__PURE__ */ dual(2, (self2, value) => asVoid(acquireRelease(flatMap8(fiberRefGet(self2), (oldValue) => as(fiberRefSet(self2, value), oldValue)), (oldValue) => fiberRefSet(self2, oldValue))));
var fiberRefLocallyScopedWith = /* @__PURE__ */ dual(2, (self2, f2) => fiberRefGetWith(self2, (a2) => fiberRefLocallyScoped(self2, f2(a2))));
var currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none5);
var currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none8);
var fiberAwaitAll = (fibers) => forEach8(fibers, _await2);
var fiberAll = (fibers) => {
  const _fiberAll = {
    ...CommitPrototype2,
    commit() {
      return join2(this);
    },
    [FiberTypeId]: fiberVariance2,
    id: () => fromIterable(fibers).reduce((id2, fiber) => combine3(id2, fiber.id()), none4),
    await: exit(forEachParUnbounded(fibers, (fiber) => flatten5(fiber.await), false)),
    children: map9(forEachParUnbounded(fibers, (fiber) => fiber.children, false), flatten),
    inheritAll: forEachSequentialDiscard(fibers, (fiber) => fiber.inheritAll),
    poll: map9(forEachSequential(fibers, (fiber) => fiber.poll), reduceRight(some2(exitSucceed(new Array())), (optionB, optionA) => {
      switch (optionA._tag) {
        case "None": {
          return none2();
        }
        case "Some": {
          switch (optionB._tag) {
            case "None": {
              return none2();
            }
            case "Some": {
              return some2(exitZipWith(optionA.value, optionB.value, {
                onSuccess: (a2, chunk5) => [a2, ...chunk5],
                onFailure: parallel
              }));
            }
          }
        }
      }
    })),
    interruptAsFork: (fiberId3) => forEachSequentialDiscard(fibers, (fiber) => fiber.interruptAsFork(fiberId3))
  };
  return _fiberAll;
};
var raceWith = /* @__PURE__ */ dual(3, (self2, other, options) => raceFibersWith(self2, other, {
  onSelfWin: (winner, loser) => flatMap8(winner.await, (exit4) => {
    switch (exit4._tag) {
      case OP_SUCCESS: {
        return flatMap8(winner.inheritAll, () => options.onSelfDone(exit4, loser));
      }
      case OP_FAILURE: {
        return options.onSelfDone(exit4, loser);
      }
    }
  }),
  onOtherWin: (winner, loser) => flatMap8(winner.await, (exit4) => {
    switch (exit4._tag) {
      case OP_SUCCESS: {
        return flatMap8(winner.inheritAll, () => options.onOtherDone(exit4, loser));
      }
      case OP_FAILURE: {
        return options.onOtherDone(exit4, loser);
      }
    }
  })
}));
var disconnect = (self2) => uninterruptibleMask((restore) => fiberIdWith((fiberId3) => flatMap8(forkDaemon(restore(self2)), (fiber) => pipe(restore(join2(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId3)))))));
var race = /* @__PURE__ */ dual(2, (self2, that) => fiberIdWith((parentFiberId) => raceWith(self2, that, {
  onSelfDone: (exit4, right3) => exitMatchEffect(exit4, {
    onFailure: (cause3) => pipe(join2(right3), mapErrorCause((cause22) => parallel(cause3, cause22))),
    onSuccess: (value) => pipe(right3, interruptAsFiber(parentFiberId), as(value))
  }),
  onOtherDone: (exit4, left3) => exitMatchEffect(exit4, {
    onFailure: (cause3) => pipe(join2(left3), mapErrorCause((cause22) => parallel(cause22, cause3))),
    onSuccess: (value) => pipe(left3, interruptAsFiber(parentFiberId), as(value))
  })
})));
var raceFibersWith = /* @__PURE__ */ dual(3, (self2, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make12(true);
  const leftFiber = unsafeMakeChildFiber(self2, parentFiber, parentRuntimeFlags, options.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
  return async_((cb) => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self2);
    rightFiber.startFork(other);
  }, combine3(leftFiber.id(), rightFiber.id()));
}));
var completeRace = (winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
};
var ensuring = /* @__PURE__ */ dual(2, (self2, finalizer3) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
  onFailure: (cause1) => matchCauseEffect(finalizer3, {
    onFailure: (cause22) => failCause(sequential(cause1, cause22)),
    onSuccess: () => failCause(cause1)
  }),
  onSuccess: (a2) => as(finalizer3, a2)
})));
var invokeWithInterrupt = (self2, entries2, onInterrupt3) => fiberIdWith((id2) => flatMap8(flatMap8(forkDaemon(interruptible2(self2)), (processing) => async_((cb) => {
  const counts = entries2.map((_2) => _2.listeners.count);
  const checkDone = () => {
    if (counts.every((count5) => count5 === 0)) {
      if (entries2.every((_2) => {
        if (_2.result.state.current._tag === "Pending") {
          return true;
        } else if (_2.result.state.current._tag === "Done" && exitIsExit(_2.result.state.current.effect) && _2.result.state.current.effect._tag === "Failure" && isInterrupted(_2.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f2) => f2());
        onInterrupt3?.();
        cb(interruptFiber(processing));
      }
    }
  };
  processing.addObserver((exit4) => {
    cleanup.forEach((f2) => f2());
    cb(exit4);
  });
  const cleanup = entries2.map((r, i) => {
    const observer = (count5) => {
      counts[i] = count5;
      checkDone();
    };
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f2) => f2());
  });
})), () => suspend(() => {
  const residual = entries2.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete(entry.request, exitInterrupt(id2)));
})));
var makeSpanScoped = (name, options) => {
  options = addSpanStackTrace(options);
  return uninterruptible(withFiberRuntime((fiber) => {
    const scope5 = unsafeGet4(fiber.getFiberRef(currentContext), scopeTag);
    const span4 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock_ = get4(fiber.getFiberRef(currentServices), clockTag);
    return as(scopeAddFinalizerExit(scope5, (exit4) => endSpan(span4, exit4, clock_, timingEnabled)), span4);
  }));
};
var withTracerScoped = (value) => fiberRefLocallyScopedWith(currentServices, add2(tracerTag, value));
var withSpanScoped = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return flatMap8(makeSpanScoped(name, addSpanStackTrace(options)), (span4) => provideService(self2, spanTag, span4));
  }
  return (self2) => flatMap8(makeSpanScoped(name, addSpanStackTrace(options)), (span4) => provideService(self2, spanTag, span4));
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Cause.js
var fail5 = fail;
var die4 = die;
var interrupt5 = interrupt;
var isDieType2 = isDieType;
var isInterrupted2 = isInterrupted;
var isInterruptedOnly2 = isInterruptedOnly;
var interruptors2 = interruptors;
var failureOrCause2 = failureOrCause;
var flipCauseOption2 = flipCauseOption;
var map12 = map7;
var squash = causeSquash;
var IllegalArgumentException2 = IllegalArgumentException;
var NoSuchElementException2 = NoSuchElementException;
var RuntimeException2 = RuntimeException;
var isRuntimeException2 = isRuntimeException;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey = "effect/ScheduleInterval";
var IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
var empty25 = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
var make34 = (startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty25;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
};
var lessThan2 = /* @__PURE__ */ dual(2, (self2, that) => min2(self2, that) === self2);
var min2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2.endMillis <= that.startMillis) return self2;
  if (that.endMillis <= self2.startMillis) return that;
  if (self2.startMillis < that.startMillis) return self2;
  if (that.startMillis < self2.startMillis) return that;
  if (self2.endMillis <= that.endMillis) return self2;
  return that;
});
var isEmpty6 = (self2) => {
  return self2.startMillis >= self2.endMillis;
};
var intersect = /* @__PURE__ */ dual(2, (self2, that) => {
  const start3 = Math.max(self2.startMillis, that.startMillis);
  const end6 = Math.min(self2.endMillis, that.endMillis);
  return make34(start3, end6);
});
var size9 = (self2) => {
  return millis(self2.endMillis - self2.startMillis);
};
var after = (startMilliseconds) => {
  return make34(startMilliseconds, Number.POSITIVE_INFINITY);
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/ScheduleInterval.js
var make35 = make34;
var empty26 = empty25;
var lessThan3 = lessThan2;
var isEmpty7 = isEmpty6;
var intersect2 = intersect;
var size10 = size9;
var after2 = after;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals";
var IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
var make36 = (intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
};
var intersect3 = /* @__PURE__ */ dual(2, (self2, that) => intersectLoop(self2.intervals, that.intervals, empty2()));
var intersectLoop = (_left, _right, _acc) => {
  let left3 = _left;
  let right3 = _right;
  let acc = _acc;
  while (isNonEmpty(left3) && isNonEmpty(right3)) {
    const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
    const intervals = isEmpty7(interval) ? acc : pipe(acc, prepend2(interval));
    if (pipe(headNonEmpty2(left3), lessThan3(headNonEmpty2(right3)))) {
      left3 = tailNonEmpty2(left3);
    } else {
      right3 = tailNonEmpty2(right3);
    }
    acc = intervals;
  }
  return make36(reverse2(acc));
};
var start = (self2) => {
  return pipe(self2.intervals, head2, getOrElse(() => empty26)).startMillis;
};
var end = (self2) => {
  return pipe(self2.intervals, head2, getOrElse(() => empty26)).endMillis;
};
var lessThan4 = /* @__PURE__ */ dual(2, (self2, that) => start(self2) < start(that));
var isNonEmpty3 = (self2) => {
  return isNonEmpty(self2.intervals);
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/ScheduleIntervals.js
var make37 = make36;
var intersect4 = intersect3;
var start2 = start;
var end2 = end;
var lessThan5 = lessThan4;
var isNonEmpty4 = isNonEmpty3;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue";
var OP_DONE2 = "Done";
var _continue = (intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
};
var continueWith = (interval) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make37(of2(interval))
  };
};
var done5 = {
  _tag: OP_DONE2
};
var isContinue = (self2) => {
  return self2._tag === OP_CONTINUE;
};
var isDone4 = (self2) => {
  return self2._tag === OP_DONE2;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2 = _continue;
var continueWith2 = continueWith;
var done6 = done5;
var isContinue2 = isContinue;
var isDone5 = isDone4;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Scope.js
var Scope = scopeTag;
var addFinalizer2 = scopeAddFinalizer;
var addFinalizerExit = scopeAddFinalizerExit;
var close = scopeClose;
var extend2 = scopeExtend;
var fork2 = scopeFork;
var make38 = scopeMake;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Data.js
var Data_exports = {};
__export(Data_exports, {
  Class: () => Class3,
  Error: () => Error3,
  Structural: () => Structural2,
  TaggedClass: () => TaggedClass,
  TaggedError: () => TaggedError,
  array: () => array3,
  case: () => _case,
  struct: () => struct2,
  tagged: () => tagged2,
  taggedEnum: () => taggedEnum,
  tuple: () => tuple,
  unsafeArray: () => unsafeArray,
  unsafeStruct: () => unsafeStruct
});
var struct2 = struct;
var unsafeStruct = (as10) => Object.setPrototypeOf(as10, StructuralPrototype);
var tuple = (...as10) => unsafeArray(as10);
var array3 = (as10) => unsafeArray(as10.slice(0));
var unsafeArray = (as10) => Object.setPrototypeOf(as10, ArrayProto);
var _case = () => (args2) => args2 === void 0 ? Object.create(StructuralPrototype) : struct2(args2);
var tagged2 = (tag) => (args2) => {
  const value = args2 === void 0 ? Object.create(StructuralPrototype) : struct2(args2);
  value._tag = tag;
  return value;
};
var Class3 = Structural;
var TaggedClass = (tag) => {
  class Base3 extends Class3 {
    _tag = tag;
  }
  return Base3;
};
var Structural2 = Structural;
var taggedEnum = () => new Proxy({}, {
  get(_target, tag, _receiver) {
    if (tag === "$is") {
      return isTagged;
    } else if (tag === "$match") {
      return taggedMatch;
    }
    return tagged2(tag);
  }
});
function taggedMatch() {
  if (arguments.length === 1) {
    const cases2 = arguments[0];
    return function(value2) {
      return cases2[value2._tag](value2);
    };
  }
  const value = arguments[0];
  const cases = arguments[1];
  return cases[value._tag](value);
}
var Error3 = /* @__PURE__ */ function() {
  const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
  return class Base extends YieldableError {
    constructor(args2) {
      super(args2?.message, args2?.cause ? {
        cause: args2.cause
      } : void 0);
      if (args2) {
        Object.assign(this, args2);
        Object.defineProperty(this, plainArgsSymbol, {
          value: args2,
          enumerable: false
        });
      }
    }
    toJSON() {
      return {
        ...this[plainArgsSymbol],
        ...this
      };
    }
  };
}();
var TaggedError = (tag) => {
  class Base3 extends Error3 {
    _tag = tag;
  }
  Base3.prototype.name = tag;
  return Base3;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule";
var ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
var isSchedule = (u2) => hasProperty(u2, ScheduleTypeId);
var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
var ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
var scheduleVariance = {
  /* c8 ignore next */
  _Out: (_2) => _2,
  /* c8 ignore next */
  _In: (_2) => _2,
  /* c8 ignore next */
  _R: (_2) => _2
};
var scheduleDriverVariance = {
  /* c8 ignore next */
  _Out: (_2) => _2,
  /* c8 ignore next */
  _In: (_2) => _2,
  /* c8 ignore next */
  _R: (_2) => _2
};
var ScheduleImpl = class {
  initial;
  step;
  [ScheduleTypeId] = scheduleVariance;
  constructor(initial, step4) {
    this.initial = initial;
    this.step = step4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var ScheduleDriverImpl = class {
  schedule;
  ref;
  [ScheduleDriverTypeId] = scheduleDriverVariance;
  constructor(schedule4, ref) {
    this.schedule = schedule4;
    this.ref = ref;
  }
  get state() {
    return map9(get10(this.ref), (tuple3) => tuple3[1]);
  }
  get last() {
    return flatMap8(get10(this.ref), ([element, _2]) => {
      switch (element._tag) {
        case "None": {
          return failSync(() => new NoSuchElementException());
        }
        case "Some": {
          return succeed(element.value);
        }
      }
    });
  }
  get reset() {
    return set4(this.ref, [none2(), this.schedule.initial]);
  }
  next(input2) {
    return pipe(map9(get10(this.ref), (tuple3) => tuple3[1]), flatMap8((state) => pipe(currentTimeMillis2, flatMap8((now) => pipe(suspend(() => this.schedule.step(now, input2, state)), flatMap8(([state2, out, decision]) => {
      const setState = set4(this.ref, [some2(out), state2]);
      if (isDone5(decision)) {
        return zipRight(setState, fail2(none2()));
      }
      const millis2 = start2(decision.intervals) - now;
      if (millis2 <= 0) {
        return as(setState, out);
      }
      return pipe(setState, zipRight(sleep3(millis(millis2))), as(out));
    }))))));
  }
};
var makeWithState = (initial, step4) => new ScheduleImpl(initial, step4);
var addDelay = /* @__PURE__ */ dual(2, (self2, f2) => addDelayEffect(self2, (out) => sync(() => f2(out))));
var addDelayEffect = /* @__PURE__ */ dual(2, (self2, f2) => modifyDelayEffect(self2, (out, duration4) => map9(f2(out), (delay4) => sum(duration4, decode(delay4)))));
var check = /* @__PURE__ */ dual(2, (self2, test) => checkEffect(self2, (input2, out) => sync(() => test(input2, out))));
var checkEffect = /* @__PURE__ */ dual(2, (self2, test) => makeWithState(self2.initial, (now, input2, state) => flatMap8(self2.step(now, input2, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, done6]);
  }
  return map9(test(input2, out), (cont) => cont ? [state2, out, decision] : [state2, out, done6]);
})));
var driver = (self2) => pipe(make24([none2(), self2.initial]), map9((ref) => new ScheduleDriverImpl(self2, ref)));
var intersect5 = /* @__PURE__ */ dual(2, (self2, that) => intersectWith(self2, that, intersect4));
var intersectWith = /* @__PURE__ */ dual(3, (self2, that, f2) => makeWithState([self2.initial, that.initial], (now, input2, state) => pipe(zipWith3(self2.step(now, input2, state[0]), that.step(now, input2, state[1]), (a2, b) => [a2, b]), flatMap8(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    return intersectWithLoop(self2, that, input2, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f2);
  }
  return succeed([[lState, rState], [out, out2], done6]);
}))));
var intersectWithLoop = (self2, that, input2, lState, out, lInterval, rState, out2, rInterval, f2) => {
  const combined = f2(lInterval, rInterval);
  if (isNonEmpty4(combined)) {
    return succeed([[lState, rState], [out, out2], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan5(rInterval))) {
    return flatMap8(self2.step(end2(lInterval), input2, lState), ([lState2, out3, decision]) => {
      if (isDone5(decision)) {
        return succeed([[lState2, rState], [out3, out2], done6]);
      }
      return intersectWithLoop(self2, that, input2, lState2, out3, decision.intervals, rState, out2, rInterval, f2);
    });
  }
  return flatMap8(that.step(end2(rInterval), input2, rState), ([rState2, out22, decision]) => {
    if (isDone5(decision)) {
      return succeed([[lState, rState2], [out, out22], done6]);
    }
    return intersectWithLoop(self2, that, input2, lState, out, lInterval, rState2, out22, decision.intervals, f2);
  });
};
var map13 = /* @__PURE__ */ dual(2, (self2, f2) => mapEffect(self2, (out) => sync(() => f2(out))));
var mapEffect = /* @__PURE__ */ dual(2, (self2, f2) => makeWithState(self2.initial, (now, input2, state) => flatMap8(self2.step(now, input2, state), ([state2, out, decision]) => map9(f2(out), (out2) => [state2, out2, decision]))));
var modifyDelayEffect = /* @__PURE__ */ dual(2, (self2, f2) => makeWithState(self2.initial, (now, input2, state) => flatMap8(self2.step(now, input2, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, decision]);
  }
  const intervals = decision.intervals;
  const delay4 = size10(make35(now, start2(intervals)));
  return map9(f2(out, delay4), (durationInput) => {
    const duration4 = decode(durationInput);
    const oldStart = start2(intervals);
    const newStart = now + toMillis(duration4);
    const delta = newStart - oldStart;
    const newEnd = Math.max(0, end2(intervals) + delta);
    const newInterval = make35(newStart, newEnd);
    return [state2, out, continueWith2(newInterval)];
  });
})));
var passthrough = (self2) => makeWithState(self2.initial, (now, input2, state) => pipe(self2.step(now, input2, state), map9(([state2, _2, decision]) => [state2, input2, decision])));
var recurs = (n2) => whileOutput(forever2, (out) => out < n2);
var spaced = (duration4) => addDelay(forever2, () => duration4);
var unfold2 = (initial, f2) => makeWithState(initial, (now, _2, state) => sync(() => [f2(state), state, continueWith2(after2(now))]));
var untilInputEffect = /* @__PURE__ */ dual(2, (self2, f2) => checkEffect(self2, (input2, _2) => negate(f2(input2))));
var whileInputEffect = /* @__PURE__ */ dual(2, (self2, f2) => checkEffect(self2, (input2, _2) => f2(input2)));
var whileOutput = /* @__PURE__ */ dual(2, (self2, f2) => check(self2, (_2, out) => f2(out)));
var ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");
var ScheduleDefect = class {
  error;
  [ScheduleDefectTypeId];
  constructor(error4) {
    this.error = error4;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
};
var isScheduleDefect = (u2) => hasProperty(u2, ScheduleDefectTypeId);
var scheduleDefectWrap = (self2) => catchAll(self2, (e) => die2(new ScheduleDefect(e)));
var scheduleDefectRefail = (self2) => catchAllCause(self2, (cause3) => match2(find(cause3, (_2) => isDieType(_2) && isScheduleDefect(_2.defect) ? some2(_2.defect) : none2()), {
  onNone: () => failCause(cause3),
  onSome: (error4) => fail2(error4.error)
}));
var repeat_Effect = /* @__PURE__ */ dual(2, (self2, schedule4) => repeatOrElse_Effect(self2, schedule4, (e, _2) => fail2(e)));
var repeat_combined = /* @__PURE__ */ dual(2, (self2, options) => {
  if (isSchedule(options)) {
    return repeat_Effect(self2, options);
  }
  const base2 = options.schedule ?? passthrough(forever2);
  const withWhile = options.while ? whileInputEffect(base2, (a2) => {
    const applied = options.while(a2);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base2;
  const withUntil = options.until ? untilInputEffect(withWhile, (a2) => {
    const applied = options.until(a2);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? intersect5(withUntil, recurs(options.times)).pipe(map13((intersectionPair) => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self2, withTimes));
});
var repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self2, schedule4, orElse14) => flatMap8(driver(schedule4), (driver3) => matchEffect(self2, {
  onFailure: (error4) => orElse14(error4, none2()),
  onSuccess: (value) => repeatOrElseEffectLoop(self2, driver3, orElse14, value)
})));
var repeatOrElseEffectLoop = (self2, driver3, orElse14, value) => {
  return matchEffect(driver3.next(value), {
    onFailure: () => orDie(driver3.last),
    onSuccess: (b) => matchEffect(self2, {
      onFailure: (error4) => orElse14(error4, some2(b)),
      onSuccess: (value2) => repeatOrElseEffectLoop(self2, driver3, orElse14, value2)
    })
  });
};
var retry_Effect = /* @__PURE__ */ dual(2, (self2, policy) => retryOrElse_Effect(self2, policy, (e, _2) => fail2(e)));
var retry_combined = /* @__PURE__ */ dual(2, (self2, options) => {
  if (isSchedule(options)) {
    return retry_Effect(self2, options);
  }
  const base2 = options.schedule ?? forever2;
  const withWhile = options.while ? whileInputEffect(base2, (e) => {
    const applied = options.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base2;
  const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
    const applied = options.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? intersect5(withUntil, recurs(options.times)) : withUntil;
  return scheduleDefectRefail(retry_Effect(self2, withTimes));
});
var retryOrElse_Effect = /* @__PURE__ */ dual(3, (self2, policy, orElse14) => flatMap8(driver(policy), (driver3) => retryOrElse_EffectLoop(self2, driver3, orElse14)));
var retryOrElse_EffectLoop = (self2, driver3, orElse14) => {
  return catchAll(self2, (e) => matchEffect(driver3.next(e), {
    onFailure: () => pipe(driver3.last, orDie, flatMap8((out) => orElse14(e, out))),
    onSuccess: () => retryOrElse_EffectLoop(self2, driver3, orElse14)
  }));
};
var schedule_Effect = /* @__PURE__ */ dual(2, (self2, schedule4) => scheduleFrom_Effect(self2, void 0, schedule4));
var scheduleFrom_Effect = /* @__PURE__ */ dual(3, (self2, initial, schedule4) => flatMap8(driver(schedule4), (driver3) => scheduleFrom_EffectLoop(self2, initial, driver3)));
var scheduleFrom_EffectLoop = (self2, initial, driver3) => matchEffect(driver3.next(initial), {
  onFailure: () => orDie(driver3.last),
  onSuccess: () => flatMap8(self2, (a2) => scheduleFrom_EffectLoop(self2, a2, driver3))
});
var forever2 = /* @__PURE__ */ unfold2(0, (n2) => n2 + 1);

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/effect/circular.js
var Semaphore = class {
  permits;
  waiters = /* @__PURE__ */ new Set();
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = (n2) => asyncInterrupt((resume2) => {
    if (this.free < n2) {
      const observer = () => {
        if (this.free < n2) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n2;
        resume2(succeed(n2));
      };
      this.waiters.add(observer);
      return sync(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n2;
    return resume2(succeed(n2));
  });
  updateTaken = (f2) => withFiberRuntime((fiber) => {
    this.taken = f2(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(currentScheduler).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(currentSchedulingPriority));
    }
    return succeed(this.free);
  });
  release = (n2) => this.updateTaken((taken) => taken - n2);
  releaseAll = /* @__PURE__ */ this.updateTaken((_2) => 0);
  withPermits = (n2) => (self2) => uninterruptibleMask((restore) => flatMap8(restore(this.take(n2)), (permits) => ensuring(restore(self2), this.release(permits))));
  withPermitsIfAvailable = (n2) => (self2) => uninterruptibleMask((restore) => suspend(() => {
    if (this.free < n2) {
      return succeedNone;
    }
    this.taken += n2;
    return ensuring(restore(asSome(self2)), this.release(n2));
  }));
};
var unsafeMakeSemaphore = (permits) => new Semaphore(permits);
var makeSemaphore = (permits) => sync(() => unsafeMakeSemaphore(permits));
var Latch = class extends Class2 {
  isOpen;
  waiters = [];
  scheduled = false;
  constructor(isOpen) {
    super();
    this.isOpen = isOpen;
  }
  commit() {
    return this.await;
  }
  unsafeSchedule(fiber) {
    if (this.scheduled || this.waiters.length === 0) {
      return void_;
    }
    this.scheduled = true;
    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
    return void_;
  }
  flushWaiters = () => {
    this.scheduled = false;
    const waiters = this.waiters;
    this.waiters = [];
    for (let i = 0; i < waiters.length; i++) {
      waiters[i](exitVoid);
    }
  };
  open = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_;
    }
    this.isOpen = true;
    return this.unsafeSchedule(fiber);
  });
  unsafeOpen() {
    if (this.isOpen) return;
    this.isOpen = true;
    this.flushWaiters();
  }
  release = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_;
    }
    return this.unsafeSchedule(fiber);
  });
  await = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.isOpen) {
      return resume2(void_);
    }
    this.waiters.push(resume2);
    return sync(() => {
      const index = this.waiters.indexOf(resume2);
      if (index !== -1) {
        this.waiters.splice(index, 1);
      }
    });
  });
  unsafeClose() {
    this.isOpen = false;
  }
  close = /* @__PURE__ */ sync(() => {
    this.isOpen = false;
  });
  whenOpen = (self2) => {
    return zipRight(this.await, self2);
  };
};
var unsafeMakeLatch = (open) => new Latch(open ?? false);
var makeLatch = (open) => sync(() => unsafeMakeLatch(open));
var awaitAllChildren = (self2) => ensuringChildren(self2, fiberAwaitAll);
var cached2 = /* @__PURE__ */ dual(2, (self2, timeToLive) => map9(cachedInvalidateWithTTL(self2, timeToLive), (tuple3) => tuple3[0]));
var cachedInvalidateWithTTL = /* @__PURE__ */ dual(2, (self2, timeToLive) => {
  const duration4 = decode(timeToLive);
  return flatMap8(context(), (env2) => map9(makeSynchronized(none2()), (cache3) => [provideContext(getCachedValue(self2, duration4, cache3), env2), invalidateCache(cache3)]));
});
var computeCachedValue = (self2, timeToLive, start3) => {
  const timeToLiveMillis = toMillis(decode(timeToLive));
  return pipe(deferredMake(), tap((deferred2) => intoDeferred(self2, deferred2)), map9((deferred2) => some2([start3 + timeToLiveMillis, deferred2])));
};
var getCachedValue = (self2, timeToLive, cache3) => uninterruptibleMask((restore) => pipe(clockWith3((clock3) => clock3.currentTimeMillis), flatMap8((time3) => updateSomeAndGetEffectSynchronized(cache3, (option5) => {
  switch (option5._tag) {
    case "None": {
      return some2(computeCachedValue(self2, timeToLive, time3));
    }
    case "Some": {
      const [end6] = option5.value;
      return end6 - time3 <= 0 ? some2(computeCachedValue(self2, timeToLive, time3)) : none2();
    }
  }
})), flatMap8((option5) => isNone2(option5) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option5.value[1])))));
var invalidateCache = (cache3) => set4(cache3, none2());
var ensuringChild = /* @__PURE__ */ dual(2, (self2, f2) => ensuringChildren(self2, (children2) => f2(fiberAll(children2))));
var ensuringChildren = /* @__PURE__ */ dual(2, (self2, children2) => flatMap8(track, (supervisor) => pipe(supervised(self2, supervisor), ensuring(flatMap8(supervisor.value, children2)))));
var forkAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork) : map9(forEachSequential(effects, fork), fiberAll));
var forkIn = /* @__PURE__ */ dual(2, (self2, scope5) => withFiberRuntime((parent, parentStatus) => {
  const scopeImpl = scope5;
  const fiber = unsafeFork2(self2, parent, parentStatus.runtimeFlags, globalScope);
  if (scopeImpl.state._tag === "Open") {
    const finalizer3 = () => fiberIdWith((fiberId3) => equals(fiberId3, fiber.id()) ? void_ : asVoid(interruptFiber(fiber)));
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer3);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed") return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return succeed(fiber);
}));
var forkScoped = (self2) => scopeWith((scope5) => forkIn(self2, scope5));
var fromFiber = (fiber) => join2(fiber);
var fromFiberEffect = (fiber) => suspend(() => flatMap8(fiber, join2));
var memoKeySymbol = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");
var Key = class {
  a;
  eq;
  [memoKeySymbol] = memoKeySymbol;
  constructor(a2, eq) {
    this.a = a2;
    this.eq = eq;
  }
  [symbol2](that) {
    if (hasProperty(that, memoKeySymbol)) {
      if (this.eq) {
        return this.eq(this.a, that.a);
      } else {
        return equals(this.a, that.a);
      }
    }
    return false;
  }
  [symbol]() {
    return this.eq ? 0 : cached(this, hash(this.a));
  }
};
var cachedFunction = (f2, eq) => {
  return pipe(sync(() => empty21()), flatMap8(makeSynchronized), map9((ref) => (a2) => pipe(ref.modifyEffect((map26) => {
    const result = pipe(map26, get12(new Key(a2, eq)));
    if (isNone2(result)) {
      return pipe(deferredMake(), tap((deferred2) => pipe(diffFiberRefs(f2(a2)), intoDeferred(deferred2), fork)), map9((deferred2) => [deferred2, pipe(map26, set6(new Key(a2, eq), deferred2))]));
    }
    return succeed([result.value, map26]);
  }), flatMap8(deferredAwait), flatMap8(([patch9, b]) => pipe(patchFiberRefs(patch9), as(b))))));
};
var raceFirst = /* @__PURE__ */ dual(2, (self2, that) => pipe(exit(self2), race(exit(that)), (effect4) => flatten5(effect4)));
var scheduleForked = /* @__PURE__ */ dual(2, (self2, schedule4) => pipe(self2, schedule_Effect(schedule4), forkScoped));
var supervised = /* @__PURE__ */ dual(2, (self2, supervisor) => {
  const supervise = fiberRefLocallyWith(currentSupervisor, (s2) => s2.zip(supervisor));
  return supervise(self2);
});
var timeout = /* @__PURE__ */ dual(2, (self2, duration4) => timeoutFail(self2, {
  onTimeout: () => timeoutExceptionFromDuration(duration4),
  duration: duration4
}));
var timeoutFail = /* @__PURE__ */ dual(2, (self2, {
  duration: duration4,
  onTimeout
}) => flatten5(timeoutTo(self2, {
  onTimeout: () => failSync(onTimeout),
  onSuccess: succeed,
  duration: duration4
})));
var timeoutFailCause = /* @__PURE__ */ dual(2, (self2, {
  duration: duration4,
  onTimeout
}) => flatten5(timeoutTo(self2, {
  onTimeout: () => failCauseSync(onTimeout),
  onSuccess: succeed,
  duration: duration4
})));
var timeoutOption = /* @__PURE__ */ dual(2, (self2, duration4) => timeoutTo(self2, {
  duration: duration4,
  onSuccess: some2,
  onTimeout: none2
}));
var timeoutTo = /* @__PURE__ */ dual(2, (self2, {
  duration: duration4,
  onSuccess,
  onTimeout
}) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self2), interruptible2(sleep3(duration4)), {
  onSelfWin: (winner, loser) => flatMap8(winner.await, (exit4) => {
    if (exit4._tag === "Success") {
      return flatMap8(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onSuccess(exit4.value)));
    } else {
      return flatMap8(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit4.cause));
    }
  }),
  onOtherWin: (winner, loser) => flatMap8(winner.await, (exit4) => {
    if (exit4._tag === "Success") {
      return flatMap8(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap8(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit4.cause));
    }
  }),
  otherScope: globalScope
}))));
var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
var synchronizedVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var SynchronizedImpl = class extends Class2 {
  ref;
  withLock;
  [SynchronizedTypeId] = synchronizedVariance;
  [RefTypeId] = refVariance;
  [TypeId10] = TypeId10;
  constructor(ref, withLock) {
    super();
    this.ref = ref;
    this.withLock = withLock;
    this.get = get10(this.ref);
  }
  get;
  commit() {
    return this.get;
  }
  modify(f2) {
    return this.modifyEffect((a2) => succeed(f2(a2)));
  }
  modifyEffect(f2) {
    return this.withLock(pipe(flatMap8(get10(this.ref), f2), flatMap8(([b, a2]) => as(set4(this.ref, a2), b))));
  }
};
var makeSynchronized = (value) => sync(() => unsafeMakeSynchronized(value));
var unsafeMakeSynchronized = (value) => {
  const ref = unsafeMake5(value);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
};
var updateSomeAndGetEffectSynchronized = /* @__PURE__ */ dual(2, (self2, pf) => self2.modifyEffect((value) => {
  const result = pf(value);
  switch (result._tag) {
    case "None": {
      return succeed([value, value]);
    }
    case "Some": {
      return map9(result.value, (a2) => [a2, a2]);
    }
  }
}));
var bindAll = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, f2, options) => flatMap8(self2, (a2) => all3(f2(a2), options).pipe(map9((record) => Object.assign({}, a2, record)))));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/managedRuntime/circular.js
var TypeId13 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_EXTEND_SCOPE = "ExtendScope";
var OP_FOLD = "Fold";
var OP_FRESH = "Fresh";
var OP_FROM_EFFECT = "FromEffect";
var OP_SCOPED = "Scoped";
var OP_SUSPEND = "Suspend";
var OP_PROVIDE = "Provide";
var OP_PROVIDE_MERGE = "ProvideMerge";
var OP_ZIP_WITH2 = "ZipWith";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Fiber.js
var _await3 = _await2;
var inheritAll2 = inheritAll;
var interrupt6 = interruptFiber;
var interruptAs = interruptAsFiber;
var join3 = join2;
var poll3 = poll2;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/runtime.js
var makeDual = (f2) => function() {
  if (arguments.length === 1) {
    const runtime4 = arguments[0];
    return (effect4, ...args2) => f2(runtime4, effect4, ...args2);
  }
  return f2.apply(this, arguments);
};
var unsafeFork3 = /* @__PURE__ */ makeDual((runtime4, self2, options) => {
  const fiberId3 = unsafeMake2();
  const fiberRefUpdates = [[currentContext, [[fiberId3, runtime4.context]]]];
  if (options?.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId3, options.scheduler]]]);
  }
  let fiberRefs3 = updateManyAs2(runtime4.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId3
  });
  if (options?.updateRefs) {
    fiberRefs3 = options.updateRefs(fiberRefs3, fiberId3);
  }
  const fiberRuntime = new FiberRuntime(fiberId3, fiberRefs3, runtime4.runtimeFlags);
  let effect4 = self2;
  if (options?.scope) {
    effect4 = flatMap8(fork2(options.scope, sequential2), (closeableScope) => zipRight(scopeAddFinalizer(closeableScope, fiberIdWith((id2) => equals(id2, fiberRuntime.id()) ? void_ : interruptAsFiber(fiberRuntime, id2))), onExit(self2, (exit4) => close(closeableScope, exit4))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  if (supervisor !== none8) {
    supervisor.onStart(runtime4.context, effect4, none2(), fiberRuntime);
    fiberRuntime.addObserver((exit4) => supervisor.onEnd(exit4, fiberRuntime));
  }
  globalScope.add(runtime4.runtimeFlags, fiberRuntime);
  if (options?.immediate === false) {
    fiberRuntime.resume(effect4);
  } else {
    fiberRuntime.start(effect4);
  }
  return fiberRuntime;
});
var unsafeRunCallback = /* @__PURE__ */ makeDual((runtime4, effect4, options = {}) => {
  const fiberRuntime = unsafeFork3(runtime4, effect4, options);
  if (options.onExit) {
    fiberRuntime.addObserver((exit4) => {
      options.onExit(exit4);
    });
  }
  return (id2, cancelOptions) => unsafeRunCallback(runtime4)(pipe(fiberRuntime, interruptAs(id2 ?? none4)), {
    ...cancelOptions,
    onExit: cancelOptions?.onExit ? (exit4) => cancelOptions.onExit(flatten6(exit4)) : void 0
  });
});
var unsafeRunSync = /* @__PURE__ */ makeDual((runtime4, effect4) => {
  const result = unsafeRunSyncExit(runtime4)(effect4);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});
var AsyncFiberExceptionImpl = class extends Error {
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
};
var asyncFiberException = (fiber) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error4 = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error4;
};
var FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");
var FiberFailureImpl = class extends Error {
  [FiberFailureId];
  [FiberFailureCauseId];
  constructor(cause3) {
    const head6 = prettyErrors(cause3)[0];
    super(head6?.message || "An error has occurred");
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause3;
    this.name = head6 ? `(FiberFailure) ${head6.name}` : "FiberFailure";
    if (head6?.stack) {
      this.stack = head6.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
      renderErrorCause: true
    });
  }
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var fiberFailure = (cause3) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error4 = new FiberFailureImpl(cause3);
  Error.stackTraceLimit = limit;
  return error4;
};
var fastPath = (effect4) => {
  const op = effect4;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(NoSuchElementException());
    }
  }
};
var unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime4, effect4) => {
  const op = fastPath(effect4);
  if (op) {
    return op;
  }
  const scheduler = new SyncScheduler();
  const fiberRuntime = unsafeFork3(runtime4)(effect4, {
    scheduler
  });
  scheduler.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
var unsafeRunPromise = /* @__PURE__ */ makeDual((runtime4, effect4, options) => unsafeRunPromiseExit(runtime4, effect4, options).then((result) => {
  switch (result._tag) {
    case OP_SUCCESS: {
      return result.effect_instruction_i0;
    }
    case OP_FAILURE: {
      throw fiberFailure(result.effect_instruction_i0);
    }
  }
}));
var unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime4, effect4, options) => new Promise((resolve9) => {
  const op = fastPath(effect4);
  if (op) {
    resolve9(op);
  }
  const fiber = unsafeFork3(runtime4)(effect4);
  fiber.addObserver((exit4) => {
    resolve9(exit4);
  });
  if (options?.signal !== void 0) {
    if (options.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));
var RuntimeImpl = class {
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context8, runtimeFlags2, fiberRefs3) {
    this.context = context8;
    this.runtimeFlags = runtimeFlags2;
    this.fiberRefs = fiberRefs3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make39 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
var runtime2 = () => withFiberRuntime((state, status2) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status2.runtimeFlags, state.getFiberRefs())));
var defaultRuntimeFlags = /* @__PURE__ */ make17(Interruption, CooperativeYielding, RuntimeMetrics);
var defaultRuntime = /* @__PURE__ */ make39({
  context: /* @__PURE__ */ empty4(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: /* @__PURE__ */ empty19()
});
var unsafeRunEffect = /* @__PURE__ */ unsafeRunCallback(defaultRuntime);
var unsafeForkEffect = /* @__PURE__ */ unsafeFork3(defaultRuntime);
var unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
var unsafeRunPromiseExitEffect = /* @__PURE__ */ unsafeRunPromiseExit(defaultRuntime);
var unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
var unsafeRunSyncExitEffect = /* @__PURE__ */ unsafeRunSyncExit(defaultRuntime);
var asyncEffect = (register) => suspend(() => {
  let cleanup = void 0;
  return flatMap8(deferredMake(), (deferred2) => flatMap8(runtime2(), (runtime4) => uninterruptibleMask((restore) => zipRight(fork(restore(matchCauseEffect(register((cb) => unsafeRunCallback(runtime4)(intoDeferred(cb, deferred2))), {
    onFailure: (cause3) => deferredFailCause(deferred2, cause3),
    onSuccess: (cleanup_) => {
      cleanup = cleanup_;
      return void_;
    }
  }))), restore(onInterrupt(deferredAwait(deferred2), () => cleanup ?? void_))))));
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/synchronizedRef.js
var modifyEffect = /* @__PURE__ */ dual(2, (self2, f2) => self2.modifyEffect(f2));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/layer.js
var LayerSymbolKey = "effect/Layer";
var LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
var layerVariance = {
  /* c8 ignore next */
  _RIn: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _ROut: (_2) => _2
};
var proto3 = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MemoMapTypeIdKey = "effect/Layer/MemoMap";
var MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
var CurrentMemoMap = /* @__PURE__ */ Reference2()("effect/Layer/CurrentMemoMap", {
  defaultValue: () => unsafeMakeMemoMap()
});
var isLayer = (u2) => hasProperty(u2, LayerTypeId);
var isFresh = (self2) => {
  return self2._op_layer === OP_FRESH;
};
var MemoMapImpl = class {
  ref;
  [MemoMapTypeId];
  constructor(ref) {
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  /**
   * Checks the memo map to see if a layer exists. If it is, immediately
   * returns it. Otherwise, obtains the layer, stores it in the memo map,
   * and adds a finalizer to the `Scope`.
   */
  getOrElseMemoize(layer, scope5) {
    return pipe(modifyEffect(this.ref, (map26) => {
      const inMap = map26.get(layer);
      if (inMap !== void 0) {
        const [acquire, release] = inMap;
        const cached4 = pipe(acquire, flatMap8(([patch9, b]) => pipe(patchFiberRefs(patch9), as(b))), onExit(exitMatch({
          onFailure: () => void_,
          onSuccess: () => scopeAddFinalizerExit(scope5, release)
        })));
        return succeed([cached4, map26]);
      }
      return pipe(make24(0), flatMap8((observers) => pipe(deferredMake(), flatMap8((deferred2) => pipe(make24(() => void_), map9((finalizerRef) => {
        const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap8((innerScope) => pipe(restore(flatMap8(makeBuilder(layer, innerScope, true), (f2) => diffFiberRefs(f2(this)))), exit, flatMap8((exit4) => {
          switch (exit4._tag) {
            case OP_FAILURE: {
              return pipe(deferredFailCause(deferred2, exit4.effect_instruction_i0), zipRight(scopeClose(innerScope, exit4)), zipRight(failCause(exit4.effect_instruction_i0)));
            }
            case OP_SUCCESS: {
              return pipe(set4(finalizerRef, (exit5) => pipe(scopeClose(innerScope, exit5), whenEffect(modify2(observers, (n2) => [n2 === 1, n2 - 1])), asVoid)), zipRight(update2(observers, (n2) => n2 + 1)), zipRight(scopeAddFinalizerExit(scope5, (exit5) => pipe(sync(() => map26.delete(layer)), zipRight(get10(finalizerRef)), flatMap8((finalizer3) => finalizer3(exit5))))), zipRight(deferredSucceed(deferred2, exit4.effect_instruction_i0)), as(exit4.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized = [pipe(deferredAwait(deferred2), onExit(exitMatchEffect({
          onFailure: () => void_,
          onSuccess: () => update2(observers, (n2) => n2 + 1)
        }))), (exit4) => pipe(get10(finalizerRef), flatMap8((finalizer3) => finalizer3(exit4)))];
        return [resource, isFresh(layer) ? map26 : map26.set(layer, memoized)];
      }))))));
    }), flatten5);
  }
};
var makeMemoMap = /* @__PURE__ */ suspend(() => map9(makeSynchronized(/* @__PURE__ */ new Map()), (ref) => new MemoMapImpl(ref)));
var unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(/* @__PURE__ */ new Map()));
var build = (self2) => scopeWith((scope5) => buildWithScope(self2, scope5));
var buildWithScope = /* @__PURE__ */ dual(2, (self2, scope5) => flatMap8(makeMemoMap, (memoMap) => buildWithMemoMap(self2, memoMap, scope5)));
var buildWithMemoMap = /* @__PURE__ */ dual(3, (self2, memoMap, scope5) => flatMap8(makeBuilder(self2, scope5), (run5) => provideService(run5(memoMap), CurrentMemoMap, memoMap)));
var makeBuilder = (self2, scope5, inMemoMap = false) => {
  const op = self2;
  switch (op._op_layer) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope5)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope6) => memoMap.getOrElseMemoize(op.layer, scope6)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope5), matchCauseEffect({
        onFailure: (cause3) => memoMap.getOrElseMemoize(op.failureK(cause3), scope5),
        onSuccess: (value) => memoMap.getOrElseMemoize(op.successK(value), scope5)
      })));
    }
    case "Fresh": {
      return sync(() => (_2) => pipe(op.layer, buildWithScope(scope5)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_2) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope5));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), flatMap8((env2) => pipe(memoMap.getOrElseMemoize(op.second, scope5), provideContext(env2)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_2) => scopeExtend(op.effect, scope5)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope5));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope5));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), zipWith3(memoMap.getOrElseMemoize(op.second, scope5), op.zipK)));
    }
    case "ZipWith": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope5), op.zipK, {
        concurrent: true
      })));
    }
  }
};
var catchAll2 = /* @__PURE__ */ dual(2, (self2, onFailure) => match11(self2, {
  onFailure,
  onSuccess: succeedContext
}));
var catchAllCause2 = /* @__PURE__ */ dual(2, (self2, onFailure) => matchCause3(self2, {
  onFailure,
  onSuccess: succeedContext
}));
var die5 = (defect) => failCause6(die4(defect));
var dieSync2 = (evaluate3) => failCauseSync2(() => die4(evaluate3()));
var discard = (self2) => map15(self2, () => empty4());
var context2 = () => fromEffectContext(context());
var extendScope = (self2) => {
  const extendScope3 = Object.create(proto3);
  extendScope3._op_layer = OP_EXTEND_SCOPE;
  extendScope3.layer = self2;
  return extendScope3;
};
var fail7 = (error4) => failCause6(fail5(error4));
var failSync2 = (evaluate3) => failCauseSync2(() => fail5(evaluate3()));
var failCause6 = (cause3) => fromEffectContext(failCause(cause3));
var failCauseSync2 = (evaluate3) => fromEffectContext(failCauseSync(evaluate3));
var flatMap10 = /* @__PURE__ */ dual(2, (self2, f2) => match11(self2, {
  onFailure: fail7,
  onSuccess: f2
}));
var flatten7 = /* @__PURE__ */ dual(2, (self2, tag) => flatMap10(self2, get4(tag)));
var fresh = (self2) => {
  const fresh3 = Object.create(proto3);
  fresh3._op_layer = OP_FRESH;
  fresh3.layer = self2;
  return fresh3;
};
var fromEffect3 = /* @__PURE__ */ dual(2, (a2, b) => {
  const tagFirst = isTag2(a2);
  const tag = tagFirst ? a2 : b;
  const effect4 = tagFirst ? b : a2;
  return fromEffectContext(map9(effect4, (service3) => make7(tag, service3)));
});
var fromEffectDiscard = (effect4) => fromEffectContext(map9(effect4, () => empty4()));
function fromEffectContext(effect4) {
  const fromEffect9 = Object.create(proto3);
  fromEffect9._op_layer = OP_FROM_EFFECT;
  fromEffect9.effect = effect4;
  return fromEffect9;
}
var fiberRefLocally2 = /* @__PURE__ */ dual(3, (self2, ref, value) => locallyEffect(self2, fiberRefLocally(ref, value)));
var locallyEffect = /* @__PURE__ */ dual(2, (self2, f2) => {
  const locally3 = Object.create(proto3);
  locally3._op_layer = "Locally";
  locally3.self = self2;
  locally3.f = f2;
  return locally3;
});
var fiberRefLocallyWith2 = /* @__PURE__ */ dual(3, (self2, ref, value) => locallyEffect(self2, fiberRefLocallyWith(ref, value)));
var fiberRefLocallyScoped2 = (self2, value) => scopedDiscard(fiberRefLocallyScoped(self2, value));
var fiberRefLocallyScopedWith2 = (self2, value) => scopedDiscard(fiberRefLocallyScopedWith(self2, value));
var fromFunction = (tagA, tagB, f2) => fromEffectContext(map9(tagA, (a2) => make7(tagB, f2(a2))));
var launch = (self2) => scopedEffect(zipRight(scopeWith((scope5) => pipe(self2, buildWithScope(scope5))), never));
var map15 = /* @__PURE__ */ dual(2, (self2, f2) => flatMap10(self2, (context8) => succeedContext(f2(context8))));
var mapError2 = /* @__PURE__ */ dual(2, (self2, f2) => catchAll2(self2, (error4) => failSync2(() => f2(error4))));
var matchCause3 = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  const fold2 = Object.create(proto3);
  fold2._op_layer = OP_FOLD;
  fold2.layer = self2;
  fold2.failureK = onFailure;
  fold2.successK = onSuccess;
  return fold2;
});
var match11 = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => matchCause3(self2, {
  onFailure: (cause3) => {
    const failureOrCause3 = failureOrCause2(cause3);
    switch (failureOrCause3._tag) {
      case "Left": {
        return onFailure(failureOrCause3.left);
      }
      case "Right": {
        return failCause6(failureOrCause3.right);
      }
    }
  },
  onSuccess
}));
var memoize2 = (self2) => scopeWith((scope5) => map9(memoize(buildWithScope(self2, scope5)), fromEffectContext));
var merge6 = /* @__PURE__ */ dual(2, (self2, that) => zipWith4(self2, that, (a2, b) => merge3(a2, b)));
var mergeAll3 = (...layers) => {
  let final = layers[0];
  for (let i = 1; i < layers.length; i++) {
    final = merge6(final, layers[i]);
  }
  return final;
};
var orDie2 = (self2) => catchAll2(self2, (defect) => die5(defect));
var orElse5 = /* @__PURE__ */ dual(2, (self2, that) => catchAll2(self2, that));
var passthrough2 = (self2) => merge6(context2(), self2);
var project = /* @__PURE__ */ dual(4, (self2, tagA, tagB, f2) => map15(self2, (context8) => make7(tagB, f2(unsafeGet4(context8, tagA)))));
var retry = /* @__PURE__ */ dual(2, (self2, schedule4) => suspend3(() => {
  const stateTag = GenericTag("effect/Layer/retry/{ state: unknown }");
  return pipe(succeed6(stateTag, {
    state: schedule4.initial
  }), flatMap10((env2) => retryLoop(self2, schedule4, stateTag, pipe(env2, get4(stateTag)).state)));
}));
var retryLoop = (self2, schedule4, stateTag, state) => {
  return pipe(self2, catchAll2((error4) => pipe(retryUpdate(schedule4, stateTag, error4, state), flatMap10((env2) => fresh(retryLoop(self2, schedule4, stateTag, pipe(env2, get4(stateTag)).state))))));
};
var retryUpdate = (schedule4, stateTag, error4, state) => {
  return fromEffect3(stateTag, pipe(currentTimeMillis2, flatMap8((now) => pipe(schedule4.step(now, error4, state), flatMap8(([state2, _2, decision]) => isDone5(decision) ? fail2(error4) : pipe(sleep2(millis(start2(decision.intervals) - now)), as({
    state: state2
  })))))));
};
var scoped = /* @__PURE__ */ dual(2, (a2, b) => {
  const tagFirst = isTag2(a2);
  const tag = tagFirst ? a2 : b;
  const effect4 = tagFirst ? b : a2;
  return scopedContext(map9(effect4, (service3) => make7(tag, service3)));
});
var scopedDiscard = (effect4) => scopedContext(pipe(effect4, as(empty4())));
var scopedContext = (effect4) => {
  const scoped7 = Object.create(proto3);
  scoped7._op_layer = OP_SCOPED;
  scoped7.effect = effect4;
  return scoped7;
};
var scope2 = /* @__PURE__ */ scopedContext(/* @__PURE__ */ map9(/* @__PURE__ */ acquireRelease(/* @__PURE__ */ scopeMake(), (scope5, exit4) => scope5.close(exit4)), (scope5) => make7(Scope, scope5)));
var service = (tag) => fromEffect3(tag, tag);
var succeed6 = /* @__PURE__ */ dual(2, (a2, b) => {
  const tagFirst = isTag2(a2);
  const tag = tagFirst ? a2 : b;
  const resource = tagFirst ? b : a2;
  return fromEffectContext(succeed(make7(tag, resource)));
});
var succeedContext = (context8) => {
  return fromEffectContext(succeed(context8));
};
var empty28 = /* @__PURE__ */ succeedContext(/* @__PURE__ */ empty4());
var suspend3 = (evaluate3) => {
  const suspend15 = Object.create(proto3);
  suspend15._op_layer = OP_SUSPEND;
  suspend15.evaluate = evaluate3;
  return suspend15;
};
var sync3 = /* @__PURE__ */ dual(2, (a2, b) => {
  const tagFirst = isTag2(a2);
  const tag = tagFirst ? a2 : b;
  const evaluate3 = tagFirst ? b : a2;
  return fromEffectContext(sync(() => make7(tag, evaluate3())));
});
var syncContext = (evaluate3) => {
  return fromEffectContext(sync(evaluate3));
};
var tap2 = /* @__PURE__ */ dual(2, (self2, f2) => flatMap10(self2, (context8) => fromEffectContext(as(f2(context8), context8))));
var tapError2 = /* @__PURE__ */ dual(2, (self2, f2) => catchAll2(self2, (e) => fromEffectContext(flatMap8(f2(e), () => fail2(e)))));
var tapErrorCause2 = /* @__PURE__ */ dual(2, (self2, f2) => catchAllCause2(self2, (cause3) => fromEffectContext(flatMap8(f2(cause3), () => failCause(cause3)))));
var toRuntime = (self2) => pipe(scopeWith((scope5) => buildWithScope(self2, scope5)), flatMap8((context8) => pipe(runtime2(), provideContext(context8))));
var toRuntimeWithMemoMap = /* @__PURE__ */ dual(2, (self2, memoMap) => flatMap8(scopeWith((scope5) => buildWithMemoMap(self2, memoMap, scope5)), (context8) => pipe(runtime2(), provideContext(context8))));
var provide = /* @__PURE__ */ dual(2, (self2, that) => suspend3(() => {
  const provideTo = Object.create(proto3);
  provideTo._op_layer = OP_PROVIDE;
  provideTo.first = Object.create(proto3, {
    _op_layer: {
      value: OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context2(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll3(...that) : that
    },
    zipK: {
      value: (a2, b) => pipe(a2, merge3(b))
    }
  });
  provideTo.second = self2;
  return provideTo;
}));
var provideMerge = /* @__PURE__ */ dual(2, (that, self2) => {
  const zipWith14 = Object.create(proto3);
  zipWith14._op_layer = OP_PROVIDE_MERGE;
  zipWith14.first = self2;
  zipWith14.second = provide(that, self2);
  zipWith14.zipK = (a2, b) => {
    return pipe(a2, merge3(b));
  };
  return zipWith14;
});
var zipWith4 = /* @__PURE__ */ dual(3, (self2, that, f2) => suspend3(() => {
  const zipWith14 = Object.create(proto3);
  zipWith14._op_layer = OP_ZIP_WITH2;
  zipWith14.first = self2;
  zipWith14.second = that;
  zipWith14.zipK = f2;
  return zipWith14;
}));
var unwrapEffect = (self2) => {
  const tag = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
  return flatMap10(fromEffect3(tag, self2), (context8) => get4(context8, tag));
};
var unwrapScoped = (self2) => {
  const tag = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
  return flatMap10(scoped(tag, self2), (context8) => get4(context8, tag));
};
var annotateLogs2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations) => Object.entries(args2[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations));
});
var annotateSpans2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations) => Object.entries(args2[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations));
});
var withSpan2 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return unwrapScoped(map9(options?.onEnd ? tap(makeSpanScoped(name, options), (span4) => addFinalizer((exit4) => options.onEnd(span4, exit4))) : makeSpanScoped(name, options), (span4) => withParentSpan2(self2, span4)));
  }
  return (self2) => unwrapScoped(map9(options?.onEnd ? tap(makeSpanScoped(name, options), (span4) => addFinalizer((exit4) => options.onEnd(span4, exit4))) : makeSpanScoped(name, options), (span4) => withParentSpan2(self2, span4)));
};
var withParentSpan2 = /* @__PURE__ */ dual(2, (self2, span4) => provide(self2, succeedContext(make7(spanTag, span4))));
var provideSomeLayer = /* @__PURE__ */ dual(2, (self2, layer) => scopedWith((scope5) => flatMap8(buildWithScope(layer, scope5), (context8) => provideSomeContext(self2, context8))));
var provideSomeRuntime = /* @__PURE__ */ dual(2, (self2, rt) => {
  const patchRefs = diff6(defaultRuntime.fiberRefs, rt.fiberRefs);
  const patchFlags = diff4(defaultRuntime.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    const oldContext = fiber.getFiberRef(currentContext);
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch7(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber.currentRuntimeFlags;
    const newFlags = patch4(patchFlags)(oldFlags);
    const rollbackRefs = diff6(newRefs, oldRefs);
    const rollbackFlags = diff4(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber.currentRuntimeFlags = newFlags;
    return ensuring(provideSomeContext(restore(self2), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
      fiber2.setFiberRefs(patch7(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2.currentRuntimeFlags = patch4(rollbackFlags)(fiber2.currentRuntimeFlags);
      return void_;
    }));
  }));
});
var effect_provide = /* @__PURE__ */ dual(2, (self2, source) => {
  if (Array.isArray(source)) {
    return provideSomeLayer(self2, mergeAll3(...source));
  } else if (isLayer(source)) {
    return provideSomeLayer(self2, source);
  } else if (isContext2(source)) {
    return provideSomeContext(self2, source);
  } else if (TypeId13 in source) {
    return flatMap8(source.runtimeEffect, (rt) => provideSomeRuntime(self2, rt));
  } else {
    return provideSomeRuntime(self2, source);
  }
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/console.js
var console2 = /* @__PURE__ */ map9(/* @__PURE__ */ fiberRefGet(currentServices), /* @__PURE__ */ get4(consoleTag));
var consoleWith = (f2) => fiberRefGetWith(currentServices, (services) => f2(get4(services, consoleTag)));
var withConsole = /* @__PURE__ */ dual(2, (effect4, value) => fiberRefLocallyWith(effect4, currentServices, add2(consoleTag, value)));
var withConsoleScoped = (console4) => fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console4));
var setConsole = (console4) => scopedDiscard(fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console4)));
var assert = (condition, ...args2) => consoleWith((_2) => _2.assert(condition, ...args2));
var clear = /* @__PURE__ */ consoleWith((_2) => _2.clear);
var count = (label) => consoleWith((_2) => _2.count(label));
var countReset = (label) => consoleWith((_2) => _2.countReset(label));
var debug = (...args2) => consoleWith((_2) => _2.debug(...args2));
var dir = (item, options) => consoleWith((_2) => _2.dir(item, options));
var dirxml = (...args2) => consoleWith((_2) => _2.dirxml(...args2));
var error = (...args2) => consoleWith((_2) => _2.error(...args2));
var group = (options) => consoleWith((_2) => acquireRelease(_2.group(options), () => _2.groupEnd));
var info = (...args2) => consoleWith((_2) => _2.info(...args2));
var log2 = (...args2) => consoleWith((_2) => _2.log(...args2));
var table = (tabularData, properties) => consoleWith((_2) => _2.table(tabularData, properties));
var time = (label) => consoleWith((_2) => acquireRelease(_2.time(label), () => _2.timeEnd(label)));
var timeLog = (label, ...args2) => consoleWith((_2) => _2.timeLog(label, ...args2));
var trace = (...args2) => consoleWith((_2) => _2.trace(...args2));
var warn = (...args2) => consoleWith((_2) => _2.warn(...args2));
var withGroup = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, options) => consoleWith((_2) => acquireUseRelease(_2.group(options), () => self2, () => _2.groupEnd)));
var withTime = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, label) => consoleWith((_2) => acquireUseRelease(_2.time(label), () => self2, () => _2.timeEnd(label))));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/MutableList.js
var TypeId14 = /* @__PURE__ */ Symbol.for("effect/MutableList");
var MutableListProto = {
  [TypeId14]: TypeId14,
  [Symbol.iterator]() {
    let done11 = false;
    let head6 = this.head;
    return {
      next() {
        if (done11) {
          return this.return();
        }
        if (head6 == null) {
          done11 = true;
          return this.return();
        }
        const value = head6.value;
        head6 = head6.next;
        return {
          done: done11,
          value
        };
      },
      return(value) {
        if (!done11) {
          done11 = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeNode = (value) => ({
  value,
  removed: false,
  prev: void 0,
  next: void 0
});
var empty29 = () => {
  const list = Object.create(MutableListProto);
  list.head = void 0;
  list.tail = void 0;
  list._length = 0;
  return list;
};
var isEmpty8 = (self2) => length(self2) === 0;
var length = (self2) => self2._length;
var append3 = /* @__PURE__ */ dual(2, (self2, value) => {
  const node = makeNode(value);
  if (self2.head === void 0) {
    self2.head = node;
  }
  if (self2.tail === void 0) {
    self2.tail = node;
  } else {
    self2.tail.next = node;
    node.prev = self2.tail;
    self2.tail = node;
  }
  self2._length += 1;
  return self2;
});
var shift = (self2) => {
  const head6 = self2.head;
  if (head6 !== void 0) {
    remove7(self2, head6);
    return head6.value;
  }
  return void 0;
};
var remove7 = (self2, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== void 0 && node.next !== void 0) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== void 0) {
    self2.tail = node.prev;
    node.prev.next = void 0;
  } else if (node.next !== void 0) {
    self2.head = node.next;
    node.next.prev = void 0;
  } else {
    self2.tail = void 0;
    self2.head = void 0;
  }
  if (self2._length > 0) {
    self2._length -= 1;
  }
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/MutableQueue.js
var TypeId15 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
var EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto = {
  [TypeId15]: TypeId15,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make40 = (capacity7) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty29();
  queue.capacity = capacity7;
  return queue;
};
var bounded = (capacity7) => make40(capacity7);
var unbounded = () => make40(void 0);
var length2 = (self2) => length(self2.queue);
var isEmpty9 = (self2) => isEmpty8(self2.queue);
var capacity = (self2) => self2.capacity === void 0 ? Infinity : self2.capacity;
var offer = /* @__PURE__ */ dual(2, (self2, value) => {
  const queueLength = length(self2.queue);
  if (self2.capacity !== void 0 && queueLength === self2.capacity) {
    return false;
  }
  append3(value)(self2.queue);
  return true;
});
var offerAll = /* @__PURE__ */ dual(2, (self2, values3) => {
  const iterator = values3[Symbol.iterator]();
  let next;
  let remainder = empty2();
  let offering = true;
  while (offering && (next = iterator.next()) && !next.done) {
    offering = offer(next.value)(self2);
  }
  while (next != null && !next.done) {
    remainder = prepend2(next.value)(remainder);
    next = iterator.next();
  }
  return reverse2(remainder);
});
var poll4 = /* @__PURE__ */ dual(2, (self2, def) => {
  if (isEmpty8(self2.queue)) {
    return def;
  }
  return shift(self2.queue);
});
var pollUpTo = /* @__PURE__ */ dual(2, (self2, n2) => {
  let result = empty2();
  let count5 = 0;
  while (count5 < n2) {
    const element = poll4(EmptyMutableQueue)(self2);
    if (element === EmptyMutableQueue) {
      break;
    }
    result = prepend2(element)(result);
    count5 += 1;
  }
  return reverse2(result);
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/cache.js
var complete2 = (key, exit4, entryStats, timeToLiveMillis) => struct({
  _tag: "Complete",
  key,
  exit: exit4,
  entryStats,
  timeToLiveMillis
});
var pending2 = (key, deferred2) => struct({
  _tag: "Pending",
  key,
  deferred: deferred2
});
var refreshing = (deferred2, complete3) => struct({
  _tag: "Refreshing",
  deferred: deferred2,
  complete: complete3
});
var MapKeyTypeId = /* @__PURE__ */ Symbol.for("effect/Cache/MapKey");
var MapKeyImpl = class {
  current;
  [MapKeyTypeId] = MapKeyTypeId;
  previous = void 0;
  next = void 0;
  constructor(current2) {
    this.current = current2;
  }
  [symbol]() {
    return pipe(hash(this.current), combine(hash(this.previous)), combine(hash(this.next)), cached(this));
  }
  [symbol2](that) {
    if (this === that) {
      return true;
    }
    return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
  }
};
var makeMapKey = (current2) => new MapKeyImpl(current2);
var isMapKey = (u2) => hasProperty(u2, MapKeyTypeId);
var KeySetImpl = class {
  head = void 0;
  tail = void 0;
  add(key) {
    if (key !== this.tail) {
      if (this.tail === void 0) {
        this.head = key;
        this.tail = key;
      } else {
        const previous2 = key.previous;
        const next = key.next;
        if (next !== void 0) {
          key.next = void 0;
          if (previous2 !== void 0) {
            previous2.next = next;
            next.previous = previous2;
          } else {
            this.head = next;
            this.head.previous = void 0;
          }
        }
        this.tail.next = key;
        key.previous = this.tail;
        this.tail = key;
      }
    }
  }
  remove() {
    const key = this.head;
    if (key !== void 0) {
      const next = key.next;
      if (next !== void 0) {
        key.next = void 0;
        this.head = next;
        this.head.previous = void 0;
      } else {
        this.head = void 0;
        this.tail = void 0;
      }
    }
    return key;
  }
};
var makeKeySet = () => new KeySetImpl();
var makeCacheState = (map26, keys5, accesses, updating, hits, misses) => ({
  map: map26,
  keys: keys5,
  accesses,
  updating,
  hits,
  misses
});
var initialCacheState = () => makeCacheState(empty21(), makeKeySet(), unbounded(), make12(false), 0, 0);
var CacheSymbolKey = "effect/Cache";
var CacheTypeId = /* @__PURE__ */ Symbol.for(CacheSymbolKey);
var cacheVariance = {
  /* c8 ignore next */
  _Key: (_2) => _2,
  /* c8 ignore next */
  _Error: (_2) => _2,
  /* c8 ignore next */
  _Value: (_2) => _2
};
var ConsumerCacheSymbolKey = "effect/ConsumerCache";
var ConsumerCacheTypeId = /* @__PURE__ */ Symbol.for(ConsumerCacheSymbolKey);
var consumerCacheVariance = {
  /* c8 ignore next */
  _Key: (_2) => _2,
  /* c8 ignore next */
  _Error: (_2) => _2,
  /* c8 ignore next */
  _Value: (_2) => _2
};
var makeCacheStats = (options) => options;
var makeEntryStats = (loadedMillis) => ({
  loadedMillis
});
var CacheImpl = class {
  capacity;
  context;
  fiberId;
  lookup;
  timeToLive;
  [CacheTypeId] = cacheVariance;
  [ConsumerCacheTypeId] = consumerCacheVariance;
  cacheState;
  constructor(capacity7, context8, fiberId3, lookup, timeToLive) {
    this.capacity = capacity7;
    this.context = context8;
    this.fiberId = fiberId3;
    this.lookup = lookup;
    this.timeToLive = timeToLive;
    this.cacheState = initialCacheState();
  }
  get(key) {
    return map9(this.getEither(key), merge);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size5(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get12(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value) => this.resolveMapValue(value)
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get12(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value) => this.resolveMapValue(value, true)
    }));
  }
  contains(key) {
    return sync(() => has4(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const option5 = get12(this.cacheState.map, key);
      if (isSome2(option5)) {
        switch (option5.value._tag) {
          case "Complete": {
            const loaded = option5.value.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
          case "Pending": {
            return none2();
          }
          case "Refreshing": {
            const loaded = option5.value.complete.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
        }
      }
      return none2();
    });
  }
  getEither(key) {
    return suspend(() => {
      const k = key;
      let mapKey = void 0;
      let deferred2 = void 0;
      let value = getOrUndefined(get12(this.cacheState.map, k));
      if (value === void 0) {
        deferred2 = unsafeMake3(this.fiberId);
        mapKey = makeMapKey(k);
        if (has4(this.cacheState.map, k)) {
          value = getOrUndefined(get12(this.cacheState.map, k));
        } else {
          set6(this.cacheState.map, k, pending2(mapKey, deferred2));
        }
      }
      if (value === void 0) {
        this.trackAccess(mapKey);
        this.trackMiss();
        return map9(this.lookupValueOf(key, deferred2), right2);
      } else {
        return flatMap8(this.resolveMapValue(value), match2({
          onNone: () => this.getEither(key),
          onSome: (value2) => succeed(left2(value2))
        }));
      }
    });
  }
  invalidate(key) {
    return sync(() => {
      remove5(this.cacheState.map, key);
    });
  }
  invalidateWhen(key, when5) {
    return sync(() => {
      const value = get12(this.cacheState.map, key);
      if (isSome2(value) && value.value._tag === "Complete") {
        if (value.value.exit._tag === "Success") {
          if (when5(value.value.exit.value)) {
            remove5(this.cacheState.map, key);
          }
        }
      }
    });
  }
  get invalidateAll() {
    return sync(() => {
      this.cacheState.map = empty21();
    });
  }
  refresh(key) {
    return clockWith3((clock3) => suspend(() => {
      const k = key;
      const deferred2 = unsafeMake3(this.fiberId);
      let value = getOrUndefined(get12(this.cacheState.map, k));
      if (value === void 0) {
        if (has4(this.cacheState.map, k)) {
          value = getOrUndefined(get12(this.cacheState.map, k));
        } else {
          set6(this.cacheState.map, k, pending2(makeMapKey(k), deferred2));
        }
      }
      if (value === void 0) {
        return asVoid(this.lookupValueOf(key, deferred2));
      } else {
        switch (value._tag) {
          case "Complete": {
            if (this.hasExpired(clock3, value.timeToLiveMillis)) {
              const found2 = getOrUndefined(get12(this.cacheState.map, k));
              if (equals(found2, value)) {
                remove5(this.cacheState.map, k);
              }
              return asVoid(this.get(key));
            }
            return pipe(this.lookupValueOf(key, deferred2), when(() => {
              const current2 = getOrUndefined(get12(this.cacheState.map, k));
              if (equals(current2, value)) {
                const mapValue = refreshing(deferred2, value);
                set6(this.cacheState.map, k, mapValue);
                return true;
              }
              return false;
            }), asVoid);
          }
          case "Pending": {
            return _await(value.deferred);
          }
          case "Refreshing": {
            return _await(value.deferred);
          }
        }
      }
    }));
  }
  set(key, value) {
    return clockWith3((clock3) => sync(() => {
      const now = clock3.unsafeCurrentTimeMillis();
      const k = key;
      const lookupResult = succeed4(value);
      const mapValue = complete2(makeMapKey(k), lookupResult, makeEntryStats(now), now + toMillis(decode(this.timeToLive(lookupResult))));
      set6(this.cacheState.map, k, mapValue);
    }));
  }
  get size() {
    return sync(() => {
      return size5(this.cacheState.map);
    });
  }
  get values() {
    return sync(() => {
      const values3 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values3.push(entry[1].exit.value);
        }
      }
      return values3;
    });
  }
  get entries() {
    return sync(() => {
      const values3 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values3.push([entry[0], entry[1].exit.value]);
        }
      }
      return values3;
    });
  }
  get keys() {
    return sync(() => {
      const keys5 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          keys5.push(entry[0]);
        }
      }
      return keys5;
    });
  }
  resolveMapValue(value, ignorePending = false) {
    return clockWith3((clock3) => {
      switch (value._tag) {
        case "Complete": {
          this.trackAccess(value.key);
          if (this.hasExpired(clock3, value.timeToLiveMillis)) {
            remove5(this.cacheState.map, value.key.current);
            return succeed(none2());
          }
          this.trackHit();
          return map9(value.exit, some2);
        }
        case "Pending": {
          this.trackAccess(value.key);
          this.trackHit();
          if (ignorePending) {
            return succeed(none2());
          }
          return map9(_await(value.deferred), some2);
        }
        case "Refreshing": {
          this.trackAccess(value.complete.key);
          this.trackHit();
          if (this.hasExpired(clock3, value.complete.timeToLiveMillis)) {
            if (ignorePending) {
              return succeed(none2());
            }
            return map9(_await(value.deferred), some2);
          }
          return map9(value.complete.exit, some2);
        }
      }
    });
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop3 = true;
      while (loop3) {
        const key2 = poll4(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop3 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size16 = size5(this.cacheState.map);
      loop3 = size16 > this.capacity;
      while (loop3) {
        const key2 = this.cacheState.keys.remove();
        if (key2 !== void 0) {
          if (has4(this.cacheState.map, key2.current)) {
            remove5(this.cacheState.map, key2.current);
            size16 = size16 - 1;
            loop3 = size16 > this.capacity;
          }
        } else {
          loop3 = false;
        }
      }
      set2(this.cacheState.updating, false);
    }
  }
  hasExpired(clock3, timeToLiveMillis) {
    return clock3.unsafeCurrentTimeMillis() > timeToLiveMillis;
  }
  lookupValueOf(input2, deferred2) {
    return clockWith3((clock3) => suspend(() => {
      const key = input2;
      return pipe(this.lookup(input2), provideContext(this.context), exit, flatMap8((exit4) => {
        const now = clock3.unsafeCurrentTimeMillis();
        const stats = makeEntryStats(now);
        const value = complete2(makeMapKey(key), exit4, stats, now + toMillis(decode(this.timeToLive(exit4))));
        set6(this.cacheState.map, key, value);
        return zipRight(done2(deferred2, exit4), exit4);
      }), onInterrupt(() => zipRight(interrupt3(deferred2), sync(() => {
        remove5(this.cacheState.map, key);
      }))));
    }));
  }
};
var unsafeMakeWith = (capacity7, lookup, timeToLive) => new CacheImpl(capacity7, empty4(), none3, lookup, (exit4) => decode(timeToLive(exit4)));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/query.js
var currentCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map9(deferredMake(), (handle) => ({
  listeners: new Listeners(),
  handle
})), () => seconds(60))));
var currentCacheEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
var fromRequest = (request2, dataSource) => flatMap8(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id2) => {
  const proxy = new Proxy(request2, {});
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      const cached4 = fiberRefGetWith(currentCache, (cache3) => flatMap8(cache3.getEither(proxy), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            if (orNew.left.listeners.interrupted) {
              return flatMap8(cache3.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached4);
            }
            orNew.left.listeners.increment();
            return uninterruptibleMask((restore) => flatMap8(exit(blocked(empty16, restore(deferredAwait(orNew.left.handle)))), (exit4) => {
              orNew.left.listeners.decrement();
              return exit4;
            }));
          }
          case "Right": {
            orNew.right.listeners.increment();
            return uninterruptibleMask((restore) => flatMap8(exit(blocked(single(ds, makeEntry({
              request: proxy,
              result: orNew.right.handle,
              listeners: orNew.right.listeners,
              ownerId: id2,
              state: {
                completed: false
              }
            })), restore(deferredAwait(orNew.right.handle)))), () => {
              orNew.right.listeners.decrement();
              return deferredAwait(orNew.right.handle);
            }));
          }
        }
      }));
      return cached4;
    }
    const listeners = new Listeners();
    listeners.increment();
    return flatMap8(deferredMake(), (ref) => ensuring(blocked(single(ds, makeEntry({
      request: proxy,
      result: ref,
      listeners,
      ownerId: id2,
      state: {
        completed: false
      }
    })), deferredAwait(ref)), sync(() => listeners.decrement())));
  });
}));
var cacheRequest = (request2, result) => {
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      return fiberRefGetWith(currentCache, (cache3) => flatMap8(cache3.getEither(request2), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            return void_;
          }
          case "Right": {
            return deferredComplete(orNew.right.handle, result);
          }
        }
      }));
    }
    return void_;
  });
};
var withRequestCaching = /* @__PURE__ */ dual(2, (self2, strategy) => fiberRefLocally(self2, currentCacheEnabled, strategy));
var withRequestCache = /* @__PURE__ */ dual(
  2,
  // @ts-expect-error
  (self2, cache3) => fiberRefLocally(self2, currentCache, cache3)
);

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Request.js
var isRequest2 = isRequest;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Effect.js
var EffectTypeId3 = EffectTypeId2;
var isEffect2 = isEffect;
var cachedWithTTL = cached2;
var cachedInvalidateWithTTL2 = cachedInvalidateWithTTL;
var cached3 = memoize;
var cachedFunction2 = cachedFunction;
var once2 = once;
var all4 = all3;
var allWith2 = allWith;
var allSuccesses2 = allSuccesses;
var dropUntil2 = dropUntil;
var dropWhile3 = dropWhile2;
var takeUntil2 = takeUntil;
var takeWhile3 = takeWhile2;
var every6 = every5;
var exists2 = exists;
var filter7 = filter5;
var filterMap5 = filterMap4;
var findFirst7 = findFirst5;
var forEach9 = forEach8;
var head4 = head3;
var mergeAll4 = mergeAll2;
var partition4 = partition3;
var reduce11 = reduce9;
var reduceWhile2 = reduceWhile;
var reduceRight4 = reduceRight3;
var reduceEffect2 = reduceEffect;
var replicate2 = replicate;
var replicateEffect2 = replicateEffect;
var validateAll2 = validateAll;
var validateFirst2 = validateFirst;
var async2 = async_;
var asyncEffect2 = asyncEffect;
var custom2 = custom;
var withFiberRuntime2 = withFiberRuntime;
var fail9 = fail2;
var failSync3 = failSync;
var failCause8 = failCause;
var failCauseSync3 = failCauseSync;
var die6 = die2;
var dieMessage2 = dieMessage;
var dieSync3 = dieSync;
var gen2 = gen;
var never3 = never;
var none9 = none6;
var promise2 = promise;
var succeed8 = succeed;
var succeedNone2 = succeedNone;
var succeedSome2 = succeedSome;
var suspend4 = suspend;
var sync4 = sync;
var _void = void_;
var yieldNow4 = yieldNow;
var _catch2 = _catch;
var catchAll3 = catchAll;
var catchAllCause3 = catchAllCause;
var catchAllDefect2 = catchAllDefect;
var catchIf2 = catchIf;
var catchSome2 = catchSome;
var catchSomeCause2 = catchSomeCause;
var catchSomeDefect2 = catchSomeDefect;
var catchTag2 = catchTag;
var catchTags2 = catchTags;
var cause2 = cause;
var eventually2 = eventually;
var ignore2 = ignore;
var ignoreLogged2 = ignoreLogged;
var parallelErrors2 = parallelErrors;
var sandbox2 = sandbox;
var retry2 = retry_combined;
var retryOrElse = retryOrElse_Effect;
var try_3 = try_2;
var tryMap2 = tryMap;
var tryMapPromise2 = tryMapPromise;
var tryPromise2 = tryPromise;
var unsandbox2 = unsandbox;
var allowInterrupt2 = allowInterrupt;
var checkInterruptible2 = checkInterruptible;
var disconnect2 = disconnect;
var interrupt7 = interrupt2;
var interruptWith2 = interruptWith;
var interruptible4 = interruptible2;
var interruptibleMask2 = interruptibleMask;
var onInterrupt2 = onInterrupt;
var uninterruptible2 = uninterruptible;
var uninterruptibleMask3 = uninterruptibleMask;
var liftPredicate3 = liftPredicate2;
var as4 = as;
var asSome2 = asSome;
var asSomeError2 = asSomeError;
var asVoid2 = asVoid;
var flip2 = flip;
var flipWith2 = flipWith;
var map16 = map9;
var mapAccum4 = mapAccum3;
var mapBoth3 = mapBoth;
var mapError3 = mapError;
var mapErrorCause2 = mapErrorCause;
var merge7 = merge5;
var negate2 = negate;
var acquireRelease2 = acquireRelease;
var acquireReleaseInterruptible2 = acquireReleaseInterruptible;
var acquireUseRelease2 = acquireUseRelease;
var addFinalizer3 = addFinalizer;
var ensuring2 = ensuring;
var onError2 = onError;
var onExit3 = onExit;
var parallelFinalizers2 = parallelFinalizers;
var sequentialFinalizers2 = sequentialFinalizers;
var finalizersMask2 = finalizersMask;
var scope3 = scope;
var scopeWith2 = scopeWith;
var scopedWith2 = scopedWith;
var scoped2 = scopedEffect;
var using2 = using;
var withEarlyRelease2 = withEarlyRelease;
var awaitAllChildren2 = awaitAllChildren;
var daemonChildren2 = daemonChildren;
var descriptor2 = descriptor;
var descriptorWith2 = descriptorWith;
var diffFiberRefs2 = diffFiberRefs;
var ensuringChild2 = ensuringChild;
var ensuringChildren2 = ensuringChildren;
var fiberId2 = fiberId;
var fiberIdWith2 = fiberIdWith;
var fork3 = fork;
var forkDaemon2 = forkDaemon;
var forkAll2 = forkAll;
var forkIn2 = forkIn;
var forkScoped2 = forkScoped;
var forkWithErrorHandler2 = forkWithErrorHandler;
var fromFiber2 = fromFiber;
var fromFiberEffect2 = fromFiberEffect;
var supervised2 = supervised;
var transplant2 = transplant;
var withConcurrency2 = withConcurrency;
var withScheduler2 = withScheduler;
var withSchedulingPriority2 = withSchedulingPriority;
var withMaxOpsBeforeYield2 = withMaxOpsBeforeYield;
var clock2 = clock;
var clockWith4 = clockWith3;
var withClockScoped2 = withClockScoped;
var withClock2 = withClock;
var console3 = console2;
var consoleWith2 = consoleWith;
var withConsoleScoped2 = withConsoleScoped;
var withConsole2 = withConsole;
var delay2 = delay;
var sleep4 = sleep3;
var timed2 = timed;
var timedWith2 = timedWith;
var timeout2 = timeout;
var timeoutOption2 = timeoutOption;
var timeoutFail2 = timeoutFail;
var timeoutFailCause2 = timeoutFailCause;
var timeoutTo2 = timeoutTo;
var configProviderWith2 = configProviderWith;
var withConfigProvider2 = withConfigProvider;
var withConfigProviderScoped2 = withConfigProviderScoped;
var context3 = context;
var contextWith2 = contextWith;
var contextWithEffect2 = contextWithEffect;
var mapInputContext2 = mapInputContext;
var provide2 = effect_provide;
var provideService2 = provideService;
var provideServiceEffect2 = provideServiceEffect;
var serviceFunction2 = serviceFunction;
var serviceFunctionEffect2 = serviceFunctionEffect;
var serviceFunctions2 = serviceFunctions;
var serviceConstants2 = serviceConstants;
var serviceMembers2 = serviceMembers;
var serviceOption2 = serviceOption;
var serviceOptional2 = serviceOptional;
var updateService2 = updateService;
var Do2 = Do;
var bind3 = bind2;
var bindAll2 = bindAll;
var bindTo3 = bindTo2;
var let_3 = let_2;
var option2 = option;
var either3 = either2;
var exit3 = exit;
var intoDeferred2 = intoDeferred;
var if_2 = if_;
var filterOrDie2 = filterOrDie;
var filterOrDieMessage2 = filterOrDieMessage;
var filterOrElse2 = filterOrElse;
var filterOrFail2 = filterOrFail;
var filterEffectOrElse2 = filterEffectOrElse;
var filterEffectOrFail2 = filterEffectOrFail;
var unless2 = unless;
var unlessEffect2 = unlessEffect;
var when2 = when;
var whenEffect2 = whenEffect;
var whenFiberRef2 = whenFiberRef;
var whenRef2 = whenRef;
var flatMap11 = flatMap8;
var andThen5 = andThen2;
var flatten8 = flatten5;
var race2 = race;
var raceAll2 = raceAll;
var raceFirst2 = raceFirst;
var raceWith2 = raceWith;
var summarized2 = summarized;
var tap3 = tap;
var tapBoth2 = tapBoth;
var tapDefect2 = tapDefect;
var tapError3 = tapError;
var tapErrorTag2 = tapErrorTag;
var tapErrorCause3 = tapErrorCause;
var forever3 = forever;
var iterate2 = iterate;
var loop2 = loop;
var repeat = repeat_combined;
var repeatN2 = repeatN;
var repeatOrElse = repeatOrElse_Effect;
var schedule = schedule_Effect;
var scheduleForked2 = scheduleForked;
var scheduleFrom = scheduleFrom_Effect;
var whileLoop3 = whileLoop;
var getFiberRefs = fiberRefs2;
var inheritFiberRefs2 = inheritFiberRefs;
var locally = fiberRefLocally;
var locallyWith = fiberRefLocallyWith;
var locallyScoped = fiberRefLocallyScoped;
var locallyScopedWith = fiberRefLocallyScopedWith;
var patchFiberRefs2 = patchFiberRefs;
var setFiberRefs2 = setFiberRefs;
var updateFiberRefs2 = updateFiberRefs;
var isFailure4 = isFailure;
var isSuccess3 = isSuccess;
var match12 = match8;
var matchCause4 = matchCause;
var matchCauseEffect3 = matchCauseEffect;
var matchEffect2 = matchEffect;
var log3 = log;
var logWithLevel2 = (level, ...message) => logWithLevel(level)(...message);
var logTrace2 = logTrace;
var logDebug2 = logDebug;
var logInfo2 = logInfo;
var logWarning2 = logWarning;
var logError2 = logError;
var logFatal2 = logFatal;
var withLogSpan2 = withLogSpan;
var annotateLogs3 = annotateLogs;
var annotateLogsScoped2 = annotateLogsScoped;
var logAnnotations2 = logAnnotations;
var withUnhandledErrorLogLevel2 = withUnhandledErrorLogLevel;
var whenLogLevel2 = whenLogLevel;
var orDie3 = orDie;
var orDieWith2 = orDieWith;
var orElse6 = orElse2;
var orElseFail2 = orElseFail;
var orElseSucceed2 = orElseSucceed;
var firstSuccessOf2 = firstSuccessOf;
var random3 = random2;
var randomWith2 = randomWith;
var withRandom2 = withRandom;
var withRandomScoped2 = withRandomScoped;
var runtime3 = runtime2;
var getRuntimeFlags = runtimeFlags;
var patchRuntimeFlags = updateRuntimeFlags;
var withRuntimeFlagsPatch = withRuntimeFlags;
var withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
var tagMetrics2 = tagMetrics;
var labelMetrics2 = labelMetrics;
var tagMetricsScoped2 = tagMetricsScoped;
var labelMetricsScoped2 = labelMetricsScoped;
var metricLabels2 = metricLabels;
var withMetric2 = withMetric;
var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
var makeSemaphore2 = makeSemaphore;
var unsafeMakeLatch2 = unsafeMakeLatch;
var makeLatch2 = makeLatch;
var runFork2 = unsafeForkEffect;
var runCallback = unsafeRunEffect;
var runPromise = unsafeRunPromiseEffect;
var runPromiseExit = unsafeRunPromiseExitEffect;
var runSync = unsafeRunSyncEffect;
var runSyncExit = unsafeRunSyncExitEffect;
var validate2 = validate;
var validateWith2 = validateWith;
var zip5 = zipOptions;
var zipLeft2 = zipLeftOptions;
var zipRight3 = zipRightOptions;
var zipWith5 = zipWithOptions;
var ap = /* @__PURE__ */ dual(2, (self2, that) => zipWith5(self2, that, (f2, a2) => f2(a2)));
var blocked2 = blocked;
var runRequestBlock2 = runRequestBlock;
var step3 = step2;
var request = /* @__PURE__ */ dual((args2) => isRequest2(args2[0]), fromRequest);
var cacheRequestResult = cacheRequest;
var withRequestBatching2 = withRequestBatching;
var withRequestCaching2 = withRequestCaching;
var withRequestCache2 = withRequestCache;
var tracer2 = tracer;
var tracerWith4 = tracerWith;
var withTracer2 = withTracer;
var withTracerScoped2 = withTracerScoped;
var withTracerEnabled2 = withTracerEnabled;
var withTracerTiming2 = withTracerTiming;
var annotateSpans3 = annotateSpans;
var annotateCurrentSpan2 = annotateCurrentSpan;
var currentSpan2 = currentSpan;
var currentParentSpan2 = currentParentSpan;
var spanAnnotations2 = spanAnnotations;
var spanLinks2 = spanLinks;
var linkSpans2 = linkSpans;
var linkSpanCurrent2 = linkSpanCurrent;
var makeSpan2 = makeSpan;
var makeSpanScoped2 = makeSpanScoped;
var useSpan2 = useSpan;
var withSpan3 = withSpan;
var functionWithSpan2 = functionWithSpan;
var withSpanScoped2 = withSpanScoped;
var withParentSpan3 = withParentSpan;
var fromNullable3 = fromNullable2;
var optionFromOptional2 = optionFromOptional;
var transposeOption = (self2) => {
  return isNone(self2) ? succeedNone2 : map16(self2.value, some);
};
var transposeMapOption = /* @__PURE__ */ dual(2, (self2, f2) => isNone(self2) ? succeedNone2 : map16(f2(self2.value), some));
var makeTagProxy = (TagClass) => {
  const cache3 = /* @__PURE__ */ new Map();
  return new Proxy(TagClass, {
    get(target, prop, receiver) {
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      }
      if (cache3.has(prop)) {
        return cache3.get(prop);
      }
      const fn2 = (...args2) => andThen2(target, (s2) => {
        if (typeof s2[prop] === "function") {
          cache3.set(prop, (...args3) => andThen2(target, (s3) => s3[prop](...args3)));
          return s2[prop](...args2);
        }
        cache3.set(prop, andThen2(target, (s3) => s3[prop]));
        return s2[prop];
      });
      const cn = andThen2(target, (s2) => s2[prop]);
      Object.assign(fn2, cn);
      Object.setPrototypeOf(fn2, Object.getPrototypeOf(cn));
      cache3.set(prop, fn2);
      return fn2;
    }
  });
};
var Tag2 = (id2) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id2;
  Object.defineProperty(TagClass, "use", {
    get() {
      return (body) => andThen2(this, body);
    }
  });
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return makeTagProxy(TagClass);
};
var Service = function() {
  return function() {
    const [id2, maker] = arguments;
    const proxy = "accessors" in maker ? maker["accessors"] : false;
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error();
    Error.stackTraceLimit = limit;
    let patchState = "unchecked";
    const TagClass = function(service3) {
      if (patchState === "unchecked") {
        const proto14 = Object.getPrototypeOf(service3);
        if (proto14 === Object.prototype || proto14 === null) {
          patchState = "plain";
        } else {
          const selfProto = Object.getPrototypeOf(this);
          Object.setPrototypeOf(selfProto, proto14);
          patchState = "patched";
        }
      }
      if (patchState === "plain") {
        Object.assign(this, service3);
      } else if (patchState === "patched") {
        Object.setPrototypeOf(service3, Object.getPrototypeOf(this));
        return service3;
      }
    };
    TagClass.prototype._tag = id2;
    Object.defineProperty(TagClass, "make", {
      get() {
        return (service3) => new this(service3);
      }
    });
    Object.defineProperty(TagClass, "use", {
      get() {
        return (body) => andThen2(this, body);
      }
    });
    TagClass.key = id2;
    Object.assign(TagClass, TagProto);
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
    const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
    let layerCache;
    if ("effect" in maker) {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= fromEffect3(TagClass, map16(maker.effect, (_2) => new this(_2)));
        }
      });
    } else if ("scoped" in maker) {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= scoped(TagClass, map16(maker.scoped, (_2) => new this(_2)));
        }
      });
    } else if ("sync" in maker) {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= sync3(TagClass, () => new this(maker.sync()));
        }
      });
    } else {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= succeed6(TagClass, new this(maker.succeed));
        }
      });
    }
    if (hasDeps) {
      let layerWithDepsCache;
      Object.defineProperty(TagClass, "Default", {
        get() {
          return layerWithDepsCache ??= provide(this.DefaultWithoutDependencies, maker.dependencies);
        }
      });
    }
    return proxy === true ? makeTagProxy(TagClass) : TagClass;
  };
};
var fn = function(nameOrBody, ...pipeables) {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const errorDef = new Error();
  Error.stackTraceLimit = limit;
  if (typeof nameOrBody !== "string") {
    return defineLength(nameOrBody.length, function(...args2) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body: nameOrBody,
        args: args2,
        pipeables,
        spanName: "<anonymous>",
        spanOptions: {
          context: DisablePropagation.context(true)
        },
        errorDef,
        errorCall
      });
    });
  }
  const name = nameOrBody;
  const options = pipeables[0];
  return (body, ...pipeables2) => defineLength(body.length, function(...args2) {
    const limit2 = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const errorCall = new Error();
    Error.stackTraceLimit = limit2;
    return fnApply({
      self: this,
      body,
      args: args2,
      pipeables: pipeables2,
      spanName: name,
      spanOptions: options,
      errorDef,
      errorCall
    });
  });
};
function defineLength(length3, fn2) {
  return Object.defineProperty(fn2, "length", {
    value: length3,
    configurable: true
  });
}
function fnApply(options) {
  let effect4;
  let fnError = void 0;
  if (isGeneratorFunction(options.body)) {
    effect4 = fromIterator(() => options.body.apply(options.self, options.args));
  } else {
    try {
      effect4 = options.body.apply(options.self, options.args);
    } catch (error4) {
      fnError = error4;
      effect4 = die6(error4);
    }
  }
  if (options.pipeables.length > 0) {
    try {
      for (const x2 of options.pipeables) {
        effect4 = x2(effect4, ...options.args);
      }
    } catch (error4) {
      effect4 = fnError ? failCause8(sequential(die(fnError), die(error4))) : die6(error4);
    }
  }
  let cache3 = false;
  const captureStackTrace = () => {
    if (cache3 !== false) {
      return cache3;
    }
    if (options.errorCall.stack) {
      const stackDef = options.errorDef.stack.trim().split("\n");
      const stackCall = options.errorCall.stack.trim().split("\n");
      cache3 = `${stackDef.slice(2).join("\n").trim()}
${stackCall.slice(2).join("\n").trim()}`;
      return cache3;
    }
  };
  const opts = options.spanOptions && "captureStackTrace" in options.spanOptions ? options.spanOptions : {
    captureStackTrace,
    ...options.spanOptions
  };
  return withSpan3(effect4, options.spanName, opts);
}
var fnUntraced2 = fnUntraced;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/FiberRef.js
var get13 = fiberRefGet;
var getWith = fiberRefGetWith;
var currentContext2 = currentContext;
var currentSchedulingPriority2 = currentSchedulingPriority;
var currentLoggers2 = currentLoggers;
var currentScheduler2 = currentScheduler;
var currentTracerTimingEnabled2 = currentTracerTimingEnabled;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Layer.js
var Layer_exports = {};
__export(Layer_exports, {
  CurrentMemoMap: () => CurrentMemoMap2,
  LayerTypeId: () => LayerTypeId2,
  MemoMapTypeId: () => MemoMapTypeId2,
  annotateLogs: () => annotateLogs4,
  annotateSpans: () => annotateSpans4,
  build: () => build2,
  buildWithMemoMap: () => buildWithMemoMap2,
  buildWithScope: () => buildWithScope2,
  catchAll: () => catchAll4,
  catchAllCause: () => catchAllCause4,
  context: () => context4,
  die: () => die7,
  dieSync: () => dieSync4,
  discard: () => discard2,
  effect: () => effect,
  effectContext: () => effectContext,
  effectDiscard: () => effectDiscard,
  empty: () => empty30,
  extendScope: () => extendScope2,
  fail: () => fail10,
  failCause: () => failCause9,
  failCauseSync: () => failCauseSync4,
  failSync: () => failSync4,
  fiberRefLocallyScopedWith: () => fiberRefLocallyScopedWith3,
  flatMap: () => flatMap12,
  flatten: () => flatten9,
  fresh: () => fresh2,
  function: () => fromFunction2,
  isFresh: () => isFresh2,
  isLayer: () => isLayer2,
  launch: () => launch2,
  locally: () => locally2,
  locallyEffect: () => locallyEffect2,
  locallyScoped: () => locallyScoped2,
  locallyWith: () => locallyWith2,
  makeMemoMap: () => makeMemoMap2,
  map: () => map17,
  mapError: () => mapError4,
  match: () => match13,
  matchCause: () => matchCause5,
  memoize: () => memoize3,
  merge: () => merge8,
  mergeAll: () => mergeAll5,
  orDie: () => orDie4,
  orElse: () => orElse7,
  parentSpan: () => parentSpan2,
  passthrough: () => passthrough3,
  project: () => project2,
  provide: () => provide3,
  provideMerge: () => provideMerge2,
  retry: () => retry3,
  scope: () => scope4,
  scoped: () => scoped3,
  scopedContext: () => scopedContext2,
  scopedDiscard: () => scopedDiscard2,
  service: () => service2,
  setClock: () => setClock,
  setConfigProvider: () => setConfigProvider2,
  setRequestBatching: () => setRequestBatching,
  setRequestCache: () => setRequestCache,
  setRequestCaching: () => setRequestCaching,
  setScheduler: () => setScheduler,
  setTracer: () => setTracer2,
  setTracerEnabled: () => setTracerEnabled,
  setTracerTiming: () => setTracerTiming,
  setUnhandledErrorLogLevel: () => setUnhandledErrorLogLevel,
  span: () => span3,
  succeed: () => succeed9,
  succeedContext: () => succeedContext2,
  suspend: () => suspend5,
  sync: () => sync5,
  syncContext: () => syncContext2,
  tap: () => tap4,
  tapError: () => tapError4,
  tapErrorCause: () => tapErrorCause4,
  toRuntime: () => toRuntime2,
  toRuntimeWithMemoMap: () => toRuntimeWithMemoMap2,
  unwrapEffect: () => unwrapEffect2,
  unwrapScoped: () => unwrapScoped2,
  updateService: () => updateService3,
  withParentSpan: () => withParentSpan4,
  withSpan: () => withSpan4,
  zipWith: () => zipWith6
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/layer/circular.js
var setConfigProvider = (configProvider) => scopedDiscard(withConfigProviderScoped(configProvider));
var parentSpan = (span4) => succeedContext(make7(spanTag, span4));
var span2 = (name, options) => {
  options = addSpanStackTrace(options);
  return scoped(spanTag, options?.onEnd ? tap(makeSpanScoped(name, options), (span4) => addFinalizer((exit4) => options.onEnd(span4, exit4))) : makeSpanScoped(name, options));
};
var setTracer = (tracer3) => scopedDiscard(withTracerScoped(tracer3));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Layer.js
var LayerTypeId2 = LayerTypeId;
var MemoMapTypeId2 = MemoMapTypeId;
var CurrentMemoMap2 = CurrentMemoMap;
var isLayer2 = isLayer;
var isFresh2 = isFresh;
var annotateLogs4 = annotateLogs2;
var annotateSpans4 = annotateSpans2;
var build2 = build;
var buildWithScope2 = buildWithScope;
var catchAll4 = catchAll2;
var catchAllCause4 = catchAllCause2;
var context4 = context2;
var die7 = die5;
var dieSync4 = dieSync2;
var discard2 = discard;
var effect = fromEffect3;
var effectDiscard = fromEffectDiscard;
var effectContext = fromEffectContext;
var empty30 = empty28;
var extendScope2 = extendScope;
var fail10 = fail7;
var failSync4 = failSync2;
var failCause9 = failCause6;
var failCauseSync4 = failCauseSync2;
var flatMap12 = flatMap10;
var flatten9 = flatten7;
var fresh2 = fresh;
var fromFunction2 = fromFunction;
var launch2 = launch;
var map17 = map15;
var mapError4 = mapError2;
var match13 = match11;
var matchCause5 = matchCause3;
var memoize3 = memoize2;
var merge8 = merge6;
var mergeAll5 = mergeAll3;
var orDie4 = orDie2;
var orElse7 = orElse5;
var passthrough3 = passthrough2;
var project2 = project;
var locallyEffect2 = locallyEffect;
var locally2 = fiberRefLocally2;
var locallyWith2 = fiberRefLocallyWith2;
var locallyScoped2 = fiberRefLocallyScoped2;
var fiberRefLocallyScopedWith3 = fiberRefLocallyScopedWith2;
var retry3 = retry;
var scope4 = scope2;
var scoped3 = scoped;
var scopedDiscard2 = scopedDiscard;
var scopedContext2 = scopedContext;
var service2 = service;
var succeed9 = succeed6;
var succeedContext2 = succeedContext;
var suspend5 = suspend3;
var sync5 = sync3;
var syncContext2 = syncContext;
var tap4 = tap2;
var tapError4 = tapError2;
var tapErrorCause4 = tapErrorCause2;
var toRuntime2 = toRuntime;
var toRuntimeWithMemoMap2 = toRuntimeWithMemoMap;
var provide3 = provide;
var provideMerge2 = provideMerge;
var zipWith6 = zipWith4;
var unwrapEffect2 = unwrapEffect;
var unwrapScoped2 = unwrapScoped;
var setClock = (clock3) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(clockTag, clock3)));
var setConfigProvider2 = setConfigProvider;
var parentSpan2 = parentSpan;
var setRequestBatching = (requestBatching) => scopedDiscard2(fiberRefLocallyScoped(currentRequestBatching, requestBatching));
var setRequestCaching = (requestCaching) => scopedDiscard2(fiberRefLocallyScoped(currentCacheEnabled, requestCaching));
var setRequestCache = (cache3) => scopedDiscard2(isEffect(cache3) ? flatMap8(cache3, (x2) => fiberRefLocallyScoped(currentCache, x2)) : fiberRefLocallyScoped(currentCache, cache3));
var setScheduler = (scheduler) => scopedDiscard2(fiberRefLocallyScoped(currentScheduler, scheduler));
var span3 = span2;
var setTracer2 = setTracer;
var setTracerEnabled = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerEnabled, enabled2));
var setTracerTiming = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerTimingEnabled, enabled2));
var setUnhandledErrorLogLevel = (level) => scopedDiscard2(fiberRefLocallyScoped(currentUnhandledErrorLogLevel, level));
var withSpan4 = withSpan2;
var withParentSpan4 = withParentSpan2;
var makeMemoMap2 = makeMemoMap;
var buildWithMemoMap2 = buildWithMemoMap;
var updateService3 = /* @__PURE__ */ dual(3, (layer, tag, f2) => provide3(layer, map17(context4(), (c) => add2(c, tag, f2(unsafeGet4(c, tag))))));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Config.js
var Config_exports = {};
__export(Config_exports, {
  ConfigTypeId: () => ConfigTypeId2,
  all: () => all6,
  array: () => array5,
  boolean: () => boolean2,
  chunk: () => chunk3,
  date: () => date2,
  duration: () => duration2,
  fail: () => fail12,
  hashMap: () => hashMap3,
  hashSet: () => hashSet3,
  integer: () => integer2,
  isConfig: () => isConfig2,
  literal: () => literal2,
  logLevel: () => logLevel2,
  map: () => map19,
  mapAttempt: () => mapAttempt2,
  mapOrFail: () => mapOrFail2,
  nested: () => nested4,
  nonEmptyString: () => nonEmptyString2,
  number: () => number4,
  option: () => option4,
  orElse: () => orElse9,
  orElseIf: () => orElseIf2,
  primitive: () => primitive2,
  redacted: () => redacted2,
  repeat: () => repeat3,
  secret: () => secret2,
  string: () => string3,
  succeed: () => succeed11,
  suspend: () => suspend7,
  sync: () => sync7,
  unwrap: () => unwrap2,
  url: () => url2,
  validate: () => validate4,
  withDefault: () => withDefault2,
  withDescription: () => withDescription2,
  zip: () => zip7,
  zipWith: () => zipWith8
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/ConfigError.js
var isMissingDataOnly2 = isMissingDataOnly;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/redacted.js
var RedactedSymbolKey = "effect/Redacted";
var redactedRegistry = /* @__PURE__ */ globalValue("effect/Redacted/redactedRegistry", () => /* @__PURE__ */ new WeakMap());
var RedactedTypeId = /* @__PURE__ */ Symbol.for(RedactedSymbolKey);
var proto4 = {
  [RedactedTypeId]: {
    _A: (_2) => _2
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return "<redacted>";
  },
  toJSON() {
    return "<redacted>";
  },
  [NodeInspectSymbol]() {
    return "<redacted>";
  },
  [symbol]() {
    return pipe(hash(RedactedSymbolKey), combine(hash(redactedRegistry.get(this))), cached(this));
  },
  [symbol2](that) {
    return isRedacted(that) && equals(redactedRegistry.get(this), redactedRegistry.get(that));
  }
};
var isRedacted = (u2) => hasProperty(u2, RedactedTypeId);
var make41 = (value) => {
  const redacted3 = Object.create(proto4);
  redactedRegistry.set(redacted3, value);
  return redacted3;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/secret.js
var SecretSymbolKey = "effect/Secret";
var SecretTypeId = /* @__PURE__ */ Symbol.for(SecretSymbolKey);
var SecretProto = {
  ...proto4,
  [SecretTypeId]: SecretTypeId
};
var make42 = (bytes) => {
  const secret3 = Object.create(SecretProto);
  Object.defineProperty(secret3, "toString", {
    enumerable: false,
    value() {
      return "Secret(<redacted>)";
    }
  });
  Object.defineProperty(secret3, "toJSON", {
    enumerable: false,
    value() {
      return "<redacted>";
    }
  });
  Object.defineProperty(secret3, "raw", {
    enumerable: false,
    value: bytes
  });
  redactedRegistry.set(secret3, bytes.map((byte) => String.fromCharCode(byte)).join(""));
  return secret3;
};
var fromString = (text) => {
  return make42(text.split("").map((char) => char.charCodeAt(0)));
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/config.js
var ConfigSymbolKey = "effect/Config";
var ConfigTypeId = /* @__PURE__ */ Symbol.for(ConfigSymbolKey);
var configVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var proto5 = {
  ...CommitPrototype,
  [ConfigTypeId]: configVariance,
  commit() {
    return config(this);
  }
};
var boolean = (name) => {
  const config2 = primitive("a boolean property", (text) => {
    switch (text) {
      case "true":
      case "yes":
      case "on":
      case "1": {
        return right2(true);
      }
      case "false":
      case "no":
      case "off":
      case "0": {
        return right2(false);
      }
      default: {
        const error4 = InvalidData([], `Expected a boolean value but received ${text}`);
        return left2(error4);
      }
    }
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var url = (name) => {
  const config2 = primitive("an URL property", (text) => try_({
    try: () => new URL(text),
    catch: (_2) => InvalidData([], `Expected an URL value but received ${text}`)
  }));
  return name === void 0 ? config2 : nested3(config2, name);
};
var array4 = (config2, name) => {
  return pipe(chunk2(config2, name), map18(toArray2));
};
var chunk2 = (config2, name) => {
  return map18(name === void 0 ? repeat2(config2) : nested3(repeat2(config2), name), unsafeFromArray);
};
var date = (name) => {
  const config2 = primitive("a date property", (text) => {
    const result = Date.parse(text);
    if (Number.isNaN(result)) {
      return left2(InvalidData([], `Expected a Date value but received ${text}`));
    }
    return right2(new Date(result));
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var fail11 = (message) => {
  const fail19 = Object.create(proto5);
  fail19._tag = OP_FAIL2;
  fail19.message = message;
  fail19.parse = () => left2(Unsupported([], message));
  return fail19;
};
var number3 = (name) => {
  const config2 = primitive("a number property", (text) => {
    const result = Number(text);
    if (Number.isNaN(result)) {
      return left2(InvalidData([], `Expected a number value but received ${text}`));
    }
    return right2(result);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var integer = (name) => {
  const config2 = primitive("an integer property", (text) => {
    const result = Number(text);
    if (!Number.isInteger(result)) {
      return left2(InvalidData([], `Expected an integer value but received ${text}`));
    }
    return right2(result);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var literal = (...literals) => (name) => {
  const valuesString = literals.map(String).join(", ");
  const config2 = primitive(`one of (${valuesString})`, (text) => {
    const found2 = literals.find((value) => String(value) === text);
    if (found2 === void 0) {
      return left2(InvalidData([], `Expected one of (${valuesString}) but received ${text}`));
    }
    return right2(found2);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var logLevel = (name) => {
  const config2 = mapOrFail(string2(), (value) => {
    const label = value.toUpperCase();
    const level = allLogLevels.find((level2) => level2.label === label);
    return level === void 0 ? left2(InvalidData([], `Expected a log level but received ${value}`)) : right2(level);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var duration = (name) => {
  const config2 = mapOrFail(string2(), (value) => {
    const duration4 = decodeUnknown(value);
    return fromOption2(duration4, () => InvalidData([], `Expected a duration but received ${value}`));
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var map18 = /* @__PURE__ */ dual(2, (self2, f2) => mapOrFail(self2, (a2) => right2(f2(a2))));
var mapAttempt = /* @__PURE__ */ dual(2, (self2, f2) => mapOrFail(self2, (a2) => {
  try {
    return right2(f2(a2));
  } catch (error4) {
    return left2(InvalidData([], error4 instanceof Error ? error4.message : `${error4}`));
  }
}));
var mapOrFail = /* @__PURE__ */ dual(2, (self2, f2) => {
  const mapOrFail3 = Object.create(proto5);
  mapOrFail3._tag = OP_MAP_OR_FAIL;
  mapOrFail3.original = self2;
  mapOrFail3.mapOrFail = f2;
  return mapOrFail3;
});
var nested3 = /* @__PURE__ */ dual(2, (self2, name) => {
  const nested6 = Object.create(proto5);
  nested6._tag = OP_NESTED;
  nested6.name = name;
  nested6.config = self2;
  return nested6;
});
var orElse8 = /* @__PURE__ */ dual(2, (self2, that) => {
  const fallback = Object.create(proto5);
  fallback._tag = OP_FALLBACK;
  fallback.first = self2;
  fallback.second = suspend6(that);
  fallback.condition = constTrue;
  return fallback;
});
var orElseIf = /* @__PURE__ */ dual(2, (self2, options) => {
  const fallback = Object.create(proto5);
  fallback._tag = OP_FALLBACK;
  fallback.first = self2;
  fallback.second = suspend6(options.orElse);
  fallback.condition = options.if;
  return fallback;
});
var option3 = (self2) => {
  return pipe(self2, map18(some2), orElseIf({
    orElse: () => succeed10(none2()),
    if: isMissingDataOnly2
  }));
};
var primitive = (description, parse6) => {
  const primitive3 = Object.create(proto5);
  primitive3._tag = OP_PRIMITIVE;
  primitive3.description = description;
  primitive3.parse = parse6;
  return primitive3;
};
var repeat2 = (self2) => {
  const repeat6 = Object.create(proto5);
  repeat6._tag = OP_SEQUENCE;
  repeat6.config = self2;
  return repeat6;
};
var secret = (name) => {
  const config2 = primitive("a secret property", (text) => right2(fromString(text)));
  return name === void 0 ? config2 : nested3(config2, name);
};
var redacted = (nameOrConfig) => {
  const config2 = isConfig(nameOrConfig) ? nameOrConfig : string2(nameOrConfig);
  return map18(config2, make41);
};
var hashSet2 = (config2, name) => {
  const newConfig = map18(chunk2(config2), fromIterable5);
  return name === void 0 ? newConfig : nested3(newConfig, name);
};
var string2 = (name) => {
  const config2 = primitive("a text property", right2);
  return name === void 0 ? config2 : nested3(config2, name);
};
var nonEmptyString = (name) => {
  const config2 = primitive("a non-empty text property", liftPredicate((text) => text.length > 0, () => MissingData([], "Expected a non-empty string")));
  return name === void 0 ? config2 : nested3(config2, name);
};
var all5 = (arg) => {
  if (Array.isArray(arg)) {
    return tuple2(arg);
  } else if (Symbol.iterator in arg) {
    return tuple2([...arg]);
  }
  return struct3(arg);
};
var struct3 = (r) => {
  const entries2 = Object.entries(r);
  let result = pipe(entries2[0][1], map18((value) => ({
    [entries2[0][0]]: value
  })));
  if (entries2.length === 1) {
    return result;
  }
  const rest = entries2.slice(1);
  for (const [key, config2] of rest) {
    result = pipe(result, zipWith7(config2, (record, value) => ({
      ...record,
      [key]: value
    })));
  }
  return result;
};
var succeed10 = (value) => {
  const constant2 = Object.create(proto5);
  constant2._tag = OP_CONSTANT;
  constant2.value = value;
  constant2.parse = () => right2(value);
  return constant2;
};
var suspend6 = (config2) => {
  const lazy = Object.create(proto5);
  lazy._tag = OP_LAZY;
  lazy.config = config2;
  return lazy;
};
var sync6 = (value) => {
  return suspend6(() => succeed10(value()));
};
var hashMap2 = (config2, name) => {
  const table3 = Object.create(proto5);
  table3._tag = OP_HASHMAP;
  table3.valueConfig = config2;
  return name === void 0 ? table3 : nested3(table3, name);
};
var isConfig = (u2) => hasProperty(u2, ConfigTypeId);
var tuple2 = (tuple3) => {
  if (tuple3.length === 0) {
    return succeed10([]);
  }
  if (tuple3.length === 1) {
    return map18(tuple3[0], (x2) => [x2]);
  }
  let result = map18(tuple3[0], (x2) => [x2]);
  for (let i = 1; i < tuple3.length; i++) {
    const config2 = tuple3[i];
    result = pipe(result, zipWith7(config2, (tuple4, value) => [...tuple4, value]));
  }
  return result;
};
var unwrap = (wrapped) => {
  if (isConfig(wrapped)) {
    return wrapped;
  }
  return struct3(Object.fromEntries(Object.entries(wrapped).map(([k, a2]) => [k, unwrap(a2)])));
};
var validate3 = /* @__PURE__ */ dual(2, (self2, {
  message,
  validation
}) => mapOrFail(self2, (a2) => {
  if (validation(a2)) {
    return right2(a2);
  }
  return left2(InvalidData([], message));
}));
var withDefault = /* @__PURE__ */ dual(2, (self2, def) => orElseIf(self2, {
  orElse: () => succeed10(def),
  if: isMissingDataOnly2
}));
var withDescription = /* @__PURE__ */ dual(2, (self2, description) => {
  const described = Object.create(proto5);
  described._tag = OP_DESCRIBED;
  described.config = self2;
  described.description = description;
  return described;
});
var zip6 = /* @__PURE__ */ dual(2, (self2, that) => zipWith7(self2, that, (a2, b) => [a2, b]));
var zipWith7 = /* @__PURE__ */ dual(3, (self2, that, f2) => {
  const zipWith14 = Object.create(proto5);
  zipWith14._tag = OP_ZIP_WITH;
  zipWith14.left = self2;
  zipWith14.right = that;
  zipWith14.zip = f2;
  return zipWith14;
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Config.js
var ConfigTypeId2 = ConfigTypeId;
var all6 = all5;
var array5 = array4;
var boolean2 = boolean;
var url2 = url;
var chunk3 = chunk2;
var date2 = date;
var fail12 = fail11;
var number4 = number3;
var integer2 = integer;
var literal2 = literal;
var logLevel2 = logLevel;
var duration2 = duration;
var isConfig2 = isConfig;
var map19 = map18;
var mapAttempt2 = mapAttempt;
var mapOrFail2 = mapOrFail;
var nested4 = nested3;
var orElse9 = orElse8;
var orElseIf2 = orElseIf;
var option4 = option3;
var primitive2 = primitive;
var repeat3 = repeat2;
var secret2 = secret;
var redacted2 = redacted;
var hashSet3 = hashSet2;
var string3 = string2;
var nonEmptyString2 = nonEmptyString;
var succeed11 = succeed10;
var suspend7 = suspend6;
var sync7 = sync6;
var hashMap3 = hashMap2;
var unwrap2 = unwrap;
var validate4 = validate3;
var withDefault2 = withDefault;
var withDescription2 = withDescription;
var zip7 = zip6;
var zipWith8 = zipWith7;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Schedule.js
var driver2 = driver;
var forever4 = forever2;
var spaced2 = spaced;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Stream.js
var Stream_exports = {};
__export(Stream_exports, {
  DefaultChunkSize: () => DefaultChunkSize2,
  Do: () => Do4,
  StreamTypeId: () => StreamTypeId3,
  accumulate: () => accumulate2,
  accumulateChunks: () => accumulateChunks2,
  acquireRelease: () => acquireRelease4,
  aggregate: () => aggregate2,
  aggregateWithin: () => aggregateWithin2,
  aggregateWithinEither: () => aggregateWithinEither2,
  as: () => as9,
  async: () => _async2,
  asyncEffect: () => asyncEffect4,
  asyncPush: () => asyncPush2,
  asyncScoped: () => asyncScoped2,
  bind: () => bind5,
  bindEffect: () => bindEffect2,
  bindTo: () => bindTo5,
  branchAfter: () => branchAfter2,
  broadcast: () => broadcast2,
  broadcastDynamic: () => broadcastDynamic2,
  broadcastedQueues: () => broadcastedQueues2,
  broadcastedQueuesDynamic: () => broadcastedQueuesDynamic2,
  buffer: () => buffer2,
  bufferChunks: () => bufferChunks2,
  catchAll: () => catchAll8,
  catchAllCause: () => catchAllCause7,
  catchSome: () => catchSome4,
  catchSomeCause: () => catchSomeCause4,
  catchTag: () => catchTag4,
  catchTags: () => catchTags4,
  changes: () => changes2,
  changesWith: () => changesWith2,
  changesWithEffect: () => changesWithEffect2,
  chunks: () => chunks2,
  chunksWith: () => chunksWith2,
  combine: () => combine10,
  combineChunks: () => combineChunks2,
  concat: () => concat3,
  concatAll: () => concatAll3,
  context: () => context6,
  contextWith: () => contextWith4,
  contextWithEffect: () => contextWithEffect4,
  contextWithStream: () => contextWithStream2,
  cross: () => cross2,
  crossLeft: () => crossLeft2,
  crossRight: () => crossRight2,
  crossWith: () => crossWith2,
  debounce: () => debounce2,
  decodeText: () => decodeText2,
  die: () => die11,
  dieMessage: () => dieMessage5,
  dieSync: () => dieSync7,
  distributedWith: () => distributedWith2,
  distributedWithDynamic: () => distributedWithDynamic2,
  drain: () => drain4,
  drainFork: () => drainFork2,
  drop: () => drop4,
  dropRight: () => dropRight2,
  dropUntil: () => dropUntil4,
  dropUntilEffect: () => dropUntilEffect2,
  dropWhile: () => dropWhile5,
  dropWhileEffect: () => dropWhileEffect2,
  either: () => either6,
  empty: () => empty32,
  encodeText: () => encodeText2,
  ensuring: () => ensuring7,
  ensuringWith: () => ensuringWith3,
  execute: () => execute2,
  fail: () => fail18,
  failCause: () => failCause14,
  failCauseSync: () => failCauseSync7,
  failSync: () => failSync8,
  filter: () => filter9,
  filterEffect: () => filterEffect2,
  filterMap: () => filterMap7,
  filterMapEffect: () => filterMapEffect2,
  filterMapWhile: () => filterMapWhile4,
  filterMapWhileEffect: () => filterMapWhileEffect2,
  finalizer: () => finalizer2,
  find: () => find3,
  findEffect: () => findEffect2,
  flatMap: () => flatMap17,
  flatten: () => flatten13,
  flattenChunks: () => flattenChunks2,
  flattenEffect: () => flattenEffect2,
  flattenExitOption: () => flattenExitOption2,
  flattenIterables: () => flattenIterables2,
  flattenTake: () => flattenTake2,
  forever: () => forever6,
  fromAsyncIterable: () => fromAsyncIterable2,
  fromChannel: () => fromChannel3,
  fromChunk: () => fromChunk2,
  fromChunkPubSub: () => fromChunkPubSub2,
  fromChunkQueue: () => fromChunkQueue2,
  fromChunks: () => fromChunks2,
  fromEffect: () => fromEffect8,
  fromEffectOption: () => fromEffectOption2,
  fromEventListener: () => fromEventListener2,
  fromIterable: () => fromIterable12,
  fromIterableEffect: () => fromIterableEffect2,
  fromIteratorSucceed: () => fromIteratorSucceed2,
  fromPubSub: () => fromPubSub2,
  fromPull: () => fromPull3,
  fromQueue: () => fromQueue3,
  fromReadableStream: () => fromReadableStream2,
  fromReadableStreamByob: () => fromReadableStreamByob2,
  fromSchedule: () => fromSchedule2,
  fromTPubSub: () => fromTPubSub2,
  fromTQueue: () => fromTQueue2,
  groupAdjacentBy: () => groupAdjacentBy2,
  groupBy: () => groupBy2,
  groupByKey: () => groupByKey2,
  grouped: () => grouped2,
  groupedWithin: () => groupedWithin2,
  haltAfter: () => haltAfter2,
  haltWhen: () => haltWhen2,
  haltWhenDeferred: () => haltWhenDeferred2,
  identity: () => identity3,
  interleave: () => interleave2,
  interleaveWith: () => interleaveWith2,
  interruptAfter: () => interruptAfter2,
  interruptWhen: () => interruptWhen3,
  interruptWhenDeferred: () => interruptWhenDeferred3,
  intersperse: () => intersperse2,
  intersperseAffixes: () => intersperseAffixes2,
  iterate: () => iterate4,
  let: () => let_5,
  make: () => make54,
  map: () => map24,
  mapAccum: () => mapAccum6,
  mapAccumEffect: () => mapAccumEffect2,
  mapBoth: () => mapBoth6,
  mapChunks: () => mapChunks2,
  mapChunksEffect: () => mapChunksEffect2,
  mapConcat: () => mapConcat2,
  mapConcatChunk: () => mapConcatChunk2,
  mapConcatChunkEffect: () => mapConcatChunkEffect2,
  mapConcatEffect: () => mapConcatEffect2,
  mapEffect: () => mapEffect4,
  mapError: () => mapError7,
  mapErrorCause: () => mapErrorCause5,
  mapInputContext: () => mapInputContext6,
  merge: () => merge10,
  mergeAll: () => mergeAll8,
  mergeEither: () => mergeEither2,
  mergeLeft: () => mergeLeft2,
  mergeRight: () => mergeRight2,
  mergeWith: () => mergeWith4,
  mergeWithTag: () => mergeWithTag2,
  mkString: () => mkString3,
  never: () => never5,
  onDone: () => onDone2,
  onEnd: () => onEnd2,
  onError: () => onError4,
  onStart: () => onStart2,
  orDie: () => orDie6,
  orDieWith: () => orDieWith5,
  orElse: () => orElse12,
  orElseEither: () => orElseEither4,
  orElseFail: () => orElseFail4,
  orElseIfEmpty: () => orElseIfEmpty2,
  orElseIfEmptyChunk: () => orElseIfEmptyChunk2,
  orElseIfEmptyStream: () => orElseIfEmptyStream2,
  orElseSucceed: () => orElseSucceed4,
  paginate: () => paginate2,
  paginateChunk: () => paginateChunk2,
  paginateChunkEffect: () => paginateChunkEffect2,
  paginateEffect: () => paginateEffect2,
  partition: () => partition6,
  partitionEither: () => partitionEither2,
  peel: () => peel2,
  pipeThrough: () => pipeThrough2,
  pipeThroughChannel: () => pipeThroughChannel2,
  pipeThroughChannelOrFail: () => pipeThroughChannelOrFail2,
  prepend: () => prepend5,
  provideContext: () => provideContext6,
  provideLayer: () => provideLayer2,
  provideService: () => provideService6,
  provideServiceEffect: () => provideServiceEffect4,
  provideServiceStream: () => provideServiceStream2,
  provideSomeLayer: () => provideSomeLayer3,
  race: () => race4,
  raceAll: () => raceAll4,
  range: () => range3,
  rechunk: () => rechunk2,
  refineOrDie: () => refineOrDie2,
  refineOrDieWith: () => refineOrDieWith2,
  repeat: () => repeat5,
  repeatEffect: () => repeatEffect2,
  repeatEffectChunk: () => repeatEffectChunk2,
  repeatEffectChunkOption: () => repeatEffectChunkOption2,
  repeatEffectOption: () => repeatEffectOption2,
  repeatEffectWithSchedule: () => repeatEffectWithSchedule2,
  repeatEither: () => repeatEither2,
  repeatElements: () => repeatElements2,
  repeatElementsWith: () => repeatElementsWith2,
  repeatValue: () => repeatValue2,
  repeatWith: () => repeatWith2,
  retry: () => retry7,
  run: () => run4,
  runCollect: () => runCollect2,
  runCount: () => runCount2,
  runDrain: () => runDrain3,
  runFold: () => runFold2,
  runFoldEffect: () => runFoldEffect2,
  runFoldScoped: () => runFoldScoped2,
  runFoldScopedEffect: () => runFoldScopedEffect2,
  runFoldWhile: () => runFoldWhile2,
  runFoldWhileEffect: () => runFoldWhileEffect2,
  runFoldWhileScoped: () => runFoldWhileScoped2,
  runFoldWhileScopedEffect: () => runFoldWhileScopedEffect2,
  runForEach: () => runForEach2,
  runForEachChunk: () => runForEachChunk2,
  runForEachChunkScoped: () => runForEachChunkScoped2,
  runForEachScoped: () => runForEachScoped2,
  runForEachWhile: () => runForEachWhile2,
  runForEachWhileScoped: () => runForEachWhileScoped2,
  runHead: () => runHead2,
  runIntoPubSub: () => runIntoPubSub2,
  runIntoPubSubScoped: () => runIntoPubSubScoped2,
  runIntoQueue: () => runIntoQueue2,
  runIntoQueueElementsScoped: () => runIntoQueueElementsScoped2,
  runIntoQueueScoped: () => runIntoQueueScoped2,
  runLast: () => runLast2,
  runScoped: () => runScoped3,
  runSum: () => runSum2,
  scan: () => scan2,
  scanEffect: () => scanEffect2,
  scanReduce: () => scanReduce2,
  scanReduceEffect: () => scanReduceEffect2,
  schedule: () => schedule3,
  scheduleWith: () => scheduleWith2,
  scoped: () => scoped6,
  scopedWith: () => scopedWith5,
  share: () => share2,
  sliding: () => sliding8,
  slidingSize: () => slidingSize2,
  some: () => some6,
  someOrElse: () => someOrElse2,
  someOrFail: () => someOrFail2,
  split: () => split2,
  splitLines: () => splitLines3,
  splitOnChunk: () => splitOnChunk2,
  succeed: () => succeed17,
  suspend: () => suspend13,
  sync: () => sync12,
  take: () => take8,
  takeRight: () => takeRight3,
  takeUntil: () => takeUntil4,
  takeUntilEffect: () => takeUntilEffect2,
  takeWhile: () => takeWhile5,
  tap: () => tap7,
  tapBoth: () => tapBoth4,
  tapError: () => tapError6,
  tapErrorCause: () => tapErrorCause6,
  tapSink: () => tapSink2,
  throttle: () => throttle2,
  throttleEffect: () => throttleEffect2,
  tick: () => tick2,
  timeout: () => timeout4,
  timeoutFail: () => timeoutFail4,
  timeoutFailCause: () => timeoutFailCause4,
  timeoutTo: () => timeoutTo4,
  toChannel: () => toChannel3,
  toPubSub: () => toPubSub3,
  toPull: () => toPull3,
  toQueue: () => toQueue3,
  toQueueOfElements: () => toQueueOfElements2,
  toReadableStream: () => toReadableStream2,
  toReadableStreamEffect: () => toReadableStreamEffect2,
  toReadableStreamRuntime: () => toReadableStreamRuntime2,
  transduce: () => transduce2,
  unfold: () => unfold4,
  unfoldChunk: () => unfoldChunk2,
  unfoldChunkEffect: () => unfoldChunkEffect2,
  unfoldEffect: () => unfoldEffect2,
  unwrap: () => unwrap5,
  unwrapScoped: () => unwrapScoped5,
  unwrapScopedWith: () => unwrapScopedWith4,
  updateService: () => updateService5,
  void: () => void_8,
  when: () => when4,
  whenCase: () => whenCase2,
  whenCaseEffect: () => whenCaseEffect2,
  whenEffect: () => whenEffect4,
  withSpan: () => withSpan7,
  zip: () => zip10,
  zipAll: () => zipAll2,
  zipAllLeft: () => zipAllLeft2,
  zipAllRight: () => zipAllRight2,
  zipAllSortedByKey: () => zipAllSortedByKey2,
  zipAllSortedByKeyLeft: () => zipAllSortedByKeyLeft2,
  zipAllSortedByKeyRight: () => zipAllSortedByKeyRight2,
  zipAllSortedByKeyWith: () => zipAllSortedByKeyWith2,
  zipAllWith: () => zipAllWith2,
  zipFlatten: () => zipFlatten2,
  zipLatest: () => zipLatest2,
  zipLatestAll: () => zipLatestAll2,
  zipLatestWith: () => zipLatestWith2,
  zipLeft: () => zipLeft6,
  zipRight: () => zipRight9,
  zipWith: () => zipWith13,
  zipWithChunks: () => zipWithChunks2,
  zipWithIndex: () => zipWithIndex2,
  zipWithNext: () => zipWithNext2,
  zipWithPrevious: () => zipWithPrevious2,
  zipWithPreviousAndNext: () => zipWithPreviousAndNext2
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/queue.js
var EnqueueSymbolKey = "effect/QueueEnqueue";
var EnqueueTypeId = /* @__PURE__ */ Symbol.for(EnqueueSymbolKey);
var DequeueSymbolKey = "effect/QueueDequeue";
var DequeueTypeId = /* @__PURE__ */ Symbol.for(DequeueSymbolKey);
var QueueStrategySymbolKey = "effect/QueueStrategy";
var QueueStrategyTypeId = /* @__PURE__ */ Symbol.for(QueueStrategySymbolKey);
var BackingQueueSymbolKey = "effect/BackingQueue";
var BackingQueueTypeId = /* @__PURE__ */ Symbol.for(BackingQueueSymbolKey);
var queueStrategyVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var backingQueueVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var enqueueVariance = {
  /* c8 ignore next */
  _In: (_2) => _2
};
var dequeueVariance = {
  /* c8 ignore next */
  _Out: (_2) => _2
};
var QueueImpl = class extends Class2 {
  queue;
  takers;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
    super();
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
  capacity() {
    return this.queue.capacity();
  }
  get size() {
    return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
  }
  unsafeSize() {
    if (get6(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.queue.length() - length2(this.takers) + this.strategy.surplusSize());
  }
  get isEmpty() {
    return map9(this.size, (size16) => size16 <= 0);
  }
  get isFull() {
    return map9(this.size, (size16) => size16 >= this.capacity());
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set2(true));
      return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d2) => deferredInterruptWith(d2, state.id()), false, false), zipRight(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid);
    }));
  }
  get isShutdown() {
    return sync(() => get6(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  isActive() {
    return !get6(this.shutdownFlag);
  }
  unsafeOffer(value) {
    if (get6(this.shutdownFlag)) {
      return false;
    }
    let noRemaining;
    if (this.queue.length() === 0) {
      const taker = pipe(this.takers, poll4(EmptyMutableQueue));
      if (taker !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, value);
        noRemaining = true;
      } else {
        noRemaining = false;
      }
    } else {
      noRemaining = false;
    }
    if (noRemaining) {
      return true;
    }
    const succeeded = this.queue.offer(value);
    unsafeCompleteTakers(this.strategy, this.queue, this.takers);
    return succeeded;
  }
  offer(value) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll4(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return succeed(true);
      }
      const succeeded = this.queue.offer(value);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded ? succeed(true) : this.strategy.handleSurplus([value], this.queue, this.takers, this.shutdownFlag);
    });
  }
  offerAll(iterable) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const values3 = fromIterable(iterable);
      const pTakers = this.queue.length() === 0 ? fromIterable(unsafePollN(this.takers, values3.length)) : empty;
      const [forTakers, remaining] = pipe(values3, splitAt(pTakers.length));
      for (let i = 0; i < pTakers.length; i++) {
        const taker = pTakers[i];
        const item = forTakers[i];
        unsafeCompleteDeferred(taker, item);
      }
      if (remaining.length === 0) {
        return succeed(true);
      }
      const surplus = this.queue.offerAll(remaining);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return isEmpty(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
    });
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const item = this.queue.poll(EmptyMutableQueue);
      if (item !== EmptyMutableQueue) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return succeed(item);
      } else {
        const deferred2 = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.takers, offer(deferred2));
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred2);
        }), onInterrupt(() => {
          return sync(() => unsafeRemove(this.takers, deferred2));
        }));
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      return get6(this.shutdownFlag) ? interrupt2 : sync(() => {
        const values3 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable2(values3);
      });
    });
  }
  takeUpTo(max5) {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => {
      const values3 = this.queue.pollUpTo(max5);
      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
      return fromIterable2(values3);
    }));
  }
  takeBetween(min3, max5) {
    return suspend(() => takeRemainderLoop(this, min3, max5, empty2()));
  }
};
var takeRemainderLoop = (self2, min3, max5, acc) => {
  if (max5 < min3) {
    return succeed(acc);
  }
  return pipe(takeUpTo(self2, max5), flatMap8((bs) => {
    const remaining = min3 - bs.length;
    if (remaining === 1) {
      return pipe(take2(self2), map9((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(take2(self2), flatMap8((b) => takeRemainderLoop(self2, remaining - 1, max5 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
};
var bounded2 = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make43(backingQueueFromMutableQueue(queue), backPressureStrategy())));
var dropping = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make43(backingQueueFromMutableQueue(queue), droppingStrategy())));
var sliding = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make43(backingQueueFromMutableQueue(queue), slidingStrategy())));
var unbounded2 = () => pipe(sync(() => unbounded()), flatMap8((queue) => make43(backingQueueFromMutableQueue(queue), droppingStrategy())));
var unsafeMake8 = (queue, takers, shutdownHook, shutdownFlag, strategy) => {
  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
};
var make43 = (queue, strategy) => pipe(deferredMake(), map9((deferred2) => unsafeMake8(queue, unbounded(), deferred2, make12(false), strategy)));
var BackingQueueFromMutableQueue = class {
  mutable;
  [BackingQueueTypeId] = backingQueueVariance;
  constructor(mutable) {
    this.mutable = mutable;
  }
  poll(def) {
    return poll4(this.mutable, def);
  }
  pollUpTo(limit) {
    return pollUpTo(this.mutable, limit);
  }
  offerAll(elements) {
    return offerAll(this.mutable, elements);
  }
  offer(element) {
    return offer(this.mutable, element);
  }
  capacity() {
    return capacity(this.mutable);
  }
  length() {
    return length2(this.mutable);
  }
};
var backingQueueFromMutableQueue = (mutable) => new BackingQueueFromMutableQueue(mutable);
var capacity2 = (self2) => self2.capacity();
var size11 = (self2) => self2.size;
var isFull = (self2) => self2.isFull;
var isEmpty10 = (self2) => self2.isEmpty;
var isShutdown = (self2) => self2.isShutdown;
var awaitShutdown = (self2) => self2.awaitShutdown;
var shutdown = (self2) => self2.shutdown;
var offer2 = /* @__PURE__ */ dual(2, (self2, value) => self2.offer(value));
var offerAll2 = /* @__PURE__ */ dual(2, (self2, iterable) => self2.offerAll(iterable));
var poll5 = (self2) => map9(self2.takeUpTo(1), head2);
var take2 = (self2) => self2.take;
var takeAll = (self2) => self2.takeAll;
var takeUpTo = /* @__PURE__ */ dual(2, (self2, max5) => self2.takeUpTo(max5));
var takeBetween = /* @__PURE__ */ dual(3, (self2, min3, max5) => self2.takeBetween(min3, max5));
var takeN = /* @__PURE__ */ dual(2, (self2, n2) => self2.takeBetween(n2, n2));
var backPressureStrategy = () => new BackPressureStrategy();
var droppingStrategy = () => new DroppingStrategy();
var slidingStrategy = () => new SlidingStrategy();
var BackPressureStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  putters = /* @__PURE__ */ unbounded();
  surplusSize() {
    return length2(this.putters);
  }
  onCompleteTakersWithEmptyQueue(takers) {
    while (!isEmpty9(this.putters) && !isEmpty9(takers)) {
      const taker = poll4(takers, void 0);
      const putter = poll4(this.putters, void 0);
      if (putter[2]) {
        unsafeCompleteDeferred(putter[1], true);
      }
      unsafeCompleteDeferred(taker, putter[0]);
    }
  }
  get shutdown() {
    return pipe(fiberId, flatMap8((fiberId3) => pipe(sync(() => unsafePollAll(this.putters)), flatMap8((putters) => forEachConcurrentDiscard(putters, ([_2, deferred2, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred2, fiberId3), asVoid) : void_, false, false)))));
  }
  handleSurplus(iterable, queue, takers, isShutdown7) {
    return withFiberRuntime((state) => {
      const deferred2 = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(iterable, deferred2);
        this.unsafeOnQueueEmptySpace(queue, takers);
        unsafeCompleteTakers(this, queue, takers);
        return get6(isShutdown7) ? interrupt2 : deferredAwait(deferred2);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred2))));
    });
  }
  unsafeOnQueueEmptySpace(queue, takers) {
    let keepPolling = true;
    while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
      const putter = pipe(this.putters, poll4(EmptyMutableQueue));
      if (putter === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const offered = queue.offer(putter[0]);
        if (offered && putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        } else if (!offered) {
          unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend2(putter)));
        }
        unsafeCompleteTakers(this, queue, takers);
      }
    }
  }
  unsafeOffer(iterable, deferred2) {
    const stuff = fromIterable(iterable);
    for (let i = 0; i < stuff.length; i++) {
      const value = stuff[i];
      if (i === stuff.length - 1) {
        pipe(this.putters, offer([value, deferred2, true]));
      } else {
        pipe(this.putters, offer([value, deferred2, false]));
      }
    }
  }
  unsafeRemove(deferred2) {
    unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter2(([, _2]) => _2 !== deferred2)));
  }
};
var DroppingStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(_iterable, _queue, _takers, _isShutdown) {
    return succeed(false);
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
};
var SlidingStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(iterable, queue, takers, _isShutdown) {
    return sync(() => {
      this.unsafeOffer(queue, iterable);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
  unsafeOffer(queue, iterable) {
    const iterator = iterable[Symbol.iterator]();
    let next;
    let offering = true;
    while (!(next = iterator.next()).done && offering) {
      if (queue.capacity() === 0) {
        return;
      }
      queue.poll(EmptyMutableQueue);
      offering = queue.offer(next.value);
    }
  }
};
var unsafeCompleteDeferred = (deferred2, a2) => {
  return deferredUnsafeDone(deferred2, succeed(a2));
};
var unsafeOfferAll = (queue, as10) => {
  return pipe(queue, offerAll(as10));
};
var unsafePollAll = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollN = (queue, max5) => {
  return pipe(queue, pollUpTo(max5));
};
var unsafeRemove = (queue, a2) => {
  unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter2((b) => a2 !== b)));
};
var unsafeCompleteTakers = (strategy, queue, takers) => {
  let keepPolling = true;
  while (keepPolling && queue.length() !== 0) {
    const taker = pipe(takers, poll4(EmptyMutableQueue));
    if (taker !== EmptyMutableQueue) {
      const element = queue.poll(EmptyMutableQueue);
      if (element !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, element);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend2(taker)));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
  if (keepPolling && queue.length() === 0 && !isEmpty9(takers)) {
    strategy.onCompleteTakersWithEmptyQueue(takers);
  }
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Queue.js
var DequeueTypeId2 = DequeueTypeId;
var bounded3 = bounded2;
var dropping2 = dropping;
var sliding2 = sliding;
var unbounded3 = unbounded2;
var capacity3 = capacity2;
var size12 = size11;
var isEmpty11 = isEmpty10;
var isFull2 = isFull;
var isShutdown2 = isShutdown;
var awaitShutdown2 = awaitShutdown;
var shutdown2 = shutdown;
var offer3 = offer2;
var offerAll3 = offerAll2;
var poll6 = poll5;
var take3 = take2;
var takeAll2 = takeAll;
var takeUpTo2 = takeUpTo;
var takeBetween2 = takeBetween;
var takeN2 = takeN;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/pubsub.js
var AbsentValue = /* @__PURE__ */ Symbol.for("effect/PubSub/AbsentValue");
var addSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    subscribers.set(subscription, /* @__PURE__ */ new Set());
  }
  const set8 = subscribers.get(subscription);
  set8.add(pollers);
};
var removeSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    return;
  }
  const set8 = subscribers.get(subscription);
  set8.delete(pollers);
  if (set8.size === 0) {
    subscribers.delete(subscription);
  }
};
var bounded4 = (capacity7) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity7);
  return makePubSub(pubsub, new BackPressureStrategy2());
});
var dropping3 = (capacity7) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity7);
  return makePubSub(pubsub, new DroppingStrategy2());
});
var sliding3 = (capacity7) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity7);
  return makePubSub(pubsub, new SlidingStrategy2());
});
var unbounded4 = (options) => suspend(() => {
  const pubsub = makeUnboundedPubSub(options);
  return makePubSub(pubsub, new DroppingStrategy2());
});
var shutdown3 = (self2) => self2.shutdown;
var subscribe = (self2) => self2.subscribe;
var makeBoundedPubSub = (capacity7) => {
  const options = typeof capacity7 === "number" ? {
    capacity: capacity7
  } : capacity7;
  ensureCapacity(options.capacity);
  const replayBuffer = options.replay && options.replay > 0 ? new ReplayBuffer(Math.ceil(options.replay)) : void 0;
  if (options.capacity === 1) {
    return new BoundedPubSubSingle(replayBuffer);
  } else if (nextPow2(options.capacity) === options.capacity) {
    return new BoundedPubSubPow2(options.capacity, replayBuffer);
  } else {
    return new BoundedPubSubArb(options.capacity, replayBuffer);
  }
};
var makeUnboundedPubSub = (options) => new UnboundedPubSub(options?.replay ? new ReplayBuffer(options.replay) : void 0);
var makeSubscription = (pubsub, subscribers, strategy) => map9(deferredMake(), (deferred2) => unsafeMakeSubscription(pubsub, subscribers, pubsub.subscribe(), unbounded(), deferred2, make12(false), strategy));
var unsafeMakeSubscription = (pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => new SubscriptionImpl(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, pubsub.replayWindow());
var BoundedPubSubArb = class {
  capacity;
  replayBuffer;
  array;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity7, replayBuffer) {
    this.capacity = capacity7;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity7
    });
    this.subscribers = Array.from({
      length: capacity7
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex % this.capacity;
      this.array[index] = value;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty2();
    }
    const chunk5 = fromIterable2(elements);
    const n2 = chunk5.length;
    const size16 = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size16;
    const forPubSub = Math.min(n2, available);
    if (forPubSub === 0) {
      return chunk5;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const a2 = unsafeGet2(chunk5, iteratorIndex++);
      const index = this.publisherIndex % this.capacity;
      this.array[index] = a2;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(a2);
      }
    }
    return drop2(chunk5, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex % this.capacity;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubArbSubscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubArbSubscription = class {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n2) {
    if (this.unsubscribed) {
      return empty2();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size16 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n2, size16);
    if (toPoll <= 0) {
      return empty2();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const a2 = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(a2);
      this.subscriberIndex += 1;
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex % this.self.capacity;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};
var BoundedPubSubPow2 = class {
  capacity;
  replayBuffer;
  array;
  mask;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity7, replayBuffer) {
    this.capacity = capacity7;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity7
    });
    this.mask = capacity7 - 1;
    this.subscribers = Array.from({
      length: capacity7
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex & this.mask;
      this.array[index] = value;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty2();
    }
    const chunk5 = fromIterable2(elements);
    const n2 = chunk5.length;
    const size16 = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size16;
    const forPubSub = Math.min(n2, available);
    if (forPubSub === 0) {
      return chunk5;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const elem = unsafeGet2(chunk5, iteratorIndex++);
      const index = this.publisherIndex & this.mask;
      this.array[index] = elem;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(elem);
      }
    }
    return drop2(chunk5, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex & this.mask;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubPow2Subscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubPow2Subscription = class {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n2) {
    if (this.unsubscribed) {
      return empty2();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size16 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n2, size16);
    if (toPoll <= 0) {
      return empty2();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(elem);
      this.subscriberIndex += 1;
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex & this.self.mask;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};
var BoundedPubSubSingle = class {
  replayBuffer;
  publisherIndex = 0;
  subscriberCount = 0;
  subscribers = 0;
  value = AbsentValue;
  capacity = 1;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  isEmpty() {
    return this.subscribers === 0;
  }
  isFull() {
    return !this.isEmpty();
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  publish(value) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      this.value = value;
      this.subscribers = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty2();
    }
    const chunk5 = fromIterable2(elements);
    if (isEmpty(chunk5)) {
      return chunk5;
    }
    if (this.publish(unsafeHead2(chunk5))) {
      return drop2(chunk5, 1);
    } else {
      return chunk5;
    }
  }
  slide() {
    if (this.isFull()) {
      this.subscribers = 0;
      this.value = AbsentValue;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubSingleSubscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubSingleSubscription = class {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  poll(default_) {
    if (this.isEmpty()) {
      return default_;
    }
    const elem = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return elem;
  }
  pollUpTo(n2) {
    if (this.isEmpty() || n2 < 1) {
      return empty2();
    }
    const a2 = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return of2(a2);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      if (this.subscriberIndex !== this.self.publisherIndex) {
        this.self.subscribers -= 1;
        if (this.self.subscribers === 0) {
          this.self.value = AbsentValue;
        }
      }
    }
  }
};
var UnboundedPubSub = class {
  replayBuffer;
  publisherHead = {
    value: AbsentValue,
    subscribers: 0,
    next: null
  };
  publisherTail = this.publisherHead;
  publisherIndex = 0;
  subscribersIndex = 0;
  capacity = Number.MAX_SAFE_INTEGER;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherHead === this.publisherTail;
  }
  isFull() {
    return false;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    const subscribers = this.publisherTail.subscribers;
    if (subscribers !== 0) {
      this.publisherTail.next = {
        value,
        subscribers,
        next: null
      };
      this.publisherTail = this.publisherTail.next;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.publisherTail.subscribers !== 0) {
      for (const a2 of elements) {
        this.publish(a2);
      }
    } else if (this.replayBuffer) {
      this.replayBuffer.offerAll(elements);
    }
    return empty2();
  }
  slide() {
    if (this.publisherHead !== this.publisherTail) {
      this.publisherHead = this.publisherHead.next;
      this.publisherHead.value = AbsentValue;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.publisherTail.subscribers += 1;
    return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
  }
};
var UnboundedPubSubSubscription = class {
  self;
  subscriberHead;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberHead, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberHead = subscriberHead;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    if (this.unsubscribed) {
      return true;
    }
    let empty34 = true;
    let loop3 = true;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        if (this.subscriberHead.next.value !== AbsentValue) {
          empty34 = false;
          loop3 = false;
        } else {
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
    }
    return empty34;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    let loop3 = true;
    let polled = default_;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        const elem = this.subscriberHead.next.value;
        if (elem !== AbsentValue) {
          polled = elem;
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          loop3 = false;
        }
        this.subscriberHead = this.subscriberHead.next;
        this.subscriberIndex += 1;
      }
    }
    return polled;
  }
  pollUpTo(n2) {
    const builder = [];
    const default_ = AbsentValue;
    let i = 0;
    while (i !== n2) {
      const a2 = this.poll(default_);
      if (a2 === default_) {
        i = n2;
      } else {
        builder.push(a2);
        i += 1;
      }
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.publisherTail.subscribers -= 1;
      while (this.subscriberHead !== this.self.publisherTail) {
        if (this.subscriberHead.next.value !== AbsentValue) {
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
        }
        this.subscriberHead = this.subscriberHead.next;
      }
    }
  }
};
var SubscriptionImpl = class extends Class2 {
  pubsub;
  subscribers;
  subscription;
  pollers;
  shutdownHook;
  shutdownFlag;
  strategy;
  replayWindow;
  [DequeueTypeId] = dequeueVariance;
  constructor(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, replayWindow) {
    super();
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.subscription = subscription;
    this.pollers = pollers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this.replayWindow = replayWindow;
  }
  commit() {
    return this.take;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  capacity() {
    return this.pubsub.capacity;
  }
  isActive() {
    return !get6(this.shutdownFlag);
  }
  get size() {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() + this.replayWindow.remaining));
  }
  unsafeSize() {
    if (get6(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.subscription.size() + this.replayWindow.remaining);
  }
  get isFull() {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() === this.capacity()));
  }
  get isEmpty() {
    return map9(this.size, (size16) => size16 === 0);
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      set2(this.shutdownFlag, true);
      return pipe(forEachParUnbounded(unsafePollAllQueue(this.pollers), (d2) => deferredInterruptWith(d2, state.id()), false), zipRight(sync(() => {
        this.subscribers.delete(this.subscription);
        this.subscription.unsubscribe();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      })), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid);
    }));
  }
  get isShutdown() {
    return sync(() => get6(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.replayWindow.remaining > 0) {
        const message2 = this.replayWindow.take();
        return succeed(message2);
      }
      const message = isEmpty9(this.pollers) ? this.subscription.poll(EmptyMutableQueue) : EmptyMutableQueue;
      if (message === EmptyMutableQueue) {
        const deferred2 = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.pollers, offer(deferred2));
          pipe(this.subscribers, addSubscribers(this.subscription, this.pollers));
          this.strategy.unsafeCompletePollers(this.pubsub, this.subscribers, this.subscription, this.pollers);
          return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred2);
        }), onInterrupt(() => sync(() => unsafeRemove2(this.pollers, deferred2))));
      } else {
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        return succeed(message);
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const as10 = isEmpty9(this.pollers) ? unsafePollAllSubscription(this.subscription) : empty2();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      if (this.replayWindow.remaining > 0) {
        return succeed(appendAll2(this.replayWindow.takeAll(), as10));
      }
      return succeed(as10);
    });
  }
  takeUpTo(max5) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      let replay = void 0;
      if (this.replayWindow.remaining >= max5) {
        const as11 = this.replayWindow.takeN(max5);
        return succeed(as11);
      } else if (this.replayWindow.remaining > 0) {
        replay = this.replayWindow.takeAll();
        max5 = max5 - replay.length;
      }
      const as10 = isEmpty9(this.pollers) ? unsafePollN2(this.subscription, max5) : empty2();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      return replay ? succeed(appendAll2(replay, as10)) : succeed(as10);
    });
  }
  takeBetween(min3, max5) {
    return suspend(() => takeRemainderLoop2(this, min3, max5, empty2()));
  }
};
var takeRemainderLoop2 = (self2, min3, max5, acc) => {
  if (max5 < min3) {
    return succeed(acc);
  }
  return pipe(self2.takeUpTo(max5), flatMap8((bs) => {
    const remaining = min3 - bs.length;
    if (remaining === 1) {
      return pipe(self2.take, map9((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(self2.take, flatMap8((b) => takeRemainderLoop2(self2, remaining - 1, max5 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
};
var PubSubImpl = class {
  pubsub;
  subscribers;
  scope;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) {
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.scope = scope5;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  capacity() {
    return this.pubsub.capacity;
  }
  get size() {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => this.pubsub.size()));
  }
  unsafeSize() {
    if (get6(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.pubsub.size());
  }
  get isFull() {
    return map9(this.size, (size16) => size16 === this.capacity());
  }
  get isEmpty() {
    return map9(this.size, (size16) => size16 === 0);
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get isShutdown() {
    return sync(() => get6(this.shutdownFlag));
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set2(true));
      return pipe(this.scope.close(exitInterrupt(state.id())), zipRight(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid);
    }));
  }
  publish(value) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.pubsub.publish(value)) {
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, of2(value), this.shutdownFlag);
    });
  }
  isActive() {
    return !get6(this.shutdownFlag);
  }
  unsafeOffer(value) {
    if (get6(this.shutdownFlag)) {
      return false;
    }
    if (this.pubsub.publish(value)) {
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      return true;
    }
    return false;
  }
  publishAll(elements) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const surplus = unsafePublishAll(this.pubsub, elements);
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      if (isEmpty(surplus)) {
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, surplus, this.shutdownFlag);
    });
  }
  get subscribe() {
    const acquire = tap(all3([this.scope.fork(sequential2), makeSubscription(this.pubsub, this.subscribers, this.strategy)]), (tuple3) => tuple3[0].addFinalizer(() => tuple3[1].shutdown));
    return map9(acquireRelease(acquire, (tuple3, exit4) => tuple3[0].close(exit4)), (tuple3) => tuple3[1]);
  }
  offer(value) {
    return this.publish(value);
  }
  offerAll(elements) {
    return this.publishAll(elements);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makePubSub = (pubsub, strategy) => flatMap8(scopeMake(), (scope5) => map9(deferredMake(), (deferred2) => unsafeMakePubSub(pubsub, /* @__PURE__ */ new Map(), scope5, deferred2, make12(false), strategy)));
var unsafeMakePubSub = (pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) => new PubSubImpl(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy);
var ensureCapacity = (capacity7) => {
  if (capacity7 <= 0) {
    throw new InvalidPubSubCapacityException(`Cannot construct PubSub with capacity of ${capacity7}`);
  }
};
var unsafeCompleteDeferred2 = (deferred2, a2) => {
  deferredUnsafeDone(deferred2, succeed(a2));
};
var unsafeOfferAll2 = (queue, as10) => {
  return pipe(queue, offerAll(as10));
};
var unsafePollAllQueue = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollAllSubscription = (subscription) => {
  return subscription.pollUpTo(Number.POSITIVE_INFINITY);
};
var unsafePollN2 = (subscription, max5) => {
  return subscription.pollUpTo(max5);
};
var unsafePublishAll = (pubsub, as10) => {
  return pubsub.publishAll(as10);
};
var unsafeRemove2 = (queue, value) => {
  unsafeOfferAll2(queue, pipe(unsafePollAllQueue(queue), filter2((elem) => elem !== value)));
};
var BackPressureStrategy2 = class {
  publishers = /* @__PURE__ */ unbounded();
  get shutdown() {
    return flatMap8(fiberId, (fiberId3) => flatMap8(sync(() => unsafePollAllQueue(this.publishers)), (publishers) => forEachConcurrentDiscard(publishers, ([_2, deferred2, last6]) => last6 ? pipe(deferredInterruptWith(deferred2, fiberId3), asVoid) : void_, false, false)));
  }
  handleSurplus(pubsub, subscribers, elements, isShutdown7) {
    return withFiberRuntime((state) => {
      const deferred2 = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(elements, deferred2);
        this.unsafeOnPubSubEmptySpace(pubsub, subscribers);
        this.unsafeCompleteSubscribers(pubsub, subscribers);
        return get6(isShutdown7) ? interrupt2 : deferredAwait(deferred2);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred2))));
    });
  }
  unsafeOnPubSubEmptySpace(pubsub, subscribers) {
    let keepPolling = true;
    while (keepPolling && !pubsub.isFull()) {
      const publisher = pipe(this.publishers, poll4(EmptyMutableQueue));
      if (publisher === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const published = pubsub.publish(publisher[0]);
        if (published && publisher[2]) {
          unsafeCompleteDeferred2(publisher[1], true);
        } else if (!published) {
          unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), prepend2(publisher)));
        }
        this.unsafeCompleteSubscribers(pubsub, subscribers);
      }
    }
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeOffer(elements, deferred2) {
    const iterator = elements[Symbol.iterator]();
    let next = iterator.next();
    if (!next.done) {
      while (1) {
        const value = next.value;
        next = iterator.next();
        if (next.done) {
          pipe(this.publishers, offer([value, deferred2, true]));
          break;
        }
        pipe(this.publishers, offer([value, deferred2, false]));
      }
    }
  }
  unsafeRemove(deferred2) {
    unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), filter2(([_2, a2]) => a2 !== deferred2)));
  }
};
var DroppingStrategy2 = class {
  get shutdown() {
    return void_;
  }
  handleSurplus(_pubsub, _subscribers, _elements, _isShutdown) {
    return succeed(false);
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
};
var SlidingStrategy2 = class {
  get shutdown() {
    return void_;
  }
  handleSurplus(pubsub, subscribers, elements, _isShutdown) {
    return sync(() => {
      this.unsafeSlidingPublish(pubsub, elements);
      this.unsafeCompleteSubscribers(pubsub, subscribers);
      return true;
    });
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeSlidingPublish(pubsub, elements) {
    const it = elements[Symbol.iterator]();
    let next = it.next();
    if (!next.done && pubsub.capacity > 0) {
      let a2 = next.value;
      let loop3 = true;
      while (loop3) {
        pubsub.slide();
        const pub = pubsub.publish(a2);
        if (pub && (next = it.next()) && !next.done) {
          a2 = next.value;
        } else if (pub) {
          loop3 = false;
        }
      }
    }
  }
};
var unsafeStrategyCompletePollers = (strategy, pubsub, subscribers, subscription, pollers) => {
  let keepPolling = true;
  while (keepPolling && !subscription.isEmpty()) {
    const poller = pipe(pollers, poll4(EmptyMutableQueue));
    if (poller === EmptyMutableQueue) {
      pipe(subscribers, removeSubscribers(subscription, pollers));
      if (isEmpty9(pollers)) {
        keepPolling = false;
      } else {
        pipe(subscribers, addSubscribers(subscription, pollers));
      }
    } else {
      const pollResult = subscription.poll(EmptyMutableQueue);
      if (pollResult === EmptyMutableQueue) {
        unsafeOfferAll2(pollers, pipe(unsafePollAllQueue(pollers), prepend2(poller)));
      } else {
        unsafeCompleteDeferred2(poller, pollResult);
        strategy.unsafeOnPubSubEmptySpace(pubsub, subscribers);
      }
    }
  }
};
var unsafeStrategyCompleteSubscribers = (strategy, pubsub, subscribers) => {
  for (const [subscription, pollersSet] of subscribers) {
    for (const pollers of pollersSet) {
      strategy.unsafeCompletePollers(pubsub, subscribers, subscription, pollers);
    }
  }
};
var ReplayBuffer = class {
  capacity;
  constructor(capacity7) {
    this.capacity = capacity7;
  }
  head = {
    value: AbsentValue,
    next: null
  };
  tail = this.head;
  size = 0;
  index = 0;
  slide() {
    this.index++;
  }
  offer(a2) {
    this.tail.value = a2;
    this.tail.next = {
      value: AbsentValue,
      next: null
    };
    this.tail = this.tail.next;
    if (this.size === this.capacity) {
      this.head = this.head.next;
    } else {
      this.size += 1;
    }
  }
  offerAll(as10) {
    for (const a2 of as10) {
      this.offer(a2);
    }
  }
};
var ReplayWindowImpl = class {
  buffer;
  head;
  index;
  remaining;
  constructor(buffer4) {
    this.buffer = buffer4;
    this.index = buffer4.index;
    this.remaining = buffer4.size;
    this.head = buffer4.head;
  }
  fastForward() {
    while (this.index < this.buffer.index) {
      this.head = this.head.next;
      this.index++;
    }
  }
  take() {
    if (this.remaining === 0) {
      return void 0;
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    this.remaining--;
    const value = this.head.value;
    this.head = this.head.next;
    return value;
  }
  takeN(n2) {
    if (this.remaining === 0) {
      return empty2();
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    const len = Math.min(n2, this.remaining);
    const items = new Array(len);
    for (let i = 0; i < len; i++) {
      const value = this.head.value;
      this.head = this.head.next;
      items[i] = value;
    }
    this.remaining -= len;
    return unsafeFromArray(items);
  }
  takeAll() {
    return this.takeN(this.remaining);
  }
};
var emptyReplayWindow = {
  remaining: 0,
  take: () => void 0,
  takeN: () => empty2(),
  takeAll: () => empty2()
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/PubSub.js
var bounded5 = bounded4;
var dropping4 = dropping3;
var sliding4 = sliding3;
var unbounded5 = unbounded4;
var shutdown4 = shutdown3;
var subscribe2 = subscribe;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
var OP_CONTINUE2 = "Continue";
var OP_CLOSE = "Close";
var OP_YIELD2 = "Yield";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
var ChildExecutorDecisionTypeId = /* @__PURE__ */ Symbol.for(ChildExecutorDecisionSymbolKey);
var proto6 = {
  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
};
var Continue = (_2) => {
  const op = Object.create(proto6);
  op._tag = OP_CONTINUE2;
  return op;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/opCodes/continuation.js
var OP_CONTINUATION_K = "ContinuationK";
var OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/channel/continuation.js
var ContinuationTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelContinuation");
var continuationVariance = {
  /* c8 ignore next */
  _Env: (_2) => _2,
  /* c8 ignore next */
  _InErr: (_2) => _2,
  /* c8 ignore next */
  _InElem: (_2) => _2,
  /* c8 ignore next */
  _InDone: (_2) => _2,
  /* c8 ignore next */
  _OutErr: (_2) => _2,
  /* c8 ignore next */
  _OutDone: (_2) => _2,
  /* c8 ignore next */
  _OutErr2: (_2) => _2,
  /* c8 ignore next */
  _OutElem: (_2) => _2,
  /* c8 ignore next */
  _OutDone2: (_2) => _2
};
var ContinuationKImpl = class {
  onSuccess;
  onHalt;
  _tag = OP_CONTINUATION_K;
  [ContinuationTypeId] = continuationVariance;
  constructor(onSuccess, onHalt) {
    this.onSuccess = onSuccess;
    this.onHalt = onHalt;
  }
  onExit(exit4) {
    return isFailure2(exit4) ? this.onHalt(exit4.cause) : this.onSuccess(exit4.value);
  }
};
var ContinuationFinalizerImpl = class {
  finalizer;
  _tag = OP_CONTINUATION_FINALIZER;
  [ContinuationTypeId] = continuationVariance;
  constructor(finalizer3) {
    this.finalizer = finalizer3;
  }
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
var OP_PULL_AFTER_NEXT = "PullAfterNext";
var OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
var UpstreamPullStrategyTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullStrategySymbolKey);
var upstreamPullStrategyVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var proto7 = {
  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
};
var PullAfterNext = (emitSeparator) => {
  const op = Object.create(proto7);
  op._tag = OP_PULL_AFTER_NEXT;
  op.emitSeparator = emitSeparator;
  return op;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/opCodes/channel.js
var OP_BRACKET_OUT = "BracketOut";
var OP_BRIDGE = "Bridge";
var OP_CONCAT_ALL = "ConcatAll";
var OP_EMIT = "Emit";
var OP_ENSURING = "Ensuring";
var OP_FAIL3 = "Fail";
var OP_FOLD2 = "Fold";
var OP_FROM_EFFECT2 = "FromEffect";
var OP_PIPE_TO = "PipeTo";
var OP_PROVIDE2 = "Provide";
var OP_READ = "Read";
var OP_SUCCEED = "Succeed";
var OP_SUCCEED_NOW = "SucceedNow";
var OP_SUSPEND2 = "Suspend";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey = "effect/Channel";
var ChannelTypeId2 = /* @__PURE__ */ Symbol.for(ChannelSymbolKey);
var channelVariance2 = {
  /* c8 ignore next */
  _Env: (_2) => _2,
  /* c8 ignore next */
  _InErr: (_2) => _2,
  /* c8 ignore next */
  _InElem: (_2) => _2,
  /* c8 ignore next */
  _InDone: (_2) => _2,
  /* c8 ignore next */
  _OutErr: (_2) => _2,
  /* c8 ignore next */
  _OutElem: (_2) => _2,
  /* c8 ignore next */
  _OutDone: (_2) => _2
};
var proto8 = {
  [ChannelTypeId2]: channelVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isChannel = (u2) => hasProperty(u2, ChannelTypeId2) || isEffect2(u2);
var acquireReleaseOut = /* @__PURE__ */ dual(2, (self2, release) => {
  const op = Object.create(proto8);
  op._tag = OP_BRACKET_OUT;
  op.acquire = () => self2;
  op.finalizer = release;
  return op;
});
var catchAllCause5 = /* @__PURE__ */ dual(2, (self2, f2) => {
  const op = Object.create(proto8);
  op._tag = OP_FOLD2;
  op.channel = self2;
  op.k = new ContinuationKImpl(succeed13, f2);
  return op;
});
var collectElements = (self2) => {
  return suspend8(() => {
    const builder = [];
    return flatMap13(pipeTo(self2, collectElementsReader(builder)), (value) => sync9(() => [fromIterable2(builder), value]));
  });
};
var collectElementsReader = (builder) => readWith({
  onInput: (outElem) => flatMap13(sync9(() => {
    builder.push(outElem);
  }), () => collectElementsReader(builder)),
  onFailure: fail13,
  onDone: succeedNow
});
var concatAllWith = (channels, f2, g) => {
  const op = Object.create(proto8);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = f2;
  op.combineAll = g;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => channels;
  op.k = identity;
  return op;
};
var concatMapWith = /* @__PURE__ */ dual(4, (self2, f2, g, h3) => {
  const op = Object.create(proto8);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h3;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => self2;
  op.k = f2;
  return op;
});
var embedInput = /* @__PURE__ */ dual(2, (self2, input2) => {
  const op = Object.create(proto8);
  op._tag = OP_BRIDGE;
  op.input = input2;
  op.channel = self2;
  return op;
});
var ensuringWith = /* @__PURE__ */ dual(2, (self2, finalizer3) => {
  const op = Object.create(proto8);
  op._tag = OP_ENSURING;
  op.channel = self2;
  op.finalizer = finalizer3;
  return op;
});
var fail13 = (error4) => failCause10(fail5(error4));
var failCause10 = (cause3) => failCauseSync5(() => cause3);
var failCauseSync5 = (evaluate3) => {
  const op = Object.create(proto8);
  op._tag = OP_FAIL3;
  op.error = evaluate3;
  return op;
};
var flatMap13 = /* @__PURE__ */ dual(2, (self2, f2) => {
  const op = Object.create(proto8);
  op._tag = OP_FOLD2;
  op.channel = self2;
  op.k = new ContinuationKImpl(f2, failCause10);
  return op;
});
var foldCauseChannel = /* @__PURE__ */ dual(2, (self2, options) => {
  const op = Object.create(proto8);
  op._tag = OP_FOLD2;
  op.channel = self2;
  op.k = new ContinuationKImpl(options.onSuccess, options.onFailure);
  return op;
});
var fromEffect4 = (effect4) => {
  const op = Object.create(proto8);
  op._tag = OP_FROM_EFFECT2;
  op.effect = () => effect4;
  return op;
};
var pipeTo = /* @__PURE__ */ dual(2, (self2, that) => {
  const op = Object.create(proto8);
  op._tag = OP_PIPE_TO;
  op.left = () => self2;
  op.right = () => that;
  return op;
});
var provideContext4 = /* @__PURE__ */ dual(2, (self2, env2) => {
  const op = Object.create(proto8);
  op._tag = OP_PROVIDE2;
  op.context = () => env2;
  op.inner = self2;
  return op;
});
var readWith = (options) => readWithCause({
  onInput: options.onInput,
  onFailure: (cause3) => match(failureOrCause2(cause3), {
    onLeft: options.onFailure,
    onRight: failCause10
  }),
  onDone: options.onDone
});
var readWithCause = (options) => {
  const op = Object.create(proto8);
  op._tag = OP_READ;
  op.more = options.onInput;
  op.done = new ContinuationKImpl(options.onDone, options.onFailure);
  return op;
};
var succeed13 = (value) => sync9(() => value);
var succeedNow = (result) => {
  const op = Object.create(proto8);
  op._tag = OP_SUCCEED_NOW;
  op.terminal = result;
  return op;
};
var suspend8 = (evaluate3) => {
  const op = Object.create(proto8);
  op._tag = OP_SUSPEND2;
  op.channel = evaluate3;
  return op;
};
var sync9 = (evaluate3) => {
  const op = Object.create(proto8);
  op._tag = OP_SUCCEED;
  op.evaluate = evaluate3;
  return op;
};
var void_5 = /* @__PURE__ */ succeedNow(void 0);
var write = (out) => {
  const op = Object.create(proto8);
  op._tag = OP_EMIT;
  op.out = out;
  return op;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/opCodes/channelState.js
var OP_DONE3 = "Done";
var OP_EMIT2 = "Emit";
var OP_FROM_EFFECT3 = "FromEffect";
var OP_READ2 = "Read";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/channel/channelState.js
var ChannelStateTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelState");
var channelStateVariance = {
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _R: (_2) => _2
};
var proto9 = {
  [ChannelStateTypeId]: channelStateVariance
};
var Done2 = () => {
  const op = Object.create(proto9);
  op._tag = OP_DONE3;
  return op;
};
var Emit = () => {
  const op = Object.create(proto9);
  op._tag = OP_EMIT2;
  return op;
};
var fromEffect5 = (effect4) => {
  const op = Object.create(proto9);
  op._tag = OP_FROM_EFFECT3;
  op.effect = effect4;
  return op;
};
var Read = (upstream, onEffect, onEmit, onDone3) => {
  const op = Object.create(proto9);
  op._tag = OP_READ2;
  op.upstream = upstream;
  op.onEffect = onEffect;
  op.onEmit = onEmit;
  op.onDone = onDone3;
  return op;
};
var isFromEffect = (self2) => self2._tag === OP_FROM_EFFECT3;
var effect2 = (self2) => isFromEffect(self2) ? self2.effect : _void;
var effectOrUndefinedIgnored = (self2) => isFromEffect(self2) ? ignore2(self2.effect) : void 0;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/channel/subexecutor.js
var OP_PULL_FROM_CHILD = "PullFromChild";
var OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
var OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
var OP_EMIT3 = "Emit";
var PullFromChild = class {
  childExecutor;
  parentSubexecutor;
  onEmit;
  _tag = OP_PULL_FROM_CHILD;
  constructor(childExecutor, parentSubexecutor, onEmit) {
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
  }
  close(exit4) {
    const fin1 = this.childExecutor.close(exit4);
    const fin2 = this.parentSubexecutor.close(exit4);
    if (fin1 !== void 0 && fin2 !== void 0) {
      return zipWith5(exit3(fin1), exit3(fin2), (exit1, exit22) => pipe(exit1, zipRight2(exit22)));
    } else if (fin1 !== void 0) {
      return fin1;
    } else if (fin2 !== void 0) {
      return fin2;
    } else {
      return void 0;
    }
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};
var PullFromUpstream = class _PullFromUpstream {
  upstreamExecutor;
  createChild;
  lastDone;
  activeChildExecutors;
  combineChildResults;
  combineWithChildResult;
  onPull;
  onEmit;
  _tag = OP_PULL_FROM_UPSTREAM;
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
    this.upstreamExecutor = upstreamExecutor;
    this.createChild = createChild;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this.onEmit = onEmit;
  }
  close(exit4) {
    const fin1 = this.upstreamExecutor.close(exit4);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit4) : void 0), fin1];
    const result = fins.reduce((acc, next) => {
      if (acc !== void 0 && next !== void 0) {
        return zipWith5(acc, exit3(next), (exit1, exit22) => zipRight2(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next !== void 0) {
        return exit3(next);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
  }
};
var DrainChildExecutors = class _DrainChildExecutors {
  upstreamExecutor;
  lastDone;
  activeChildExecutors;
  upstreamDone;
  combineChildResults;
  combineWithChildResult;
  onPull;
  _tag = OP_DRAIN_CHILD_EXECUTORS;
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
    this.upstreamExecutor = upstreamExecutor;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.upstreamDone = upstreamDone;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
  }
  close(exit4) {
    const fin1 = this.upstreamExecutor.close(exit4);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit4) : void 0), fin1];
    const result = fins.reduce((acc, next) => {
      if (acc !== void 0 && next !== void 0) {
        return zipWith5(acc, exit3(next), (exit1, exit22) => zipRight2(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next !== void 0) {
        return exit3(next);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
  }
};
var Emit2 = class {
  value;
  next;
  _tag = OP_EMIT3;
  constructor(value, next) {
    this.value = value;
    this.next = next;
  }
  close(exit4) {
    const result = this.next.close(exit4);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
var OP_PULLED = "Pulled";
var OP_NO_UPSTREAM = "NoUpstream";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
var UpstreamPullRequestTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullRequestSymbolKey);
var upstreamPullRequestVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var proto10 = {
  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
};
var Pulled = (value) => {
  const op = Object.create(proto10);
  op._tag = OP_PULLED;
  op.value = value;
  return op;
};
var NoUpstream = (activeDownstreamCount) => {
  const op = Object.create(proto10);
  op._tag = OP_NO_UPSTREAM;
  op.activeDownstreamCount = activeDownstreamCount;
  return op;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/channel/channelExecutor.js
var ChannelExecutor = class _ChannelExecutor {
  _activeSubexecutor = void 0;
  _cancelled = void 0;
  _closeLastSubstream = void 0;
  _currentChannel;
  _done = void 0;
  _doneStack = [];
  _emitted = void 0;
  _executeCloseLastSubstream;
  _input = void 0;
  _inProgressFinalizer = void 0;
  _providedEnv;
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    this._currentChannel = initialChannel;
    this._executeCloseLastSubstream = executeCloseLastSubstream;
    this._providedEnv = providedEnv;
  }
  run() {
    let result = void 0;
    while (result === void 0) {
      if (this._cancelled !== void 0) {
        result = this.processCancellation();
      } else if (this._activeSubexecutor !== void 0) {
        result = this.runSubexecutor();
      } else {
        try {
          if (this._currentChannel === void 0) {
            result = Done2();
          } else {
            if (isEffect2(this._currentChannel)) {
              this._currentChannel = fromEffect4(this._currentChannel);
            }
            switch (this._currentChannel._tag) {
              case OP_BRACKET_OUT: {
                result = this.runBracketOut(this._currentChannel);
                break;
              }
              case OP_BRIDGE: {
                const bridgeInput = this._currentChannel.input;
                this._currentChannel = this._currentChannel.channel;
                if (this._input !== void 0) {
                  const inputExecutor = this._input;
                  this._input = void 0;
                  const drainer = () => flatMap11(bridgeInput.awaitRead(), () => suspend4(() => {
                    const state = inputExecutor.run();
                    switch (state._tag) {
                      case OP_DONE3: {
                        return match9(inputExecutor.getDone(), {
                          onFailure: (cause3) => bridgeInput.error(cause3),
                          onSuccess: (value) => bridgeInput.done(value)
                        });
                      }
                      case OP_EMIT2: {
                        return flatMap11(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                      }
                      case OP_FROM_EFFECT3: {
                        return matchCauseEffect3(state.effect, {
                          onFailure: (cause3) => bridgeInput.error(cause3),
                          onSuccess: () => drainer()
                        });
                      }
                      case OP_READ2: {
                        return readUpstream(state, () => drainer(), (cause3) => bridgeInput.error(cause3));
                      }
                    }
                  }));
                  result = fromEffect5(flatMap11(forkDaemon2(interruptible4(drainer())), (fiber) => sync4(() => this.addFinalizer((exit4) => flatMap11(interrupt6(fiber), () => suspend4(() => {
                    const effect4 = this.restorePipe(exit4, inputExecutor);
                    return effect4 !== void 0 ? effect4 : _void;
                  }))))));
                }
                break;
              }
              case OP_CONCAT_ALL: {
                const executor = new _ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect4) => sync4(() => {
                  const prevLastClose = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
                  this._closeLastSubstream = pipe(prevLastClose, zipRight3(effect4));
                }));
                executor._input = this._input;
                const channel = this._currentChannel;
                this._activeSubexecutor = new PullFromUpstream(executor, (value) => channel.k(value), void 0, [], (x2, y) => channel.combineInners(x2, y), (x2, y) => channel.combineAll(x2, y), (request2) => channel.onPull(request2), (value) => channel.onEmit(value));
                this._closeLastSubstream = void 0;
                this._currentChannel = void 0;
                break;
              }
              case OP_EMIT: {
                this._emitted = this._currentChannel.out;
                this._currentChannel = this._activeSubexecutor !== void 0 ? void 0 : void_5;
                result = Emit();
                break;
              }
              case OP_ENSURING: {
                this.runEnsuring(this._currentChannel);
                break;
              }
              case OP_FAIL3: {
                result = this.doneHalt(this._currentChannel.error());
                break;
              }
              case OP_FOLD2: {
                this._doneStack.push(this._currentChannel.k);
                this._currentChannel = this._currentChannel.channel;
                break;
              }
              case OP_FROM_EFFECT2: {
                const effect4 = this._providedEnv === void 0 ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                result = fromEffect5(matchCauseEffect3(effect4, {
                  onFailure: (cause3) => {
                    const state = this.doneHalt(cause3);
                    return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                  },
                  onSuccess: (value) => {
                    const state = this.doneSucceed(value);
                    return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                  }
                }));
                break;
              }
              case OP_PIPE_TO: {
                const previousInput = this._input;
                const leftExec = new _ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect4) => this._executeCloseLastSubstream(effect4));
                leftExec._input = previousInput;
                this._input = leftExec;
                this.addFinalizer((exit4) => {
                  const effect4 = this.restorePipe(exit4, previousInput);
                  return effect4 !== void 0 ? effect4 : _void;
                });
                this._currentChannel = this._currentChannel.right();
                break;
              }
              case OP_PROVIDE2: {
                const previousEnv = this._providedEnv;
                this._providedEnv = this._currentChannel.context();
                this._currentChannel = this._currentChannel.inner;
                this.addFinalizer(() => sync4(() => {
                  this._providedEnv = previousEnv;
                }));
                break;
              }
              case OP_READ: {
                const read2 = this._currentChannel;
                result = Read(this._input, identity, (emitted) => {
                  try {
                    this._currentChannel = read2.more(emitted);
                  } catch (error4) {
                    this._currentChannel = read2.done.onExit(die3(error4));
                  }
                  return void 0;
                }, (exit4) => {
                  const onExit4 = (exit5) => {
                    return read2.done.onExit(exit5);
                  };
                  this._currentChannel = onExit4(exit4);
                  return void 0;
                });
                break;
              }
              case OP_SUCCEED: {
                result = this.doneSucceed(this._currentChannel.evaluate());
                break;
              }
              case OP_SUCCEED_NOW: {
                result = this.doneSucceed(this._currentChannel.terminal);
                break;
              }
              case OP_SUSPEND2: {
                this._currentChannel = this._currentChannel.channel();
                break;
              }
            }
          }
        } catch (error4) {
          this._currentChannel = failCause10(die4(error4));
        }
      }
    }
    return result;
  }
  getDone() {
    return this._done;
  }
  getEmit() {
    return this._emitted;
  }
  cancelWith(exit4) {
    this._cancelled = exit4;
  }
  clearInProgressFinalizer() {
    this._inProgressFinalizer = void 0;
  }
  storeInProgressFinalizer(finalizer3) {
    this._inProgressFinalizer = finalizer3;
  }
  popAllFinalizers(exit4) {
    const finalizers = [];
    let next = this._doneStack.pop();
    while (next) {
      if (next._tag === "ContinuationFinalizer") {
        finalizers.push(next.finalizer);
      }
      next = this._doneStack.pop();
    }
    const effect4 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit4);
    this.storeInProgressFinalizer(effect4);
    return effect4;
  }
  popNextFinalizers() {
    const builder = [];
    while (this._doneStack.length !== 0) {
      const cont = this._doneStack[this._doneStack.length - 1];
      if (cont._tag === OP_CONTINUATION_K) {
        return builder;
      }
      builder.push(cont);
      this._doneStack.pop();
    }
    return builder;
  }
  restorePipe(exit4, prev) {
    const currInput = this._input;
    this._input = prev;
    if (currInput !== void 0) {
      const effect4 = currInput.close(exit4);
      return effect4;
    }
    return _void;
  }
  close(exit4) {
    let runInProgressFinalizers = void 0;
    const finalizer3 = this._inProgressFinalizer;
    if (finalizer3 !== void 0) {
      runInProgressFinalizers = pipe(finalizer3, ensuring2(sync4(() => this.clearInProgressFinalizer())));
    }
    let closeSelf = void 0;
    const selfFinalizers = this.popAllFinalizers(exit4);
    if (selfFinalizers !== void 0) {
      closeSelf = pipe(selfFinalizers, ensuring2(sync4(() => this.clearInProgressFinalizer())));
    }
    const closeSubexecutors = this._activeSubexecutor === void 0 ? void 0 : this._activeSubexecutor.close(exit4);
    if (closeSubexecutors === void 0 && runInProgressFinalizers === void 0 && closeSelf === void 0) {
      return void 0;
    }
    return pipe(
      exit3(ifNotNull(closeSubexecutors)),
      zip5(exit3(ifNotNull(runInProgressFinalizers))),
      zip5(exit3(ifNotNull(closeSelf))),
      map16(([[exit1, exit22], exit32]) => pipe(exit1, zipRight2(exit22), zipRight2(exit32))),
      uninterruptible2,
      // TODO: remove
      flatMap11((exit5) => suspend4(() => exit5))
    );
  }
  doneSucceed(value) {
    if (this._doneStack.length === 0) {
      this._done = succeed4(value);
      this._currentChannel = void 0;
      return Done2();
    }
    const head6 = this._doneStack[this._doneStack.length - 1];
    if (head6._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head6.onSuccess(value);
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = succeed4(value);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f2) => f2.finalizer), succeed4(value));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect4 = pipe(finalizerEffect, ensuring2(sync4(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap11(() => sync4(() => this.doneSucceed(value))));
    return fromEffect5(effect4);
  }
  doneHalt(cause3) {
    if (this._doneStack.length === 0) {
      this._done = failCause4(cause3);
      this._currentChannel = void 0;
      return Done2();
    }
    const head6 = this._doneStack[this._doneStack.length - 1];
    if (head6._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      try {
        this._currentChannel = head6.onHalt(cause3);
      } catch (error4) {
        this._currentChannel = failCause10(die4(error4));
      }
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = failCause4(cause3);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f2) => f2.finalizer), failCause4(cause3));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect4 = pipe(finalizerEffect, ensuring2(sync4(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap11(() => sync4(() => this.doneHalt(cause3))));
    return fromEffect5(effect4);
  }
  processCancellation() {
    this._currentChannel = void 0;
    this._done = this._cancelled;
    this._cancelled = void 0;
    return Done2();
  }
  runBracketOut(bracketOut) {
    const effect4 = uninterruptible2(matchCauseEffect3(this.provide(bracketOut.acquire()), {
      onFailure: (cause3) => sync4(() => {
        this._currentChannel = failCause10(cause3);
      }),
      onSuccess: (out) => sync4(() => {
        this.addFinalizer((exit4) => this.provide(bracketOut.finalizer(out, exit4)));
        this._currentChannel = write(out);
      })
    }));
    return fromEffect5(effect4);
  }
  provide(effect4) {
    if (this._providedEnv === void 0) {
      return effect4;
    }
    return pipe(effect4, provide2(this._providedEnv));
  }
  runEnsuring(ensuring8) {
    this.addFinalizer(ensuring8.finalizer);
    this._currentChannel = ensuring8.channel;
  }
  addFinalizer(f2) {
    this._doneStack.push(new ContinuationFinalizerImpl(f2));
  }
  runSubexecutor() {
    const subexecutor = this._activeSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_CHILD: {
        return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
      }
      case OP_PULL_FROM_UPSTREAM: {
        return this.pullFromUpstream(subexecutor);
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        return this.drainChildExecutors(subexecutor);
      }
      case OP_EMIT3: {
        this._emitted = subexecutor.value;
        this._activeSubexecutor = subexecutor.next;
        return Emit();
      }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this._currentChannel = void 0;
    this._activeSubexecutor = nextSubExec;
  }
  finishWithExit(exit4) {
    const state = match9(exit4, {
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value) => this.doneSucceed(value)
    });
    this._activeSubexecutor = void 0;
    return state === void 0 ? _void : effect2(state);
  }
  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
    this.addFinalizer(() => pipe(closeFuncs, forEach9((closeFunc) => pipe(sync4(() => closeFunc(subexecutorDone)), flatMap11((closeEffect) => closeEffect !== void 0 ? closeEffect : _void)), {
      discard: true
    })));
    const state = pipe(subexecutorDone, match9({
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value) => this.doneSucceed(value)
    }));
    this._activeSubexecutor = void 0;
    return state;
  }
  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
    switch (strategy._tag) {
      case OP_PULL_AFTER_NEXT: {
        const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldPrepend ? [void 0, ...queue] : queue];
      }
      case OP_PULL_AFTER_ALL_ENQUEUED: {
        const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldEnqueue ? [...queue, void 0] : queue];
      }
    }
  }
  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
    return Read(childExecutor, identity, (emitted) => {
      const childExecutorDecision = onEmitted(emitted);
      switch (childExecutorDecision._tag) {
        case OP_CONTINUE2: {
          break;
        }
        case OP_CLOSE: {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
          break;
        }
        case OP_YIELD2: {
          const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      }
      this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
      return void 0;
    }, match9({
      onFailure: (cause3) => {
        const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3);
        return state === void 0 ? void 0 : effectOrUndefinedIgnored(state);
      },
      onSuccess: (doneValue) => {
        this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
        return void 0;
      }
    }));
  }
  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
    const subexecutor = parentSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_UPSTREAM: {
        const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
        this._closeLastSubstream = childExecutor.close(succeed4(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        this._closeLastSubstream = childExecutor.close(succeed4(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
    }
  }
  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3) {
    return this.finishSubexecutorWithCloseEffect(failCause4(cause3), (exit4) => parentSubexecutor.close(exit4), (exit4) => childExecutor.close(exit4));
  }
  pullFromUpstream(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      return this.performPullFromUpstream(subexecutor);
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
    if (activeChild === void 0) {
      return this.performPullFromUpstream(parentSubexecutor);
    }
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
  performPullFromUpstream(subexecutor) {
    return Read(subexecutor.upstreamExecutor, (effect4) => {
      const closeLastSubstream = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
      this._closeLastSubstream = void 0;
      return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight3(effect4));
    }, (emitted) => {
      if (this._closeLastSubstream !== void 0) {
        const closeLastSubstream = this._closeLastSubstream;
        this._closeLastSubstream = void 0;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), map16(() => {
          const childExecutor2 = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor2._input = this._input;
          const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
          this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (isSome2(emitSeparator2)) {
            this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
          }
          return void 0;
        }));
      }
      const childExecutor = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
      childExecutor._input = this._input;
      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
      this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
      if (isSome2(emitSeparator)) {
        this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
      }
      return void 0;
    }, (exit4) => {
      if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== void 0)) {
        const drain5 = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [void 0, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        if (this._closeLastSubstream !== void 0) {
          const closeLastSubstream2 = this._closeLastSubstream;
          this._closeLastSubstream = void 0;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map16(() => this.replaceSubexecutor(drain5)));
        }
        this.replaceSubexecutor(drain5);
        return void 0;
      }
      const closeLastSubstream = this._closeLastSubstream;
      const state = this.finishSubexecutorWithCloseEffect(pipe(exit4, map11((a2) => subexecutor.combineWithChildResult(subexecutor.lastDone, a2))), () => closeLastSubstream, (exit5) => subexecutor.upstreamExecutor.close(exit5));
      return state === void 0 ? void 0 : (
        // NOTE: assuming finalizers cannot fail
        effectOrUndefinedIgnored(state)
      );
    });
  }
  drainChildExecutors(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      const lastClose = this._closeLastSubstream;
      if (lastClose !== void 0) {
        this.addFinalizer(() => succeed8(lastClose));
      }
      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit4) => subexecutor.upstreamExecutor.close(exit4));
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const rest = subexecutor.activeChildExecutors.slice(1);
    if (activeChild === void 0) {
      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n2, curr) => curr !== void 0 ? n2 + 1 : n2, 0))));
      this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
      if (isSome2(emitSeparator)) {
        this._emitted = emitSeparator.value;
        return Emit();
      }
      return void 0;
    }
    const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
};
var ifNotNull = (effect4) => effect4 !== void 0 ? effect4 : _void;
var runFinalizers = (finalizers, exit4) => {
  return pipe(forEach9(finalizers, (fin) => exit3(fin(exit4))), map16((exits) => pipe(all2(exits), getOrElse(() => void_3))), flatMap11((exit5) => suspend4(() => exit5)));
};
var readUpstream = (r, onSuccess, onFailure) => {
  const readStack = [r];
  const read2 = () => {
    const current2 = readStack.pop();
    if (current2 === void 0 || current2.upstream === void 0) {
      return dieMessage2("Unexpected end of input for channel execution");
    }
    const state = current2.upstream.run();
    switch (state._tag) {
      case OP_EMIT2: {
        const emitEffect = current2.onEmit(current2.upstream.getEmit());
        if (readStack.length === 0) {
          if (emitEffect === void 0) {
            return suspend4(onSuccess);
          }
          return pipe(emitEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (emitEffect === void 0) {
          return suspend4(() => read2());
        }
        return pipe(emitEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read2()
        }));
      }
      case OP_DONE3: {
        const doneEffect = current2.onDone(current2.upstream.getDone());
        if (readStack.length === 0) {
          if (doneEffect === void 0) {
            return suspend4(onSuccess);
          }
          return pipe(doneEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (doneEffect === void 0) {
          return suspend4(() => read2());
        }
        return pipe(doneEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read2()
        }));
      }
      case OP_FROM_EFFECT3: {
        readStack.push(current2);
        return pipe(current2.onEffect(state.effect), catchAllCause3((cause3) => suspend4(() => {
          const doneEffect = current2.onDone(failCause4(cause3));
          return doneEffect === void 0 ? _void : doneEffect;
        })), matchCauseEffect3({
          onFailure,
          onSuccess: () => read2()
        }));
      }
      case OP_READ2: {
        readStack.push(current2);
        readStack.push(state);
        return suspend4(() => read2());
      }
    }
  };
  return read2();
};
var runIn = /* @__PURE__ */ dual(2, (self2, scope5) => {
  const run5 = (channelDeferred, scopeDeferred, scope6) => acquireUseRelease2(sync4(() => new ChannelExecutor(self2, void 0, identity)), (exec) => suspend4(() => runScopedInterpret(exec.run(), exec).pipe(intoDeferred2(channelDeferred), zipRight3(_await(channelDeferred)), zipLeft2(_await(scopeDeferred)))), (exec, exit4) => {
    const finalize = exec.close(exit4);
    if (finalize === void 0) {
      return _void;
    }
    return tapErrorCause3(finalize, (cause3) => addFinalizer2(scope6, failCause8(cause3)));
  });
  return uninterruptibleMask3((restore) => all4([fork2(scope5, sequential3), make23(), make23()]).pipe(flatMap11(([child, channelDeferred, scopeDeferred]) => restore(run5(channelDeferred, scopeDeferred, child)).pipe(forkIn2(scope5), flatMap11((fiber) => scope5.addFinalizer((exit4) => {
    const interruptors3 = isFailure2(exit4) ? interruptors2(exit4.cause) : void 0;
    return isDone(channelDeferred).pipe(flatMap11((isDone7) => isDone7 ? succeed2(scopeDeferred, void 0).pipe(zipRight3(_await3(fiber)), zipRight3(inheritAll2(fiber))) : succeed2(scopeDeferred, void 0).pipe(zipRight3(interruptors3 && size3(interruptors3) > 0 ? interruptAs(fiber, combineAll2(interruptors3)) : interrupt6(fiber)), zipRight3(inheritAll2(fiber)))));
  }).pipe(zipRight3(restore(_await(channelDeferred)))))))));
});
var runScopedInterpret = (channelState, exec) => {
  const op = channelState;
  switch (op._tag) {
    case OP_FROM_EFFECT3: {
      return pipe(op.effect, flatMap11(() => runScopedInterpret(exec.run(), exec)));
    }
    case OP_EMIT2: {
      return runScopedInterpret(exec.run(), exec);
    }
    case OP_DONE3: {
      return suspend4(() => exec.getDone());
    }
    case OP_READ2: {
      return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause8);
    }
  }
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
var OP_DONE4 = "Done";
var OP_AWAIT = "Await";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
var MergeDecisionTypeId = /* @__PURE__ */ Symbol.for(MergeDecisionSymbolKey);
var proto11 = {
  [MergeDecisionTypeId]: {
    _R: (_2) => _2,
    _E0: (_2) => _2,
    _Z0: (_2) => _2,
    _E: (_2) => _2,
    _Z: (_2) => _2
  }
};
var Done3 = (effect4) => {
  const op = Object.create(proto11);
  op._tag = OP_DONE4;
  op.effect = effect4;
  return op;
};
var Await = (f2) => {
  const op = Object.create(proto11);
  op._tag = OP_AWAIT;
  op.f = f2;
  return op;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
var OP_BOTH_RUNNING = "BothRunning";
var OP_LEFT_DONE = "LeftDone";
var OP_RIGHT_DONE = "RightDone";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey = "effect/ChannelMergeState";
var MergeStateTypeId = /* @__PURE__ */ Symbol.for(MergeStateSymbolKey);
var proto12 = {
  [MergeStateTypeId]: MergeStateTypeId
};
var BothRunning = (left3, right3) => {
  const op = Object.create(proto12);
  op._tag = OP_BOTH_RUNNING;
  op.left = left3;
  op.right = right3;
  return op;
};
var LeftDone = (f2) => {
  const op = Object.create(proto12);
  op._tag = OP_LEFT_DONE;
  op.f = f2;
  return op;
};
var RightDone = (f2) => {
  const op = Object.create(proto12);
  op._tag = OP_RIGHT_DONE;
  op.f = f2;
  return op;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
var OP_BACK_PRESSURE = "BackPressure";
var OP_BUFFER_SLIDING = "BufferSliding";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
var MergeStrategyTypeId = /* @__PURE__ */ Symbol.for(MergeStrategySymbolKey);
var proto13 = {
  [MergeStrategyTypeId]: MergeStrategyTypeId
};
var BackPressure = (_2) => {
  const op = Object.create(proto13);
  op._tag = OP_BACK_PRESSURE;
  return op;
};
var BufferSliding = (_2) => {
  const op = Object.create(proto13);
  op._tag = OP_BUFFER_SLIDING;
  return op;
};
var match14 = /* @__PURE__ */ dual(2, (self2, {
  onBackPressure,
  onBufferSliding
}) => {
  switch (self2._tag) {
    case OP_BACK_PRESSURE: {
      return onBackPressure();
    }
    case OP_BUFFER_SLIDING: {
      return onBufferSliding();
    }
  }
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
var OP_STATE_EMPTY = "Empty";
var OP_STATE_EMIT = "Emit";
var OP_STATE_ERROR = "Error";
var OP_STATE_DONE2 = "Done";
var stateEmpty = (notifyProducer) => ({
  _tag: OP_STATE_EMPTY,
  notifyProducer
});
var stateEmit = (notifyConsumers) => ({
  _tag: OP_STATE_EMIT,
  notifyConsumers
});
var stateError = (cause3) => ({
  _tag: OP_STATE_ERROR,
  cause: cause3
});
var stateDone = (done11) => ({
  _tag: OP_STATE_DONE2,
  done: done11
});
var SingleProducerAsyncInputImpl = class {
  ref;
  constructor(ref) {
    this.ref = ref;
  }
  awaitRead() {
    return flatten8(modify3(this.ref, (state) => state._tag === OP_STATE_EMPTY ? [_await(state.notifyProducer), state] : [_void, state]));
  }
  get close() {
    return fiberIdWith2((fiberId3) => this.error(interrupt5(fiberId3)));
  }
  done(value) {
    return flatten8(modify3(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach9(state.notifyConsumers, (deferred2) => succeed2(deferred2, left2(value)), {
            discard: true
          }), stateDone(value)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    }));
  }
  emit(element) {
    return flatMap11(make23(), (deferred2) => flatten8(modify3(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          const notifyConsumer = state.notifyConsumers[0];
          const notifyConsumers = state.notifyConsumers.slice(1);
          if (notifyConsumer !== void 0) {
            return [succeed2(notifyConsumer, right2(element)), notifyConsumers.length === 0 ? stateEmpty(deferred2) : stateEmit(notifyConsumers)];
          }
          throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    })));
  }
  error(cause3) {
    return flatten8(modify3(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach9(state.notifyConsumers, (deferred2) => failCause2(deferred2, cause3), {
            discard: true
          }), stateError(cause3)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    }));
  }
  get take() {
    return this.takeWith((cause3) => failCause4(map12(cause3, left2)), (elem) => succeed4(elem), (done11) => fail4(right2(done11)));
  }
  takeWith(onError7, onElement, onDone3) {
    return flatMap11(make23(), (deferred2) => flatten8(modify3(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [zipRight3(succeed2(state.notifyProducer, void 0), matchCause4(_await(deferred2), {
            onFailure: onError7,
            onSuccess: match({
              onLeft: onDone3,
              onRight: onElement
            })
          })), stateEmit([deferred2])];
        }
        case OP_STATE_EMIT: {
          return [matchCause4(_await(deferred2), {
            onFailure: onError7,
            onSuccess: match({
              onLeft: onDone3,
              onRight: onElement
            })
          }), stateEmit([...state.notifyConsumers, deferred2])];
        }
        case OP_STATE_ERROR: {
          return [succeed8(onError7(state.cause)), state];
        }
        case OP_STATE_DONE2: {
          return [succeed8(onDone3(state.done)), state];
        }
      }
    })));
  }
};
var make44 = () => pipe(make23(), flatMap11((deferred2) => make25(stateEmpty(deferred2))), map16((ref) => new SingleProducerAsyncInputImpl(ref)));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/channel.js
var acquireUseRelease3 = (acquire, use, release) => flatMap13(fromEffect4(make25(() => _void)), (ref) => pipe(fromEffect4(uninterruptible2(tap3(acquire, (a2) => set5(ref, (exit4) => release(a2, exit4))))), flatMap13(use), ensuringWith((exit4) => flatMap11(get11(ref), (f2) => f2(exit4)))));
var as6 = /* @__PURE__ */ dual(2, (self2, value) => map20(self2, () => value));
var catchAll5 = /* @__PURE__ */ dual(2, (self2, f2) => catchAllCause5(self2, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f2,
  onRight: failCause10
})));
var concatMap = /* @__PURE__ */ dual(2, (self2, f2) => concatMapWith(self2, f2, () => void 0, () => void 0));
var drain = (self2) => {
  const drainer = readWithCause({
    onInput: () => drainer,
    onFailure: failCause10,
    onDone: succeed13
  });
  return pipeTo(self2, drainer);
};
var ensuring4 = /* @__PURE__ */ dual(2, (self2, finalizer3) => ensuringWith(self2, () => finalizer3));
var flatten10 = (self2) => flatMap13(self2, identity);
var foldChannel = /* @__PURE__ */ dual(2, (self2, options) => foldCauseChannel(self2, {
  onFailure: (cause3) => {
    const either7 = failureOrCause2(cause3);
    switch (either7._tag) {
      case "Left": {
        return options.onFailure(either7.left);
      }
      case "Right": {
        return failCause10(either7.right);
      }
    }
  },
  onSuccess: options.onSuccess
}));
var fromInput = (input2) => unwrap3(input2.takeWith(failCause10, (elem) => flatMap13(write(elem), () => fromInput(input2)), succeed13));
var fromQueue = (queue) => suspend8(() => fromQueueInternal(queue));
var fromQueueInternal = (queue) => pipe(fromEffect4(take3(queue)), flatMap13(match({
  onLeft: match9({
    onFailure: failCause10,
    onSuccess: succeedNow
  }),
  onRight: (elem) => flatMap13(write(elem), () => fromQueueInternal(queue))
})));
var identityChannel = () => readWith({
  onInput: (input2) => flatMap13(write(input2), () => identityChannel()),
  onFailure: fail13,
  onDone: succeedNow
});
var interruptWhen = /* @__PURE__ */ dual(2, (self2, effect4) => mergeWith2(self2, {
  other: fromEffect4(effect4),
  onSelfDone: (selfDone) => Done3(suspend4(() => selfDone)),
  onOtherDone: (effectDone) => Done3(suspend4(() => effectDone))
}));
var interruptWhenDeferred = /* @__PURE__ */ dual(2, (self2, deferred2) => interruptWhen(self2, _await(deferred2)));
var map20 = /* @__PURE__ */ dual(2, (self2, f2) => flatMap13(self2, (a2) => sync9(() => f2(a2))));
var mapError5 = /* @__PURE__ */ dual(2, (self2, f2) => mapErrorCause3(self2, map12(f2)));
var mapErrorCause3 = /* @__PURE__ */ dual(2, (self2, f2) => catchAllCause5(self2, (cause3) => failCause10(f2(cause3))));
var mapOut = /* @__PURE__ */ dual(2, (self2, f2) => {
  const reader = readWith({
    onInput: (outElem) => flatMap13(write(f2(outElem)), () => reader),
    onFailure: fail13,
    onDone: succeedNow
  });
  return pipeTo(self2, reader);
});
var mapOutEffect = /* @__PURE__ */ dual(2, (self2, f2) => {
  const reader = readWithCause({
    onInput: (outElem) => pipe(fromEffect4(f2(outElem)), flatMap13(write), flatMap13(() => reader)),
    onFailure: failCause10,
    onDone: succeedNow
  });
  return pipeTo(self2, reader);
});
var mapOutEffectPar = /* @__PURE__ */ dual(3, (self2, f2, n2) => unwrapScopedWith((scope5) => gen2(function* () {
  const input2 = yield* make44();
  const queueReader = fromInput(input2);
  const queue = yield* bounded3(n2);
  yield* addFinalizer2(scope5, shutdown2(queue));
  const errorSignal = yield* make23();
  const withPermits = n2 === Number.POSITIVE_INFINITY ? (_2) => identity : (yield* makeSemaphore2(n2)).withPermits;
  const pull = yield* queueReader.pipe(pipeTo(self2), toPullIn(scope5));
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause3) => offer3(queue, failCause8(cause3)),
    onSuccess: match({
      onLeft: (outDone) => zipRight3(interruptible4(withPermits(n2)(_void)), asVoid2(offer3(queue, succeed8(left2(outDone))))),
      onRight: (outElem) => gen2(function* () {
        const deferred2 = yield* make23();
        const latch = yield* make23();
        yield* offer3(queue, map16(_await(deferred2), right2));
        yield* succeed2(latch, void 0).pipe(zipRight3(uninterruptibleMask3((restore) => exit3(restore(_await(errorSignal))).pipe(raceFirst2(exit3(restore(f2(outElem)))), flatMap11(identity))).pipe(tapErrorCause3((cause3) => failCause2(errorSignal, cause3)), intoDeferred2(deferred2))), withPermits(1), forkIn2(scope5));
        yield* _await(latch);
      })
    })
  }), forever3, interruptible4, forkIn2(scope5));
  const consumer = unwrap3(matchCause4(flatten8(take3(queue)), {
    onFailure: failCause10,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap13(write(outElem), () => consumer)
    })
  }));
  return embedInput(consumer, input2);
})));
var mergeAll6 = (options) => {
  return (channels) => mergeAllWith(options)(channels, constVoid);
};
var mergeAllWith = ({
  bufferSize = 16,
  concurrency,
  mergeStrategy = BackPressure()
}) => (channels, f2) => unwrapScopedWith((scope5) => gen2(function* () {
  const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
  const input2 = yield* make44();
  const queueReader = fromInput(input2);
  const queue = yield* bounded3(bufferSize);
  yield* addFinalizer2(scope5, shutdown2(queue));
  const cancelers = yield* unbounded3();
  yield* addFinalizer2(scope5, shutdown2(cancelers));
  const lastDone = yield* make25(none2());
  const errorSignal = yield* make23();
  const withPermits = (yield* makeSemaphore2(concurrencyN)).withPermits;
  const pull = yield* toPullIn(pipeTo(queueReader, channels), scope5);
  function evaluatePull(pull2) {
    return pull2.pipe(flatMap11(match({
      onLeft: (done11) => succeed8(some2(done11)),
      onRight: (outElem) => as4(offer3(queue, succeed8(right2(outElem))), none2())
    })), repeat({
      until: (_2) => isSome2(_2)
    }), flatMap11((outDone) => update3(lastDone, match2({
      onNone: () => some2(outDone.value),
      onSome: (lastDone2) => some2(f2(lastDone2, outDone.value))
    }))), catchAllCause3((cause3) => isInterrupted2(cause3) ? failCause8(cause3) : offer3(queue, failCause8(cause3)).pipe(zipRight3(succeed2(errorSignal, void 0)), asVoid2)));
  }
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause3) => offer3(queue, failCause8(cause3)).pipe(zipRight3(succeed8(false))),
    onSuccess: match({
      onLeft: (outDone) => raceWith2(interruptible4(_await(errorSignal)), interruptible4(withPermits(concurrencyN)(_void)), {
        onSelfDone: (_2, permitAcquisition) => as4(interrupt6(permitAcquisition), false),
        onOtherDone: (_2, failureAwait) => zipRight3(interrupt6(failureAwait), get11(lastDone).pipe(flatMap11(match2({
          onNone: () => offer3(queue, succeed8(left2(outDone))),
          onSome: (lastDone2) => offer3(queue, succeed8(left2(f2(lastDone2, outDone))))
        })), as4(false)))
      }),
      onRight: (channel) => match14(mergeStrategy, {
        onBackPressure: () => gen2(function* () {
          const latch = yield* make23();
          const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel), scope6).pipe(flatMap11((pull2) => race2(exit3(evaluatePull(pull2)), exit3(interruptible4(_await(errorSignal))))), flatMap11(identity)));
          yield* succeed2(latch, void 0).pipe(zipRight3(raceEffects), withPermits(1), forkIn2(scope5));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        }),
        onBufferSliding: () => gen2(function* () {
          const canceler = yield* make23();
          const latch = yield* make23();
          const size16 = yield* size12(cancelers);
          yield* take3(cancelers).pipe(flatMap11((canceler2) => succeed2(canceler2, void 0)), when2(() => size16 >= concurrencyN));
          yield* offer3(cancelers, canceler);
          const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel), scope6).pipe(flatMap11((pull2) => exit3(evaluatePull(pull2)).pipe(race2(exit3(interruptible4(_await(errorSignal)))), race2(exit3(interruptible4(_await(canceler)))))), flatMap11(identity)));
          yield* succeed2(latch, void 0).pipe(zipRight3(raceEffects), withPermits(1), forkIn2(scope5));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        })
      })
    })
  }), repeat({
    while: (_2) => _2
  }), forkIn2(scope5));
  const consumer = pipe(take3(queue), flatten8, matchCause4({
    onFailure: failCause10,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap13(write(outElem), () => consumer)
    })
  }), unwrap3);
  return embedInput(consumer, input2);
}));
var mergeMap = /* @__PURE__ */ dual(3, (self2, f2, options) => mergeAll6(options)(mapOut(self2, f2)));
var mergeWith2 = /* @__PURE__ */ dual(2, (self2, options) => {
  function merge12(scope5) {
    return gen2(function* () {
      const input2 = yield* make44();
      const queueReader = fromInput(input2);
      const pullL = yield* toPullIn(pipeTo(queueReader, self2), scope5);
      const pullR = yield* toPullIn(pipeTo(queueReader, options.other), scope5);
      function handleSide(exit4, fiber, pull) {
        return (done11, both2, single2) => {
          function onDecision2(decision) {
            const op = decision;
            if (op._tag === OP_DONE4) {
              return succeed8(fromEffect4(zipRight3(interrupt6(fiber), op.effect)));
            }
            return map16(_await3(fiber), match9({
              onFailure: (cause3) => fromEffect4(op.f(failCause4(cause3))),
              onSuccess: match({
                onLeft: (done12) => fromEffect4(op.f(succeed4(done12))),
                onRight: (elem) => zipRight5(write(elem), go(single2(op.f)))
              })
            }));
          }
          return match9(exit4, {
            onFailure: (cause3) => onDecision2(done11(failCause4(cause3))),
            onSuccess: match({
              onLeft: (z2) => onDecision2(done11(succeed4(z2))),
              onRight: (elem) => succeed8(flatMap13(write(elem), () => flatMap13(fromEffect4(forkIn2(interruptible4(pull), scope5)), (leftFiber) => go(both2(leftFiber, fiber)))))
            })
          });
        };
      }
      function go(state) {
        switch (state._tag) {
          case OP_BOTH_RUNNING: {
            const leftJoin = interruptible4(join3(state.left));
            const rightJoin = interruptible4(join3(state.right));
            return unwrap3(raceWith2(leftJoin, rightJoin, {
              onSelfDone: (leftExit, rf) => zipRight3(interrupt6(rf), handleSide(leftExit, state.right, pullL)(options.onSelfDone, BothRunning, (f2) => LeftDone(f2))),
              onOtherDone: (rightExit, lf) => zipRight3(interrupt6(lf), handleSide(rightExit, state.left, pullR)(options.onOtherDone, (left3, right3) => BothRunning(right3, left3), (f2) => RightDone(f2)))
            }));
          }
          case OP_LEFT_DONE: {
            return unwrap3(map16(exit3(pullR), match9({
              onFailure: (cause3) => fromEffect4(state.f(failCause4(cause3))),
              onSuccess: match({
                onLeft: (done11) => fromEffect4(state.f(succeed4(done11))),
                onRight: (elem) => flatMap13(write(elem), () => go(LeftDone(state.f)))
              })
            })));
          }
          case OP_RIGHT_DONE: {
            return unwrap3(map16(exit3(pullL), match9({
              onFailure: (cause3) => fromEffect4(state.f(failCause4(cause3))),
              onSuccess: match({
                onLeft: (done11) => fromEffect4(state.f(succeed4(done11))),
                onRight: (elem) => flatMap13(write(elem), () => go(RightDone(state.f)))
              })
            })));
          }
        }
      }
      return fromEffect4(withFiberRuntime2((parent) => {
        const inherit = withFiberRuntime2((state) => {
          state.transferChildren(parent.scope());
          return _void;
        });
        const leftFiber = interruptible4(pullL).pipe(ensuring2(inherit), forkIn2(scope5));
        const rightFiber = interruptible4(pullR).pipe(ensuring2(inherit), forkIn2(scope5));
        return zipWith5(leftFiber, rightFiber, (left3, right3) => BothRunning(left3, right3));
      })).pipe(flatMap13(go), embedInput(input2));
    });
  }
  return unwrapScopedWith(merge12);
});
var orDieWith3 = /* @__PURE__ */ dual(2, (self2, f2) => catchAll5(self2, (e) => failCauseSync5(() => die4(f2(e)))));
var orElse10 = /* @__PURE__ */ dual(2, (self2, that) => catchAll5(self2, that));
var pipeToOrFail = /* @__PURE__ */ dual(2, (self2, that) => suspend8(() => {
  let channelException = void 0;
  const reader = readWith({
    onInput: (outElem) => flatMap13(write(outElem), () => reader),
    onFailure: (outErr) => {
      channelException = ChannelException(outErr);
      return failCause10(die4(channelException));
    },
    onDone: succeedNow
  });
  const writer = readWithCause({
    onInput: (outElem) => pipe(write(outElem), flatMap13(() => writer)),
    onFailure: (cause3) => isDieType2(cause3) && isChannelException(cause3.defect) && equals(cause3.defect, channelException) ? fail13(cause3.defect.error) : failCause10(cause3),
    onDone: succeedNow
  });
  return pipeTo(pipeTo(pipeTo(self2, reader), that), writer);
}));
var repeated = (self2) => flatMap13(self2, () => repeated(self2));
var run2 = (self2) => scopedWith2((scope5) => runIn(self2, scope5));
var runDrain = (self2) => run2(drain(self2));
var runScoped = (self2) => scopeWith2((scope5) => runIn(self2, scope5));
var scoped4 = (effect4) => unwrap3(uninterruptibleMask3((restore) => map16(make38(), (scope5) => acquireReleaseOut(tapErrorCause3(restore(extend2(effect4, scope5)), (cause3) => close(scope5, failCause4(cause3))), (_2, exit4) => close(scope5, exit4)))));
var scopedWith3 = (f2) => unwrapScoped3(map16(scope3, (scope5) => flatMap13(fromEffect4(f2(scope5)), write)));
var splitLines = () => suspend8(() => {
  let stringBuilder = "";
  let midCRLF = false;
  const splitLinesChunk = (chunk5) => {
    const chunkBuilder = [];
    map3(chunk5, (str) => {
      if (str.length !== 0) {
        let from = 0;
        let indexOfCR = str.indexOf("\r");
        let indexOfLF = str.indexOf("\n");
        if (midCRLF) {
          if (indexOfLF === 0) {
            chunkBuilder.push(stringBuilder);
            stringBuilder = "";
            from = 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            stringBuilder = stringBuilder + "\r";
          }
          midCRLF = false;
        }
        while (indexOfCR !== -1 || indexOfLF !== -1) {
          if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
            if (stringBuilder.length === 0) {
              chunkBuilder.push(str.substring(from, indexOfLF));
            } else {
              chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF));
              stringBuilder = "";
            }
            from = indexOfLF + 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            if (str.length === indexOfCR + 1) {
              midCRLF = true;
              indexOfCR = -1;
            } else {
              if (indexOfLF === indexOfCR + 1) {
                if (stringBuilder.length === 0) {
                  chunkBuilder.push(str.substring(from, indexOfCR));
                } else {
                  stringBuilder = stringBuilder + str.substring(from, indexOfCR);
                  chunkBuilder.push(stringBuilder);
                  stringBuilder = "";
                }
                from = indexOfCR + 2;
                indexOfCR = str.indexOf("\r", from);
                indexOfLF = str.indexOf("\n", from);
              } else {
                indexOfCR = str.indexOf("\r", indexOfCR + 1);
              }
            }
          }
        }
        if (midCRLF) {
          stringBuilder = stringBuilder + str.substring(from, str.length - 1);
        } else {
          stringBuilder = stringBuilder + str.substring(from, str.length);
        }
      }
    });
    return unsafeFromArray(chunkBuilder);
  };
  const loop3 = readWithCause({
    onInput: (input2) => {
      const out = splitLinesChunk(input2);
      return isEmpty(out) ? loop3 : flatMap13(write(out), () => loop3);
    },
    onFailure: (cause3) => stringBuilder.length === 0 ? failCause10(cause3) : flatMap13(write(of2(stringBuilder)), () => failCause10(cause3)),
    onDone: (done11) => stringBuilder.length === 0 ? succeed13(done11) : flatMap13(write(of2(stringBuilder)), () => succeed13(done11))
  });
  return loop3;
});
var toPubSub = (pubsub) => toQueue(pubsub);
var toPull = (self2) => flatMap11(scope3, (scope5) => toPullIn(self2, scope5));
var toPullIn = /* @__PURE__ */ dual(2, (self2, scope5) => zip5(sync4(() => new ChannelExecutor(self2, void 0, identity)), runtime3()).pipe(tap3(([executor, runtime4]) => addFinalizerExit(scope5, (exit4) => {
  const finalizer3 = executor.close(exit4);
  return finalizer3 !== void 0 ? provide2(finalizer3, runtime4) : _void;
})), uninterruptible2, map16(([executor]) => suspend4(() => interpretToPull(executor.run(), executor)))));
var interpretToPull = (channelState, exec) => {
  const state = channelState;
  switch (state._tag) {
    case OP_DONE3: {
      return match9(exec.getDone(), {
        onFailure: failCause8,
        onSuccess: (done11) => succeed8(left2(done11))
      });
    }
    case OP_EMIT2: {
      return succeed8(right2(exec.getEmit()));
    }
    case OP_FROM_EFFECT3: {
      return pipe(state.effect, flatMap11(() => interpretToPull(exec.run(), exec)));
    }
    case OP_READ2: {
      return readUpstream(state, () => interpretToPull(exec.run(), exec), (cause3) => failCause8(cause3));
    }
  }
};
var toQueue = (queue) => suspend8(() => toQueueInternal(queue));
var toQueueInternal = (queue) => {
  return readWithCause({
    onInput: (elem) => flatMap13(fromEffect4(offer3(queue, right2(elem))), () => toQueueInternal(queue)),
    onFailure: (cause3) => fromEffect4(pipe(offer3(queue, left2(failCause4(cause3))))),
    onDone: (done11) => fromEffect4(pipe(offer3(queue, left2(succeed4(done11)))))
  });
};
var unwrap3 = (channel) => flatten10(fromEffect4(channel));
var unwrapScoped3 = (self2) => concatAllWith(scoped4(self2), (d2, _2) => d2, (d2, _2) => d2);
var unwrapScopedWith = (f2) => concatAllWith(scopedWith3(f2), (d2, _2) => d2, (d2, _2) => d2);
var withSpan5 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  const acquire = all4([makeSpan2(name, options), context3(), clock2, get13(currentTracerTimingEnabled2)]);
  if (dataFirst) {
    const self2 = arguments[0];
    return acquireUseRelease3(acquire, ([span4, context8]) => provideContext4(self2, add2(context8, spanTag, span4)), ([span4, , clock3, timingEnabled], exit4) => endSpan(span4, exit4, clock3, timingEnabled));
  }
  return (self2) => acquireUseRelease3(acquire, ([span4, context8]) => provideContext4(self2, add2(context8, spanTag, span4)), ([span4, , clock3, timingEnabled], exit4) => endSpan(span4, exit4, clock3, timingEnabled));
};
var writeAll = (...outs) => writeChunk(fromIterable2(outs));
var writeChunk = (outs) => writeChunkWriter(0, outs.length, outs);
var writeChunkWriter = (idx, len, chunk5) => {
  return idx === len ? void_5 : pipe(write(pipe(chunk5, unsafeGet2(idx))), flatMap13(() => writeChunkWriter(idx + 1, len, chunk5)));
};
var zip8 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options) => options?.concurrent ? mergeWith2(self2, {
  other: that,
  onSelfDone: (exit1) => Await((exit22) => suspend4(() => zip3(exit1, exit22))),
  onOtherDone: (exit22) => Await((exit1) => suspend4(() => zip3(exit1, exit22)))
}) : flatMap13(self2, (a2) => map20(that, (b) => [a2, b])));
var zipLeft4 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options) => options?.concurrent ? map20(zip8(self2, that, {
  concurrent: true
}), (tuple3) => tuple3[0]) : flatMap13(self2, (z2) => as6(that, z2)));
var zipRight5 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options) => options?.concurrent ? map20(zip8(self2, that, {
  concurrent: true
}), (tuple3) => tuple3[1]) : flatMap13(self2, () => that));
var ChannelExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Channel/ChannelException");
var ChannelException = (error4) => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error: error4
});
var isChannelException = (u2) => hasProperty(u2, ChannelExceptionTypeId);

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/MergeDecision.js
var Done4 = Done3;
var Await2 = Await;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/rcRef.js
var TypeId16 = /* @__PURE__ */ Symbol.for("effect/RcRef");
var stateEmpty2 = {
  _tag: "Empty"
};
var stateClosed = {
  _tag: "Closed"
};
var variance5 = {
  _A: identity,
  _E: identity
};
var RcRefImpl = class extends Class2 {
  acquire;
  context;
  scope;
  idleTimeToLive;
  [TypeId16] = variance5;
  [TypeId10] = TypeId10;
  state = stateEmpty2;
  semaphore = /* @__PURE__ */ unsafeMakeSemaphore(1);
  constructor(acquire, context8, scope5, idleTimeToLive) {
    super();
    this.acquire = acquire;
    this.context = context8;
    this.scope = scope5;
    this.idleTimeToLive = idleTimeToLive;
    this.get = get14(this);
  }
  get;
  commit() {
    return this.get;
  }
};
var make45 = (options) => withFiberRuntime((fiber) => {
  const context8 = fiber.getFiberRef(currentContext);
  const scope5 = get4(context8, scopeTag);
  const ref = new RcRefImpl(options.acquire, context8, scope5, options.idleTimeToLive ? decode(options.idleTimeToLive) : void 0);
  return as(scope5.addFinalizer(() => ref.semaphore.withPermits(1)(suspend(() => {
    const close2 = ref.state._tag === "Acquired" ? scopeClose(ref.state.scope, exitVoid) : void_;
    ref.state = stateClosed;
    return close2;
  }))), ref);
});
var get14 = (self_) => {
  const self2 = self_;
  return uninterruptibleMask((restore) => suspend(() => {
    switch (self2.state._tag) {
      case "Closed": {
        return interrupt2;
      }
      case "Acquired": {
        self2.state.refCount++;
        return self2.state.fiber ? as(interruptFiber(self2.state.fiber), self2.state) : succeed(self2.state);
      }
      case "Empty": {
        return scopeMake().pipe(bindTo2("scope"), bind2("value", ({
          scope: scope5
        }) => restore(fiberRefLocally(self2.acquire, currentContext, add2(self2.context, scopeTag, scope5)))), map9(({
          scope: scope5,
          value
        }) => {
          const state = {
            _tag: "Acquired",
            value,
            scope: scope5,
            fiber: void 0,
            refCount: 1
          };
          self2.state = state;
          return state;
        }));
      }
    }
  })).pipe(self2.semaphore.withPermits(1), bindTo2("state"), bind2("scope", () => scopeTag), tap(({
    scope: scope5,
    state
  }) => scope5.addFinalizer(() => suspend(() => {
    state.refCount--;
    if (state.refCount > 0) {
      return void_;
    }
    if (self2.idleTimeToLive === void 0) {
      self2.state = stateEmpty2;
      return scopeClose(state.scope, exitVoid);
    }
    return sleep3(self2.idleTimeToLive).pipe(interruptible2, zipRight(suspend(() => {
      if (self2.state._tag === "Acquired" && self2.state.refCount === 0) {
        self2.state = stateEmpty2;
        return scopeClose(state.scope, exitVoid);
      }
      return void_;
    })), ensuring(sync(() => {
      state.fiber = void 0;
    })), forkIn(self2.scope), tap((fiber) => {
      state.fiber = fiber;
    }), self2.semaphore.withPermits(1));
  }))), map9(({
    state
  }) => state.value));
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/RcRef.js
var make46 = make45;
var get15 = get14;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Runtime.js
var runFork3 = unsafeFork3;
var runPromiseExit2 = unsafeRunPromiseExit;
var defaultRuntime2 = defaultRuntime;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/opCodes/streamHaltStrategy.js
var OP_LEFT = "Left";
var OP_RIGHT = "Right";
var OP_BOTH = "Both";
var OP_EITHER = "Either";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stream/haltStrategy.js
var Left = {
  _tag: OP_LEFT
};
var Right = {
  _tag: OP_RIGHT
};
var Both = {
  _tag: OP_BOTH
};
var Either = {
  _tag: OP_EITHER
};
var fromInput2 = (input2) => {
  switch (input2) {
    case "left":
      return Left;
    case "right":
      return Right;
    case "both":
      return Both;
    case "either":
      return Either;
    default:
      return input2;
  }
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/StreamHaltStrategy.js
var Both2 = Both;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/sink.js
var SinkTypeId2 = /* @__PURE__ */ Symbol.for("effect/Sink");
var sinkVariance2 = {
  /* c8 ignore next */
  _A: (_2) => _2,
  /* c8 ignore next */
  _In: (_2) => _2,
  /* c8 ignore next */
  _L: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _R: (_2) => _2
};
var SinkImpl = class {
  channel;
  [SinkTypeId2] = sinkVariance2;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isSink = (u2) => hasProperty(u2, SinkTypeId2);
var suspend9 = (evaluate3) => new SinkImpl(suspend8(() => toChannel(evaluate3())));
var collectAll = () => new SinkImpl(collectAllLoop(empty2()));
var collectAllLoop = (acc) => readWithCause({
  onInput: (chunk5) => collectAllLoop(pipe(acc, appendAll2(chunk5))),
  onFailure: failCause10,
  onDone: () => succeed13(acc)
});
var collectAllN = (n2) => suspend9(() => fromChannel(collectAllNLoop(n2, empty2())));
var collectAllNLoop = (n2, acc) => readWithCause({
  onInput: (chunk5) => {
    const [collected, leftovers] = splitAt2(chunk5, n2);
    if (collected.length < n2) {
      return collectAllNLoop(n2 - collected.length, appendAll2(acc, collected));
    }
    if (isEmpty(leftovers)) {
      return succeed13(appendAll2(acc, collected));
    }
    return flatMap13(write(leftovers), () => succeed13(appendAll2(acc, collected)));
  },
  onFailure: failCause10,
  onDone: () => succeed13(acc)
});
var collectLeftover = (self2) => new SinkImpl(pipe(collectElements(toChannel(self2)), map20(([chunks3, z2]) => [z2, flatten2(chunks3)])));
var drain2 = /* @__PURE__ */ new SinkImpl(/* @__PURE__ */ drain(/* @__PURE__ */ identityChannel()));
var fail14 = (e) => new SinkImpl(fail13(e));
var fold = (s2, contFn, f2) => suspend9(() => new SinkImpl(foldReader(s2, contFn, f2)));
var foldReader = (s2, contFn, f2) => {
  if (!contFn(s2)) {
    return succeedNow(s2);
  }
  return readWith({
    onInput: (input2) => {
      const [nextS, leftovers] = foldChunkSplit(s2, input2, contFn, f2, 0, input2.length);
      if (isNonEmpty(leftovers)) {
        return pipe(write(leftovers), as6(nextS));
      }
      return foldReader(nextS, contFn, f2);
    },
    onFailure: fail13,
    onDone: () => succeedNow(s2)
  });
};
var foldChunkSplit = (s2, chunk5, contFn, f2, index, length3) => {
  if (index === length3) {
    return [s2, empty2()];
  }
  const s1 = f2(s2, pipe(chunk5, unsafeGet2(index)));
  if (contFn(s1)) {
    return foldChunkSplit(s1, chunk5, contFn, f2, index + 1, length3);
  }
  return [s1, pipe(chunk5, drop2(index + 1))];
};
var foldSink = /* @__PURE__ */ dual(2, (self2, options) => {
  const newChannel = pipe(toChannel(self2), collectElements, foldChannel({
    onFailure: (error4) => toChannel(options.onFailure(error4)),
    onSuccess: ([leftovers, z2]) => suspend8(() => {
      const leftoversRef = {
        ref: pipe(leftovers, filter2(isNonEmpty))
      };
      const refReader = pipe(
        sync9(() => {
          const ref = leftoversRef.ref;
          leftoversRef.ref = empty2();
          return ref;
        }),
        // This cast is safe because of the L1 >: L <: In1 bound. It follows that
        // L <: In1 and therefore Chunk[L] can be safely cast to Chunk[In1].
        flatMap13((chunk5) => writeChunk(chunk5))
      );
      const passthrough4 = identityChannel();
      const continuationSink = pipe(refReader, zipRight5(passthrough4), pipeTo(toChannel(options.onSuccess(z2))));
      return flatMap13(collectElements(continuationSink), ([newLeftovers, z1]) => pipe(succeed13(leftoversRef.ref), flatMap13(writeChunk), zipRight5(writeChunk(newLeftovers)), as6(z1)));
    })
  }));
  return new SinkImpl(newChannel);
});
var foldChunks = (s2, contFn, f2) => suspend9(() => new SinkImpl(foldChunksReader(s2, contFn, f2)));
var foldChunksReader = (s2, contFn, f2) => {
  if (!contFn(s2)) {
    return succeedNow(s2);
  }
  return readWith({
    onInput: (input2) => foldChunksReader(f2(s2, input2), contFn, f2),
    onFailure: fail13,
    onDone: () => succeedNow(s2)
  });
};
var foldEffect = (s2, contFn, f2) => suspend9(() => new SinkImpl(foldEffectReader(s2, contFn, f2)));
var foldEffectReader = (s2, contFn, f2) => {
  if (!contFn(s2)) {
    return succeedNow(s2);
  }
  return readWith({
    onInput: (input2) => pipe(fromEffect4(foldChunkSplitEffect(s2, input2, contFn, f2)), flatMap13(([nextS, leftovers]) => pipe(leftovers, match2({
      onNone: () => foldEffectReader(nextS, contFn, f2),
      onSome: (leftover) => pipe(write(leftover), as6(nextS))
    })))),
    onFailure: fail13,
    onDone: () => succeedNow(s2)
  });
};
var foldChunkSplitEffect = (s2, chunk5, contFn, f2) => foldChunkSplitEffectInternal(s2, chunk5, 0, chunk5.length, contFn, f2);
var foldChunkSplitEffectInternal = (s2, chunk5, index, length3, contFn, f2) => {
  if (index === length3) {
    return succeed8([s2, none2()]);
  }
  return pipe(f2(s2, pipe(chunk5, unsafeGet2(index))), flatMap11((s1) => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk5, index + 1, length3, contFn, f2) : succeed8([s1, some2(pipe(chunk5, drop2(index + 1)))])));
};
var foldLeftChunks = (s2, f2) => foldChunks(s2, constTrue, f2);
var flatMap14 = /* @__PURE__ */ dual(2, (self2, f2) => foldSink(self2, {
  onFailure: fail14,
  onSuccess: f2
}));
var forEach10 = (f2) => {
  const process2 = readWithCause({
    onInput: (input2) => pipe(fromEffect4(forEach9(input2, (v2) => f2(v2), {
      discard: true
    })), flatMap13(() => process2)),
    onFailure: failCause10,
    onDone: () => void_5
  });
  return new SinkImpl(process2);
};
var forEachChunk = (f2) => {
  const process2 = readWithCause({
    onInput: (input2) => pipe(fromEffect4(f2(input2)), flatMap13(() => process2)),
    onFailure: failCause10,
    onDone: () => void_5
  });
  return new SinkImpl(process2);
};
var forEachWhile = (f2) => {
  const process2 = readWithCause({
    onInput: (input2) => forEachWhileReader(f2, input2, 0, input2.length, process2),
    onFailure: failCause10,
    onDone: () => void_5
  });
  return new SinkImpl(process2);
};
var forEachWhileReader = (f2, input2, index, length3, cont) => {
  if (index === length3) {
    return cont;
  }
  return pipe(fromEffect4(f2(pipe(input2, unsafeGet2(index)))), flatMap13((bool) => bool ? forEachWhileReader(f2, input2, index + 1, length3, cont) : write(pipe(input2, drop2(index)))), catchAll5((error4) => pipe(write(pipe(input2, drop2(index))), zipRight5(fail13(error4)))));
};
var fromChannel = (channel) => new SinkImpl(channel);
var fromEffect6 = (effect4) => new SinkImpl(fromEffect4(effect4));
var head5 = () => fold(none2(), isNone2, (option5, input2) => match2(option5, {
  onNone: () => some2(input2),
  onSome: () => option5
}));
var last4 = () => foldLeftChunks(none2(), (s2, input2) => orElse(last2(input2), () => s2));
var map21 = /* @__PURE__ */ dual(2, (self2, f2) => {
  return new SinkImpl(pipe(toChannel(self2), map20(f2)));
});
var raceWith3 = /* @__PURE__ */ dual(2, (self2, options) => {
  function race5(scope5) {
    return gen2(function* () {
      const pubsub = yield* bounded5(options?.capacity ?? 16);
      const subscription1 = yield* extend2(subscribe2(pubsub), scope5);
      const subscription2 = yield* extend2(subscribe2(pubsub), scope5);
      const reader = toPubSub(pubsub);
      const writer = fromQueue(subscription1).pipe(pipeTo(toChannel(self2)), zipLeft4(fromEffect4(shutdown2(subscription1))), mergeWith2({
        other: fromQueue(subscription2).pipe(pipeTo(toChannel(options.other)), zipLeft4(fromEffect4(shutdown2(subscription2)))),
        onSelfDone: options.onSelfDone,
        onOtherDone: options.onOtherDone
      }));
      const racedChannel = mergeWith2(reader, {
        other: writer,
        onSelfDone: () => Await(identity),
        onOtherDone: (exit4) => Done3(exit4)
      });
      return new SinkImpl(racedChannel);
    });
  }
  return unwrapScopedWith2(race5);
});
var sum2 = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk5) => acc + reduce2(chunk5, 0, (s2, a2) => s2 + a2));
var toChannel = (self2) => isEffect2(self2) ? toChannel(fromEffect6(self2)) : self2.channel;
var unwrapScopedWith2 = (f2) => new SinkImpl(unwrapScopedWith((scope5) => f2(scope5).pipe(map16((sink) => toChannel(sink)))));
var zipRight6 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self2, that, options) => zipWith10(self2, that, (_2, z2) => z2, options));
var zipWith10 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self2, that, f2, options) => options?.concurrent ? raceWith3(self2, {
  other: that,
  onSelfDone: match9({
    onFailure: (cause3) => Done3(failCause8(cause3)),
    onSuccess: (leftZ) => Await(match9({
      onFailure: failCause8,
      onSuccess: (rightZ) => succeed8(f2(leftZ, rightZ))
    }))
  }),
  onOtherDone: match9({
    onFailure: (cause3) => Done3(failCause8(cause3)),
    onSuccess: (rightZ) => Await(match9({
      onFailure: failCause8,
      onSuccess: (leftZ) => succeed8(f2(leftZ, rightZ))
    }))
  })
}) : flatMap14(self2, (z2) => map21(that, (z22) => f2(z2, z22))));
var count3 = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk5) => acc + chunk5.length);
var mkString = /* @__PURE__ */ suspend9(() => {
  const strings = [];
  return pipe(foldLeftChunks(void 0, (_2, elems) => map3(elems, (elem) => {
    strings.push(String(elem));
  })), map21(() => strings.join("")));
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stm/versioned.js
var Versioned = class {
  value;
  constructor(value) {
    this.value = value;
  }
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stm/entry.js
var make47 = (ref, isNew) => ({
  ref,
  isNew,
  isChanged: false,
  expected: ref.versioned,
  newValue: ref.versioned.value
});
var unsafeGet6 = (self2) => {
  return self2.newValue;
};
var unsafeSet = (self2, value) => {
  self2.isChanged = true;
  self2.newValue = value;
};
var commit = (self2) => {
  self2.ref.versioned = new Versioned(self2.newValue);
};
var isInvalid = (self2) => {
  return self2.ref.versioned !== self2.expected;
};
var isChanged = (self2) => {
  return self2.isChanged;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stm/journal.js
var JournalAnalysisInvalid = "Invalid";
var JournalAnalysisReadWrite = "ReadWrite";
var JournalAnalysisReadOnly = "ReadOnly";
var commitJournal = (journal) => {
  for (const entry of journal) {
    commit(entry[1]);
  }
};
var analyzeJournal = (journal) => {
  let val = JournalAnalysisReadOnly;
  for (const [, entry] of journal) {
    val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
    if (val === JournalAnalysisInvalid) {
      return val;
    }
  }
  return val;
};
var collectTodos = (journal) => {
  const allTodos = /* @__PURE__ */ new Map();
  for (const [, entry] of journal) {
    for (const todo of entry.ref.todos) {
      allTodos.set(todo[0], todo[1]);
    }
    entry.ref.todos = /* @__PURE__ */ new Map();
  }
  return allTodos;
};
var execTodos = (todos) => {
  const todosSorted = Array.from(todos.entries()).sort((x2, y) => x2[0] - y[0]);
  for (const [_2, todo] of todosSorted) {
    todo();
  }
};
var addTodo = (txnId, journal, todoEffect) => {
  let added = false;
  for (const [, entry] of journal) {
    if (!entry.ref.todos.has(txnId)) {
      entry.ref.todos.set(txnId, todoEffect);
      added = true;
    }
  }
  return added;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
var OP_WITH_STM_RUNTIME = "WithSTMRuntime";
var OP_ON_FAILURE2 = "OnFailure";
var OP_ON_RETRY = "OnRetry";
var OP_ON_SUCCESS2 = "OnSuccess";
var OP_PROVIDE3 = "Provide";
var OP_SYNC2 = "Sync";
var OP_SUCCEED2 = "Succeed";
var OP_RETRY = "Retry";
var OP_FAIL4 = "Fail";
var OP_DIE2 = "Die";
var OP_INTERRUPT2 = "Interrupt";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
var OP_FAIL5 = "Fail";
var OP_DIE3 = "Die";
var OP_INTERRUPT3 = "Interrupt";
var OP_SUCCEED3 = "Succeed";
var OP_RETRY2 = "Retry";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
var OP_DONE5 = "Done";
var OP_SUSPEND3 = "Suspend";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
var OP_DONE6 = "Done";
var OP_INTERRUPTED = "Interrupted";
var OP_RUNNING2 = "Running";

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stm/stmState.js
var STMStateSymbolKey = "effect/STM/State";
var STMStateTypeId = /* @__PURE__ */ Symbol.for(STMStateSymbolKey);
var isSTMState = (u2) => hasProperty(u2, STMStateTypeId);
var isRunning2 = (self2) => {
  return self2._tag === OP_RUNNING2;
};
var isDone6 = (self2) => {
  return self2._tag === OP_DONE6;
};
var done8 = (exit4) => {
  return {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_DONE6,
    exit: exit4,
    [symbol]() {
      return pipe(hash(STMStateSymbolKey), combine(hash(OP_DONE6)), combine(hash(exit4)), cached(this));
    },
    [symbol2](that) {
      return isSTMState(that) && that._tag === OP_DONE6 && equals(exit4, that.exit);
    }
  };
};
var interruptedHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_INTERRUPTED)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("interrupted")));
var interrupted2 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_INTERRUPTED,
  [symbol]() {
    return interruptedHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_INTERRUPTED;
  }
};
var runningHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RUNNING2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("running")));
var running3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_RUNNING2,
  [symbol]() {
    return runningHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_RUNNING2;
  }
};
var fromTExit = (tExit) => {
  switch (tExit._tag) {
    case OP_FAIL5: {
      return done8(fail4(tExit.error));
    }
    case OP_DIE3: {
      return done8(die3(tExit.defect));
    }
    case OP_INTERRUPT3: {
      return done8(interrupt4(tExit.fiberId));
    }
    case OP_SUCCEED3: {
      return done8(succeed4(tExit.value));
    }
    case OP_RETRY2: {
      throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
  }
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stm/tExit.js
var TExitSymbolKey = "effect/TExit";
var TExitTypeId = /* @__PURE__ */ Symbol.for(TExitSymbolKey);
var variance6 = {
  /* c8 ignore next */
  _A: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2
};
var isExit2 = (u2) => hasProperty(u2, TExitTypeId);
var isSuccess4 = (self2) => {
  return self2._tag === OP_SUCCEED3;
};
var isRetry = (self2) => {
  return self2._tag === OP_RETRY2;
};
var fail15 = (error4) => ({
  [TExitTypeId]: variance6,
  _tag: OP_FAIL5,
  error: error4,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_FAIL5)), combine(hash(error4)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_FAIL5 && equals(error4, that.error);
  }
});
var die8 = (defect) => ({
  [TExitTypeId]: variance6,
  _tag: OP_DIE3,
  defect,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_DIE3)), combine(hash(defect)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
  }
});
var interrupt8 = (fiberId3) => ({
  [TExitTypeId]: variance6,
  _tag: OP_INTERRUPT3,
  fiberId: fiberId3,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_INTERRUPT3)), combine(hash(fiberId3)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_INTERRUPT3 && equals(fiberId3, that.fiberId);
  }
});
var succeed14 = (value) => ({
  [TExitTypeId]: variance6,
  _tag: OP_SUCCEED3,
  value,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_SUCCEED3)), combine(hash(value)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_SUCCEED3 && equals(value, that.value);
  }
});
var retryHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(TExitSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RETRY2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("retry")));
var retry4 = {
  [TExitTypeId]: variance6,
  _tag: OP_RETRY2,
  [symbol]() {
    return retryHash;
  },
  [symbol2](that) {
    return isExit2(that) && isRetry(that);
  }
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stm/tryCommit.js
var done9 = (exit4) => {
  return {
    _tag: OP_DONE5,
    exit: exit4
  };
};
var suspend10 = (journal) => {
  return {
    _tag: OP_SUSPEND3,
    journal
  };
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stm/txnId.js
var txnCounter = {
  ref: 0
};
var make48 = () => {
  const newId = txnCounter.ref + 1;
  txnCounter.ref = newId;
  return newId;
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stm/core.js
var STMSymbolKey2 = "effect/STM";
var STMTypeId2 = /* @__PURE__ */ Symbol.for(STMSymbolKey2);
var stmVariance = {
  /* c8 ignore next */
  _R: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _A: (_2) => _2
};
var STMPrimitive = class {
  effect_instruction_i0;
  _op = OP_COMMIT;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  [EffectTypeId3];
  [StreamTypeId];
  [SinkTypeId2];
  [ChannelTypeId2];
  get [STMTypeId2]() {
    return stmVariance;
  }
  constructor(effect_instruction_i0) {
    this.effect_instruction_i0 = effect_instruction_i0;
    this[EffectTypeId3] = effectVariance;
    this[StreamTypeId] = stmVariance;
    this[SinkTypeId2] = stmVariance;
    this[ChannelTypeId2] = stmVariance;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
  commit() {
    return unsafeAtomically(this);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeAtomically = (self2, onDone3, onInterrupt3) => withFiberRuntime((state) => {
  const fiberId3 = state.id();
  const env2 = state.getFiberRef(currentContext2);
  const scheduler = state.getFiberRef(currentScheduler2);
  const priority = state.getFiberRef(currentSchedulingPriority2);
  const commitResult = tryCommitSync(fiberId3, self2, env2, scheduler, priority);
  switch (commitResult._tag) {
    case OP_DONE5: {
      return commitResult.exit;
    }
    case OP_SUSPEND3: {
      const txnId = make48();
      const state2 = {
        value: running3
      };
      const effect4 = async2((k) => tryCommitAsync(fiberId3, self2, txnId, state2, env2, scheduler, priority, k));
      return uninterruptibleMask3((restore) => pipe(restore(effect4), catchAllCause3((cause3) => {
        let currentState = state2.value;
        if (isRunning2(currentState)) {
          state2.value = interrupted2;
        }
        currentState = state2.value;
        if (isDone6(currentState)) {
          return currentState.exit;
        }
        return failCause8(cause3);
      })));
    }
  }
});
var tryCommit = (fiberId3, stm, state, env2, scheduler, priority) => {
  const journal = /* @__PURE__ */ new Map();
  const tExit = new STMDriver(stm, journal, fiberId3, env2).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      state.value = fromTExit(tExit);
      return completeTodos(succeed4(tExit.value), journal, scheduler, priority);
    }
    case OP_FAIL5: {
      state.value = fromTExit(tExit);
      const cause3 = fail5(tExit.error);
      return completeTodos(failCause4(cause3), journal, scheduler, priority);
    }
    case OP_DIE3: {
      state.value = fromTExit(tExit);
      const cause3 = die4(tExit.defect);
      return completeTodos(failCause4(cause3), journal, scheduler, priority);
    }
    case OP_INTERRUPT3: {
      state.value = fromTExit(tExit);
      const cause3 = interrupt5(fiberId3);
      return completeTodos(failCause4(cause3), journal, scheduler, priority);
    }
    case OP_RETRY2: {
      return suspend10(journal);
    }
  }
};
var tryCommitSync = (fiberId3, stm, env2, scheduler, priority) => {
  const journal = /* @__PURE__ */ new Map();
  const tExit = new STMDriver(stm, journal, fiberId3, env2).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite && isSuccess4(tExit)) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      return completeTodos(succeed4(tExit.value), journal, scheduler, priority);
    }
    case OP_FAIL5: {
      const cause3 = fail5(tExit.error);
      return completeTodos(failCause4(cause3), journal, scheduler, priority);
    }
    case OP_DIE3: {
      const cause3 = die4(tExit.defect);
      return completeTodos(failCause4(cause3), journal, scheduler, priority);
    }
    case OP_INTERRUPT3: {
      const cause3 = interrupt5(fiberId3);
      return completeTodos(failCause4(cause3), journal, scheduler, priority);
    }
    case OP_RETRY2: {
      return suspend10(journal);
    }
  }
};
var tryCommitAsync = (fiberId3, self2, txnId, state, context8, scheduler, priority, k) => {
  if (isRunning2(state.value)) {
    const result = tryCommit(fiberId3, self2, state, context8, scheduler, priority);
    switch (result._tag) {
      case OP_DONE5: {
        completeTryCommit(result.exit, k);
        break;
      }
      case OP_SUSPEND3: {
        addTodo(txnId, result.journal, () => tryCommitAsync(fiberId3, self2, txnId, state, context8, scheduler, priority, k));
        break;
      }
    }
  }
};
var completeTodos = (exit4, journal, scheduler, priority) => {
  const todos = collectTodos(journal);
  if (todos.size > 0) {
    scheduler.scheduleTask(() => execTodos(todos), priority);
  }
  return done9(exit4);
};
var completeTryCommit = (exit4, k) => {
  k(exit4);
};
var STMDriver = class {
  self;
  journal;
  fiberId;
  contStack = [];
  env;
  constructor(self2, journal, fiberId3, r0) {
    this.self = self2;
    this.journal = journal;
    this.fiberId = fiberId3;
    this.env = r0;
  }
  getEnv() {
    return this.env;
  }
  pushStack(cont) {
    this.contStack.push(cont);
  }
  popStack() {
    return this.contStack.pop();
  }
  nextSuccess() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_SUCCESS2) {
      current2 = this.popStack();
    }
    return current2;
  }
  nextFailure() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_FAILURE2) {
      current2 = this.popStack();
    }
    return current2;
  }
  nextRetry() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_RETRY) {
      current2 = this.popStack();
    }
    return current2;
  }
  run() {
    let curr = this.self;
    let exit4 = void 0;
    while (exit4 === void 0 && curr !== void 0) {
      try {
        const current2 = curr;
        if (current2) {
          switch (current2._op) {
            case "Tag": {
              curr = effect3((_2, __, env2) => unsafeGet4(env2, current2));
              break;
            }
            case "Left": {
              curr = fail16(current2.left);
              break;
            }
            case "None": {
              curr = fail16(new NoSuchElementException2());
              break;
            }
            case "Right": {
              curr = succeed15(current2.right);
              break;
            }
            case "Some": {
              curr = succeed15(current2.value);
              break;
            }
            case "Commit": {
              switch (current2.effect_instruction_i0) {
                case OP_DIE2: {
                  exit4 = die8(internalCall(() => current2.effect_instruction_i1()));
                  break;
                }
                case OP_FAIL4: {
                  const cont = this.nextFailure();
                  if (cont === void 0) {
                    exit4 = fail15(internalCall(() => current2.effect_instruction_i1()));
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current2.effect_instruction_i1())));
                  }
                  break;
                }
                case OP_RETRY: {
                  const cont = this.nextRetry();
                  if (cont === void 0) {
                    exit4 = retry4;
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2());
                  }
                  break;
                }
                case OP_INTERRUPT2: {
                  exit4 = interrupt8(this.fiberId);
                  break;
                }
                case OP_WITH_STM_RUNTIME: {
                  curr = internalCall(() => current2.effect_instruction_i1(this));
                  break;
                }
                case OP_ON_SUCCESS2:
                case OP_ON_FAILURE2:
                case OP_ON_RETRY: {
                  this.pushStack(current2);
                  curr = current2.effect_instruction_i1;
                  break;
                }
                case OP_PROVIDE3: {
                  const env2 = this.env;
                  this.env = internalCall(() => current2.effect_instruction_i2(env2));
                  curr = pipe(current2.effect_instruction_i1, ensuring5(sync10(() => this.env = env2)));
                  break;
                }
                case OP_SUCCEED2: {
                  const value = current2.effect_instruction_i1;
                  const cont = this.nextSuccess();
                  if (cont === void 0) {
                    exit4 = succeed14(value);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value));
                  }
                  break;
                }
                case OP_SYNC2: {
                  const value = internalCall(() => current2.effect_instruction_i1());
                  const cont = this.nextSuccess();
                  if (cont === void 0) {
                    exit4 = succeed14(value);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value));
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      } catch (e) {
        curr = die9(e);
      }
    }
    return exit4;
  }
};
var catchAll6 = /* @__PURE__ */ dual(2, (self2, f2) => {
  const stm = new STMPrimitive(OP_ON_FAILURE2);
  stm.effect_instruction_i1 = self2;
  stm.effect_instruction_i2 = f2;
  return stm;
});
var die9 = (defect) => dieSync5(() => defect);
var dieSync5 = (evaluate3) => {
  const stm = new STMPrimitive(OP_DIE2);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
};
var effect3 = (f2) => withSTMRuntime((_2) => succeed15(f2(_2.journal, _2.fiberId, _2.getEnv())));
var ensuring5 = /* @__PURE__ */ dual(2, (self2, finalizer3) => matchSTM(self2, {
  onFailure: (e) => zipRight7(finalizer3, fail16(e)),
  onSuccess: (a2) => zipRight7(finalizer3, succeed15(a2))
}));
var fail16 = (error4) => failSync6(() => error4);
var failSync6 = (evaluate3) => {
  const stm = new STMPrimitive(OP_FAIL4);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
};
var flatMap15 = /* @__PURE__ */ dual(2, (self2, f2) => {
  const stm = new STMPrimitive(OP_ON_SUCCESS2);
  stm.effect_instruction_i1 = self2;
  stm.effect_instruction_i2 = f2;
  return stm;
});
var matchSTM = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => pipe(self2, map22(right2), catchAll6((e) => pipe(onFailure(e), map22(left2))), flatMap15((either7) => {
  switch (either7._tag) {
    case "Left": {
      return succeed15(either7.left);
    }
    case "Right": {
      return onSuccess(either7.right);
    }
  }
})));
var withSTMRuntime = (f2) => {
  const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
  stm.effect_instruction_i1 = f2;
  return stm;
};
var interruptAs2 = (fiberId3) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = fiberId3;
  return stm;
};
var map22 = /* @__PURE__ */ dual(2, (self2, f2) => pipe(self2, flatMap15((a2) => sync10(() => f2(a2)))));
var retry5 = /* @__PURE__ */ new STMPrimitive(OP_RETRY);
var succeed15 = (value) => {
  const stm = new STMPrimitive(OP_SUCCEED2);
  stm.effect_instruction_i1 = value;
  return stm;
};
var sync10 = (evaluate3) => {
  const stm = new STMPrimitive(OP_SYNC2);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
};
var zipRight7 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, flatMap15(() => that)));
var zipWith11 = /* @__PURE__ */ dual(3, (self2, that, f2) => pipe(self2, flatMap15((a2) => pipe(that, map22((b) => f2(a2, b))))));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stm/stm.js
var as7 = /* @__PURE__ */ dual(2, (self2, value) => pipe(self2, map22(() => value)));
var flatten11 = (self2) => flatMap15(self2, identity);
var forEach11 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (iterable, f2, options) => {
  if (options?.discard) {
    return pipe(sync10(() => iterable[Symbol.iterator]()), flatMap15((iterator) => {
      const loop3 = suspend11(() => {
        const next = iterator.next();
        if (next.done) {
          return void_6;
        }
        return pipe(f2(next.value), flatMap15(() => loop3));
      });
      return loop3;
    }));
  }
  return suspend11(() => fromIterable(iterable).reduce((acc, curr) => zipWith11(acc, f2(curr), (array6, elem) => {
    array6.push(elem);
    return array6;
  }), succeed15([])));
});
var all7 = (input2, options) => {
  if (Symbol.iterator in input2) {
    return forEach11(input2, identity, options);
  }
  return map22(forEach11(Object.entries(input2), ([_2, e]) => map22(e, (a2) => [_2, a2])), (values3) => {
    const res = {};
    for (const [k, v2] of values3) {
      res[k] = v2;
    }
    return res;
  });
};
var suspend11 = (evaluate3) => flatten11(sync10(evaluate3));
var tap5 = /* @__PURE__ */ dual(2, (self2, f2) => flatMap15(self2, (a2) => as7(f2(a2), a2)));
var void_6 = /* @__PURE__ */ succeed15(void 0);

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stm/tRef.js
var TRefSymbolKey = "effect/TRef";
var TRefTypeId = /* @__PURE__ */ Symbol.for(TRefSymbolKey);
var tRefVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var TRefImpl = class {
  [TRefTypeId] = tRefVariance;
  /** @internal */
  todos;
  /** @internal */
  versioned;
  constructor(value) {
    this.versioned = new Versioned(value);
    this.todos = /* @__PURE__ */ new Map();
  }
  modify(f2) {
    return effect3((journal) => {
      const entry = getOrMakeEntry(this, journal);
      const [retValue, newValue] = f2(unsafeGet6(entry));
      unsafeSet(entry, newValue);
      return retValue;
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make49 = (value) => effect3((journal) => {
  const ref = new TRefImpl(value);
  journal.set(ref, make47(ref, true));
  return ref;
});
var get16 = (self2) => self2.modify((a2) => [a2, a2]);
var set7 = /* @__PURE__ */ dual(2, (self2, value) => self2.modify(() => [void 0, value]));
var getOrMakeEntry = (self2, journal) => {
  if (journal.has(self2)) {
    return journal.get(self2);
  }
  const entry = make47(self2, false);
  journal.set(self2, entry);
  return entry;
};
var unsafeGet7 = /* @__PURE__ */ dual(2, (self2, journal) => unsafeGet6(getOrMakeEntry(self2, journal)));
var unsafeSet2 = /* @__PURE__ */ dual(3, (self2, value, journal) => {
  const entry = getOrMakeEntry(self2, journal);
  unsafeSet(entry, value);
  return void 0;
});
var TDequeueSymbolKey = "effect/TQueue/TDequeue";
var TDequeueTypeId = /* @__PURE__ */ Symbol.for(TDequeueSymbolKey);
var tDequeueVariance = {
  /* c8 ignore next */
  _Out: (_2) => _2
};
var isShutdown4 = (self2) => self2.isShutdown;
var shutdown5 = (self2) => self2.shutdown;
var take4 = (self2) => self2.take;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stm/tPubSub.js
var TPubSubSymbolKey = "effect/TPubSub";
var TPubSubTypeId = /* @__PURE__ */ Symbol.for(TPubSubSymbolKey);
var AbsentValue2 = /* @__PURE__ */ Symbol.for("effect/TPubSub/AbsentValue");
var makeNode2 = (head6, subscribers, tail) => ({
  head: head6,
  subscribers,
  tail
});
var TPubSubSubscriptionImpl = class {
  pubsubSize;
  publisherHead;
  requestedCapacity;
  subscriberHead;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = TPubSubTypeId;
  [TDequeueTypeId] = tDequeueVariance;
  constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.requestedCapacity = requestedCapacity;
    this.subscriberHead = subscriberHead;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const currentSubscriberHead = unsafeGet7(this.subscriberHead, journal);
    return currentSubscriberHead === void 0;
  });
  awaitShutdown = /* @__PURE__ */ flatMap15(this.isShutdown, (isShutdown7) => isShutdown7 ? void_6 : retry5);
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime4) => {
    let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime4.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime4.fiberId);
    }
    let loop3 = true;
    let size16 = 0;
    while (loop3) {
      const node = unsafeGet7(currentSubscriberHead, runtime4.journal);
      if (node === void 0) {
        loop3 = false;
      } else {
        const head6 = node.head;
        const tail = node.tail;
        if (head6 !== AbsentValue2) {
          size16 = size16 + 1;
          if (size16 >= Number.MAX_SAFE_INTEGER) {
            loop3 = false;
          }
        }
        currentSubscriberHead = tail;
      }
    }
    return succeed15(size16);
  });
  isEmpty = /* @__PURE__ */ map22(this.size, (size16) => size16 === 0);
  isFull = /* @__PURE__ */ map22(this.size, (size16) => size16 === this.capacity());
  peek = /* @__PURE__ */ withSTMRuntime((runtime4) => {
    let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime4.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime4.fiberId);
    }
    let value = AbsentValue2;
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet7(currentSubscriberHead, runtime4.journal);
      if (node === void 0) {
        return retry5;
      }
      const head6 = node.head;
      const tail = node.tail;
      if (head6 !== AbsentValue2) {
        value = head6;
        loop3 = false;
      } else {
        currentSubscriberHead = tail;
      }
    }
    return succeed15(value);
  });
  peekOption = /* @__PURE__ */ withSTMRuntime((runtime4) => {
    let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime4.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime4.fiberId);
    }
    let value = none2();
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet7(currentSubscriberHead, runtime4.journal);
      if (node === void 0) {
        value = none2();
        loop3 = false;
      } else {
        const head6 = node.head;
        const tail = node.tail;
        if (head6 !== AbsentValue2) {
          value = some2(head6);
          loop3 = false;
        } else {
          currentSubscriberHead = tail;
        }
      }
    }
    return succeed15(value);
  });
  shutdown = /* @__PURE__ */ effect3((journal) => {
    let currentSubscriberHead = unsafeGet7(this.subscriberHead, journal);
    if (currentSubscriberHead !== void 0) {
      unsafeSet2(this.subscriberHead, void 0, journal);
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet7(currentSubscriberHead, journal);
        if (node === void 0) {
          loop3 = false;
        } else {
          const head6 = node.head;
          const tail = node.tail;
          if (head6 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size16 = unsafeGet7(this.pubsubSize, journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
              unsafeSet2(this.publisherHead, tail, journal);
              unsafeSet2(this.pubsubSize, size16 - 1, journal);
            } else {
              const updatedNode = makeNode2(head6, subscribers - 1, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
            }
          }
          currentSubscriberHead = tail;
        }
      }
      const currentSubscriberCount = unsafeGet7(this.subscriberCount, journal);
      unsafeSet2(this.subscriberCount, currentSubscriberCount - 1, journal);
      unsafeSet2(this.subscribers, remove4(unsafeGet7(this.subscribers, journal), this.subscriberHead), journal);
    }
  });
  take = /* @__PURE__ */ withSTMRuntime((runtime4) => {
    let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime4.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime4.fiberId);
    }
    let value = AbsentValue2;
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet7(currentSubscriberHead, runtime4.journal);
      if (node === void 0) {
        return retry5;
      }
      const head6 = node.head;
      const tail = node.tail;
      if (head6 !== AbsentValue2) {
        const subscribers = node.subscribers;
        if (subscribers === 1) {
          const size16 = unsafeGet7(this.pubsubSize, runtime4.journal);
          const updatedNode = makeNode2(AbsentValue2, 0, tail);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime4.journal);
          unsafeSet2(this.publisherHead, tail, runtime4.journal);
          unsafeSet2(this.pubsubSize, size16 - 1, runtime4.journal);
        } else {
          const updatedNode = makeNode2(head6, subscribers - 1, tail);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime4.journal);
        }
        unsafeSet2(this.subscriberHead, tail, runtime4.journal);
        value = head6;
        loop3 = false;
      } else {
        currentSubscriberHead = tail;
      }
    }
    return succeed15(value);
  });
  takeAll = /* @__PURE__ */ this.takeUpTo(Number.POSITIVE_INFINITY);
  takeUpTo(max5) {
    return withSTMRuntime((runtime4) => {
      let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime4.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime4.fiberId);
      }
      const builder = [];
      let n2 = 0;
      while (n2 !== max5) {
        const node = unsafeGet7(currentSubscriberHead, runtime4.journal);
        if (node === void 0) {
          n2 = max5;
        } else {
          const head6 = node.head;
          const tail = node.tail;
          if (head6 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size16 = unsafeGet7(this.pubsubSize, runtime4.journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime4.journal);
              unsafeSet2(this.publisherHead, tail, runtime4.journal);
              unsafeSet2(this.pubsubSize, size16 - 1, runtime4.journal);
            } else {
              const updatedNode = makeNode2(head6, subscribers - 1, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime4.journal);
            }
            builder.push(head6);
            n2 = n2 + 1;
          }
          currentSubscriberHead = tail;
        }
      }
      unsafeSet2(this.subscriberHead, currentSubscriberHead, runtime4.journal);
      return succeed15(builder);
    });
  }
};
var makeSubscription2 = (pubsubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => pipe(get16(publisherTail), flatMap15((currentPublisherTail) => pipe(all7([make49(currentPublisherTail), get16(subscriberCount), get16(subscribers)]), tap5(([_2, currentSubscriberCount]) => pipe(subscriberCount, set7(currentSubscriberCount + 1))), tap5(([subscriberHead, _2, currentSubscribers]) => pipe(subscribers, set7(pipe(currentSubscribers, add4(subscriberHead))))), map22(([subscriberHead]) => new TPubSubSubscriptionImpl(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers)))));
var subscribe3 = (self2) => makeSubscription2(self2.pubsubSize, self2.publisherHead, self2.publisherTail, self2.requestedCapacity, self2.subscriberCount, self2.subscribers);
var subscribeScoped = (self2) => acquireRelease2(subscribe3(self2), (dequeue) => shutdown5(dequeue));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/TPubSub.js
var subscribeScoped2 = subscribeScoped;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/TQueue.js
var isShutdown6 = isShutdown4;
var take5 = take4;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/ringBuffer.js
var RingBuffer = class {
  capacity;
  array;
  size = 0;
  current = 0;
  constructor(capacity7) {
    this.capacity = capacity7;
    this.array = Array.from({
      length: capacity7
    }, constUndefined);
  }
  head() {
    return fromNullable(this.array[this.current]);
  }
  lastOrNull() {
    if (this.size === 0) {
      return void 0;
    }
    const index = this.current === 0 ? this.array.length - 1 : this.current - 1;
    return this.array[index] ?? void 0;
  }
  put(value) {
    this.array[this.current] = value;
    this.increment();
  }
  dropLast() {
    if (this.size > 0) {
      this.decrement();
      this.array[this.current] = void 0;
    }
  }
  toChunk() {
    const begin = this.current - this.size;
    const newArray = begin < 0 ? [...this.array.slice(this.capacity + begin, this.capacity), ...this.array.slice(0, this.current)] : this.array.slice(begin, this.current);
    return fromIterable2(newArray);
  }
  increment() {
    if (this.size < this.capacity) {
      this.size += 1;
    }
    this.current = (this.current + 1) % this.capacity;
  }
  decrement() {
    this.size -= 1;
    if (this.current > 0) {
      this.current -= 1;
    } else {
      this.current = this.capacity - 1;
    }
  }
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stream/debounceState.js
var OP_NOT_STARTED = "NotStarted";
var OP_PREVIOUS = "Previous";
var OP_CURRENT = "Current";
var notStarted = {
  _tag: OP_NOT_STARTED
};
var previous = (fiber) => ({
  _tag: OP_PREVIOUS,
  fiber
});
var current = (fiber) => ({
  _tag: OP_CURRENT,
  fiber
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stream/emit.js
var make50 = (emit2) => {
  const ops = {
    chunk(as10) {
      return this(succeed8(as10));
    },
    die(defect) {
      return this(die6(defect));
    },
    dieMessage(message) {
      return this(dieMessage2(message));
    },
    done(exit4) {
      return this(suspend4(() => mapBoth2(exit4, {
        onFailure: some2,
        onSuccess: of2
      })));
    },
    end() {
      return this(fail9(none2()));
    },
    fail(e) {
      return this(fail9(some2(e)));
    },
    fromEffect(effect4) {
      return this(mapBoth3(effect4, {
        onFailure: some2,
        onSuccess: of2
      }));
    },
    fromEffectChunk(effect4) {
      return this(pipe(effect4, mapError3(some2)));
    },
    halt(cause3) {
      return this(failCause8(pipe(cause3, map12(some2))));
    },
    single(value) {
      return this(succeed8(of2(value)));
    }
  };
  return Object.assign(emit2, ops);
};
var makePush = (queue, scheduler) => {
  let finished = false;
  let buffer4 = [];
  let running4 = false;
  function array6(items) {
    if (finished) return false;
    if (items.length <= 5e4) {
      buffer4.push.apply(buffer4, items);
    } else {
      for (let i = 0; i < items.length; i++) {
        buffer4.push(items[0]);
      }
    }
    if (!running4) {
      running4 = true;
      scheduler.scheduleTask(flush, 0);
    }
    return true;
  }
  function flush() {
    running4 = false;
    if (buffer4.length > 0) {
      queue.unsafeOffer(buffer4);
      buffer4 = [];
    }
  }
  function done11(exit4) {
    if (finished) return;
    finished = true;
    if (exit4._tag === "Success") {
      buffer4.push(exit4.value);
    }
    flush();
    queue.unsafeOffer(exit4._tag === "Success" ? void_3 : exit4);
  }
  return {
    single(value) {
      if (finished) return false;
      buffer4.push(value);
      if (!running4) {
        running4 = true;
        scheduler.scheduleTask(flush, 0);
      }
      return true;
    },
    array: array6,
    chunk(chunk5) {
      return array6(toReadonlyArray(chunk5));
    },
    done: done11,
    end() {
      if (finished) return;
      finished = true;
      flush();
      queue.unsafeOffer(void_3);
    },
    halt(cause3) {
      return done11(failCause4(cause3));
    },
    fail(error4) {
      return done11(fail4(error4));
    },
    die(defect) {
      return done11(die3(defect));
    },
    dieMessage(message) {
      return done11(die3(new Error(message)));
    }
  };
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stream/handoff.js
var HandoffTypeId = /* @__PURE__ */ Symbol.for("effect/Stream/Handoff");
var OP_HANDOFF_STATE_EMPTY = "Empty";
var OP_HANDOFF_STATE_FULL = "Full";
var handoffStateEmpty = (notifyConsumer) => ({
  _tag: OP_HANDOFF_STATE_EMPTY,
  notifyConsumer
});
var handoffStateFull = (value, notifyProducer) => ({
  _tag: OP_HANDOFF_STATE_FULL,
  value,
  notifyProducer
});
var handoffStateMatch = (onEmpty, onFull) => {
  return (self2) => {
    switch (self2._tag) {
      case OP_HANDOFF_STATE_EMPTY: {
        return onEmpty(self2.notifyConsumer);
      }
      case OP_HANDOFF_STATE_FULL: {
        return onFull(self2.value, self2.notifyProducer);
      }
    }
  };
};
var handoffVariance = {
  /* c8 ignore next */
  _A: (_2) => _2
};
var make51 = () => pipe(make23(), flatMap11((deferred2) => make25(handoffStateEmpty(deferred2))), map16((ref) => ({
  [HandoffTypeId]: handoffVariance,
  ref
})));
var offer5 = /* @__PURE__ */ dual(2, (self2, value) => {
  return flatMap11(make23(), (deferred2) => flatten8(modify3(self2.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [zipRight3(succeed2(notifyConsumer, void 0), _await(deferred2)), handoffStateFull(value, deferred2)], (_2, notifyProducer) => [flatMap11(_await(notifyProducer), () => pipe(self2, offer5(value))), state])))));
});
var take6 = (self2) => flatMap11(make23(), (deferred2) => flatten8(modify3(self2.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [flatMap11(_await(notifyConsumer), () => take6(self2)), state], (value, notifyProducer) => [as4(succeed2(notifyProducer, void 0), value), handoffStateEmpty(deferred2)])))));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stream/handoffSignal.js
var OP_EMIT4 = "Emit";
var OP_HALT = "Halt";
var OP_END = "End";
var emit = (elements) => ({
  _tag: OP_EMIT4,
  elements
});
var halt = (cause3) => ({
  _tag: OP_HALT,
  cause: cause3
});
var end3 = (reason) => ({
  _tag: OP_END,
  reason
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/take.js
var TakeSymbolKey = "effect/Take";
var TakeTypeId = /* @__PURE__ */ Symbol.for(TakeSymbolKey);
var takeVariance = {
  /* c8 ignore next */
  _A: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2
};
var TakeImpl = class {
  exit;
  [TakeTypeId] = takeVariance;
  constructor(exit4) {
    this.exit = exit4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var chunk4 = (chunk5) => new TakeImpl(succeed4(chunk5));
var done10 = (self2) => suspend4(() => self2.exit);
var end4 = /* @__PURE__ */ new TakeImpl(/* @__PURE__ */ fail4(/* @__PURE__ */ none2()));
var failCause11 = (cause3) => new TakeImpl(failCause4(pipe(cause3, map12(some2))));
var fromPull = (pull) => matchCause4(pull, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: () => end4,
    onSome: failCause11
  }),
  onSuccess: chunk4
});
var match17 = /* @__PURE__ */ dual(2, (self2, {
  onEnd: onEnd3,
  onFailure,
  onSuccess
}) => match9(self2.exit, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: onEnd3,
    onSome: onFailure
  }),
  onSuccess
}));
var of5 = (value) => new TakeImpl(succeed4(of2(value)));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stream/pull.js
var end5 = () => fail9(none2());
var failCause12 = (cause3) => mapError3(failCause8(cause3), some2);

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stream/sinkEndReason.js
var OP_SCHEDULE_END = "ScheduleEnd";
var OP_UPSTREAM_END = "UpstreamEnd";
var ScheduleEnd = {
  _tag: OP_SCHEDULE_END
};
var UpstreamEnd = {
  _tag: OP_UPSTREAM_END
};

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stream/zipAllState.js
var OP_DRAIN_LEFT = "DrainLeft";
var OP_DRAIN_RIGHT = "DrainRight";
var OP_PULL_BOTH = "PullBoth";
var OP_PULL_LEFT = "PullLeft";
var OP_PULL_RIGHT = "PullRight";
var DrainLeft = {
  _tag: OP_DRAIN_LEFT
};
var DrainRight = {
  _tag: OP_DRAIN_RIGHT
};
var PullBoth = {
  _tag: OP_PULL_BOTH
};
var PullLeft = (rightChunk) => ({
  _tag: OP_PULL_LEFT,
  rightChunk
});
var PullRight = (leftChunk) => ({
  _tag: OP_PULL_RIGHT,
  leftChunk
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stream/zipChunksState.js
var OP_PULL_BOTH2 = "PullBoth";
var OP_PULL_LEFT2 = "PullLet";
var OP_PULL_RIGHT2 = "PullRight";
var PullBoth2 = {
  _tag: OP_PULL_BOTH2
};
var PullLeft2 = (rightChunk) => ({
  _tag: OP_PULL_LEFT2,
  rightChunk
});
var PullRight2 = (leftChunk) => ({
  _tag: OP_PULL_RIGHT2,
  leftChunk
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/stream.js
var StreamSymbolKey = "effect/Stream";
var StreamTypeId2 = /* @__PURE__ */ Symbol.for(StreamSymbolKey);
var streamVariance = {
  _R: (_2) => _2,
  _E: (_2) => _2,
  _A: (_2) => _2
};
var StreamImpl = class {
  channel;
  [StreamTypeId2] = streamVariance;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isStream = (u2) => hasProperty(u2, StreamTypeId2) || isEffect2(u2);
var DefaultChunkSize = 4096;
var accumulate = (self2) => chunks(accumulateChunks(self2));
var accumulateChunks = (self2) => {
  const accumulator = (s2) => readWith({
    onInput: (input2) => {
      const next = appendAll2(s2, input2);
      return flatMap13(write(next), () => accumulator(next));
    },
    onFailure: fail13,
    onDone: () => void_5
  });
  return new StreamImpl(pipeTo(toChannel2(self2), accumulator(empty2())));
};
var acquireRelease3 = (acquire, release) => scoped5(acquireRelease2(acquire, release));
var aggregate = /* @__PURE__ */ dual(2, (self2, sink) => aggregateWithin(self2, sink, forever4));
var aggregateWithin = /* @__PURE__ */ dual(3, (self2, sink, schedule4) => filterMap6(aggregateWithinEither(self2, sink, schedule4), (_2) => match(_2, {
  onLeft: none2,
  onRight: some2
})));
var aggregateWithinEither = /* @__PURE__ */ dual(3, (self2, sink, schedule4) => {
  const layer = all4([make51(), make25(ScheduleEnd), make25(empty2()), driver2(schedule4), make25(false), make25(false)]);
  return fromEffect7(layer).pipe(flatMap16(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
    const handoffProducer = readWithCause({
      onInput: (input2) => flatMap13(fromEffect4(pipe(handoff, offer5(emit(input2)), when2(() => isNonEmpty(input2)))), () => handoffProducer),
      onFailure: (cause3) => fromEffect4(offer5(handoff, halt(cause3))),
      onDone: () => fromEffect4(offer5(handoff, end3(UpstreamEnd)))
    });
    const handoffConsumer = pipe(getAndSet2(sinkLeftovers, empty2()), flatMap11((leftovers) => {
      if (isNonEmpty(leftovers)) {
        return pipe(set5(consumed, true), zipRight3(succeed8(pipe(write(leftovers), flatMap13(() => handoffConsumer)))));
      }
      return pipe(take6(handoff), map16((signal) => {
        switch (signal._tag) {
          case OP_EMIT4: {
            return pipe(fromEffect4(set5(consumed, true)), zipRight5(write(signal.elements)), zipRight5(fromEffect4(get11(endAfterEmit))), flatMap13((bool) => bool ? void_5 : handoffConsumer));
          }
          case OP_HALT: {
            return failCause10(signal.cause);
          }
          case OP_END: {
            if (signal.reason._tag === OP_SCHEDULE_END) {
              return pipe(get11(consumed), map16((bool) => bool ? fromEffect4(pipe(set5(sinkEndReason, ScheduleEnd), zipRight3(set5(endAfterEmit, true)))) : pipe(fromEffect4(pipe(set5(sinkEndReason, ScheduleEnd), zipRight3(set5(endAfterEmit, true)))), flatMap13(() => handoffConsumer))), unwrap3);
            }
            return pipe(set5(sinkEndReason, signal.reason), zipRight3(set5(endAfterEmit, true)), fromEffect4);
          }
        }
      }));
    }), unwrap3);
    const timeout5 = (lastB) => scheduleDriver.next(lastB);
    const scheduledAggregator = (sinkFiber, scheduleFiber, scope5) => {
      const forkSink = pipe(set5(consumed, false), zipRight3(set5(endAfterEmit, false)), zipRight3(pipe(handoffConsumer, pipeToOrFail(toChannel(sink)), collectElements, run2, forkIn2(scope5))));
      const handleSide = (leftovers, b, c) => pipe(set5(sinkLeftovers, flatten2(leftovers)), zipRight3(map16(get11(sinkEndReason), (reason) => {
        switch (reason._tag) {
          case OP_SCHEDULE_END: {
            return pipe(all4([get11(consumed), forkSink, pipe(timeout5(some2(b)), forkIn2(scope5))]), map16(([wasConsumed, sinkFiber2, scheduleFiber2]) => {
              const toWrite = pipe(c, match2({
                onNone: () => of2(right2(b)),
                onSome: (c2) => make5(right2(b), left2(c2))
              }));
              if (wasConsumed) {
                return pipe(write(toWrite), flatMap13(() => scheduledAggregator(sinkFiber2, scheduleFiber2, scope5)));
              }
              return scheduledAggregator(sinkFiber2, scheduleFiber2, scope5);
            }), unwrap3);
          }
          case OP_UPSTREAM_END: {
            return pipe(get11(consumed), map16((wasConsumed) => wasConsumed ? write(of2(right2(b))) : void_5), unwrap3);
          }
        }
      })), unwrap3);
      return unwrap3(raceWith2(join3(sinkFiber), join3(scheduleFiber), {
        onSelfDone: (sinkExit, _2) => pipe(interrupt6(scheduleFiber), zipRight3(pipe(suspend4(() => sinkExit), map16(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
        onOtherDone: (scheduleExit, _2) => matchCauseEffect3(suspend4(() => scheduleExit), {
          onFailure: (cause3) => match(failureOrCause2(cause3), {
            onLeft: () => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight3(pipe(join3(sinkFiber), map16(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
            onRight: (cause4) => pipe(handoff, offer5(halt(cause4)), forkDaemon2, zipRight3(pipe(join3(sinkFiber), map16(([leftovers, b]) => handleSide(leftovers, b, none2())))))
          }),
          onSuccess: (c) => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight3(pipe(join3(sinkFiber), map16(([leftovers, b]) => handleSide(leftovers, b, some2(c))))))
        })
      }));
    };
    return unwrapScopedWith3((scope5) => pipeTo(toChannel2(self2), handoffProducer).pipe(run2, forkIn2(scope5), zipRight3(pipeToOrFail(handoffConsumer, toChannel(sink)).pipe(collectElements, run2, forkIn2(scope5), flatMap11((sinkFiber) => timeout5(none2()).pipe(forkIn2(scope5), map16((scheduleFiber) => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope5)))))))));
  }));
});
var as8 = /* @__PURE__ */ dual(2, (self2, value) => map23(self2, () => value));
var queueFromBufferOptions = (bufferSize) => {
  if (bufferSize === "unbounded") {
    return unbounded3();
  } else if (typeof bufferSize === "number" || bufferSize === void 0) {
    return bounded3(bufferSize ?? 16);
  }
  switch (bufferSize.strategy) {
    case "dropping":
      return dropping2(bufferSize.bufferSize ?? 16);
    case "sliding":
      return sliding2(bufferSize.bufferSize ?? 16);
    default:
      return bounded3(bufferSize.bufferSize ?? 16);
  }
};
var _async = (register, bufferSize) => acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown2(queue)).pipe(flatMap11((output) => runtime3().pipe(flatMap11((runtime4) => sync4(() => {
  const runPromiseExit3 = runPromiseExit2(runtime4);
  const canceler = register(make50((resume2) => fromPull(resume2).pipe(flatMap11((take9) => offer3(output, take9)), asVoid2, runPromiseExit3).then((exit4) => {
    if (isFailure2(exit4)) {
      if (!isInterrupted2(exit4.cause)) {
        throw squash(exit4.cause);
      }
    }
  })));
  return canceler;
})), map16((value) => {
  const loop3 = take3(output).pipe(flatMap11((take9) => done10(take9)), match12({
    onFailure: (maybeError) => fromEffect4(shutdown2(output)).pipe(zipRight5(match2(maybeError, {
      onNone: () => void_5,
      onSome: (error4) => fail13(error4)
    }))),
    onSuccess: (chunk5) => write(chunk5).pipe(flatMap13(() => loop3))
  }), unwrap3);
  return fromChannel2(loop3).pipe(ensuring6(value ?? _void));
}))), unwrapScoped4);
var asyncEffect3 = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown2(queue)), flatMap11((output) => pipe(runtime3(), flatMap11((runtime4) => pipe(register(make50((k) => pipe(fromPull(k), flatMap11((take9) => offer3(output, take9)), asVoid2, runPromiseExit2(runtime4)).then((exit4) => {
  if (isFailure2(exit4)) {
    if (!isInterrupted2(exit4.cause)) {
      throw squash(exit4.cause);
    }
  }
}))), map16(() => {
  const loop3 = pipe(take3(output), flatMap11(done10), match12({
    onFailure: (maybeError) => pipe(fromEffect4(shutdown2(output)), zipRight5(match2(maybeError, {
      onNone: () => void_5,
      onSome: fail13
    }))),
    onSuccess: (chunk5) => pipe(write(chunk5), flatMap13(() => loop3))
  }), unwrap3);
  return loop3;
}))))), unwrapScoped3, fromChannel2);
var queueFromBufferOptionsPush = (options) => {
  if (options?.bufferSize === "unbounded" || options?.bufferSize === void 0 && options?.strategy === void 0) {
    return unbounded3();
  }
  switch (options?.strategy) {
    case "sliding":
      return sliding2(options.bufferSize ?? 16);
    default:
      return dropping2(options?.bufferSize ?? 16);
  }
};
var asyncPush = (register, options) => acquireRelease2(queueFromBufferOptionsPush(options), shutdown2).pipe(tap3((queue) => getWith(currentScheduler2, (scheduler) => register(makePush(queue, scheduler)))), map16((queue) => {
  const loop3 = flatMap13(take3(queue), (item) => isExit(item) ? isSuccess2(item) ? void_5 : failCause10(item.cause) : zipRight5(write(unsafeFromArray(item)), loop3));
  return loop3;
}), unwrapScoped3, fromChannel2);
var asyncScoped = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown2(queue)), flatMap11((output) => pipe(runtime3(), flatMap11((runtime4) => pipe(register(make50((k) => pipe(fromPull(k), flatMap11((take9) => offer3(output, take9)), asVoid2, runPromiseExit2(runtime4)).then((exit4) => {
  if (isFailure2(exit4)) {
    if (!isInterrupted2(exit4.cause)) {
      throw squash(exit4.cause);
    }
  }
}))), zipRight3(make25(false)), flatMap11((ref) => pipe(get11(ref), map16((isDone7) => isDone7 ? end5() : pipe(take3(output), flatMap11(done10), onError2(() => pipe(set5(ref, true), zipRight3(shutdown2(output)))))))))))), scoped5, flatMap16(repeatEffectChunkOption));
var branchAfter = /* @__PURE__ */ dual(3, (self2, n2, f2) => suspend12(() => {
  const buffering = (acc) => readWith({
    onInput: (input2) => {
      const nextSize = acc.length + input2.length;
      if (nextSize >= n2) {
        const [b1, b2] = pipe(input2, splitAt2(n2 - acc.length));
        return running4(pipe(acc, appendAll2(b1)), b2);
      }
      return buffering(pipe(acc, appendAll2(input2)));
    },
    onFailure: fail13,
    onDone: () => running4(acc, empty2())
  });
  const running4 = (prefix, leftover) => pipeTo(zipRight5(write(leftover), identityChannel()), toChannel2(f2(prefix)));
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(buffering(empty2()))));
}));
var broadcast = /* @__PURE__ */ dual(3, (self2, n2, maximumLag) => pipe(self2, broadcastedQueues(n2, maximumLag), map16((tuple3) => tuple3.map((queue) => flattenTake(fromQueue2(queue, {
  shutdown: true
}))))));
var broadcastDynamic = /* @__PURE__ */ dual(2, (self2, maximumLag) => map16(toPubSub2(self2, maximumLag), (pubsub) => flattenTake(fromPubSub(pubsub))));
var share = /* @__PURE__ */ dual(2, (self2, options) => map16(make46({
  acquire: broadcastDynamic(self2, options),
  idleTimeToLive: options.idleTimeToLive
}), (rcRef) => unwrapScoped4(get15(rcRef))));
var broadcastedQueues = /* @__PURE__ */ dual(3, (self2, n2, maximumLag) => flatMap11(pubsubFromOptions(maximumLag), (pubsub) => pipe(all4(Array.from({
  length: n2
}, () => subscribe2(pubsub))), tap3(() => forkScoped2(runIntoPubSubScoped(self2, pubsub))))));
var broadcastedQueuesDynamic = /* @__PURE__ */ dual(2, (self2, maximumLag) => map16(toPubSub2(self2, maximumLag), subscribe2));
var buffer = /* @__PURE__ */ dual(2, (self2, options) => {
  if (options.capacity === "unbounded") {
    return bufferUnbounded(self2);
  } else if (options.strategy === "dropping") {
    return bufferDropping(self2, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferSliding(self2, options.capacity);
  }
  const queue = toQueueOfElements(self2, options);
  return new StreamImpl(unwrapScoped3(map16(queue, (queue2) => {
    const process2 = pipe(fromEffect4(take3(queue2)), flatMap13(match9({
      onFailure: (cause3) => pipe(flipCauseOption2(cause3), match2({
        onNone: () => void_5,
        onSome: failCause10
      })),
      onSuccess: (value) => flatMap13(write(of2(value)), () => process2)
    })));
    return process2;
  })));
});
var bufferChunks = /* @__PURE__ */ dual(2, (self2, options) => {
  if (options.strategy === "dropping") {
    return bufferChunksDropping(self2, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferChunksSliding(self2, options.capacity);
  }
  const queue = toQueue2(self2, options);
  return new StreamImpl(unwrapScoped3(map16(queue, (queue2) => {
    const process2 = pipe(fromEffect4(take3(queue2)), flatMap13(match17({
      onEnd: () => void_5,
      onFailure: failCause10,
      onSuccess: (value) => pipe(write(value), flatMap13(() => process2))
    })));
    return process2;
  })));
});
var bufferChunksDropping = /* @__PURE__ */ dual(2, (self2, capacity7) => {
  const queue = acquireRelease2(dropping2(capacity7), (queue2) => shutdown2(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self2)));
});
var bufferChunksSliding = /* @__PURE__ */ dual(2, (self2, capacity7) => {
  const queue = acquireRelease2(sliding2(capacity7), (queue2) => shutdown2(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self2)));
});
var bufferDropping = /* @__PURE__ */ dual(2, (self2, capacity7) => {
  const queue = acquireRelease2(dropping2(capacity7), (queue2) => shutdown2(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(rechunk(1)(self2))));
});
var bufferSliding = /* @__PURE__ */ dual(2, (self2, capacity7) => {
  const queue = acquireRelease2(sliding2(capacity7), (queue2) => shutdown2(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(pipe(self2, rechunk(1)))));
});
var bufferUnbounded = (self2) => {
  const queue = toQueue2(self2, {
    strategy: "unbounded"
  });
  return new StreamImpl(unwrapScoped3(map16(queue, (queue2) => {
    const process2 = pipe(fromEffect4(take3(queue2)), flatMap13(match17({
      onEnd: () => void_5,
      onFailure: failCause10,
      onSuccess: (value) => flatMap13(write(value), () => process2)
    })));
    return process2;
  })));
};
var bufferSignal = (scoped7, bufferChannel) => {
  const producer = (queue, ref) => {
    const terminate = (take9) => pipe(get11(ref), tap3(_await), zipRight3(make23()), flatMap11((deferred2) => pipe(offer3(queue, [take9, deferred2]), zipRight3(set5(ref, deferred2)), zipRight3(_await(deferred2)))), asVoid2, fromEffect4);
    return readWithCause({
      onInput: (input2) => pipe(make23(), flatMap11((deferred2) => pipe(offer3(queue, [chunk4(input2), deferred2]), flatMap11((added) => pipe(set5(ref, deferred2), when2(() => added))))), asVoid2, fromEffect4, flatMap13(() => producer(queue, ref))),
      onFailure: (error4) => terminate(failCause11(error4)),
      onDone: () => terminate(end4)
    });
  };
  const consumer = (queue) => {
    const process2 = pipe(fromEffect4(take3(queue)), flatMap13(([take9, deferred2]) => zipRight5(fromEffect4(succeed2(deferred2, void 0)), match17(take9, {
      onEnd: () => void_5,
      onFailure: failCause10,
      onSuccess: (value) => pipe(write(value), flatMap13(() => process2))
    }))));
    return process2;
  };
  return unwrapScoped3(pipe(scoped7, flatMap11((queue) => pipe(make23(), tap3((start3) => succeed2(start3, void 0)), flatMap11((start3) => pipe(make25(start3), flatMap11((ref) => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped, forkScoped2)), as4(consumer(queue))))))));
};
var catchAll7 = /* @__PURE__ */ dual(2, (self2, f2) => catchAllCause6(self2, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f2,
  onRight: failCause13
})));
var catchAllCause6 = /* @__PURE__ */ dual(2, (self2, f2) => new StreamImpl(pipe(toChannel2(self2), catchAllCause5((cause3) => toChannel2(f2(cause3))))));
var catchSome3 = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, catchAll7((error4) => pipe(pf(error4), getOrElse(() => fail17(error4))))));
var catchSomeCause3 = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, catchAllCause6((cause3) => pipe(pf(cause3), getOrElse(() => failCause13(cause3))))));
var catchTag3 = /* @__PURE__ */ dual(3, (self2, k, f2) => catchAll7(self2, (e) => {
  if ("_tag" in e && e["_tag"] === k) {
    return f2(e);
  }
  return fail17(e);
}));
var catchTags3 = /* @__PURE__ */ dual(2, (self2, cases) => catchAll7(self2, (e) => {
  const keys5 = Object.keys(cases);
  if ("_tag" in e && keys5.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail17(e);
}));
var changes = (self2) => pipe(self2, changesWith((x2, y) => equals(y)(x2)));
var changesWith = /* @__PURE__ */ dual(2, (self2, f2) => {
  const writer = (last6) => readWithCause({
    onInput: (input2) => {
      const [newLast, newChunk] = reduce2(input2, [last6, empty2()], ([option5, outputs], output) => {
        if (isSome2(option5) && f2(option5.value, output)) {
          return [some2(output), outputs];
        }
        return [some2(output), pipe(outputs, append2(output))];
      });
      return flatMap13(write(newChunk), () => writer(newLast));
    },
    onFailure: failCause10,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer(none2()))));
});
var changesWithEffect = /* @__PURE__ */ dual(2, (self2, f2) => {
  const writer = (last6) => readWithCause({
    onInput: (input2) => pipe(input2, reduce11([last6, empty2()], ([option5, outputs], output) => {
      if (isSome2(option5)) {
        return pipe(f2(option5.value, output), map16((bool) => bool ? [some2(output), outputs] : [some2(output), pipe(outputs, append2(output))]));
      }
      return succeed8([some2(output), pipe(outputs, append2(output))]);
    }), fromEffect4, flatMap13(([newLast, newChunk]) => pipe(write(newChunk), flatMap13(() => writer(newLast))))),
    onFailure: failCause10,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer(none2()))));
});
var chunks = (self2) => pipe(self2, mapChunks(of2));
var chunksWith = /* @__PURE__ */ dual(2, (self2, f2) => flattenChunks(f2(chunks(self2))));
var unsome = (effect4) => catchAll3(asSome2(effect4), (o2) => o2._tag === "None" ? succeedNone2 : fail9(o2.value));
var combine9 = /* @__PURE__ */ dual(4, (self2, that, s2, f2) => {
  function producer(handoff, latch) {
    return fromEffect4(take6(latch)).pipe(zipRight5(readWithCause({
      onInput: (input2) => flatMap13(fromEffect4(offer5(handoff, succeed4(input2))), () => producer(handoff, latch)),
      onFailure: (cause3) => fromEffect4(offer5(handoff, failCause4(pipe(cause3, map12(some2))))),
      onDone: () => flatMap13(fromEffect4(offer5(handoff, fail4(none2()))), () => producer(handoff, latch))
    })));
  }
  return new StreamImpl(unwrapScopedWith((scope5) => all4([make51(), make51(), make51(), make51()]).pipe(tap3(([left3, _2, latchL]) => toChannel2(self2).pipe(concatMap(writeChunk), pipeTo(producer(left3, latchL)), runIn(scope5), forkIn2(scope5))), tap3(([, right3, _2, rightL]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3, rightL)), runIn(scope5), forkIn2(scope5))), map16(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer5(latchL, void 0).pipe(zipRight3(take6(left3).pipe(flatMap11(identity))));
    const pullRight = offer5(latchR, void 0).pipe(zipRight3(take6(right3).pipe(flatMap11(identity))));
    return toChannel2(unfoldEffect(s2, (s3) => flatMap11(f2(s3, pullLeft, pullRight), unsome)));
  }))));
});
var combineChunks = /* @__PURE__ */ dual(4, (self2, that, s2, f2) => {
  const producer = (handoff, latch) => zipRight5(fromEffect4(take6(latch)), readWithCause({
    onInput: (input2) => flatMap13(fromEffect4(pipe(handoff, offer5(chunk4(input2)))), () => producer(handoff, latch)),
    onFailure: (cause3) => fromEffect4(offer5(handoff, failCause11(cause3))),
    onDone: () => fromEffect4(offer5(handoff, end4))
  }));
  return new StreamImpl(unwrapScopedWith((scope5) => all4([make51(), make51(), make51(), make51()]).pipe(tap3(([left3, _2, latchL]) => pipeTo(toChannel2(self2), producer(left3, latchL)).pipe(runIn(scope5), forkIn2(scope5))), tap3(([_2, right3, __, latchR]) => pipeTo(toChannel2(that), producer(right3, latchR)).pipe(runIn(scope5), forkIn2(scope5))), map16(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer5(latchL, void 0).pipe(zipRight3(take6(left3).pipe(flatMap11(done10))));
    const pullRight = offer5(latchR, void 0).pipe(zipRight3(take6(right3).pipe(flatMap11(done10))));
    return toChannel2(unfoldChunkEffect(s2, (s3) => flatMap11(f2(s3, pullLeft, pullRight), unsome)));
  }))));
});
var concat2 = /* @__PURE__ */ dual(2, (self2, that) => new StreamImpl(pipe(toChannel2(self2), zipRight5(toChannel2(that)))));
var concatAll2 = (streams) => suspend12(() => pipe(streams, reduce2(empty31, (x2, y) => concat2(y)(x2))));
var cross = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a2, a22) => [a2, a22])));
var crossLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a2, _2) => a2)));
var crossRight = /* @__PURE__ */ dual(2, (left3, right3) => flatMap16(left3, () => right3));
var crossWith = /* @__PURE__ */ dual(3, (left3, right3, f2) => pipe(left3, flatMap16((a2) => pipe(right3, map23((b) => f2(a2, b))))));
var debounce = /* @__PURE__ */ dual(2, (self2, duration4) => unwrapScopedWith3((scope5) => gen2(function* () {
  const handoff = yield* make51();
  function enqueue(last6) {
    return sleep2(duration4).pipe(as4(last6), forkIn2(scope5), map16((fiber) => consumer(previous(fiber))));
  }
  const producer = readWithCause({
    onInput: (input2) => match2(last2(input2), {
      onNone: () => producer,
      onSome: (elem) => fromEffect4(offer5(handoff, emit(of2(elem)))).pipe(flatMap13(() => producer))
    }),
    onFailure: (cause3) => fromEffect4(offer5(handoff, halt(cause3))),
    onDone: () => fromEffect4(offer5(handoff, end3(UpstreamEnd)))
  });
  function consumer(state) {
    switch (state._tag) {
      case OP_NOT_STARTED: {
        return unwrap3(take6(handoff).pipe(map16((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap3(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause10(signal.cause);
            }
            case OP_END: {
              return void_5;
            }
          }
        })));
      }
      case OP_PREVIOUS: {
        return unwrap3(take6(handoff).pipe(forkIn2(scope5), flatMap11((handoffFiber) => raceWith2(join3(state.fiber), join3(handoffFiber), {
          onSelfDone: (leftExit, current2) => match9(leftExit, {
            onFailure: (cause3) => interrupt6(current2).pipe(as4(failCause10(cause3))),
            onSuccess: (chunk5) => interrupt6(current2).pipe(zipRight3(succeed8(write(chunk5).pipe(flatMap13(() => consumer(current(handoffFiber)))))))
          }),
          onOtherDone: (rightExit, previous2) => match9(rightExit, {
            onFailure: (cause3) => interrupt6(previous2).pipe(as4(failCause10(cause3))),
            onSuccess: (signal) => {
              switch (signal._tag) {
                case OP_EMIT4: {
                  return interrupt6(previous2).pipe(zipRight3(enqueue(signal.elements)));
                }
                case OP_HALT: {
                  return interrupt6(previous2).pipe(as4(failCause10(signal.cause)));
                }
                case OP_END: {
                  return join3(previous2).pipe(map16((chunk5) => write(chunk5).pipe(zipRight5(void_5))));
                }
              }
            }
          })
        }))));
      }
      case OP_CURRENT: {
        return unwrap3(join3(state.fiber).pipe(map16((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap3(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause10(signal.cause);
            }
            case OP_END: {
              return void_5;
            }
          }
        })));
      }
    }
  }
  return scopedWith4((scope6) => pipeTo(toChannel2(self2), producer).pipe(runIn(scope6), forkIn2(scope6))).pipe(crossRight(new StreamImpl(consumer(notStarted))));
})));
var die10 = (defect) => fromEffect7(die6(defect));
var dieSync6 = (evaluate3) => fromEffect7(dieSync3(evaluate3));
var dieMessage4 = (message) => fromEffect7(dieMessage2(message));
var distributedWith = /* @__PURE__ */ dual(2, (self2, options) => pipe(make23(), flatMap11((deferred2) => pipe(self2, distributedWithDynamic({
  maximumLag: options.maximumLag,
  decide: (a2) => flatMap11(_await(deferred2), (f2) => f2(a2))
}), flatMap11((next) => pipe(all4(map3(range(0, options.size - 1), (id2) => map16(next, ([key, queue]) => [[key, id2], queue]))), map16(unsafeFromArray), flatMap11((entries2) => {
  const [mappings, queues] = reduceRight2(entries2, [/* @__PURE__ */ new Map(), empty2()], ([mappings2, queues2], [mapping, queue]) => [mappings2.set(mapping[0], mapping[1]), pipe(queues2, prepend2(queue))]);
  return pipe(succeed2(deferred2, (a2) => map16(options.decide(a2), (f2) => (key) => pipe(f2(mappings.get(key))))), as4(Array.from(queues)));
})))))));
var distributedWithDynamicId = {
  ref: 0
};
var newDistributedWithDynamicId = () => {
  const current2 = distributedWithDynamicId.ref;
  distributedWithDynamicId.ref = current2 + 1;
  return current2;
};
var distributedWithDynamic = /* @__PURE__ */ dual(2, (self2, options) => distributedWithDynamicCallback(self2, options.maximumLag, options.decide, () => _void));
var distributedWithDynamicCallback = /* @__PURE__ */ dual(4, (self2, maximumLag, decide, done11) => pipe(acquireRelease2(make25(/* @__PURE__ */ new Map()), (ref, _2) => pipe(get11(ref), flatMap11((queues) => pipe(queues.values(), forEach9(shutdown2))))), flatMap11((queuesRef) => gen2(function* () {
  const offer6 = (a2) => pipe(decide(a2), flatMap11((shouldProcess) => pipe(get11(queuesRef), flatMap11((queues) => pipe(queues.entries(), reduce11(empty2(), (acc, [id2, queue]) => {
    if (shouldProcess(id2)) {
      return pipe(offer3(queue, succeed4(a2)), matchCauseEffect3({
        onFailure: (cause3) => (
          // Ignore all downstream queues that were shut
          // down and remove them later
          isInterrupted2(cause3) ? succeed8(pipe(acc, prepend2(id2))) : failCause8(cause3)
        ),
        onSuccess: () => succeed8(acc)
      }));
    }
    return succeed8(acc);
  }), flatMap11((ids3) => {
    if (isNonEmpty(ids3)) {
      return pipe(update3(queuesRef, (map26) => {
        for (const id2 of ids3) {
          map26.delete(id2);
        }
        return map26;
      }));
    }
    return _void;
  }))))), asVoid2);
  const queuesLock = yield* makeSemaphore2(1);
  const newQueue = yield* make25(pipe(bounded3(maximumLag), flatMap11((queue) => {
    const id2 = newDistributedWithDynamicId();
    return pipe(update3(queuesRef, (map26) => map26.set(id2, queue)), as4([id2, queue]));
  })));
  const finalize = (endTake) => (
    // Make sure that no queues are currently being added
    queuesLock.withPermits(1)(pipe(set5(newQueue, pipe(
      // All newly created queues should end immediately
      bounded3(1),
      tap3((queue) => offer3(queue, endTake)),
      flatMap11((queue) => {
        const id2 = newDistributedWithDynamicId();
        return pipe(update3(queuesRef, (map26) => map26.set(id2, queue)), as4(make3(id2, queue)));
      })
    )), zipRight3(pipe(get11(queuesRef), flatMap11((map26) => pipe(fromIterable2(map26.values()), forEach9((queue) => pipe(offer3(queue, endTake), catchSomeCause2((cause3) => isInterrupted2(cause3) ? some2(_void) : none2()))))))), zipRight3(done11(endTake)), asVoid2))
  );
  yield* pipe(self2, runForEachScoped(offer6), matchCauseEffect3({
    onFailure: (cause3) => finalize(failCause4(pipe(cause3, map12(some2)))),
    onSuccess: () => finalize(fail4(none2()))
  }), forkScoped2);
  return queuesLock.withPermits(1)(flatten8(get11(newQueue)));
}))));
var drain3 = (self2) => new StreamImpl(drain(toChannel2(self2)));
var drainFork = /* @__PURE__ */ dual(2, (self2, that) => fromEffect7(make23()).pipe(flatMap16((backgroundDied) => scopedWith4((scope5) => toChannel2(that).pipe(drain, runIn(scope5), catchAllCause3((cause3) => failCause2(backgroundDied, cause3)), forkIn2(scope5))).pipe(crossRight(interruptWhenDeferred2(self2, backgroundDied))))));
var drop3 = /* @__PURE__ */ dual(2, (self2, n2) => {
  const loop3 = (r) => readWith({
    onInput: (input2) => {
      const dropped = pipe(input2, drop2(r));
      const leftover = Math.max(0, r - input2.length);
      const more = isEmpty(input2) || leftover > 0;
      if (more) {
        return loop3(leftover);
      }
      return pipe(write(dropped), zipRight5(identityChannel()));
    },
    onFailure: fail13,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3(n2))));
});
var dropRight = /* @__PURE__ */ dual(2, (self2, n2) => {
  if (n2 <= 0) {
    return identityStream();
  }
  return suspend12(() => {
    const queue = new RingBuffer(n2);
    const reader = readWith({
      onInput: (input2) => {
        const outputs = pipe(input2, filterMap2((elem) => {
          const head6 = queue.head();
          queue.put(elem);
          return head6;
        }));
        return pipe(write(outputs), flatMap13(() => reader));
      },
      onFailure: fail13,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(reader)));
  });
});
var dropUntil3 = /* @__PURE__ */ dual(2, (self2, predicate) => drop3(dropWhile4(self2, (a2) => !predicate(a2)), 1));
var dropUntilEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input2) => pipe(dropUntil2(input2, predicate), map16(unsafeFromArray), map16((leftover) => {
      const more = isEmpty(leftover);
      if (more) {
        return suspend8(() => loop3);
      }
      return pipe(write(leftover), zipRight5(identityChannel()));
    }), unwrap3),
    onFailure: fail13,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
});
var dropWhile4 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input2) => {
      const output = dropWhile(input2, predicate);
      if (isEmpty(output)) {
        return suspend8(() => loop3);
      }
      return zipRight5(write(output), identityChannel());
    },
    onFailure: fail13,
    onDone: succeedNow
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self2), loop3));
});
var dropWhileEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input2) => pipe(dropWhile3(input2, predicate), map16(unsafeFromArray), map16((leftover) => {
      const more = isEmpty(leftover);
      if (more) {
        return suspend8(() => loop3);
      }
      return zipRight5(write(leftover), identityChannel());
    }), unwrap3),
    onFailure: fail13,
    onDone: () => void_5
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self2), loop3));
});
var either5 = (self2) => pipe(self2, map23(right2), catchAll7((error4) => make52(left2(error4))));
var empty31 = /* @__PURE__ */ new StreamImpl(void_5);
var ensuring6 = /* @__PURE__ */ dual(2, (self2, finalizer3) => new StreamImpl(pipe(toChannel2(self2), ensuring4(finalizer3))));
var ensuringWith2 = /* @__PURE__ */ dual(2, (self2, finalizer3) => new StreamImpl(ensuringWith(toChannel2(self2), finalizer3)));
var context5 = () => fromEffect7(context3());
var contextWith3 = (f2) => pipe(context5(), map23(f2));
var contextWithEffect3 = (f2) => pipe(context5(), mapEffectSequential(f2));
var contextWithStream = (f2) => pipe(context5(), flatMap16(f2));
var execute = (effect4) => drain3(fromEffect7(effect4));
var fail17 = (error4) => fromEffectOption(fail9(some2(error4)));
var failSync7 = (evaluate3) => fromEffectOption(failSync3(() => some2(evaluate3())));
var failCause13 = (cause3) => fromEffect7(failCause8(cause3));
var failCauseSync6 = (evaluate3) => fromEffect7(failCauseSync3(evaluate3));
var filter8 = /* @__PURE__ */ dual(2, (self2, predicate) => mapChunks(self2, filter2(predicate)));
var filterEffect = /* @__PURE__ */ dual(2, (self2, f2) => {
  const loop3 = (iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (input2) => loop3(input2[Symbol.iterator]()),
        onFailure: failCause10,
        onDone: succeed13
      });
    } else {
      return pipe(f2(next.value), map16((bool) => bool ? pipe(write(of2(next.value)), flatMap13(() => loop3(iterator))) : loop3(iterator)), unwrap3);
    }
  };
  return new StreamImpl(suspend8(() => pipe(toChannel2(self2), pipeTo(loop3(empty2()[Symbol.iterator]())))));
});
var filterMap6 = /* @__PURE__ */ dual(2, (self2, pf) => mapChunks(self2, filterMap2(pf)));
var filterMapEffect = /* @__PURE__ */ dual(2, (self2, pf) => suspend12(() => {
  const loop3 = (iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (input2) => loop3(input2[Symbol.iterator]()),
        onFailure: failCause10,
        onDone: succeed13
      });
    } else {
      return pipe(pf(next.value), match2({
        onNone: () => sync4(() => loop3(iterator)),
        onSome: map16((a2) => flatMap13(write(of2(a2)), () => loop3(iterator)))
      }), unwrap3);
    }
  };
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty2()[Symbol.iterator]()))));
}));
var filterMapWhile3 = /* @__PURE__ */ dual(2, (self2, pf) => {
  const loop3 = readWith({
    onInput: (input2) => {
      const mapped = filterMapWhile2(input2, pf);
      if (mapped.length === input2.length) {
        return pipe(write(mapped), flatMap13(() => loop3));
      }
      return write(mapped);
    },
    onFailure: fail13,
    onDone: succeed13
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
});
var filterMapWhileEffect = /* @__PURE__ */ dual(2, (self2, pf) => suspend12(() => {
  const loop3 = (iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (input2) => loop3(input2[Symbol.iterator]()),
        onFailure: failCause10,
        onDone: succeed13
      });
    } else {
      return unwrap3(match2(pf(next.value), {
        onNone: () => succeed8(void_5),
        onSome: map16((a2) => flatMap13(write(of2(a2)), () => loop3(iterator)))
      }));
    }
  };
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3(empty2()[Symbol.iterator]()))));
}));
var finalizer = (finalizer3) => acquireRelease3(_void, () => finalizer3);
var find2 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input2) => match2(findFirst3(input2, predicate), {
      onNone: () => loop3,
      onSome: (n2) => write(of2(n2))
    }),
    onFailure: fail13,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
});
var findEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input2) => pipe(findFirst7(input2, predicate), map16(match2({
      onNone: () => loop3,
      onSome: (n2) => write(of2(n2))
    })), unwrap3),
    onFailure: fail13,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
});
var flatMap16 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, f2, options) => {
  const bufferSize = options?.bufferSize ?? 16;
  if (options?.switch) {
    return matchConcurrency(options?.concurrency, () => flatMapParSwitchBuffer(self2, 1, bufferSize, f2), (n2) => flatMapParSwitchBuffer(self2, n2, bufferSize, f2));
  }
  return matchConcurrency(options?.concurrency, () => new StreamImpl(concatMap(toChannel2(self2), (as10) => pipe(as10, map3((a2) => toChannel2(f2(a2))), reduce2(void_5, (left3, right3) => pipe(left3, zipRight5(right3)))))), (_2) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mergeMap((out) => toChannel2(f2(out)), options))));
});
var matchConcurrency = (concurrency, sequential4, bounded8) => {
  switch (concurrency) {
    case void 0:
      return sequential4();
    case "unbounded":
      return bounded8(Number.MAX_SAFE_INTEGER);
    default:
      return concurrency > 1 ? bounded8(concurrency) : sequential4();
  }
};
var flatMapParSwitchBuffer = /* @__PURE__ */ dual(4, (self2, n2, bufferSize, f2) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mergeMap((out) => toChannel2(f2(out)), {
  concurrency: n2,
  mergeStrategy: BufferSliding(),
  bufferSize
}))));
var flatten12 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => flatMap16(self2, identity, options));
var flattenChunks = (self2) => {
  const flatten14 = readWithCause({
    onInput: (chunks3) => flatMap13(writeChunk(chunks3), () => flatten14),
    onFailure: failCause10,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(flatten14)));
};
var flattenEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => options?.unordered ? flatMap16(self2, (a2) => fromEffect7(a2), {
  concurrency: options.concurrency
}) : matchConcurrency(options?.concurrency, () => mapEffectSequential(self2, identity), (n2) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mapOutEffectPar(identity, n2), mapOut(of2)))));
var flattenExitOption = (self2) => {
  const processChunk = (chunk5, cont) => {
    const [toEmit, rest] = pipe(chunk5, splitWhere((exit4) => !isSuccess2(exit4)));
    const next = pipe(head2(rest), match2({
      onNone: () => cont,
      onSome: match9({
        onFailure: (cause3) => match2(flipCauseOption2(cause3), {
          onNone: () => void_5,
          onSome: failCause10
        }),
        onSuccess: () => void_5
      })
    }));
    return pipe(write(pipe(toEmit, filterMap2((exit4) => isSuccess2(exit4) ? some2(exit4.value) : none2()))), flatMap13(() => next));
  };
  const process2 = readWithCause({
    onInput: (chunk5) => processChunk(chunk5, process2),
    onFailure: (cause3) => failCause10(cause3),
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(process2)));
};
var flattenIterables = (self2) => pipe(self2, map23(fromIterable2), flattenChunks);
var flattenTake = (self2) => flattenChunks(flattenExitOption(pipe(self2, map23((take9) => take9.exit))));
var forever5 = (self2) => new StreamImpl(repeated(toChannel2(self2)));
var fromAsyncIterable = (iterable, onError7) => pipe(acquireRelease2(sync4(() => iterable[Symbol.asyncIterator]()), (iterator) => iterator.return ? promise2(async () => iterator.return()) : _void), map16((iterator) => repeatEffectOption(pipe(tryPromise2({
  try: async () => iterator.next(),
  catch: (reason) => some2(onError7(reason))
}), flatMap11((result) => result.done ? fail9(none2()) : succeed8(result.value))))), unwrapScoped4);
var fromChannel2 = (channel) => new StreamImpl(channel);
var toChannel2 = (stream) => {
  if ("channel" in stream) {
    return stream.channel;
  } else if (isEffect2(stream)) {
    return toChannel2(fromEffect7(stream));
  } else {
    throw new TypeError(`Expected a Stream.`);
  }
};
var fromChunk = (chunk5) => new StreamImpl(isEmpty(chunk5) ? void_5 : write(chunk5));
var fromChunkPubSub = (pubsub, options) => {
  if (options?.scoped) {
    const effect4 = map16(subscribe2(pubsub), fromChunkQueue);
    return options.shutdown ? map16(effect4, ensuring6(shutdown4(pubsub))) : effect4;
  }
  const stream = flatMap16(scoped5(subscribe2(pubsub)), fromChunkQueue);
  return options?.shutdown ? ensuring6(stream, shutdown4(pubsub)) : stream;
};
var fromChunkQueue = (queue, options) => pipe(take3(queue), catchAllCause3((cause3) => pipe(isShutdown2(queue), flatMap11((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause12(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring6(shutdown2(queue)) : identity);
var fromChunks = (...chunks3) => pipe(fromIterable11(chunks3), flatMap16(fromChunk));
var fromEffect7 = (effect4) => pipe(effect4, mapError3(some2), fromEffectOption);
var fromEffectOption = (effect4) => new StreamImpl(unwrap3(match12(effect4, {
  onFailure: match2({
    onNone: () => void_5,
    onSome: fail13
  }),
  onSuccess: (a2) => write(of2(a2))
})));
var fromPubSub = (pubsub, options) => {
  const maxChunkSize = options?.maxChunkSize ?? DefaultChunkSize;
  if (options?.scoped) {
    const effect4 = map16(subscribe2(pubsub), (queue) => fromQueue2(queue, {
      maxChunkSize,
      shutdown: true
    }));
    return options.shutdown ? map16(effect4, ensuring6(shutdown4(pubsub))) : effect4;
  }
  const stream = flatMap16(scoped5(subscribe2(pubsub)), (queue) => fromQueue2(queue, {
    maxChunkSize
  }));
  return options?.shutdown ? ensuring6(stream, shutdown4(pubsub)) : stream;
};
var fromTPubSub = (pubsub) => {
  return unwrapScoped4(map16(subscribeScoped2(pubsub), (queue) => fromTQueue(queue)));
};
var fromIterable11 = (iterable) => suspend12(() => isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]()));
var fromIterableEffect = (effect4) => pipe(effect4, map16(fromIterable11), unwrap4);
var fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {
  return pipe(sync4(() => {
    let builder = [];
    const loop3 = (iterator2) => pipe(sync4(() => {
      let next = iterator2.next();
      if (maxChunkSize === 1) {
        if (next.done) {
          return void_5;
        }
        return pipe(write(of2(next.value)), flatMap13(() => loop3(iterator2)));
      }
      builder = [];
      let count5 = 0;
      while (next.done === false) {
        builder.push(next.value);
        count5 = count5 + 1;
        if (count5 >= maxChunkSize) {
          break;
        }
        next = iterator2.next();
      }
      if (count5 > 0) {
        return pipe(write(unsafeFromArray(builder)), flatMap13(() => loop3(iterator2)));
      }
      return void_5;
    }), unwrap3);
    return new StreamImpl(loop3(iterator));
  }), unwrap4);
};
var fromPull2 = (effect4) => pipe(effect4, map16(repeatEffectChunkOption), unwrapScoped4);
var fromQueue2 = (queue, options) => pipe(takeBetween2(queue, 1, options?.maxChunkSize ?? DefaultChunkSize), catchAllCause3((cause3) => pipe(isShutdown2(queue), flatMap11((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause12(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring6(shutdown2(queue)) : identity);
var fromTQueue = (queue) => pipe(take5(queue), map16(of2), catchAllCause3((cause3) => pipe(isShutdown6(queue), flatMap11((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause12(cause3)))), repeatEffectChunkOption);
var fromSchedule = (schedule4) => pipe(driver2(schedule4), map16((driver3) => repeatEffectOption(driver3.next(void 0))), unwrap4);
var fromReadableStream = (...args2) => {
  const evaluate3 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError7 = args2.length === 1 ? args2[0].onError : args2[1];
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped4(map16(acquireRelease2(sync4(() => evaluate3().getReader()), (reader) => releaseLockOnEnd ? sync4(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => repeatEffectOption(flatMap11(tryPromise2({
    try: () => reader.read(),
    catch: (reason) => some2(onError7(reason))
  }), ({
    done: done11,
    value
  }) => done11 ? fail9(none2()) : succeed8(value)))));
};
var fromReadableStreamByob = (...args2) => {
  const evaluate3 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError7 = args2.length === 1 ? args2[0].onError : args2[1];
  const allocSize = (args2.length === 1 ? args2[0].bufferSize : args2[2]) ?? 4096;
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped4(map16(acquireRelease2(sync4(() => evaluate3().getReader({
    mode: "byob"
  })), (reader) => releaseLockOnEnd ? sync4(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => catchAll7(forever5(readChunkStreamByobReader(reader, onError7, allocSize)), (error4) => error4 === EOF ? empty31 : fail17(error4))));
};
var EOF = /* @__PURE__ */ Symbol.for("effect/Stream/EOF");
var readChunkStreamByobReader = (reader, onError7, size16) => {
  const buffer4 = new ArrayBuffer(size16);
  return paginateEffect(0, (offset) => flatMap11(tryPromise2({
    try: () => reader.read(new Uint8Array(buffer4, offset, buffer4.byteLength - offset)),
    catch: (reason) => onError7(reason)
  }), ({
    done: done11,
    value
  }) => {
    if (done11) {
      return fail9(EOF);
    }
    const newOffset = offset + value.byteLength;
    return succeed8([value, newOffset >= buffer4.byteLength ? none2() : some2(newOffset)]);
  }));
};
var groupAdjacentBy = /* @__PURE__ */ dual(2, (self2, f2) => {
  const groupAdjacentByChunk = (state, chunk5) => {
    if (isEmpty(chunk5)) {
      return [state, empty2()];
    }
    const builder = [];
    let from = 0;
    let until = 0;
    let key = void 0;
    let previousChunk = empty2();
    switch (state._tag) {
      case "Some": {
        const tuple3 = state.value;
        key = tuple3[0];
        let loop3 = true;
        while (loop3 && until < chunk5.length) {
          const input2 = unsafeGet2(chunk5, until);
          const updatedKey = f2(input2);
          if (!equals(key, updatedKey)) {
            const previousChunk2 = tuple3[1];
            const additionalChunk = unsafeFromArray(Array.from(chunk5).slice(from, until));
            const group3 = appendAll2(previousChunk2, additionalChunk);
            builder.push([key, group3]);
            key = updatedKey;
            from = until;
            loop3 = false;
          }
          until = until + 1;
        }
        if (loop3) {
          previousChunk = tuple3[1];
        }
        break;
      }
      case "None": {
        key = f2(unsafeGet2(chunk5, until));
        until = until + 1;
        break;
      }
    }
    while (until < chunk5.length) {
      const input2 = unsafeGet2(chunk5, until);
      const updatedKey = f2(input2);
      if (!equals(key, updatedKey)) {
        builder.push([key, unsafeFromArray(Array.from(chunk5).slice(from, until))]);
        key = updatedKey;
        from = until;
      }
      until = until + 1;
    }
    const nonEmptyChunk = appendAll2(previousChunk, unsafeFromArray(Array.from(chunk5).slice(from, until)));
    const output = unsafeFromArray(builder);
    return [some2([key, nonEmptyChunk]), output];
  };
  const groupAdjacent = (state) => readWithCause({
    onInput: (input2) => {
      const [updatedState, output] = groupAdjacentByChunk(state, input2);
      return isEmpty(output) ? groupAdjacent(updatedState) : flatMap13(write(output), () => groupAdjacent(updatedState));
    },
    onFailure: (cause3) => match2(state, {
      onNone: () => failCause10(cause3),
      onSome: (output) => flatMap13(write(of2(output)), () => failCause10(cause3))
    }),
    onDone: (done11) => match2(state, {
      onNone: () => succeedNow(done11),
      onSome: (output) => flatMap13(write(of2(output)), () => succeedNow(done11))
    })
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self2), groupAdjacent(none2())));
});
var grouped = /* @__PURE__ */ dual(2, (self2, chunkSize) => pipe(self2, rechunk(chunkSize), chunks));
var groupedWithin = /* @__PURE__ */ dual(3, (self2, chunkSize, duration4) => aggregateWithin(self2, collectAllN(chunkSize), spaced2(duration4)));
var haltWhen = /* @__PURE__ */ dual(2, (self2, effect4) => {
  const writer = (fiber) => pipe(poll3(fiber), map16(match2({
    onNone: () => readWith({
      onInput: (input2) => flatMap13(write(input2), () => writer(fiber)),
      onFailure: fail13,
      onDone: () => void_5
    }),
    onSome: match9({
      onFailure: failCause10,
      onSuccess: () => void_5
    })
  })), unwrap3);
  return new StreamImpl(unwrapScopedWith((scope5) => effect4.pipe(forkIn2(scope5), map16((fiber) => toChannel2(self2).pipe(pipeTo(writer(fiber)))))));
});
var haltAfter = /* @__PURE__ */ dual(2, (self2, duration4) => pipe(self2, haltWhen(sleep2(duration4))));
var haltWhenDeferred = /* @__PURE__ */ dual(2, (self2, deferred2) => {
  const writer = pipe(poll(deferred2), map16(match2({
    onNone: () => readWith({
      onInput: (input2) => pipe(write(input2), flatMap13(() => writer)),
      onFailure: fail13,
      onDone: () => void_5
    }),
    onSome: (effect4) => unwrap3(match12(effect4, {
      onFailure: fail13,
      onSuccess: () => void_5
    }))
  })), unwrap3);
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer)));
});
var identityStream = () => new StreamImpl(identityChannel());
var interleave = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, interleaveWith(that, forever5(make52(true, false)))));
var interleaveWith = /* @__PURE__ */ dual(3, (self2, that, decider) => {
  const producer = (handoff) => readWithCause({
    onInput: (value) => flatMap13(fromEffect4(offer5(handoff, of5(value))), () => producer(handoff)),
    onFailure: (cause3) => fromEffect4(offer5(handoff, failCause11(cause3))),
    onDone: () => fromEffect4(offer5(handoff, end4))
  });
  return new StreamImpl(unwrapScopedWith((scope5) => pipe(make51(), zip5(make51()), tap3(([left3]) => toChannel2(self2).pipe(concatMap(writeChunk), pipeTo(producer(left3)), runIn(scope5), forkIn2(scope5))), tap3(([_2, right3]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3)), runIn(scope5), forkIn2(scope5))), map16(([left3, right3]) => {
    const process2 = (leftDone, rightDone) => readWithCause({
      onInput: (bool) => {
        if (bool && !leftDone) {
          return pipe(fromEffect4(take6(left3)), flatMap13(match17({
            onEnd: () => rightDone ? void_5 : process2(true, rightDone),
            onFailure: failCause10,
            onSuccess: (chunk5) => pipe(write(chunk5), flatMap13(() => process2(leftDone, rightDone)))
          })));
        }
        if (!bool && !rightDone) {
          return pipe(fromEffect4(take6(right3)), flatMap13(match17({
            onEnd: () => leftDone ? void_5 : process2(leftDone, true),
            onFailure: failCause10,
            onSuccess: (chunk5) => pipe(write(chunk5), flatMap13(() => process2(leftDone, rightDone)))
          })));
        }
        return process2(leftDone, rightDone);
      },
      onFailure: failCause10,
      onDone: () => void_5
    });
    return pipe(toChannel2(decider), concatMap(writeChunk), pipeTo(process2(false, false)));
  }))));
});
var intersperse = /* @__PURE__ */ dual(2, (self2, element) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(suspend8(() => {
  const writer = (isFirst) => readWithCause({
    onInput: (chunk5) => {
      const builder = [];
      let flagResult = isFirst;
      for (const output of chunk5) {
        if (flagResult) {
          flagResult = false;
          builder.push(output);
        } else {
          builder.push(element);
          builder.push(output);
        }
      }
      return pipe(write(unsafeFromArray(builder)), flatMap13(() => writer(flagResult)));
    },
    onFailure: failCause10,
    onDone: () => void_5
  });
  return writer(true);
})))));
var intersperseAffixes = /* @__PURE__ */ dual(2, (self2, {
  end: end6,
  middle,
  start: start3
}) => pipe(make52(start3), concat2(pipe(self2, intersperse(middle))), concat2(make52(end6))));
var interruptAfter = /* @__PURE__ */ dual(2, (self2, duration4) => pipe(self2, interruptWhen2(sleep2(duration4))));
var interruptWhen2 = /* @__PURE__ */ dual(2, (self2, effect4) => new StreamImpl(pipe(toChannel2(self2), interruptWhen(effect4))));
var interruptWhenDeferred2 = /* @__PURE__ */ dual(2, (self2, deferred2) => new StreamImpl(pipe(toChannel2(self2), interruptWhenDeferred(deferred2))));
var iterate3 = (value, next) => unfold3(value, (a2) => some2([a2, next(a2)]));
var make52 = (...as10) => fromIterable11(as10);
var map23 = /* @__PURE__ */ dual(2, (self2, f2) => new StreamImpl(pipe(toChannel2(self2), mapOut(map3(f2)))));
var mapAccum5 = /* @__PURE__ */ dual(3, (self2, s2, f2) => {
  const accumulator = (s3) => readWith({
    onInput: (input2) => {
      const [nextS, chunk5] = mapAccum2(input2, s3, f2);
      return flatMap13(write(chunk5), () => accumulator(nextS));
    },
    onFailure: fail13,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(accumulator(s2))));
});
var mapAccumEffect = /* @__PURE__ */ dual(3, (self2, s2, f2) => suspend12(() => {
  const accumulator = (s3) => readWith({
    onInput: (input2) => pipe(suspend4(() => {
      const outputs = [];
      const emit2 = (output) => sync4(() => {
        outputs.push(output);
      });
      return pipe(input2, reduce11(s3, (s4, a2) => pipe(f2(s4, a2), flatMap11(([s5, a3]) => pipe(emit2(a3), as4(s5))))), match12({
        onFailure: (error4) => {
          if (outputs.length !== 0) {
            return zipRight5(write(unsafeFromArray(outputs)), fail13(error4));
          }
          return fail13(error4);
        },
        onSuccess: (s4) => flatMap13(write(unsafeFromArray(outputs)), () => accumulator(s4))
      }));
    }), unwrap3),
    onFailure: fail13,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(accumulator(s2))));
}));
var mapBoth5 = /* @__PURE__ */ dual(2, (self2, options) => pipe(self2, mapError6(options.onFailure), map23(options.onSuccess)));
var mapChunks = /* @__PURE__ */ dual(2, (self2, f2) => new StreamImpl(pipe(toChannel2(self2), mapOut(f2))));
var mapChunksEffect = /* @__PURE__ */ dual(2, (self2, f2) => new StreamImpl(pipe(toChannel2(self2), mapOutEffect(f2))));
var mapConcat = /* @__PURE__ */ dual(2, (self2, f2) => pipe(self2, mapConcatChunk((a2) => fromIterable2(f2(a2)))));
var mapConcatChunk = /* @__PURE__ */ dual(2, (self2, f2) => pipe(self2, mapChunks(flatMap3(f2))));
var mapConcatChunkEffect = /* @__PURE__ */ dual(2, (self2, f2) => pipe(self2, mapEffectSequential(f2), mapConcatChunk(identity)));
var mapConcatEffect = /* @__PURE__ */ dual(2, (self2, f2) => pipe(self2, mapEffectSequential((a2) => pipe(f2(a2), map16(fromIterable2))), mapConcatChunk(identity)));
var mapEffectSequential = /* @__PURE__ */ dual(2, (self2, f2) => {
  const loop3 = (iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (elem) => loop3(elem[Symbol.iterator]()),
        onFailure: failCause10,
        onDone: succeed13
      });
    } else {
      const value = next.value;
      return unwrap3(map16(f2(value), (a2) => flatMap13(write(of2(a2)), () => loop3(iterator))));
    }
  };
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(suspend8(() => loop3(empty2()[Symbol.iterator]())))));
});
var mapEffectPar = /* @__PURE__ */ dual(3, (self2, n2, f2) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mapOutEffectPar(f2, n2), mapOut(of2))));
var mapError6 = /* @__PURE__ */ dual(2, (self2, f2) => new StreamImpl(pipe(toChannel2(self2), mapError5(f2))));
var mapErrorCause4 = /* @__PURE__ */ dual(2, (self2, f2) => new StreamImpl(pipe(toChannel2(self2), mapErrorCause3(f2))));
var merge9 = /* @__PURE__ */ dual((args2) => isStream(args2[1]), (self2, that, options) => mergeWith3(self2, that, {
  onSelf: identity,
  onOther: identity,
  haltStrategy: options?.haltStrategy
}));
var mergeAll7 = /* @__PURE__ */ dual((args2) => Symbol.iterator in args2[0], (streams, options) => flatten12(fromIterable11(streams), options));
var mergeWithTag = /* @__PURE__ */ dual(2, (streams, options) => {
  const keys5 = Object.keys(streams);
  const values3 = keys5.map((key) => streams[key].pipe(map23((value) => ({
    _tag: key,
    value
  }))));
  return mergeAll7(values3, options);
});
var mergeEither = /* @__PURE__ */ dual(2, (self2, that) => mergeWith3(self2, that, {
  onSelf: left2,
  onOther: right2
}));
var mergeLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, merge9(drain3(right3))));
var mergeRight = /* @__PURE__ */ dual(2, (left3, right3) => pipe(drain3(left3), merge9(right3)));
var mergeWith3 = /* @__PURE__ */ dual(3, (self2, other, options) => {
  const strategy = options.haltStrategy ? fromInput2(options.haltStrategy) : Both2;
  const handler = (terminate) => (exit4) => terminate || !isSuccess2(exit4) ? (
    // TODO: remove
    Done4(suspend4(() => exit4))
  ) : Await2((exit5) => suspend4(() => exit5));
  return new StreamImpl(mergeWith2(toChannel2(map23(self2, options.onSelf)), {
    other: toChannel2(map23(other, options.onOther)),
    onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
    onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
  }));
});
var mkString2 = (self2) => run3(self2, mkString);
var never4 = /* @__PURE__ */ fromEffect7(never3);
var onEnd = /* @__PURE__ */ dual(2, (self2, effect4) => concat2(self2, drain3(fromEffect7(effect4))));
var onError3 = /* @__PURE__ */ dual(2, (self2, cleanup) => pipe(self2, catchAllCause6((cause3) => fromEffect7(pipe(cleanup(cause3), zipRight3(failCause8(cause3)))))));
var onDone = /* @__PURE__ */ dual(2, (self2, cleanup) => new StreamImpl(pipe(toChannel2(self2), ensuringWith((exit4) => isSuccess2(exit4) ? cleanup() : _void))));
var onStart = /* @__PURE__ */ dual(2, (self2, effect4) => unwrap4(as4(effect4, self2)));
var orDie5 = (self2) => pipe(self2, orDieWith4(identity));
var orDieWith4 = /* @__PURE__ */ dual(2, (self2, f2) => new StreamImpl(pipe(toChannel2(self2), orDieWith3(f2))));
var orElse11 = /* @__PURE__ */ dual(2, (self2, that) => new StreamImpl(pipe(toChannel2(self2), orElse10(() => toChannel2(that())))));
var orElseEither3 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, map23(left2), orElse11(() => pipe(that(), map23(right2)))));
var orElseFail3 = /* @__PURE__ */ dual(2, (self2, error4) => pipe(self2, orElse11(() => failSync7(error4))));
var orElseIfEmpty = /* @__PURE__ */ dual(2, (self2, element) => pipe(self2, orElseIfEmptyChunk(() => of2(element()))));
var orElseIfEmptyChunk = /* @__PURE__ */ dual(2, (self2, chunk5) => pipe(self2, orElseIfEmptyStream(() => new StreamImpl(write(chunk5())))));
var orElseIfEmptyStream = /* @__PURE__ */ dual(2, (self2, stream) => {
  const writer = readWith({
    onInput: (input2) => {
      if (isEmpty(input2)) {
        return suspend8(() => writer);
      }
      return pipe(write(input2), zipRight5(identityChannel()));
    },
    onFailure: fail13,
    onDone: () => suspend8(() => toChannel2(stream()))
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer)));
});
var orElseSucceed3 = /* @__PURE__ */ dual(2, (self2, value) => pipe(self2, orElse11(() => sync11(value))));
var paginate = (s2, f2) => paginateChunk(s2, (s3) => {
  const page = f2(s3);
  return [of2(page[0]), page[1]];
});
var paginateChunk = (s2, f2) => {
  const loop3 = (s3) => {
    const page = f2(s3);
    return match2(page[1], {
      onNone: () => zipRight5(write(page[0]), void_5),
      onSome: (s4) => flatMap13(write(page[0]), () => loop3(s4))
    });
  };
  return new StreamImpl(suspend8(() => loop3(s2)));
};
var paginateChunkEffect = (s2, f2) => {
  const loop3 = (s3) => unwrap3(map16(f2(s3), ([chunk5, option5]) => match2(option5, {
    onNone: () => zipRight5(write(chunk5), void_5),
    onSome: (s4) => flatMap13(write(chunk5), () => loop3(s4))
  })));
  return new StreamImpl(suspend8(() => loop3(s2)));
};
var paginateEffect = (s2, f2) => paginateChunkEffect(s2, (s3) => pipe(f2(s3), map16(([a2, s4]) => [of2(a2), s4])));
var peel = /* @__PURE__ */ dual(2, (self2, sink) => {
  const OP_EMIT5 = "Emit";
  const OP_HALT2 = "Halt";
  const OP_END2 = "End";
  return pipe(make23(), flatMap11((deferred2) => pipe(make51(), map16((handoff) => {
    const consumer = foldSink(collectLeftover(sink), {
      onFailure: (error4) => zipRight6(fromEffect6(fail3(deferred2, error4)), fail14(error4)),
      onSuccess: ([z2, leftovers]) => {
        const loop3 = readWithCause({
          onInput: (elements) => flatMap13(fromEffect4(offer5(handoff, {
            _tag: OP_EMIT5,
            elements
          })), () => loop3),
          onFailure: (cause3) => zipRight5(fromEffect4(offer5(handoff, {
            _tag: OP_HALT2,
            cause: cause3
          })), failCause10(cause3)),
          onDone: (_2) => zipRight5(fromEffect4(offer5(handoff, {
            _tag: OP_END2
          })), void_5)
        });
        return fromChannel(pipe(fromEffect4(succeed2(deferred2, z2)), zipRight5(fromEffect4(pipe(handoff, offer5({
          _tag: OP_EMIT5,
          elements: leftovers
        })))), zipRight5(loop3)));
      }
    });
    const producer = pipe(take6(handoff), map16((signal) => {
      switch (signal._tag) {
        case OP_EMIT5: {
          return pipe(write(signal.elements), flatMap13(() => producer));
        }
        case OP_HALT2: {
          return failCause10(signal.cause);
        }
        case OP_END2: {
          return void_5;
        }
      }
    }), unwrap3);
    return pipe(self2, tapErrorCause5((cause3) => failCause2(deferred2, cause3)), run3(consumer), forkScoped2, zipRight3(_await(deferred2)), map16((z2) => [z2, new StreamImpl(producer)]));
  }))), flatten8);
});
var partition5 = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self2, predicate, options) => partitionEither(self2, (a2) => succeed8(predicate(a2) ? right2(a2) : left2(a2)), options));
var partitionEither = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self2, predicate, options) => pipe(mapEffectSequential(self2, predicate), distributedWith({
  size: 2,
  maximumLag: options?.bufferSize ?? 16,
  decide: match({
    onLeft: () => succeed8((n2) => n2 === 0),
    onRight: () => succeed8((n2) => n2 === 1)
  })
}), flatMap11(([queue1, queue2]) => succeed8([filterMap6(flattenExitOption(fromQueue2(queue1, {
  shutdown: true
})), (_2) => match(_2, {
  onLeft: some2,
  onRight: none2
})), filterMap6(flattenExitOption(fromQueue2(queue2, {
  shutdown: true
})), (_2) => match(_2, {
  onLeft: none2,
  onRight: some2
}))]))));
var pipeThrough = /* @__PURE__ */ dual(2, (self2, sink) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(toChannel(sink)))));
var pipeThroughChannel = /* @__PURE__ */ dual(2, (self2, channel) => new StreamImpl(pipeTo(toChannel2(self2), channel)));
var pipeThroughChannelOrFail = /* @__PURE__ */ dual(2, (self2, chan) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(chan))));
var prepend4 = /* @__PURE__ */ dual(2, (self2, values3) => new StreamImpl(zipRight5(write(values3), toChannel2(self2))));
var provideContext5 = /* @__PURE__ */ dual(2, (self2, context8) => new StreamImpl(pipe(toChannel2(self2), provideContext4(context8))));
var provideLayer = /* @__PURE__ */ dual(2, (self2, layer) => new StreamImpl(unwrapScopedWith((scope5) => buildWithScope2(layer, scope5).pipe(map16((env2) => pipe(toChannel2(self2), provideContext4(env2)))))));
var provideService5 = /* @__PURE__ */ dual(3, (self2, tag, resource) => provideServiceEffect3(self2, tag, succeed8(resource)));
var provideServiceEffect3 = /* @__PURE__ */ dual(3, (self2, tag, effect4) => provideServiceStream(self2, tag, fromEffect7(effect4)));
var provideServiceStream = /* @__PURE__ */ dual(3, (self2, tag, stream) => contextWithStream((env2) => flatMap16(stream, (service3) => pipe(self2, provideContext5(add2(env2, tag, service3))))));
var mapInputContext5 = /* @__PURE__ */ dual(2, (self2, f2) => contextWithStream((env2) => pipe(self2, provideContext5(f2(env2)))));
var provideSomeLayer2 = /* @__PURE__ */ dual(2, (self2, layer) => (
  // @ts-expect-error
  pipe(self2, provideLayer(pipe(context4(), merge8(layer))))
));
var range2 = (min3, max5, chunkSize = DefaultChunkSize) => suspend12(() => {
  if (min3 > max5) {
    return empty31;
  }
  const go = (min4, max6, chunkSize2) => {
    const remaining = max6 - min4 + 1;
    if (remaining > chunkSize2) {
      return pipe(write(range(min4, min4 + chunkSize2 - 1)), flatMap13(() => go(min4 + chunkSize2, max6, chunkSize2)));
    }
    return write(range(min4, min4 + remaining - 1));
  };
  return new StreamImpl(go(min3, max5, chunkSize));
});
var race3 = /* @__PURE__ */ dual(2, (left3, right3) => raceAll3(left3, right3));
var raceAll3 = (...streams) => make23().pipe(map16((halt2) => {
  let winner = null;
  return mergeAll7(streams.map((stream, index) => stream.pipe(takeWhile4(() => {
    if (winner === null) {
      winner = index;
      unsafeDone(halt2, void_3);
      return true;
    }
    return winner === index;
  }), interruptWhen2(_await(halt2).pipe(flatMap11(() => winner === index ? never3 : _void))))), {
    concurrency: streams.length
  });
}), unwrap4);
var rechunk = /* @__PURE__ */ dual(2, (self2, n2) => suspend12(() => {
  const target = Math.max(n2, 1);
  const process2 = rechunkProcess(new StreamRechunker(target), target);
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(process2)));
}));
var rechunkProcess = (rechunker, target) => readWithCause({
  onInput: (chunk5) => {
    if (chunk5.length === target && rechunker.isEmpty()) {
      return flatMap13(write(chunk5), () => rechunkProcess(rechunker, target));
    }
    if (chunk5.length > 0) {
      const chunks3 = [];
      let result = void 0;
      let index = 0;
      while (index < chunk5.length) {
        while (index < chunk5.length && result === void 0) {
          result = rechunker.write(pipe(chunk5, unsafeGet2(index)));
          index = index + 1;
        }
        if (result !== void 0) {
          chunks3.push(result);
          result = void 0;
        }
      }
      return flatMap13(writeAll(...chunks3), () => rechunkProcess(rechunker, target));
    }
    return suspend8(() => rechunkProcess(rechunker, target));
  },
  onFailure: (cause3) => zipRight5(rechunker.emitIfNotEmpty(), failCause10(cause3)),
  onDone: () => rechunker.emitIfNotEmpty()
});
var StreamRechunker = class {
  n;
  builder = [];
  pos = 0;
  constructor(n2) {
    this.n = n2;
  }
  isEmpty() {
    return this.pos === 0;
  }
  write(elem) {
    this.builder.push(elem);
    this.pos += 1;
    if (this.pos === this.n) {
      const result = unsafeFromArray(this.builder);
      this.builder = [];
      this.pos = 0;
      return result;
    }
    return void 0;
  }
  emitIfNotEmpty() {
    if (this.pos !== 0) {
      return write(unsafeFromArray(this.builder));
    }
    return void_5;
  }
};
var refineOrDie = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, refineOrDieWith(pf, identity)));
var refineOrDieWith = /* @__PURE__ */ dual(3, (self2, pf, f2) => new StreamImpl(catchAll5(toChannel2(self2), (error4) => match2(pf(error4), {
  onNone: () => failCause10(die4(f2(error4))),
  onSome: fail13
}))));
var repeat4 = /* @__PURE__ */ dual(2, (self2, schedule4) => filterMap6(repeatEither(self2, schedule4), (_2) => match(_2, {
  onLeft: none2,
  onRight: some2
})));
var repeatEffect = (effect4) => repeatEffectOption(pipe(effect4, mapError3(some2)));
var repeatEffectChunk = (effect4) => repeatEffectChunkOption(pipe(effect4, mapError3(some2)));
var repeatEffectChunkOption = (effect4) => unfoldChunkEffect(effect4, (effect5) => pipe(map16(effect5, (chunk5) => some2([chunk5, effect5])), catchAll3(match2({
  onNone: () => succeed8(none2()),
  onSome: fail9
}))));
var repeatEffectOption = (effect4) => repeatEffectChunkOption(pipe(effect4, map16(of2)));
var repeatEither = /* @__PURE__ */ dual(2, (self2, schedule4) => repeatWith(self2, schedule4, {
  onElement: (a2) => right2(a2),
  onSchedule: left2
}));
var repeatElements = /* @__PURE__ */ dual(2, (self2, schedule4) => filterMap6(repeatElementsWith(self2, schedule4, {
  onElement: (a2) => some2(a2),
  onSchedule: none2
}), identity));
var repeatElementsWith = /* @__PURE__ */ dual(3, (self2, schedule4, options) => {
  const driver3 = pipe(driver2(schedule4), map16((driver4) => {
    const feed = (input2) => match2(head2(input2), {
      onNone: () => loop3,
      onSome: (a2) => zipRight5(write(of2(options.onElement(a2))), step4(pipe(input2, drop2(1)), a2))
    });
    const step4 = (input2, a2) => {
      const advance = pipe(driver4.next(a2), as4(pipe(write(of2(options.onElement(a2))), flatMap13(() => step4(input2, a2)))));
      const reset = pipe(driver4.last, orDie3, flatMap11((b) => pipe(driver4.reset, map16(() => pipe(write(of2(options.onSchedule(b))), zipRight5(feed(input2)))))));
      return pipe(advance, orElse6(() => reset), unwrap3);
    };
    const loop3 = readWith({
      onInput: feed,
      onFailure: fail13,
      onDone: () => void_5
    });
    return loop3;
  }), unwrap3);
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(driver3)));
});
var repeatValue = (value) => new StreamImpl(repeated(write(of2(value))));
var repeatWith = /* @__PURE__ */ dual(3, (self2, schedule4, options) => {
  return pipe(driver2(schedule4), map16((driver3) => {
    const scheduleOutput = pipe(driver3.last, orDie3, map16(options.onSchedule));
    const process2 = pipe(self2, map23(options.onElement), toChannel2);
    const loop3 = unwrap3(match12(driver3.next(void 0), {
      onFailure: () => void_5,
      onSuccess: () => pipe(process2, zipRight5(pipe(scheduleOutput, map16((c) => pipe(write(of2(c)), flatMap13(() => loop3))), unwrap3)))
    }));
    return new StreamImpl(pipe(process2, zipRight5(loop3)));
  }), unwrap4);
});
var repeatWithSchedule = (value, schedule4) => repeatEffectWithSchedule(succeed8(value), schedule4);
var repeatEffectWithSchedule = (effect4, schedule4) => flatMap16(fromEffect7(zip5(effect4, driver2(schedule4))), ([a2, driver3]) => concat2(succeed16(a2), unfoldEffect(a2, (s2) => matchEffect2(driver3.next(s2), {
  onFailure: succeed8,
  onSuccess: () => map16(effect4, (nextA) => some2([nextA, nextA]))
}))));
var retry6 = /* @__PURE__ */ dual(2, (self2, schedule4) => driver2(schedule4).pipe(map16((driver3) => {
  const loop3 = toChannel2(self2).pipe(mapOutEffect((out) => as4(driver3.reset, out)), catchAll5((error4) => driver3.next(error4).pipe(match12({
    onFailure: () => fail13(error4),
    onSuccess: () => loop3
  }), unwrap3)));
  return loop3;
}), unwrap3, fromChannel2));
var run3 = /* @__PURE__ */ dual(2, (self2, sink) => toChannel2(self2).pipe(pipeToOrFail(toChannel(sink)), runDrain));
var runCollect = (self2) => run3(self2, collectAll());
var runCount = (self2) => run3(self2, count3);
var runDrain2 = (self2) => run3(self2, drain2);
var runFold = /* @__PURE__ */ dual(3, (self2, s2, f2) => runFoldWhile(self2, s2, constTrue, f2));
var runFoldEffect = /* @__PURE__ */ dual(3, (self2, s2, f2) => runFoldWhileEffect(self2, s2, constTrue, f2));
var runFoldScoped = /* @__PURE__ */ dual(3, (self2, s2, f2) => pipe(self2, runFoldWhileScoped(s2, constTrue, f2)));
var runFoldScopedEffect = /* @__PURE__ */ dual(3, (self2, s2, f2) => pipe(self2, runFoldWhileScopedEffect(s2, constTrue, f2)));
var runFoldWhile = /* @__PURE__ */ dual(4, (self2, s2, cont, f2) => run3(self2, fold(s2, cont, f2)));
var runFoldWhileEffect = /* @__PURE__ */ dual(4, (self2, s2, cont, f2) => run3(self2, foldEffect(s2, cont, f2)));
var runFoldWhileScoped = /* @__PURE__ */ dual(4, (self2, s2, cont, f2) => pipe(self2, runScoped2(fold(s2, cont, f2))));
var runFoldWhileScopedEffect = /* @__PURE__ */ dual(4, (self2, s2, cont, f2) => pipe(self2, runScoped2(foldEffect(s2, cont, f2))));
var runForEach = /* @__PURE__ */ dual(2, (self2, f2) => run3(self2, forEach10(f2)));
var runForEachChunk = /* @__PURE__ */ dual(2, (self2, f2) => run3(self2, forEachChunk(f2)));
var runForEachChunkScoped = /* @__PURE__ */ dual(2, (self2, f2) => pipe(self2, runScoped2(forEachChunk(f2))));
var runForEachScoped = /* @__PURE__ */ dual(2, (self2, f2) => pipe(self2, runScoped2(forEach10(f2))));
var runForEachWhile = /* @__PURE__ */ dual(2, (self2, f2) => run3(self2, forEachWhile(f2)));
var runForEachWhileScoped = /* @__PURE__ */ dual(2, (self2, f2) => pipe(self2, runScoped2(forEachWhile(f2))));
var runHead = (self2) => run3(self2, head5());
var runIntoPubSub = /* @__PURE__ */ dual(2, (self2, pubsub) => pipe(self2, runIntoQueue(pubsub)));
var runIntoPubSubScoped = /* @__PURE__ */ dual(2, (self2, pubsub) => pipe(self2, runIntoQueueScoped(pubsub)));
var runIntoQueue = /* @__PURE__ */ dual(2, (self2, queue) => pipe(self2, runIntoQueueScoped(queue), scoped2));
var runIntoQueueElementsScoped = /* @__PURE__ */ dual(2, (self2, queue) => {
  const writer = readWithCause({
    onInput: (input2) => flatMap13(fromEffect4(offerAll3(queue, map3(input2, succeed4))), () => writer),
    onFailure: (cause3) => fromEffect4(offer3(queue, failCause4(map12(cause3, some2)))),
    onDone: () => fromEffect4(offer3(queue, fail4(none2())))
  });
  return pipe(pipeTo(toChannel2(self2), writer), drain, runScoped, asVoid2);
});
var runIntoQueueScoped = /* @__PURE__ */ dual(2, (self2, queue) => {
  const writer = readWithCause({
    onInput: (input2) => flatMap13(write(chunk4(input2)), () => writer),
    onFailure: (cause3) => write(failCause11(cause3)),
    onDone: () => write(end4)
  });
  return pipe(pipeTo(toChannel2(self2), writer), mapOutEffect((take9) => offer3(queue, take9)), drain, runScoped, asVoid2);
});
var runLast = (self2) => run3(self2, last4());
var runScoped2 = /* @__PURE__ */ dual(2, (self2, sink) => pipe(toChannel2(self2), pipeToOrFail(toChannel(sink)), drain, runScoped));
var runSum = (self2) => run3(self2, sum2);
var scan = /* @__PURE__ */ dual(3, (self2, s2, f2) => pipe(self2, scanEffect(s2, (s3, a2) => succeed8(f2(s3, a2)))));
var scanReduce = /* @__PURE__ */ dual(2, (self2, f2) => pipe(self2, scanReduceEffect((a2, a3) => succeed8(f2(a2, a3)))));
var scanReduceEffect = /* @__PURE__ */ dual(2, (self2, f2) => pipe(self2, mapAccumEffect(none2(), (option5, a2) => {
  switch (option5._tag) {
    case "None": {
      return succeed8([some2(a2), a2]);
    }
    case "Some": {
      return pipe(f2(option5.value, a2), map16((b) => [some2(b), b]));
    }
  }
})));
var schedule2 = /* @__PURE__ */ dual(2, (self2, schedule4) => filterMap6(scheduleWith(self2, schedule4, {
  onElement: some2,
  onSchedule: none2
}), identity));
var scheduleWith = /* @__PURE__ */ dual(3, (self2, schedule4, options) => {
  const loop3 = (driver3, iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (chunk5) => loop3(driver3, chunk5[Symbol.iterator]()),
        onFailure: failCause10,
        onDone: succeedNow
      });
    }
    return unwrap3(matchEffect2(driver3.next(next.value), {
      onFailure: () => pipe(driver3.last, orDie3, map16((b) => pipe(write(make5(options.onElement(next.value), options.onSchedule(b))), flatMap13(() => loop3(driver3, iterator)))), zipLeft2(driver3.reset)),
      onSuccess: () => succeed8(pipe(write(of2(options.onElement(next.value))), flatMap13(() => loop3(driver3, iterator))))
    }));
  };
  return new StreamImpl(pipe(fromEffect4(driver2(schedule4)), flatMap13((driver3) => pipe(toChannel2(self2), pipeTo(loop3(driver3, empty2()[Symbol.iterator]()))))));
});
var scanEffect = /* @__PURE__ */ dual(3, (self2, s2, f2) => new StreamImpl(pipe(write(of2(s2)), flatMap13(() => toChannel2(pipe(self2, mapAccumEffect(s2, (s3, a2) => pipe(f2(s3, a2), map16((s4) => [s4, s4])))))))));
var scoped5 = (effect4) => new StreamImpl(ensuring4(scoped4(pipe(effect4, map16(of2))), _void));
var scopedWith4 = (f2) => new StreamImpl(scopedWith3((scope5) => f2(scope5).pipe(map16(of2))));
var some5 = (self2) => pipe(self2, mapError6(some2), someOrFail(() => none2()));
var someOrElse = /* @__PURE__ */ dual(2, (self2, fallback) => pipe(self2, map23(getOrElse(fallback))));
var someOrFail = /* @__PURE__ */ dual(2, (self2, error4) => mapEffectSequential(self2, match2({
  onNone: () => failSync3(error4),
  onSome: succeed8
})));
var sliding7 = /* @__PURE__ */ dual(2, (self2, chunkSize) => slidingSize(self2, chunkSize, 1));
var slidingSize = /* @__PURE__ */ dual(3, (self2, chunkSize, stepSize) => {
  if (chunkSize <= 0 || stepSize <= 0) {
    return die10(new IllegalArgumentException2("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
  }
  return new StreamImpl(suspend8(() => {
    const queue = new RingBuffer(chunkSize);
    const emitOnStreamEnd = (queueSize, channelEnd) => {
      if (queueSize < chunkSize) {
        const items = queue.toChunk();
        const result2 = isEmpty(items) ? empty2() : of2(items);
        return pipe(write(result2), flatMap13(() => channelEnd));
      }
      const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
      if (lastEmitIndex === queueSize) {
        return channelEnd;
      }
      const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
      const lastItems = pipe(queue.toChunk(), takeRight(leftovers));
      const result = isEmpty(lastItems) ? empty2() : of2(lastItems);
      return pipe(write(result), flatMap13(() => channelEnd));
    };
    const reader = (queueSize) => readWithCause({
      onInput: (input2) => flatMap13(write(filterMap2(input2, (element, index) => {
        queue.put(element);
        const currentIndex = queueSize + index + 1;
        if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
          return none2();
        }
        return some2(queue.toChunk());
      })), () => reader(queueSize + input2.length)),
      onFailure: (cause3) => emitOnStreamEnd(queueSize, failCause10(cause3)),
      onDone: () => emitOnStreamEnd(queueSize, void_5)
    });
    return pipe(toChannel2(self2), pipeTo(reader(0)));
  }));
});
var split = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const split3 = (leftovers, input2) => {
    const [chunk5, remaining] = pipe(leftovers, appendAll2(input2), splitWhere(predicate));
    if (isEmpty(chunk5) || isEmpty(remaining)) {
      return loop3(pipe(chunk5, appendAll2(pipe(remaining, drop2(1)))));
    }
    return pipe(write(of2(chunk5)), flatMap13(() => split3(empty2(), pipe(remaining, drop2(1)))));
  };
  const loop3 = (leftovers) => readWith({
    onInput: (input2) => split3(leftovers, input2),
    onFailure: fail13,
    onDone: () => {
      if (isEmpty(leftovers)) {
        return void_5;
      }
      if (isNone2(pipe(leftovers, findFirst3(predicate)))) {
        return zipRight5(write(of2(leftovers)), void_5);
      }
      return zipRight5(split3(empty2(), leftovers), void_5);
    }
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty2()))));
});
var splitOnChunk = /* @__PURE__ */ dual(2, (self2, delimiter) => {
  const next = (leftover, delimiterIndex) => readWithCause({
    onInput: (inputChunk) => {
      let buffer4;
      const [carry, delimiterCursor] = pipe(inputChunk, reduce2([pipe(leftover, getOrElse(() => empty2())), delimiterIndex], ([carry2, delimiterCursor2], a2) => {
        const concatenated = pipe(carry2, append2(a2));
        if (delimiterCursor2 < delimiter.length && equals(a2, pipe(delimiter, unsafeGet2(delimiterCursor2)))) {
          if (delimiterCursor2 + 1 === delimiter.length) {
            if (buffer4 === void 0) {
              buffer4 = [];
            }
            buffer4.push(pipe(concatenated, take(concatenated.length - delimiter.length)));
            return [empty2(), 0];
          }
          return [concatenated, delimiterCursor2 + 1];
        }
        return [concatenated, equals(a2, pipe(delimiter, unsafeGet2(0))) ? 1 : 0];
      }));
      const output = buffer4 === void 0 ? empty2() : unsafeFromArray(buffer4);
      return flatMap13(write(output), () => next(isNonEmpty(carry) ? some2(carry) : none2(), delimiterCursor));
    },
    onFailure: (cause3) => match2(leftover, {
      onNone: () => failCause10(cause3),
      onSome: (chunk5) => zipRight5(write(of2(chunk5)), failCause10(cause3))
    }),
    onDone: (done11) => match2(leftover, {
      onNone: () => succeed13(done11),
      onSome: (chunk5) => zipRight5(write(of2(chunk5)), succeed13(done11))
    })
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(next(none2(), 0))));
});
var splitLines2 = (self2) => pipeThroughChannel(self2, splitLines());
var succeed16 = (value) => fromChunk(of2(value));
var sync11 = (evaluate3) => suspend12(() => fromChunk(of2(evaluate3())));
var suspend12 = (stream) => new StreamImpl(suspend8(() => toChannel2(stream())));
var take7 = /* @__PURE__ */ dual(2, (self2, n2) => {
  if (!Number.isInteger(n2)) {
    return die10(new IllegalArgumentException2(`${n2} must be an integer`));
  }
  const loop3 = (n3) => readWith({
    onInput: (input2) => {
      const taken = pipe(input2, take(Math.min(n3, Number.POSITIVE_INFINITY)));
      const leftover = Math.max(0, n3 - taken.length);
      const more = leftover > 0;
      if (more) {
        return pipe(write(taken), flatMap13(() => loop3(leftover)));
      }
      return write(taken);
    },
    onFailure: fail13,
    onDone: succeed13
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(0 < n2 ? loop3(n2) : void_5)));
});
var takeRight2 = /* @__PURE__ */ dual(2, (self2, n2) => {
  if (n2 <= 0) {
    return empty31;
  }
  return new StreamImpl(pipe(succeed8(new RingBuffer(n2)), map16((queue) => {
    const reader = readWith({
      onInput: (input2) => {
        for (const element of input2) {
          queue.put(element);
        }
        return reader;
      },
      onFailure: fail13,
      onDone: () => pipe(write(queue.toChunk()), zipRight5(void_5))
    });
    return pipe(toChannel2(self2), pipeTo(reader));
  }), unwrap3));
});
var takeUntil3 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input2) => {
      const taken = pipe(input2, takeWhile((a2) => !predicate(a2)));
      const last6 = pipe(input2, drop2(taken.length), take(1));
      if (isEmpty(last6)) {
        return pipe(write(taken), flatMap13(() => loop3));
      }
      return write(pipe(taken, appendAll2(last6)));
    },
    onFailure: fail13,
    onDone: succeed13
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
});
var takeUntilEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = (iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (elem) => loop3(elem[Symbol.iterator]()),
        onFailure: failCause10,
        onDone: succeed13
      });
    }
    return pipe(predicate(next.value), map16((bool) => bool ? write(of2(next.value)) : pipe(write(of2(next.value)), flatMap13(() => loop3(iterator)))), unwrap3);
  };
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty2()[Symbol.iterator]()))));
});
var takeWhile4 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input2) => {
      const taken = pipe(input2, takeWhile(predicate));
      const more = taken.length === input2.length;
      if (more) {
        return pipe(write(taken), flatMap13(() => loop3));
      }
      return write(taken);
    },
    onFailure: fail13,
    onDone: succeed13
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
});
var tap6 = /* @__PURE__ */ dual(2, (self2, f2) => mapEffectSequential(self2, (a2) => as4(f2(a2), a2)));
var tapBoth3 = /* @__PURE__ */ dual(2, (self2, options) => pipe(self2, tapError5(options.onFailure), tap6(options.onSuccess)));
var tapError5 = /* @__PURE__ */ dual(2, (self2, f2) => catchAll7(self2, (error4) => fromEffect7(zipRight3(f2(error4), fail9(error4)))));
var tapErrorCause5 = /* @__PURE__ */ dual(2, (self2, f2) => {
  const loop3 = readWithCause({
    onInput: (chunk5) => flatMap13(write(chunk5), () => loop3),
    onFailure: (cause3) => fromEffect4(zipRight3(f2(cause3), failCause8(cause3))),
    onDone: succeedNow
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
});
var tapSink = /* @__PURE__ */ dual(2, (self2, sink) => pipe(fromEffect7(all4([bounded3(1), make23()])), flatMap16(([queue, deferred2]) => {
  const right3 = flattenTake(fromQueue2(queue, {
    maxChunkSize: 1
  }));
  const loop3 = readWithCause({
    onInput: (chunk5) => pipe(fromEffect4(offer3(queue, chunk4(chunk5))), foldCauseChannel({
      onFailure: () => flatMap13(write(chunk5), () => identityChannel()),
      onSuccess: () => flatMap13(write(chunk5), () => loop3)
    })),
    onFailure: (cause3) => pipe(fromEffect4(offer3(queue, failCause11(cause3))), foldCauseChannel({
      onFailure: () => failCause10(cause3),
      onSuccess: () => failCause10(cause3)
    })),
    onDone: () => pipe(fromEffect4(offer3(queue, end4)), foldCauseChannel({
      onFailure: () => void_5,
      onSuccess: () => void_5
    }))
  });
  return pipe(new StreamImpl(pipe(pipeTo(toChannel2(self2), loop3), ensuring4(zipRight3(forkDaemon2(offer3(queue, end4)), _await(deferred2))))), merge9(execute(pipe(run3(right3, sink), ensuring2(zipRight3(shutdown2(queue), succeed2(deferred2, void 0)))))));
})));
var throttle = /* @__PURE__ */ dual(2, (self2, options) => throttleEffect(self2, {
  ...options,
  cost: (chunk5) => succeed8(options.cost(chunk5))
}));
var throttleEffect = /* @__PURE__ */ dual(2, (self2, options) => {
  if (options.strategy === "enforce") {
    return throttleEnforceEffect(self2, options.cost, options.units, options.duration, options.burst ?? 0);
  }
  return throttleShapeEffect(self2, options.cost, options.units, options.duration, options.burst ?? 0);
});
var throttleEnforceEffect = (self2, cost, units, duration4, burst) => {
  const loop3 = (tokens, timestampMillis) => readWithCause({
    onInput: (input2) => pipe(cost(input2), zip5(currentTimeMillis2), map16(([weight, currentTimeMillis3]) => {
      const elapsed2 = currentTimeMillis3 - timestampMillis;
      const cycles = elapsed2 / toMillis(duration4);
      const sum3 = tokens + cycles * units;
      const max5 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum3 < 0 ? max5 : Math.min(sum3, max5);
      if (weight <= available) {
        return pipe(write(input2), flatMap13(() => loop3(available - weight, currentTimeMillis3)));
      }
      return loop3(tokens, timestampMillis);
    }), unwrap3),
    onFailure: failCause10,
    onDone: () => void_5
  });
  const throttled = pipe(currentTimeMillis2, map16((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap3);
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(throttled)));
};
var throttleShapeEffect = (self2, costFn, units, duration4, burst) => {
  const loop3 = (tokens, timestampMillis) => readWithCause({
    onInput: (input2) => pipe(costFn(input2), zip5(currentTimeMillis2), map16(([weight, currentTimeMillis3]) => {
      const elapsed2 = currentTimeMillis3 - timestampMillis;
      const cycles = elapsed2 / toMillis(duration4);
      const sum3 = tokens + cycles * units;
      const max5 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum3 < 0 ? max5 : Math.min(sum3, max5);
      const remaining = available - weight;
      const waitCycles = remaining >= 0 ? 0 : -remaining / units;
      const delay4 = millis(Math.max(0, waitCycles * toMillis(duration4)));
      if (greaterThan2(delay4, zero)) {
        return pipe(fromEffect4(sleep2(delay4)), zipRight5(write(input2)), flatMap13(() => loop3(remaining, currentTimeMillis3)));
      }
      return flatMap13(write(input2), () => loop3(remaining, currentTimeMillis3));
    }), unwrap3),
    onFailure: failCause10,
    onDone: () => void_5
  });
  const throttled = pipe(currentTimeMillis2, map16((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap3);
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(throttled)));
};
var tick = (interval) => repeatWithSchedule(void 0, spaced2(interval));
var timeout3 = /* @__PURE__ */ dual(2, (self2, duration4) => pipe(toPull2(self2), map16(timeoutFail2({
  onTimeout: () => none2(),
  duration: duration4
})), fromPull2));
var timeoutFail3 = /* @__PURE__ */ dual(3, (self2, error4, duration4) => pipe(self2, timeoutTo3(duration4, failSync7(error4))));
var timeoutFailCause3 = /* @__PURE__ */ dual(3, (self2, cause3, duration4) => pipe(toPull2(self2), map16(timeoutFailCause2({
  onTimeout: () => map12(cause3(), some2),
  duration: duration4
})), fromPull2));
var timeoutTo3 = /* @__PURE__ */ dual(3, (self2, duration4, that) => {
  const StreamTimeout = new RuntimeException2("Stream Timeout");
  return pipe(self2, timeoutFailCause3(() => die4(StreamTimeout), duration4), catchSomeCause3((cause3) => isDieType2(cause3) && isRuntimeException2(cause3.defect) && cause3.defect.message !== void 0 && cause3.defect.message === "Stream Timeout" ? some2(that) : none2()));
});
var pubsubFromOptions = (options) => {
  if (typeof options === "number") {
    return bounded5(options);
  } else if (options.capacity === "unbounded") {
    return unbounded5({
      replay: options.replay
    });
  }
  switch (options.strategy) {
    case "dropping":
      return dropping4(options);
    case "sliding":
      return sliding4(options);
    default:
      return bounded5(options);
  }
};
var toPubSub2 = /* @__PURE__ */ dual(2, (self2, capacity7) => pipe(acquireRelease2(pubsubFromOptions(capacity7), (pubsub) => shutdown4(pubsub)), tap3((pubsub) => pipe(self2, runIntoPubSubScoped(pubsub), forkScoped2))));
var toPull2 = (self2) => map16(toPull(toChannel2(self2)), (pull) => pipe(pull, mapError3(some2), flatMap11(match({
  onLeft: () => fail9(none2()),
  onRight: succeed8
}))));
var toQueue2 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => tap3(acquireRelease2(options?.strategy === "unbounded" ? unbounded3() : options?.strategy === "dropping" ? dropping2(options.capacity ?? 2) : options?.strategy === "sliding" ? sliding2(options.capacity ?? 2) : bounded3(options?.capacity ?? 2), (queue) => shutdown2(queue)), (queue) => forkScoped2(runIntoQueueScoped(self2, queue))));
var toQueueOfElements = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => tap3(acquireRelease2(bounded3(options?.capacity ?? 2), (queue) => shutdown2(queue)), (queue) => forkScoped2(runIntoQueueElementsScoped(self2, queue))));
var toReadableStream = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => toReadableStreamRuntime(self2, defaultRuntime2, options));
var toReadableStreamEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => map16(runtime3(), (runtime4) => toReadableStreamRuntime(self2, runtime4, options)));
var toReadableStreamRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, runtime4, options) => {
  const runFork4 = runFork3(runtime4);
  let currentResolve = void 0;
  let fiber = void 0;
  const latch = unsafeMakeLatch2(false);
  return new ReadableStream({
    start(controller) {
      fiber = runFork4(runForEachChunk(self2, (chunk5) => latch.whenOpen(sync4(() => {
        latch.unsafeClose();
        for (const item of chunk5) {
          controller.enqueue(item);
        }
        currentResolve();
        currentResolve = void 0;
      }))));
      fiber.addObserver((exit4) => {
        if (exit4._tag === "Failure") {
          controller.error(squash(exit4.cause));
        } else {
          controller.close();
        }
      });
    },
    pull() {
      return new Promise((resolve9) => {
        currentResolve = resolve9;
        runSync(latch.open);
      });
    },
    cancel() {
      if (!fiber) return;
      return runPromise(asVoid2(interrupt6(fiber)));
    }
  }, options?.strategy);
});
var transduce = /* @__PURE__ */ dual(2, (self2, sink) => {
  const newChannel = suspend8(() => {
    const leftovers = {
      ref: empty2()
    };
    const upstreamDone = {
      ref: false
    };
    const buffer4 = suspend8(() => {
      const leftover = leftovers.ref;
      if (isEmpty(leftover)) {
        return readWith({
          onInput: (input2) => pipe(write(input2), flatMap13(() => buffer4)),
          onFailure: fail13,
          onDone: succeedNow
        });
      }
      leftovers.ref = empty2();
      return pipe(writeChunk(leftover), flatMap13(() => buffer4));
    });
    const concatAndGet = (chunk5) => {
      const leftover = leftovers.ref;
      const concatenated = appendAll2(leftover, filter2(chunk5, (chunk6) => chunk6.length !== 0));
      leftovers.ref = concatenated;
      return concatenated;
    };
    const upstreamMarker = readWith({
      onInput: (input2) => flatMap13(write(input2), () => upstreamMarker),
      onFailure: fail13,
      onDone: (done11) => zipRight5(sync9(() => {
        upstreamDone.ref = true;
      }), succeedNow(done11))
    });
    const transducer = pipe(sink, toChannel, collectElements, flatMap13(([leftover, z2]) => pipe(succeed13([upstreamDone.ref, concatAndGet(leftover)]), flatMap13(([done11, newLeftovers]) => {
      const nextChannel = done11 && isEmpty(newLeftovers) ? void_5 : transducer;
      return pipe(write(of2(z2)), flatMap13(() => nextChannel));
    }))));
    return pipe(toChannel2(self2), pipeTo(upstreamMarker), pipeTo(buffer4), pipeToOrFail(transducer));
  });
  return new StreamImpl(newChannel);
});
var unfold3 = (s2, f2) => unfoldChunk(s2, (s3) => pipe(f2(s3), map(([a2, s4]) => [of2(a2), s4])));
var unfoldChunk = (s2, f2) => {
  const loop3 = (s3) => match2(f2(s3), {
    onNone: () => void_5,
    onSome: ([chunk5, s4]) => flatMap13(write(chunk5), () => loop3(s4))
  });
  return new StreamImpl(suspend8(() => loop3(s2)));
};
var unfoldChunkEffect = (s2, f2) => suspend12(() => {
  const loop3 = (s3) => unwrap3(map16(f2(s3), match2({
    onNone: () => void_5,
    onSome: ([chunk5, s4]) => flatMap13(write(chunk5), () => loop3(s4))
  })));
  return new StreamImpl(loop3(s2));
});
var unfoldEffect = (s2, f2) => unfoldChunkEffect(s2, (s3) => pipe(f2(s3), map16(map(([a2, s4]) => [of2(a2), s4]))));
var void_7 = /* @__PURE__ */ succeed16(void 0);
var unwrap4 = (effect4) => flatten12(fromEffect7(effect4));
var unwrapScoped4 = (effect4) => flatten12(scoped5(effect4));
var unwrapScopedWith3 = (f2) => flatten12(scopedWith4((scope5) => f2(scope5)));
var updateService4 = /* @__PURE__ */ dual(3, (self2, tag, f2) => pipe(self2, mapInputContext5((context8) => pipe(context8, add2(tag, f2(pipe(context8, unsafeGet4(tag))))))));
var when3 = /* @__PURE__ */ dual(2, (self2, test) => pipe(self2, whenEffect3(sync4(test))));
var whenCase = (evaluate3, pf) => whenCaseEffect(pf)(sync4(evaluate3));
var whenCaseEffect = /* @__PURE__ */ dual(2, (self2, pf) => pipe(fromEffect7(self2), flatMap16((a2) => pipe(pf(a2), getOrElse(() => empty31)))));
var whenEffect3 = /* @__PURE__ */ dual(2, (self2, effect4) => pipe(fromEffect7(effect4), flatMap16((bool) => bool ? self2 : empty31)));
var withSpan6 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return new StreamImpl(withSpan5(toChannel2(self2), name, options));
  }
  return (self2) => new StreamImpl(withSpan5(toChannel2(self2), name, options));
};
var zip9 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, zipWith12(that, (a2, a22) => [a2, a22])));
var zipFlatten = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, zipWith12(that, (a2, a22) => [...a2, a22])));
var zipAll = /* @__PURE__ */ dual(2, (self2, options) => zipAllWith(self2, {
  other: options.other,
  onSelf: (a2) => [a2, options.defaultOther],
  onOther: (a2) => [options.defaultSelf, a2],
  onBoth: (a2, a22) => [a2, a22]
}));
var zipAllLeft = /* @__PURE__ */ dual(3, (self2, other, defaultSelf) => zipAllWith(self2, {
  other,
  onSelf: identity,
  onOther: () => defaultSelf,
  onBoth: (a2) => a2
}));
var zipAllRight = /* @__PURE__ */ dual(3, (self2, other, defaultRight) => zipAllWith(self2, {
  other,
  onSelf: () => defaultRight,
  onOther: identity,
  onBoth: (_2, a2) => a2
}));
var zipAllSortedByKey = /* @__PURE__ */ dual(2, (self2, options) => zipAllSortedByKeyWith(self2, {
  other: options.other,
  onSelf: (a2) => [a2, options.defaultOther],
  onOther: (a2) => [options.defaultSelf, a2],
  onBoth: (a2, a22) => [a2, a22],
  order: options.order
}));
var zipAllSortedByKeyLeft = /* @__PURE__ */ dual(2, (self2, options) => zipAllSortedByKeyWith(self2, {
  other: options.other,
  onSelf: identity,
  onOther: () => options.defaultSelf,
  onBoth: (a2) => a2,
  order: options.order
}));
var zipAllSortedByKeyRight = /* @__PURE__ */ dual(2, (self2, options) => zipAllSortedByKeyWith(self2, {
  other: options.other,
  onSelf: () => options.defaultOther,
  onOther: identity,
  onBoth: (_2, a2) => a2,
  order: options.order
}));
var zipAllSortedByKeyWith = /* @__PURE__ */ dual(2, (self2, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return pipe(pullLeft, match12({
          onFailure: fail4,
          onSuccess: (leftChunk) => succeed4([map3(leftChunk, ([k, a2]) => [k, options.onSelf(a2)]), DrainLeft])
        }));
      }
      case OP_DRAIN_RIGHT: {
        return pipe(pullRight, match12({
          onFailure: fail4,
          onSuccess: (rightChunk) => succeed4([map3(rightChunk, ([k, a2]) => [k, options.onOther(a2)]), DrainRight])
        }));
      }
      case OP_PULL_BOTH: {
        return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
          concurrent: true
        }), matchEffect2({
          onFailure: (error4) => succeed8(fail4(some2(error4))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed8(succeed4(merge12(leftOption.value, rightOption.value)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              if (isEmpty(leftOption.value)) {
                return pull(DrainLeft, pullLeft, pullRight);
              }
              return succeed8(succeed4([pipe(leftOption.value, map3(([k, a2]) => [k, options.onSelf(a2)])), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(rightOption.value)) {
                return pull(DrainRight, pullLeft, pullRight);
              }
              return succeed8(succeed4([pipe(rightOption.value, map3(([k, a2]) => [k, options.onOther(a2)])), DrainRight]));
            }
            return succeed8(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect2(pullLeft, {
          onFailure: match2({
            onNone: () => succeed8(succeed4([pipe(state.rightChunk, map3(([k, a2]) => [k, options.onOther(a2)])), DrainRight])),
            onSome: (error4) => succeed8(fail4(some2(error4)))
          }),
          onSuccess: (leftChunk) => isEmpty(leftChunk) ? pull(PullLeft(state.rightChunk), pullLeft, pullRight) : succeed8(succeed4(merge12(leftChunk, state.rightChunk)))
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect2(pullRight, {
          onFailure: match2({
            onNone: () => succeed8(succeed4([map3(state.leftChunk, ([k, a2]) => [k, options.onSelf(a2)]), DrainLeft])),
            onSome: (error4) => succeed8(fail4(some2(error4)))
          }),
          onSuccess: (rightChunk) => isEmpty(rightChunk) ? pull(PullRight(state.leftChunk), pullLeft, pullRight) : succeed8(succeed4(merge12(state.leftChunk, rightChunk)))
        });
      }
    }
  };
  const merge12 = (leftChunk, rightChunk) => {
    const hasNext = (chunk5, index) => index < chunk5.length - 1;
    const builder = [];
    let state = void 0;
    let leftIndex = 0;
    let rightIndex = 0;
    let leftTuple = pipe(leftChunk, unsafeGet2(leftIndex));
    let rightTuple = pipe(rightChunk, unsafeGet2(rightIndex));
    let k1 = leftTuple[0];
    let a2 = leftTuple[1];
    let k2 = rightTuple[0];
    let a22 = rightTuple[1];
    let loop3 = true;
    while (loop3) {
      const compare = options.order(k1, k2);
      if (compare === 0) {
        builder.push([k1, options.onBoth(a2, a22)]);
        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
          leftIndex = leftIndex + 1;
          rightIndex = rightIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet2(leftIndex));
          rightTuple = pipe(rightChunk, unsafeGet2(rightIndex));
          k1 = leftTuple[0];
          a2 = leftTuple[1];
          k2 = rightTuple[0];
          a22 = rightTuple[1];
        } else if (hasNext(leftChunk, leftIndex)) {
          state = PullRight(pipe(leftChunk, drop2(leftIndex + 1)));
          loop3 = false;
        } else if (hasNext(rightChunk, rightIndex)) {
          state = PullLeft(pipe(rightChunk, drop2(rightIndex + 1)));
          loop3 = false;
        } else {
          state = PullBoth;
          loop3 = false;
        }
      } else if (compare < 0) {
        builder.push([k1, options.onSelf(a2)]);
        if (hasNext(leftChunk, leftIndex)) {
          leftIndex = leftIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet2(leftIndex));
          k1 = leftTuple[0];
          a2 = leftTuple[1];
        } else {
          const rightBuilder = [];
          rightBuilder.push(rightTuple);
          while (hasNext(rightChunk, rightIndex)) {
            rightIndex = rightIndex + 1;
            rightTuple = pipe(rightChunk, unsafeGet2(rightIndex));
            rightBuilder.push(rightTuple);
          }
          state = PullLeft(unsafeFromArray(rightBuilder));
          loop3 = false;
        }
      } else {
        builder.push([k2, options.onOther(a22)]);
        if (hasNext(rightChunk, rightIndex)) {
          rightIndex = rightIndex + 1;
          rightTuple = pipe(rightChunk, unsafeGet2(rightIndex));
          k2 = rightTuple[0];
          a22 = rightTuple[1];
        } else {
          const leftBuilder = [];
          leftBuilder.push(leftTuple);
          while (hasNext(leftChunk, leftIndex)) {
            leftIndex = leftIndex + 1;
            leftTuple = pipe(leftChunk, unsafeGet2(leftIndex));
            leftBuilder.push(leftTuple);
          }
          state = PullRight(unsafeFromArray(leftBuilder));
          loop3 = false;
        }
      }
    }
    return [unsafeFromArray(builder), state];
  };
  return combineChunks(self2, options.other, PullBoth, pull);
});
var zipAllWith = /* @__PURE__ */ dual(2, (self2, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return matchEffect2(pullLeft, {
          onFailure: (error4) => succeed8(fail4(error4)),
          onSuccess: (leftChunk) => succeed8(succeed4([map3(leftChunk, options.onSelf), DrainLeft]))
        });
      }
      case OP_DRAIN_RIGHT: {
        return matchEffect2(pullRight, {
          onFailure: (error4) => succeed8(fail4(error4)),
          onSuccess: (rightChunk) => succeed8(succeed4([map3(rightChunk, options.onOther), DrainRight]))
        });
      }
      case OP_PULL_BOTH: {
        return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
          concurrent: true
        }), matchEffect2({
          onFailure: (error4) => succeed8(fail4(some2(error4))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed8(succeed4(zip12(leftOption.value, rightOption.value, options.onBoth)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              return succeed8(succeed4([map3(leftOption.value, options.onSelf), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              return succeed8(succeed4([map3(rightOption.value, options.onOther), DrainRight]));
            }
            return succeed8(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect2(pullLeft, {
          onFailure: match2({
            onNone: () => succeed8(succeed4([map3(state.rightChunk, options.onOther), DrainRight])),
            onSome: (error4) => succeed8(fail4(some2(error4)))
          }),
          onSuccess: (leftChunk) => {
            if (isEmpty(leftChunk)) {
              return pull(PullLeft(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.rightChunk)) {
              return pull(PullRight(leftChunk), pullLeft, pullRight);
            }
            return succeed8(succeed4(zip12(leftChunk, state.rightChunk, options.onBoth)));
          }
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect2(pullRight, {
          onFailure: match2({
            onNone: () => succeed8(succeed4([map3(state.leftChunk, options.onSelf), DrainLeft])),
            onSome: (error4) => succeed8(fail4(some2(error4)))
          }),
          onSuccess: (rightChunk) => {
            if (isEmpty(rightChunk)) {
              return pull(PullRight(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.leftChunk)) {
              return pull(PullLeft(rightChunk), pullLeft, pullRight);
            }
            return succeed8(succeed4(zip12(state.leftChunk, rightChunk, options.onBoth)));
          }
        });
      }
    }
  };
  const zip12 = (leftChunk, rightChunk, f2) => {
    const [output, either7] = zipChunks(leftChunk, rightChunk, f2);
    switch (either7._tag) {
      case "Left": {
        if (isEmpty(either7.left)) {
          return [output, PullBoth];
        }
        return [output, PullRight(either7.left)];
      }
      case "Right": {
        if (isEmpty(either7.right)) {
          return [output, PullBoth];
        }
        return [output, PullLeft(either7.right)];
      }
    }
  };
  return combineChunks(self2, options.other, PullBoth, pull);
});
var zipLatest = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipLatestWith(right3, (a2, a22) => [a2, a22])));
var zipLatestAll = (...streams) => {
  if (streams.length === 0) {
    return empty31;
  } else if (streams.length === 1) {
    return map23(streams[0], (x2) => [x2]);
  }
  const [head6, ...tail] = streams;
  return zipLatestWith(head6, zipLatestAll(...tail), (first3, second) => [first3, ...second]);
};
var zipLatestWith = /* @__PURE__ */ dual(3, (left3, right3, f2) => {
  const pullNonEmpty = (pull) => pipe(pull, flatMap11((chunk5) => isEmpty(chunk5) ? pullNonEmpty(pull) : succeed8(chunk5)));
  return pipe(toPull2(left3), map16(pullNonEmpty), zip5(pipe(toPull2(right3), map16(pullNonEmpty))), flatMap11(([left4, right4]) => pipe(fromEffectOption(raceWith2(left4, right4, {
    onSelfDone: (leftDone, rightFiber) => pipe(suspend4(() => leftDone), zipWith5(join3(rightFiber), (l, r) => [l, r, true])),
    onOtherDone: (rightDone, leftFiber) => pipe(suspend4(() => rightDone), zipWith5(join3(leftFiber), (l, r) => [r, l, false]))
  })), flatMap16(([l, r, leftFirst]) => pipe(fromEffect7(make25([unsafeLast(l), unsafeLast(r)])), flatMap16((latest) => pipe(fromChunk(leftFirst ? pipe(r, map3((a2) => f2(unsafeLast(l), a2))) : pipe(l, map3((a2) => f2(a2, unsafeLast(r))))), concat2(pipe(repeatEffectOption(left4), mergeEither(repeatEffectOption(right4)), mapEffectSequential(match({
    onLeft: (leftChunk) => pipe(modify3(latest, ([_2, rightLatest]) => [pipe(leftChunk, map3((a2) => f2(a2, rightLatest))), [unsafeLast(leftChunk), rightLatest]])),
    onRight: (rightChunk) => pipe(modify3(latest, ([leftLatest, _2]) => [pipe(rightChunk, map3((a2) => f2(leftLatest, a2))), [leftLatest, unsafeLast(rightChunk)]]))
  })), flatMap16(fromChunk))))))), toPull2)), fromPull2);
});
var zipLeft5 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [pipe(left4, take(right4.length)), left2(pipe(left4, take(right4.length)))];
  }
  return [left4, right2(pipe(right4, drop2(left4.length)))];
})));
var zipRight8 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [right4, left2(pipe(left4, take(right4.length)))];
  }
  return [pipe(right4, take(left4.length)), right2(pipe(right4, drop2(left4.length)))];
})));
var zipWith12 = /* @__PURE__ */ dual(3, (left3, right3, f2) => pipe(left3, zipWithChunks(right3, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f2))));
var zipWithChunks = /* @__PURE__ */ dual(3, (self2, that, f2) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_PULL_BOTH2: {
        return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
          concurrent: true
        }), matchEffect2({
          onFailure: (error4) => succeed8(fail4(some2(error4))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth2, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft2(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight2(leftOption.value), pullLeft, pullRight);
              }
              return succeed8(succeed4(zip12(leftOption.value, rightOption.value)));
            }
            return succeed8(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT2: {
        return matchEffect2(pullLeft, {
          onFailure: (error4) => succeed8(fail4(error4)),
          onSuccess: (leftChunk) => {
            if (isEmpty(leftChunk)) {
              return pull(PullLeft2(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.rightChunk)) {
              return pull(PullRight2(leftChunk), pullLeft, pullRight);
            }
            return succeed8(succeed4(zip12(leftChunk, state.rightChunk)));
          }
        });
      }
      case OP_PULL_RIGHT2: {
        return matchEffect2(pullRight, {
          onFailure: (error4) => succeed8(fail4(error4)),
          onSuccess: (rightChunk) => {
            if (isEmpty(rightChunk)) {
              return pull(PullRight2(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.leftChunk)) {
              return pull(PullLeft2(rightChunk), pullLeft, pullRight);
            }
            return succeed8(succeed4(zip12(state.leftChunk, rightChunk)));
          }
        });
      }
    }
  };
  const zip12 = (leftChunk, rightChunk) => {
    const [output, either7] = f2(leftChunk, rightChunk);
    switch (either7._tag) {
      case "Left": {
        if (isEmpty(either7.left)) {
          return [output, PullBoth2];
        }
        return [output, PullRight2(either7.left)];
      }
      case "Right": {
        if (isEmpty(either7.right)) {
          return [output, PullBoth2];
        }
        return [output, PullLeft2(either7.right)];
      }
    }
  };
  return pipe(self2, combineChunks(that, PullBoth2, pull));
});
var zipWithIndex = (self2) => pipe(self2, mapAccum5(0, (index, a2) => [index + 1, [a2, index]]));
var zipWithNext = (self2) => {
  const process2 = (last6) => readWithCause({
    onInput: (input2) => {
      const [newLast, chunk5] = mapAccum2(input2, last6, (prev, curr) => [some2(curr), pipe(prev, map((a2) => [a2, curr]))]);
      const output = filterMap2(chunk5, (option5) => isSome2(option5) ? some2([option5.value[0], some2(option5.value[1])]) : none2());
      return flatMap13(write(output), () => process2(newLast));
    },
    onFailure: failCause10,
    onDone: () => match2(last6, {
      onNone: () => void_5,
      onSome: (value) => zipRight5(write(of2([value, none2()])), void_5)
    })
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(process2(none2()))));
};
var zipWithPrevious = (self2) => pipe(self2, mapAccum5(none2(), (prev, curr) => [some2(curr), [prev, curr]]));
var zipWithPreviousAndNext = (self2) => pipe(zipWithNext(zipWithPrevious(self2)), map23(([[prev, curr], next]) => [prev, curr, pipe(next, map((tuple3) => tuple3[1]))]));
var zipChunks = (left3, right3, f2) => {
  if (left3.length > right3.length) {
    return [pipe(left3, take(right3.length), zipWith2(right3, f2)), left2(pipe(left3, drop2(right3.length)))];
  }
  return [pipe(left3, zipWith2(pipe(right3, take(left3.length)), f2)), right2(pipe(right3, drop2(left3.length)))];
};
var Do3 = /* @__PURE__ */ succeed16({});
var bind4 = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self2, tag, f2, options) => flatMap16(self2, (k) => map23(f2(k), (a2) => ({
  ...k,
  [tag]: a2
})), options));
var bindTo4 = /* @__PURE__ */ bindTo(map23);
var let_4 = /* @__PURE__ */ let_(map23);
var decodeText = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, encoding = "utf-8") => suspend12(() => {
  const decoder = new TextDecoder(encoding);
  return map23(self2, (s2) => decoder.decode(s2));
}));
var encodeText = (self2) => suspend12(() => {
  const encoder = new TextEncoder();
  return map23(self2, (s2) => encoder.encode(s2));
});
var fromEventListener = (target, type, options) => asyncPush((emit2) => acquireRelease2(sync4(() => target.addEventListener(type, emit2.single, options)), () => sync4(() => target.removeEventListener(type, emit2.single, options))), {
  bufferSize: typeof options === "object" ? options.bufferSize : void 0
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/groupBy.js
var GroupBySymbolKey = "effect/GroupBy";
var GroupByTypeId = /* @__PURE__ */ Symbol.for(GroupBySymbolKey);
var groupByVariance = {
  /* c8 ignore next */
  _R: (_2) => _2,
  /* c8 ignore next */
  _E: (_2) => _2,
  /* c8 ignore next */
  _K: (_2) => _2,
  /* c8 ignore next */
  _V: (_2) => _2
};
var isGroupBy = (u2) => hasProperty(u2, GroupByTypeId);
var evaluate2 = /* @__PURE__ */ dual((args2) => isGroupBy(args2[0]), (self2, f2, options) => flatMap16(self2.grouped, ([key, queue]) => f2(key, flattenTake(fromQueue2(queue, {
  shutdown: true
}))), {
  concurrency: "unbounded",
  bufferSize: options?.bufferSize ?? 16
}));
var make53 = (grouped3) => ({
  [GroupByTypeId]: groupByVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  grouped: grouped3
});
var groupBy = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, f2, options) => make53(unwrapScoped4(gen2(function* () {
  const decider = yield* make23();
  const output = yield* acquireRelease2(bounded3(options?.bufferSize ?? 16), (queue) => shutdown2(queue));
  const ref = yield* make25(/* @__PURE__ */ new Map());
  const add6 = yield* pipe(mapEffectSequential(self2, f2), distributedWithDynamicCallback(options?.bufferSize ?? 16, ([key, value]) => flatMap11(_await(decider), (f3) => f3(key, value)), (exit4) => offer3(output, exit4)));
  yield* succeed2(decider, (key, _2) => pipe(get11(ref), map16((map26) => fromNullable(map26.get(key))), flatMap11(match2({
    onNone: () => flatMap11(add6, ([index, queue]) => zipRight3(update3(ref, (map26) => map26.set(key, index)), pipe(offer3(output, succeed4([key, mapDequeue(queue, (exit4) => new TakeImpl(pipe(exit4, map11((tuple3) => of2(tuple3[1])))))])), as4((n2) => n2 === index)))),
    onSome: (index) => succeed8((n2) => n2 === index)
  }))));
  return flattenExitOption(fromQueue2(output, {
    shutdown: true
  }));
}))));
var mapEffectOptions = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self2, f2, options) => {
  if (options?.key) {
    return evaluate2(groupByKey(self2, options.key, {
      bufferSize: options.bufferSize
    }), (_2, s2) => mapEffectSequential(s2, f2));
  }
  return matchConcurrency(options?.concurrency, () => mapEffectSequential(self2, f2), (n2) => options?.unordered ? flatMap16(self2, (a2) => fromEffect7(f2(a2)), {
    concurrency: n2
  }) : mapEffectPar(self2, n2, f2));
});
var bindEffect = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self2, tag, f2, options) => mapEffectOptions(self2, (k) => map16(f2(k), (a2) => ({
  ...k,
  [tag]: a2
})), options));
var mapDequeue = (dequeue, f2) => new MapDequeue(dequeue, f2);
var MapDequeue = class extends Class2 {
  dequeue;
  f;
  [DequeueTypeId2] = {
    _Out: (_2) => _2
  };
  constructor(dequeue, f2) {
    super();
    this.dequeue = dequeue;
    this.f = f2;
  }
  capacity() {
    return capacity3(this.dequeue);
  }
  get size() {
    return size12(this.dequeue);
  }
  unsafeSize() {
    return this.dequeue.unsafeSize();
  }
  get awaitShutdown() {
    return awaitShutdown2(this.dequeue);
  }
  isActive() {
    return this.dequeue.isActive();
  }
  get isShutdown() {
    return isShutdown2(this.dequeue);
  }
  get shutdown() {
    return shutdown2(this.dequeue);
  }
  get isFull() {
    return isFull2(this.dequeue);
  }
  get isEmpty() {
    return isEmpty11(this.dequeue);
  }
  get take() {
    return pipe(take3(this.dequeue), map16((a2) => this.f(a2)));
  }
  get takeAll() {
    return pipe(takeAll2(this.dequeue), map16(map3((a2) => this.f(a2))));
  }
  takeUpTo(max5) {
    return pipe(takeUpTo2(this.dequeue, max5), map16(map3((a2) => this.f(a2))));
  }
  takeBetween(min3, max5) {
    return pipe(takeBetween2(this.dequeue, min3, max5), map16(map3((a2) => this.f(a2))));
  }
  takeN(n2) {
    return pipe(takeN2(this.dequeue, n2), map16(map3((a2) => this.f(a2))));
  }
  poll() {
    return pipe(poll6(this.dequeue), map16(map((a2) => this.f(a2))));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
};
var groupByKey = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self2, f2, options) => {
  const loop3 = (map26, outerQueue) => readWithCause({
    onInput: (input2) => flatMap13(fromEffect4(forEach9(groupByIterable(input2, f2), ([key, values3]) => {
      const innerQueue = map26.get(key);
      if (innerQueue === void 0) {
        return pipe(bounded3(options?.bufferSize ?? 16), flatMap11((innerQueue2) => pipe(sync4(() => {
          map26.set(key, innerQueue2);
        }), zipRight3(offer3(outerQueue, of5([key, innerQueue2]))), zipRight3(pipe(offer3(innerQueue2, chunk4(values3)), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2()))))));
      }
      return catchSomeCause2(offer3(innerQueue, chunk4(values3)), (cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2());
    }, {
      discard: true
    })), () => loop3(map26, outerQueue)),
    onFailure: (cause3) => fromEffect4(offer3(outerQueue, failCause11(cause3))),
    onDone: () => pipe(fromEffect4(pipe(forEach9(map26.entries(), ([_2, innerQueue]) => pipe(offer3(innerQueue, end4), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2())), {
      discard: true
    }), zipRight3(offer3(outerQueue, end4)))))
  });
  return make53(unwrapScopedWith3((scope5) => gen2(function* () {
    const map26 = /* @__PURE__ */ new Map();
    const queue = yield* unbounded3();
    yield* addFinalizer2(scope5, shutdown2(queue));
    return yield* toChannel2(self2).pipe(pipeTo(loop3(map26, queue)), drain, runIn(scope5), forkIn2(scope5), as4(flattenTake(fromQueue2(queue, {
      shutdown: true
    }))));
  })));
});
var groupByIterable = /* @__PURE__ */ dual(2, (iterable, f2) => {
  const builder = [];
  const iterator = iterable[Symbol.iterator]();
  const map26 = /* @__PURE__ */ new Map();
  let next;
  while ((next = iterator.next()) && !next.done) {
    const value = next.value;
    const key = f2(value);
    if (map26.has(key)) {
      const innerBuilder = map26.get(key);
      innerBuilder.push(value);
    } else {
      const innerBuilder = [value];
      builder.push([key, innerBuilder]);
      map26.set(key, innerBuilder);
    }
  }
  return unsafeFromArray(builder.map((tuple3) => [tuple3[0], unsafeFromArray(tuple3[1])]));
});

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Stream.js
var StreamTypeId3 = StreamTypeId2;
var DefaultChunkSize2 = DefaultChunkSize;
var accumulate2 = accumulate;
var accumulateChunks2 = accumulateChunks;
var acquireRelease4 = acquireRelease3;
var aggregate2 = aggregate;
var aggregateWithin2 = aggregateWithin;
var aggregateWithinEither2 = aggregateWithinEither;
var as9 = as8;
var _async2 = _async;
var asyncEffect4 = asyncEffect3;
var asyncPush2 = asyncPush;
var asyncScoped2 = asyncScoped;
var branchAfter2 = branchAfter;
var broadcast2 = broadcast;
var share2 = share;
var broadcastDynamic2 = broadcastDynamic;
var broadcastedQueues2 = broadcastedQueues;
var broadcastedQueuesDynamic2 = broadcastedQueuesDynamic;
var buffer2 = buffer;
var bufferChunks2 = bufferChunks;
var catchAll8 = catchAll7;
var catchAllCause7 = catchAllCause6;
var catchSome4 = catchSome3;
var catchTag4 = catchTag3;
var catchTags4 = catchTags3;
var catchSomeCause4 = catchSomeCause3;
var changes2 = changes;
var changesWith2 = changesWith;
var changesWithEffect2 = changesWithEffect;
var chunks2 = chunks;
var chunksWith2 = chunksWith;
var combine10 = combine9;
var combineChunks2 = combineChunks;
var concat3 = concat2;
var concatAll3 = concatAll2;
var cross2 = cross;
var crossLeft2 = crossLeft;
var crossRight2 = crossRight;
var crossWith2 = crossWith;
var debounce2 = debounce;
var die11 = die10;
var dieSync7 = dieSync6;
var dieMessage5 = dieMessage4;
var distributedWith2 = distributedWith;
var distributedWithDynamic2 = distributedWithDynamic;
var drain4 = drain3;
var drainFork2 = drainFork;
var drop4 = drop3;
var dropRight2 = dropRight;
var dropUntil4 = dropUntil3;
var dropUntilEffect2 = dropUntilEffect;
var dropWhile5 = dropWhile4;
var dropWhileEffect2 = dropWhileEffect;
var either6 = either5;
var empty32 = empty31;
var ensuring7 = ensuring6;
var ensuringWith3 = ensuringWith2;
var context6 = context5;
var contextWith4 = contextWith3;
var contextWithEffect4 = contextWithEffect3;
var contextWithStream2 = contextWithStream;
var execute2 = execute;
var fail18 = fail17;
var failSync8 = failSync7;
var failCause14 = failCause13;
var failCauseSync7 = failCauseSync6;
var filter9 = filter8;
var filterEffect2 = filterEffect;
var filterMap7 = filterMap6;
var filterMapEffect2 = filterMapEffect;
var filterMapWhile4 = filterMapWhile3;
var filterMapWhileEffect2 = filterMapWhileEffect;
var finalizer2 = finalizer;
var find3 = find2;
var findEffect2 = findEffect;
var flatMap17 = flatMap16;
var flatten13 = flatten12;
var flattenChunks2 = flattenChunks;
var flattenEffect2 = flattenEffect;
var flattenExitOption2 = flattenExitOption;
var flattenIterables2 = flattenIterables;
var flattenTake2 = flattenTake;
var forever6 = forever5;
var fromAsyncIterable2 = fromAsyncIterable;
var fromChannel3 = fromChannel2;
var toChannel3 = toChannel2;
var fromChunk2 = fromChunk;
var fromChunkPubSub2 = fromChunkPubSub;
var fromChunkQueue2 = fromChunkQueue;
var fromChunks2 = fromChunks;
var fromEffect8 = fromEffect7;
var fromEffectOption2 = fromEffectOption;
var fromPubSub2 = fromPubSub;
var fromTPubSub2 = fromTPubSub;
var fromIterable12 = fromIterable11;
var fromIterableEffect2 = fromIterableEffect;
var fromIteratorSucceed2 = fromIteratorSucceed;
var fromPull3 = fromPull2;
var fromQueue3 = fromQueue2;
var fromTQueue2 = fromTQueue;
var fromReadableStream2 = fromReadableStream;
var fromReadableStreamByob2 = fromReadableStreamByob;
var fromSchedule2 = fromSchedule;
var groupAdjacentBy2 = groupAdjacentBy;
var groupBy2 = groupBy;
var groupByKey2 = groupByKey;
var grouped2 = grouped;
var groupedWithin2 = groupedWithin;
var haltAfter2 = haltAfter;
var haltWhen2 = haltWhen;
var haltWhenDeferred2 = haltWhenDeferred;
var identity3 = identityStream;
var interleave2 = interleave;
var interleaveWith2 = interleaveWith;
var intersperse2 = intersperse;
var intersperseAffixes2 = intersperseAffixes;
var interruptAfter2 = interruptAfter;
var interruptWhen3 = interruptWhen2;
var interruptWhenDeferred3 = interruptWhenDeferred2;
var iterate4 = iterate3;
var make54 = make52;
var map24 = map23;
var mapAccum6 = mapAccum5;
var mapAccumEffect2 = mapAccumEffect;
var mapBoth6 = mapBoth5;
var mapChunks2 = mapChunks;
var mapChunksEffect2 = mapChunksEffect;
var mapConcat2 = mapConcat;
var mapConcatChunk2 = mapConcatChunk;
var mapConcatChunkEffect2 = mapConcatChunkEffect;
var mapConcatEffect2 = mapConcatEffect;
var mapEffect4 = mapEffectOptions;
var mapError7 = mapError6;
var mapErrorCause5 = mapErrorCause4;
var merge10 = merge9;
var mergeAll8 = mergeAll7;
var mergeWithTag2 = mergeWithTag;
var mergeWith4 = mergeWith3;
var mergeEither2 = mergeEither;
var mergeLeft2 = mergeLeft;
var mergeRight2 = mergeRight;
var mkString3 = mkString2;
var never5 = never4;
var onEnd2 = onEnd;
var onError4 = onError3;
var onDone2 = onDone;
var onStart2 = onStart;
var orDie6 = orDie5;
var orDieWith5 = orDieWith4;
var orElse12 = orElse11;
var orElseEither4 = orElseEither3;
var orElseFail4 = orElseFail3;
var orElseIfEmpty2 = orElseIfEmpty;
var orElseIfEmptyChunk2 = orElseIfEmptyChunk;
var orElseIfEmptyStream2 = orElseIfEmptyStream;
var orElseSucceed4 = orElseSucceed3;
var paginate2 = paginate;
var paginateChunk2 = paginateChunk;
var paginateChunkEffect2 = paginateChunkEffect;
var paginateEffect2 = paginateEffect;
var partition6 = partition5;
var partitionEither2 = partitionEither;
var peel2 = peel;
var pipeThrough2 = pipeThrough;
var pipeThroughChannel2 = pipeThroughChannel;
var pipeThroughChannelOrFail2 = pipeThroughChannelOrFail;
var prepend5 = prepend4;
var provideContext6 = provideContext5;
var provideLayer2 = provideLayer;
var provideService6 = provideService5;
var provideServiceEffect4 = provideServiceEffect3;
var provideServiceStream2 = provideServiceStream;
var mapInputContext6 = mapInputContext5;
var provideSomeLayer3 = provideSomeLayer2;
var race4 = race3;
var raceAll4 = raceAll3;
var range3 = range2;
var rechunk2 = rechunk;
var refineOrDie2 = refineOrDie;
var refineOrDieWith2 = refineOrDieWith;
var repeat5 = repeat4;
var repeatEffect2 = repeatEffect;
var repeatEffectChunk2 = repeatEffectChunk;
var repeatEffectChunkOption2 = repeatEffectChunkOption;
var repeatEffectOption2 = repeatEffectOption;
var repeatEffectWithSchedule2 = repeatEffectWithSchedule;
var repeatEither2 = repeatEither;
var repeatElements2 = repeatElements;
var repeatElementsWith2 = repeatElementsWith;
var repeatValue2 = repeatValue;
var repeatWith2 = repeatWith;
var retry7 = retry6;
var run4 = run3;
var runCollect2 = runCollect;
var runCount2 = runCount;
var runDrain3 = runDrain2;
var runFold2 = runFold;
var runFoldEffect2 = runFoldEffect;
var runFoldScoped2 = runFoldScoped;
var runFoldScopedEffect2 = runFoldScopedEffect;
var runFoldWhile2 = runFoldWhile;
var runFoldWhileEffect2 = runFoldWhileEffect;
var runFoldWhileScoped2 = runFoldWhileScoped;
var runFoldWhileScopedEffect2 = runFoldWhileScopedEffect;
var runForEach2 = runForEach;
var runForEachChunk2 = runForEachChunk;
var runForEachChunkScoped2 = runForEachChunkScoped;
var runForEachScoped2 = runForEachScoped;
var runForEachWhile2 = runForEachWhile;
var runForEachWhileScoped2 = runForEachWhileScoped;
var runHead2 = runHead;
var runIntoPubSub2 = runIntoPubSub;
var runIntoPubSubScoped2 = runIntoPubSubScoped;
var runIntoQueue2 = runIntoQueue;
var runIntoQueueElementsScoped2 = runIntoQueueElementsScoped;
var runIntoQueueScoped2 = runIntoQueueScoped;
var runLast2 = runLast;
var runScoped3 = runScoped2;
var runSum2 = runSum;
var scan2 = scan;
var scanEffect2 = scanEffect;
var scanReduce2 = scanReduce;
var scanReduceEffect2 = scanReduceEffect;
var schedule3 = schedule2;
var scheduleWith2 = scheduleWith;
var scoped6 = scoped5;
var scopedWith5 = scopedWith4;
var sliding8 = sliding7;
var slidingSize2 = slidingSize;
var some6 = some5;
var someOrElse2 = someOrElse;
var someOrFail2 = someOrFail;
var split2 = split;
var splitOnChunk2 = splitOnChunk;
var splitLines3 = splitLines2;
var succeed17 = succeed16;
var sync12 = sync11;
var suspend13 = suspend12;
var take8 = take7;
var takeRight3 = takeRight2;
var takeUntil4 = takeUntil3;
var takeUntilEffect2 = takeUntilEffect;
var takeWhile5 = takeWhile4;
var tap7 = tap6;
var tapBoth4 = tapBoth3;
var tapError6 = tapError5;
var tapErrorCause6 = tapErrorCause5;
var tapSink2 = tapSink;
var throttle2 = throttle;
var throttleEffect2 = throttleEffect;
var tick2 = tick;
var timeout4 = timeout3;
var timeoutFail4 = timeoutFail3;
var timeoutFailCause4 = timeoutFailCause3;
var timeoutTo4 = timeoutTo3;
var toPubSub3 = toPubSub2;
var toPull3 = toPull2;
var toQueue3 = toQueue2;
var toQueueOfElements2 = toQueueOfElements;
var toReadableStream2 = toReadableStream;
var toReadableStreamEffect2 = toReadableStreamEffect;
var toReadableStreamRuntime2 = toReadableStreamRuntime;
var transduce2 = transduce;
var unfold4 = unfold3;
var unfoldChunk2 = unfoldChunk;
var unfoldChunkEffect2 = unfoldChunkEffect;
var unfoldEffect2 = unfoldEffect;
var void_8 = void_7;
var unwrap5 = unwrap4;
var unwrapScoped5 = unwrapScoped4;
var unwrapScopedWith4 = unwrapScopedWith3;
var updateService5 = updateService4;
var when4 = when3;
var whenCase2 = whenCase;
var whenCaseEffect2 = whenCaseEffect;
var whenEffect4 = whenEffect3;
var withSpan7 = withSpan6;
var zip10 = zip9;
var zipFlatten2 = zipFlatten;
var zipAll2 = zipAll;
var zipAllLeft2 = zipAllLeft;
var zipAllRight2 = zipAllRight;
var zipAllSortedByKey2 = zipAllSortedByKey;
var zipAllSortedByKeyLeft2 = zipAllSortedByKeyLeft;
var zipAllSortedByKeyRight2 = zipAllSortedByKeyRight;
var zipAllSortedByKeyWith2 = zipAllSortedByKeyWith;
var zipAllWith2 = zipAllWith;
var zipLatest2 = zipLatest;
var zipLatestAll2 = zipLatestAll;
var zipLatestWith2 = zipLatestWith;
var zipLeft6 = zipLeft5;
var zipRight9 = zipRight8;
var zipWith13 = zipWith12;
var zipWithChunks2 = zipWithChunks;
var zipWithNext2 = zipWithNext;
var zipWithPrevious2 = zipWithPrevious;
var zipWithPreviousAndNext2 = zipWithPreviousAndNext;
var zipWithIndex2 = zipWithIndex;
var Do4 = Do3;
var bind5 = bind4;
var bindEffect2 = bindEffect;
var bindTo5 = bindTo4;
var let_5 = let_4;
var decodeText2 = decodeText;
var encodeText2 = encodeText;
var fromEventListener2 = fromEventListener;

// node_modules/.pnpm/@effect+platform@0.80.2_effect@3.14.2/node_modules/@effect/platform/dist/esm/internal/error.js
var PlatformErrorTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Error/PlatformErrorTypeId");
var make55 = (tag) => (props) => struct2({
  [PlatformErrorTypeId]: PlatformErrorTypeId,
  _tag: tag,
  ...props
});
var systemError = /* @__PURE__ */ make55("SystemError");

// node_modules/.pnpm/@effect+platform@0.80.2_effect@3.14.2/node_modules/@effect/platform/dist/esm/Error.js
var SystemError = systemError;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Channel.js
var acquireUseRelease4 = acquireUseRelease3;
var embedInput2 = embedInput;
var flatMap18 = flatMap13;
var suspend14 = suspend8;
var void_9 = void_5;
var write2 = write;
var zipRight10 = zipRight5;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/internal/mailbox.js
var TypeId17 = /* @__PURE__ */ Symbol.for("effect/Mailbox");
var ReadonlyTypeId = /* @__PURE__ */ Symbol.for("effect/Mailbox/ReadonlyMailbox");
var empty33 = /* @__PURE__ */ empty2();
var exitEmpty = /* @__PURE__ */ exitSucceed(empty33);
var exitFalse = /* @__PURE__ */ exitSucceed(false);
var exitTrue = /* @__PURE__ */ exitSucceed(true);
var constDone = [empty33, true];
var MailboxImpl = class extends Class2 {
  scheduler;
  capacity;
  strategy;
  [TypeId17] = TypeId17;
  [ReadonlyTypeId] = ReadonlyTypeId;
  state = {
    _tag: "Open",
    takers: /* @__PURE__ */ new Set(),
    offers: /* @__PURE__ */ new Set(),
    awaiters: /* @__PURE__ */ new Set()
  };
  messages = [];
  messagesChunk = /* @__PURE__ */ empty2();
  constructor(scheduler, capacity7, strategy) {
    super();
    this.scheduler = scheduler;
    this.capacity = capacity7;
    this.strategy = strategy;
  }
  offer(message) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return exitFalse;
      } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
        switch (this.strategy) {
          case "dropping":
            return exitFalse;
          case "suspend":
            if (this.capacity <= 0 && this.state.takers.size > 0) {
              this.messages.push(message);
              this.releaseTaker();
              return exitTrue;
            }
            return this.offerRemainingSingle(message);
          case "sliding":
            this.unsafeTake();
            this.messages.push(message);
            return exitTrue;
        }
      }
      this.messages.push(message);
      this.scheduleReleaseTaker();
      return exitTrue;
    });
  }
  unsafeOffer(message) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
      if (this.strategy === "sliding") {
        this.unsafeTake();
        this.messages.push(message);
        return true;
      } else if (this.capacity <= 0 && this.state.takers.size > 0) {
        this.messages.push(message);
        this.releaseTaker();
        return true;
      }
      return false;
    }
    this.messages.push(message);
    this.scheduleReleaseTaker();
    return true;
  }
  offerAll(messages) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return succeed(fromIterable2(messages));
      }
      const remaining = this.unsafeOfferAllArray(messages);
      if (remaining.length === 0) {
        return exitEmpty;
      } else if (this.strategy === "dropping") {
        return succeed(unsafeFromArray(remaining));
      }
      return this.offerRemainingArray(remaining);
    });
  }
  unsafeOfferAll(messages) {
    return unsafeFromArray(this.unsafeOfferAllArray(messages));
  }
  unsafeOfferAllArray(messages) {
    if (this.state._tag !== "Open") {
      return fromIterable(messages);
    } else if (this.capacity === Number.POSITIVE_INFINITY || this.strategy === "sliding") {
      if (this.messages.length > 0) {
        this.messagesChunk = appendAll2(this.messagesChunk, unsafeFromArray(this.messages));
      }
      if (this.strategy === "sliding") {
        this.messagesChunk = this.messagesChunk.pipe(appendAll2(fromIterable2(messages)), takeRight(this.capacity));
      } else if (isChunk(messages)) {
        this.messagesChunk = appendAll2(this.messagesChunk, messages);
      } else {
        this.messages = fromIterable(messages);
      }
      this.scheduleReleaseTaker();
      return [];
    }
    const free = this.capacity <= 0 ? this.state.takers.size : this.capacity - this.messages.length - this.messagesChunk.length;
    if (free === 0) {
      return fromIterable(messages);
    }
    const remaining = [];
    let i = 0;
    for (const message of messages) {
      if (i < free) {
        this.messages.push(message);
      } else {
        remaining.push(message);
      }
      i++;
    }
    this.scheduleReleaseTaker();
    return remaining;
  }
  fail(error4) {
    return this.done(exitFail(error4));
  }
  failCause(cause3) {
    return this.done(exitFailCause(cause3));
  }
  unsafeDone(exit4) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.state.offers.size === 0 && this.messages.length === 0 && this.messagesChunk.length === 0) {
      this.finalize(exit4);
      return true;
    }
    this.state = {
      ...this.state,
      _tag: "Closing",
      exit: exit4
    };
    return true;
  }
  shutdown = /* @__PURE__ */ sync(() => {
    if (this.state._tag === "Done") {
      return true;
    }
    this.messages = [];
    this.messagesChunk = empty33;
    const offers = this.state.offers;
    this.finalize(this.state._tag === "Open" ? exitVoid : this.state.exit);
    if (offers.size > 0) {
      for (const entry of offers) {
        if (entry._tag === "Single") {
          entry.resume(exitFalse);
        } else {
          entry.resume(exitSucceed(unsafeFromArray(entry.remaining.slice(entry.offset))));
        }
      }
      offers.clear();
    }
    return true;
  });
  done(exit4) {
    return sync(() => this.unsafeDone(exit4));
  }
  end = /* @__PURE__ */ this.done(exitVoid);
  clear = /* @__PURE__ */ suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, empty33);
    }
    const messages = this.unsafeTakeAll();
    this.releaseCapacity();
    return succeed(messages);
  });
  takeAll = /* @__PURE__ */ suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, constDone);
    }
    const messages = this.unsafeTakeAll();
    if (messages.length === 0) {
      return zipRight(this.awaitTake, this.takeAll);
    }
    return succeed([messages, this.releaseCapacity()]);
  });
  takeN(n2) {
    return suspend(() => {
      if (this.state._tag === "Done") {
        return exitAs(this.state.exit, constDone);
      } else if (n2 <= 0) {
        return succeed([empty33, false]);
      }
      n2 = Math.min(n2, this.capacity);
      let messages;
      if (n2 <= this.messagesChunk.length) {
        messages = take(this.messagesChunk, n2);
        this.messagesChunk = drop2(this.messagesChunk, n2);
      } else if (n2 <= this.messages.length + this.messagesChunk.length) {
        this.messagesChunk = appendAll2(this.messagesChunk, unsafeFromArray(this.messages));
        this.messages = [];
        messages = take(this.messagesChunk, n2);
        this.messagesChunk = drop2(this.messagesChunk, n2);
      } else {
        return zipRight(this.awaitTake, this.takeN(n2));
      }
      return succeed([messages, this.releaseCapacity()]);
    });
  }
  unsafeTake() {
    if (this.state._tag === "Done") {
      return exitZipRight(this.state.exit, exitFail(new NoSuchElementException2()));
    }
    let message;
    if (this.messagesChunk.length > 0) {
      message = unsafeHead2(this.messagesChunk);
      this.messagesChunk = drop2(this.messagesChunk, 1);
    } else if (this.messages.length > 0) {
      message = this.messages[0];
      this.messagesChunk = drop2(unsafeFromArray(this.messages), 1);
      this.messages = [];
    } else if (this.capacity <= 0 && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return this.messages.length > 0 ? exitSucceed(this.messages.pop()) : void 0;
    } else {
      return void 0;
    }
    this.releaseCapacity();
    return exitSucceed(message);
  }
  take = /* @__PURE__ */ suspend(() => this.unsafeTake() ?? zipRight(this.awaitTake, this.take));
  await = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.awaiters.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.awaiters.delete(resume2);
      }
    });
  });
  unsafeSize() {
    const size16 = this.messages.length + this.messagesChunk.length;
    return this.state._tag === "Done" ? none2() : some2(size16);
  }
  size = /* @__PURE__ */ sync(() => this.unsafeSize());
  commit() {
    return this.takeAll;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "effect/Mailbox",
      state: this.state._tag,
      size: this.unsafeSize().toJSON()
    };
  }
  toString() {
    return format(this);
  }
  [NodeInspectSymbol]() {
    return format(this);
  }
  offerRemainingSingle(message) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitFalse);
      }
      const entry = {
        _tag: "Single",
        message,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  offerRemainingArray(remaining) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitSucceed(unsafeFromArray(remaining)));
      }
      const entry = {
        _tag: "Array",
        remaining,
        offset: 0,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  releaseCapacity() {
    if (this.state._tag === "Done") {
      return this.state.exit._tag === "Success";
    } else if (this.state.offers.size === 0) {
      if (this.state._tag === "Closing" && this.messages.length === 0 && this.messagesChunk.length === 0) {
        this.finalize(this.state.exit);
        return this.state.exit._tag === "Success";
      }
      return false;
    }
    let n2 = this.capacity - this.messages.length - this.messagesChunk.length;
    for (const entry of this.state.offers) {
      if (n2 === 0) return false;
      else if (entry._tag === "Single") {
        this.messages.push(entry.message);
        n2--;
        entry.resume(exitTrue);
        this.state.offers.delete(entry);
      } else {
        for (; entry.offset < entry.remaining.length; entry.offset++) {
          if (n2 === 0) return false;
          this.messages.push(entry.remaining[entry.offset]);
          n2--;
        }
        entry.resume(exitEmpty);
        this.state.offers.delete(entry);
      }
    }
    return false;
  }
  awaitTake = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.takers.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.takers.delete(resume2);
      }
    });
  });
  scheduleRunning = false;
  scheduleReleaseTaker() {
    if (this.scheduleRunning) {
      return;
    }
    this.scheduleRunning = true;
    this.scheduler.scheduleTask(this.releaseTaker, 0);
  }
  releaseTaker = () => {
    this.scheduleRunning = false;
    if (this.state._tag === "Done") {
      return;
    } else if (this.state.takers.size === 0) {
      return;
    }
    const taker = unsafeHead(this.state.takers);
    this.state.takers.delete(taker);
    taker(exitVoid);
  };
  unsafeTakeAll() {
    if (this.messagesChunk.length > 0) {
      const messages = this.messages.length > 0 ? appendAll2(this.messagesChunk, unsafeFromArray(this.messages)) : this.messagesChunk;
      this.messagesChunk = empty33;
      this.messages = [];
      return messages;
    } else if (this.messages.length > 0) {
      const messages = unsafeFromArray(this.messages);
      this.messages = [];
      return messages;
    } else if (this.state._tag !== "Done" && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return of2(this.messages.pop());
    }
    return empty33;
  }
  finalize(exit4) {
    if (this.state._tag === "Done") {
      return;
    }
    const openState = this.state;
    this.state = {
      _tag: "Done",
      exit: exit4
    };
    for (const taker of openState.takers) {
      taker(exit4);
    }
    openState.takers.clear();
    for (const awaiter of openState.awaiters) {
      awaiter(exit4);
    }
    openState.awaiters.clear();
  }
};
var make56 = (capacity7) => withFiberRuntime((fiber) => succeed(new MailboxImpl(fiber.currentScheduler, typeof capacity7 === "number" ? capacity7 : capacity7?.capacity ?? Number.POSITIVE_INFINITY, typeof capacity7 === "number" ? "suspend" : capacity7?.strategy ?? "suspend")));

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Mailbox.js
var make57 = make56;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/ConfigProvider.js
var ConfigProvider_exports = {};
__export(ConfigProvider_exports, {
  ConfigProvider: () => ConfigProvider,
  ConfigProviderTypeId: () => ConfigProviderTypeId2,
  FlatConfigProviderTypeId: () => FlatConfigProviderTypeId2,
  constantCase: () => constantCase3,
  fromEnv: () => fromEnv2,
  fromFlat: () => fromFlat2,
  fromJson: () => fromJson2,
  fromMap: () => fromMap2,
  kebabCase: () => kebabCase3,
  lowerCase: () => lowerCase3,
  make: () => make58,
  makeFlat: () => makeFlat2,
  mapInputPath: () => mapInputPath2,
  nested: () => nested5,
  orElse: () => orElse13,
  snakeCase: () => snakeCase3,
  unnested: () => unnested3,
  upperCase: () => upperCase3,
  within: () => within2
});
var ConfigProviderTypeId2 = ConfigProviderTypeId;
var FlatConfigProviderTypeId2 = FlatConfigProviderTypeId;
var ConfigProvider = configProviderTag;
var make58 = make20;
var makeFlat2 = makeFlat;
var fromEnv2 = fromEnv;
var fromFlat2 = fromFlat;
var fromJson2 = fromJson;
var fromMap2 = fromMap;
var constantCase3 = constantCase2;
var mapInputPath2 = mapInputPath;
var kebabCase3 = kebabCase2;
var lowerCase3 = lowerCase2;
var nested5 = nested2;
var orElse13 = orElse3;
var unnested3 = unnested2;
var snakeCase3 = snakeCase2;
var upperCase3 = upperCase2;
var within2 = within;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Console.js
var Console_exports = {};
__export(Console_exports, {
  Console: () => Console,
  TypeId: () => TypeId18,
  assert: () => assert2,
  clear: () => clear2,
  consoleWith: () => consoleWith3,
  count: () => count4,
  countReset: () => countReset2,
  debug: () => debug2,
  dir: () => dir2,
  dirxml: () => dirxml2,
  error: () => error2,
  group: () => group2,
  info: () => info2,
  log: () => log4,
  setConsole: () => setConsole2,
  table: () => table2,
  time: () => time2,
  timeLog: () => timeLog2,
  trace: () => trace2,
  warn: () => warn2,
  withConsole: () => withConsole3,
  withGroup: () => withGroup2,
  withTime: () => withTime2
});
var TypeId18 = TypeId8;
var Console = consoleTag;
var withConsole3 = withConsole;
var setConsole2 = setConsole;
var consoleWith3 = consoleWith;
var assert2 = assert;
var clear2 = clear;
var count4 = count;
var countReset2 = countReset;
var debug2 = debug;
var dir2 = dir;
var dirxml2 = dirxml;
var error2 = error;
var group2 = group;
var info2 = info;
var log4 = log2;
var table2 = table;
var time2 = time;
var timeLog2 = timeLog;
var trace2 = trace;
var warn2 = warn;
var withGroup2 = withGroup;
var withTime2 = withTime;

// node_modules/.pnpm/effect@3.14.2/node_modules/effect/dist/esm/Logger.js
var defaultLogger2 = defaultLogger;
var prettyLoggerDefault2 = prettyLoggerDefault;
var fromReadable = (evaluate3, onError7, {
  chunkSize
} = {}) => fromChannel3(fromReadableChannel(evaluate3, onError7, chunkSize ? Number(chunkSize) : void 0));
var toString = (readable, options) => {
  const maxBytesNumber = options.maxBytes ? Number(options.maxBytes) : void 0;
  return acquireUseRelease2(sync4(() => {
    const stream = readable();
    stream.setEncoding(options.encoding ?? "utf8");
    return stream;
  }), (stream) => async2((resume2) => {
    let string4 = "";
    let bytes = 0;
    stream.once("error", (err) => {
      resume2(fail9(options.onFailure(err)));
    });
    stream.once("end", () => {
      resume2(succeed8(string4));
    });
    stream.on("data", (chunk5) => {
      string4 += chunk5;
      bytes += Buffer.byteLength(chunk5);
      if (maxBytesNumber && bytes > maxBytesNumber) {
        resume2(fail9(options.onFailure(new Error("maxBytes exceeded"))));
      }
    });
  }), (stream) => sync4(() => {
    if ("closed" in stream && !stream.closed) {
      stream.destroy();
    }
  }));
};
var toUint8Array = (readable, options) => {
  const maxBytesNumber = options.maxBytes ? Number(options.maxBytes) : void 0;
  return acquireUseRelease2(sync4(readable), (stream) => async2((resume2) => {
    let buffer4 = Buffer.alloc(0);
    let bytes = 0;
    stream.once("error", (err) => {
      resume2(fail9(options.onFailure(err)));
    });
    stream.once("end", () => {
      resume2(succeed8(buffer4));
    });
    stream.on("data", (chunk5) => {
      buffer4 = Buffer.concat([buffer4, chunk5]);
      bytes += chunk5.length;
      if (maxBytesNumber && bytes > maxBytesNumber) {
        resume2(fail9(options.onFailure(new Error("maxBytes exceeded"))));
      }
    });
  }), (stream) => sync4(() => {
    if ("closed" in stream && !stream.closed) {
      stream.destroy();
    }
  }));
};
var fromDuplex = (evaluate3, onError7, options = {}) => acquireUseRelease4(tap3(zip5(sync4(evaluate3), make57()), ([duplex, mailbox]) => readableOffer(duplex, mailbox, onError7)), ([duplex, mailbox]) => embedInput2(readableTake(duplex, mailbox, options.chunkSize ? Number(options.chunkSize) : void 0), writeInput(duplex, (cause3) => mailbox.failCause(cause3), options)), ([duplex, mailbox]) => zipRight3(sync4(() => {
  if (!duplex.closed) {
    duplex.destroy();
  }
}), mailbox.shutdown));
var pipeThroughDuplex = /* @__PURE__ */ dual((args2) => StreamTypeId3 in args2[0], (self2, duplex, onError7, options) => pipeThroughChannelOrFail2(self2, fromDuplex(duplex, onError7, options)));
var pipeThroughSimple = /* @__PURE__ */ dual(2, (self2, duplex) => pipeThroughChannelOrFail2(self2, fromDuplex(duplex, (error4) => SystemError({
  module: "Stream",
  method: "pipeThroughSimple",
  pathOrDescriptor: "",
  reason: "Unknown",
  message: String(error4)
}))));
var fromReadableChannel = (evaluate3, onError7, chunkSize) => acquireUseRelease4(tap3(zip5(sync4(evaluate3), make57()), ([readable, mailbox]) => readableOffer(readable, mailbox, onError7)), ([readable, mailbox]) => readableTake(readable, mailbox, chunkSize), ([readable, mailbox]) => zipRight3(sync4(() => {
  if ("closed" in readable && !readable.closed) {
    readable.destroy();
  }
}), mailbox.shutdown));
var writeInput = (writable, onFailure, {
  encoding,
  endOnDone = true
} = {}, onDone3 = _void) => {
  const write3 = writeEffect(writable, encoding);
  const close2 = endOnDone ? async2((resume2) => {
    if ("closed" in writable && writable.closed) {
      resume2(_void);
    } else {
      writable.once("finish", () => resume2(_void));
      writable.end();
    }
  }) : _void;
  return {
    awaitRead: () => _void,
    emit: write3,
    error: (cause3) => zipRight3(close2, onFailure(cause3)),
    done: (_2) => zipRight3(close2, onDone3)
  };
};
var writeEffect = (writable, encoding) => (chunk5) => chunk5.length === 0 ? _void : async2((resume2) => {
  const iterator = chunk5[Symbol.iterator]();
  let next = iterator.next();
  function loop3() {
    const item = next;
    next = iterator.next();
    const success = writable.write(item.value, encoding);
    if (next.done) {
      resume2(_void);
    } else if (success) {
      loop3();
    } else {
      writable.once("drain", loop3);
    }
  }
  loop3();
});
var readableOffer = (readable, mailbox, onError7) => sync4(() => {
  readable.on("readable", () => {
    mailbox.unsafeOffer(void 0);
  });
  readable.on("error", (err) => {
    mailbox.unsafeDone(fail4(onError7(err)));
  });
  readable.on("end", () => {
    mailbox.unsafeDone(void_3);
  });
  if (readable.readable) {
    mailbox.unsafeOffer(void 0);
  }
});
var readableTake = (readable, mailbox, chunkSize) => {
  const read2 = readChunkChannel(readable, chunkSize);
  const loop3 = flatMap18(mailbox.takeAll, ([, done11]) => done11 ? read2 : zipRight10(read2, loop3));
  return loop3;
};
var readChunkChannel = (readable, chunkSize) => suspend14(() => {
  const arr = [];
  let chunk5 = readable.read(chunkSize);
  if (chunk5 === null) {
    return void_9;
  }
  while (chunk5 !== null) {
    arr.push(chunk5);
    chunk5 = readable.read(chunkSize);
  }
  return write2(unsafeFromArray(arr));
});
var StreamAdapter = class extends stream.Readable {
  readLatch;
  fiber = void 0;
  constructor(runtime4, stream) {
    super({});
    this.readLatch = unsafeMakeLatch2(false);
    this.fiber = runFork3(runtime4)(runForEachChunk2(stream, (chunk5) => this.readLatch.whenOpen(sync4(() => {
      if (chunk5.length === 0) return;
      this.readLatch.unsafeClose();
      for (const item of chunk5) {
        if (typeof item === "string") {
          this.push(item, "utf8");
        } else {
          this.push(item);
        }
      }
    }))));
    this.fiber.addObserver((exit4) => {
      this.fiber = void 0;
      if (isSuccess2(exit4)) {
        this.push(null);
      } else {
        this._destroy(squash(exit4.cause), constVoid);
      }
    });
  }
  _read(_size) {
    runSync(this.readLatch.open);
  }
  _destroy(_error, callback) {
    if (!this.fiber) {
      return callback(null);
    }
    runFork2(interrupt6(this.fiber)).addObserver((exit4) => {
      callback(exit4._tag === "Failure" ? squash(exit4.cause) : null);
    });
  }
};
var toReadable = (stream) => map16(runtime3(), (runtime4) => new StreamAdapter(runtime4, stream));
var toReadableNever = (stream) => new StreamAdapter(defaultRuntime2, stream);

// node_modules/.pnpm/@effect+platform-node@0.76.5_@effect+cluster@0.29.5_@effect+platform@0.80.2_effect@3.14_5932c3b361b09d56baff336920e7e328/node_modules/@effect/platform-node/dist/esm/NodeStream.js
var NodeStream_exports = {};
__export(NodeStream_exports, {
  fromDuplex: () => fromDuplex2,
  fromReadable: () => fromReadable2,
  fromReadableChannel: () => fromReadableChannel2,
  pipeThroughDuplex: () => pipeThroughDuplex2,
  pipeThroughSimple: () => pipeThroughSimple2,
  toReadable: () => toReadable2,
  toReadableNever: () => toReadableNever2,
  toString: () => toString2,
  toUint8Array: () => toUint8Array2
});

// node_modules/.pnpm/@effect+platform-node-shared@0.30.5_@effect+cluster@0.29.5_@effect+platform@0.80.2_effe_0ce7704d95c1c3436a1eb1cff9d398b2/node_modules/@effect/platform-node-shared/dist/esm/NodeStream.js
var fromReadable2 = fromReadable;
var fromReadableChannel2 = fromReadableChannel;
var fromDuplex2 = fromDuplex;
var pipeThroughDuplex2 = pipeThroughDuplex;
var pipeThroughSimple2 = pipeThroughSimple;
var toReadable2 = toReadable;
var toReadableNever2 = toReadableNever;
var toString2 = toString;
var toUint8Array2 = toUint8Array;

// node_modules/.pnpm/@effect+platform-node@0.76.5_@effect+cluster@0.29.5_@effect+platform@0.80.2_effect@3.14_5932c3b361b09d56baff336920e7e328/node_modules/@effect/platform-node/dist/esm/Undici.js
var Undici_exports = {};
__reExport(Undici_exports, __toESM(require_undici()));

// node_modules/.pnpm/@effect+platform-node@0.76.5_@effect+cluster@0.29.5_@effect+platform@0.80.2_effect@3.14_5932c3b361b09d56baff336920e7e328/node_modules/@effect/platform-node/dist/esm/NodeRuntime.js
var NodeRuntime_exports = {};
__export(NodeRuntime_exports, {
  runMain: () => runMain3
});

// node_modules/.pnpm/@effect+platform@0.80.2_effect@3.14.2/node_modules/@effect/platform/dist/esm/Runtime.js
var defaultTeardown = (exit4, onExit4) => {
  onExit4(isFailure2(exit4) && !isInterruptedOnly2(exit4.cause) ? 1 : 0);
};
var addPrettyLogger = (refs, fiberId3) => {
  const loggers = getOrDefault2(refs, currentLoggers2);
  if (!has3(loggers, defaultLogger2)) {
    return refs;
  }
  return updateAs2(refs, {
    fiberId: fiberId3,
    fiberRef: currentLoggers2,
    value: loggers.pipe(remove4(defaultLogger2), add4(prettyLoggerDefault2))
  });
};
var makeRunMain = (f2) => dual((args2) => isEffect2(args2[0]), (effect4, options) => {
  const fiber = options?.disableErrorReporting === true ? runFork2(effect4, {
    updateRefs: options?.disablePrettyLogger === true ? void 0 : addPrettyLogger
  }) : runFork2(tapErrorCause3(effect4, (cause3) => {
    if (isInterruptedOnly2(cause3)) {
      return _void;
    }
    return logError2(cause3);
  }), {
    updateRefs: options?.disablePrettyLogger === true ? void 0 : addPrettyLogger
  });
  const teardown = options?.teardown ?? defaultTeardown;
  return f2({
    fiber,
    teardown
  });
});

// node_modules/.pnpm/@effect+platform-node-shared@0.30.5_@effect+cluster@0.29.5_@effect+platform@0.80.2_effe_0ce7704d95c1c3436a1eb1cff9d398b2/node_modules/@effect/platform-node-shared/dist/esm/internal/runtime.js
var runMain = /* @__PURE__ */ makeRunMain(({
  fiber,
  teardown
}) => {
  const keepAlive = setInterval(constVoid, 2 ** 31 - 1);
  let receivedSignal = false;
  fiber.addObserver((exit4) => {
    if (!receivedSignal) {
      process.removeListener("SIGINT", onSigint);
      process.removeListener("SIGTERM", onSigint);
    }
    clearInterval(keepAlive);
    teardown(exit4, (code) => {
      if (receivedSignal || code !== 0) {
        process.exit(code);
      }
    });
  });
  function onSigint() {
    receivedSignal = true;
    process.removeListener("SIGINT", onSigint);
    process.removeListener("SIGTERM", onSigint);
    fiber.unsafeInterruptAsFork(fiber.id());
  }
  process.on("SIGINT", onSigint);
  process.on("SIGTERM", onSigint);
});

// node_modules/.pnpm/@effect+platform-node-shared@0.30.5_@effect+cluster@0.29.5_@effect+platform@0.80.2_effe_0ce7704d95c1c3436a1eb1cff9d398b2/node_modules/@effect/platform-node-shared/dist/esm/NodeRuntime.js
var runMain2 = runMain;

// node_modules/.pnpm/@effect+platform-node@0.76.5_@effect+cluster@0.29.5_@effect+platform@0.80.2_effect@3.14_5932c3b361b09d56baff336920e7e328/node_modules/@effect/platform-node/dist/esm/NodeRuntime.js
var runMain3 = runMain2;

// node_modules/.pnpm/simple-git@3.27.0/node_modules/simple-git/dist/esm/index.js
var import_file_exists = __toESM(require_dist());
var import_debug = __toESM(require_src());
var import_promise_deferred = __toESM(require_dist2());
var import_promise_deferred2 = __toESM(require_dist2());
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp(a2, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b) => __defProps(a2, __getOwnPropDescs(b));
var __esm2 = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames2(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS2 = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export2 = (target, all8) => {
  for (var name in all8)
    __defProp2(target, name, { get: all8[name], enumerable: true });
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve9, reject) => {
    var fulfilled = (value) => {
      try {
        step4(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step4(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step4 = (x2) => x2.done ? resolve9(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step4((generator = generator.apply(__this, __arguments)).next());
  });
};
function pathspec(...paths) {
  const key = new String(paths);
  cache.set(key, paths);
  return key;
}
function isPathSpec(path3) {
  return path3 instanceof String && cache.has(path3);
}
function toPaths(pathSpec) {
  return cache.get(pathSpec) || [];
}
var cache;
var init_pathspec = __esm2({
  "src/lib/args/pathspec.ts"() {
    cache = /* @__PURE__ */ new WeakMap();
  }
});
var GitError;
var init_git_error = __esm2({
  "src/lib/errors/git-error.ts"() {
    GitError = class extends Error {
      constructor(task, message) {
        super(message);
        this.task = task;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
  }
});
var GitResponseError;
var init_git_response_error = __esm2({
  "src/lib/errors/git-response-error.ts"() {
    init_git_error();
    GitResponseError = class extends GitError {
      constructor(git, message) {
        super(void 0, message || String(git));
        this.git = git;
      }
    };
  }
});
var TaskConfigurationError;
var init_task_configuration_error = __esm2({
  "src/lib/errors/task-configuration-error.ts"() {
    init_git_error();
    TaskConfigurationError = class extends GitError {
      constructor(message) {
        super(void 0, message);
      }
    };
  }
});
function asFunction(source) {
  return typeof source === "function" ? source : NOOP;
}
function isUserFunction(source) {
  return typeof source === "function" && source !== NOOP;
}
function splitOn(input2, char) {
  const index = input2.indexOf(char);
  if (index <= 0) {
    return [input2, ""];
  }
  return [input2.substr(0, index), input2.substr(index + 1)];
}
function first2(input2, offset = 0) {
  return isArrayLike(input2) && input2.length > offset ? input2[offset] : void 0;
}
function last5(input2, offset = 0) {
  if (isArrayLike(input2) && input2.length > offset) {
    return input2[input2.length - 1 - offset];
  }
}
function isArrayLike(input2) {
  return !!(input2 && typeof input2.length === "number");
}
function toLinesWithContent(input2 = "", trimmed2 = true, separator = "\n") {
  return input2.split(separator).reduce((output, line) => {
    const lineContent = trimmed2 ? line.trim() : line;
    if (lineContent) {
      output.push(lineContent);
    }
    return output;
  }, []);
}
function forEachLineWithContent(input2, callback) {
  return toLinesWithContent(input2, true).map((line) => callback(line));
}
function folderExists(path3) {
  return (0, import_file_exists.exists)(path3, import_file_exists.FOLDER);
}
function append4(target, item) {
  if (Array.isArray(target)) {
    if (!target.includes(item)) {
      target.push(item);
    }
  } else {
    target.add(item);
  }
  return item;
}
function including(target, item) {
  if (Array.isArray(target) && !target.includes(item)) {
    target.push(item);
  }
  return target;
}
function remove8(target, item) {
  if (Array.isArray(target)) {
    const index = target.indexOf(item);
    if (index >= 0) {
      target.splice(index, 1);
    }
  } else {
    target.delete(item);
  }
  return item;
}
function asArray(source) {
  return Array.isArray(source) ? source : [source];
}
function asCamelCase(str) {
  return str.replace(/[\s-]+(.)/g, (_all, chr) => {
    return chr.toUpperCase();
  });
}
function asStringArray(source) {
  return asArray(source).map(String);
}
function asNumber(source, onNaN = 0) {
  if (source == null) {
    return onNaN;
  }
  const num = parseInt(source, 10);
  return isNaN(num) ? onNaN : num;
}
function prefixedArray(input2, prefix) {
  const output = [];
  for (let i = 0, max5 = input2.length; i < max5; i++) {
    output.push(prefix, input2[i]);
  }
  return output;
}
function bufferToString(input2) {
  return (Array.isArray(input2) ? Buffer.concat(input2) : input2).toString("utf-8");
}
function pick2(source, properties) {
  return Object.assign(
    {},
    ...properties.map((property3) => property3 in source ? { [property3]: source[property3] } : {})
  );
}
function delay3(duration4 = 0) {
  return new Promise((done11) => setTimeout(done11, duration4));
}
function orVoid(input2) {
  if (input2 === false) {
    return void 0;
  }
  return input2;
}
var NULL;
var NOOP;
var objectToString;
var init_util = __esm2({
  "src/lib/utils/util.ts"() {
    NULL = "\0";
    NOOP = () => {
    };
    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);
  }
});
function filterType(input2, filter10, def) {
  if (filter10(input2)) {
    return input2;
  }
  return arguments.length > 2 ? def : void 0;
}
function filterPrimitives(input2, omit2) {
  const type = isPathSpec(input2) ? "string" : typeof input2;
  return /number|string|boolean/.test(type) && (!omit2 || !omit2.includes(type));
}
function filterPlainObject(input2) {
  return !!input2 && objectToString(input2) === "[object Object]";
}
function filterFunction(input2) {
  return typeof input2 === "function";
}
var filterArray;
var filterString;
var filterStringArray;
var filterStringOrStringArray;
var filterHasLength;
var init_argument_filters = __esm2({
  "src/lib/utils/argument-filters.ts"() {
    init_util();
    init_pathspec();
    filterArray = (input2) => {
      return Array.isArray(input2);
    };
    filterString = (input2) => {
      return typeof input2 === "string";
    };
    filterStringArray = (input2) => {
      return Array.isArray(input2) && input2.every(filterString);
    };
    filterStringOrStringArray = (input2) => {
      return filterString(input2) || Array.isArray(input2) && input2.every(filterString);
    };
    filterHasLength = (input2) => {
      if (input2 == null || "number|boolean|function".includes(typeof input2)) {
        return false;
      }
      return Array.isArray(input2) || typeof input2 === "string" || typeof input2.length === "number";
    };
  }
});
var ExitCodes;
var init_exit_codes = __esm2({
  "src/lib/utils/exit-codes.ts"() {
    ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {
      ExitCodes2[ExitCodes2["SUCCESS"] = 0] = "SUCCESS";
      ExitCodes2[ExitCodes2["ERROR"] = 1] = "ERROR";
      ExitCodes2[ExitCodes2["NOT_FOUND"] = -2] = "NOT_FOUND";
      ExitCodes2[ExitCodes2["UNCLEAN"] = 128] = "UNCLEAN";
      return ExitCodes2;
    })(ExitCodes || {});
  }
});
var GitOutputStreams;
var init_git_output_streams = __esm2({
  "src/lib/utils/git-output-streams.ts"() {
    GitOutputStreams = class {
      constructor(stdOut, stdErr) {
        this.stdOut = stdOut;
        this.stdErr = stdErr;
      }
      asStrings() {
        return new GitOutputStreams(this.stdOut.toString("utf8"), this.stdErr.toString("utf8"));
      }
    };
  }
});
var LineParser;
var RemoteLineParser;
var init_line_parser = __esm2({
  "src/lib/utils/line-parser.ts"() {
    LineParser = class {
      constructor(regExp, useMatches) {
        this.matches = [];
        this.parse = (line, target) => {
          this.resetMatches();
          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {
            return false;
          }
          return this.useMatches(target, this.prepareMatches()) !== false;
        };
        this._regExp = Array.isArray(regExp) ? regExp : [regExp];
        if (useMatches) {
          this.useMatches = useMatches;
        }
      }
      useMatches(target, match18) {
        throw new Error(`LineParser:useMatches not implemented`);
      }
      resetMatches() {
        this.matches.length = 0;
      }
      prepareMatches() {
        return this.matches;
      }
      addMatch(reg, index, line) {
        const matched = line && reg.exec(line);
        if (matched) {
          this.pushMatch(index, matched);
        }
        return !!matched;
      }
      pushMatch(_index, matched) {
        this.matches.push(...matched.slice(1));
      }
    };
    RemoteLineParser = class extends LineParser {
      addMatch(reg, index, line) {
        return /^remote:\s/.test(String(line)) && super.addMatch(reg, index, line);
      }
      pushMatch(index, matched) {
        if (index > 0 || matched.length > 1) {
          super.pushMatch(index, matched);
        }
      }
    };
  }
});
function createInstanceConfig(...options) {
  const baseDir = process.cwd();
  const config2 = Object.assign(
    __spreadValues({ baseDir }, defaultOptions),
    ...options.filter((o2) => typeof o2 === "object" && o2)
  );
  config2.baseDir = config2.baseDir || baseDir;
  config2.trimmed = config2.trimmed === true;
  return config2;
}
var defaultOptions;
var init_simple_git_options = __esm2({
  "src/lib/utils/simple-git-options.ts"() {
    defaultOptions = {
      binary: "git",
      maxConcurrentProcesses: 5,
      config: [],
      trimmed: false
    };
  }
});
function appendTaskOptions(options, commands = []) {
  if (!filterPlainObject(options)) {
    return commands;
  }
  return Object.keys(options).reduce((commands2, key) => {
    const value = options[key];
    if (isPathSpec(value)) {
      commands2.push(value);
    } else if (filterPrimitives(value, ["boolean"])) {
      commands2.push(key + "=" + value);
    } else {
      commands2.push(key);
    }
    return commands2;
  }, commands);
}
function getTrailingOptions(args2, initialPrimitive = 0, objectOnly = false) {
  const command = [];
  for (let i = 0, max5 = initialPrimitive < 0 ? args2.length : initialPrimitive; i < max5; i++) {
    if ("string|number".includes(typeof args2[i])) {
      command.push(String(args2[i]));
    }
  }
  appendTaskOptions(trailingOptionsArgument(args2), command);
  if (!objectOnly) {
    command.push(...trailingArrayArgument(args2));
  }
  return command;
}
function trailingArrayArgument(args2) {
  const hasTrailingCallback = typeof last5(args2) === "function";
  return filterType(last5(args2, hasTrailingCallback ? 1 : 0), filterArray, []);
}
function trailingOptionsArgument(args2) {
  const hasTrailingCallback = filterFunction(last5(args2));
  return filterType(last5(args2, hasTrailingCallback ? 1 : 0), filterPlainObject);
}
function trailingFunctionArgument(args2, includeNoop = true) {
  const callback = asFunction(last5(args2));
  return includeNoop || isUserFunction(callback) ? callback : void 0;
}
var init_task_options = __esm2({
  "src/lib/utils/task-options.ts"() {
    init_argument_filters();
    init_util();
    init_pathspec();
  }
});
function callTaskParser(parser4, streams) {
  return parser4(streams.stdOut, streams.stdErr);
}
function parseStringResponse(result, parsers12, texts, trim2 = true) {
  asArray(texts).forEach((text) => {
    for (let lines = toLinesWithContent(text, trim2), i = 0, max5 = lines.length; i < max5; i++) {
      const line = (offset = 0) => {
        if (i + offset >= max5) {
          return;
        }
        return lines[i + offset];
      };
      parsers12.some(({ parse: parse6 }) => parse6(line, result));
    }
  });
  return result;
}
var init_task_parser = __esm2({
  "src/lib/utils/task-parser.ts"() {
    init_util();
  }
});
var utils_exports = {};
__export2(utils_exports, {
  ExitCodes: () => ExitCodes,
  GitOutputStreams: () => GitOutputStreams,
  LineParser: () => LineParser,
  NOOP: () => NOOP,
  NULL: () => NULL,
  RemoteLineParser: () => RemoteLineParser,
  append: () => append4,
  appendTaskOptions: () => appendTaskOptions,
  asArray: () => asArray,
  asCamelCase: () => asCamelCase,
  asFunction: () => asFunction,
  asNumber: () => asNumber,
  asStringArray: () => asStringArray,
  bufferToString: () => bufferToString,
  callTaskParser: () => callTaskParser,
  createInstanceConfig: () => createInstanceConfig,
  delay: () => delay3,
  filterArray: () => filterArray,
  filterFunction: () => filterFunction,
  filterHasLength: () => filterHasLength,
  filterPlainObject: () => filterPlainObject,
  filterPrimitives: () => filterPrimitives,
  filterString: () => filterString,
  filterStringArray: () => filterStringArray,
  filterStringOrStringArray: () => filterStringOrStringArray,
  filterType: () => filterType,
  first: () => first2,
  folderExists: () => folderExists,
  forEachLineWithContent: () => forEachLineWithContent,
  getTrailingOptions: () => getTrailingOptions,
  including: () => including,
  isUserFunction: () => isUserFunction,
  last: () => last5,
  objectToString: () => objectToString,
  orVoid: () => orVoid,
  parseStringResponse: () => parseStringResponse,
  pick: () => pick2,
  prefixedArray: () => prefixedArray,
  remove: () => remove8,
  splitOn: () => splitOn,
  toLinesWithContent: () => toLinesWithContent,
  trailingFunctionArgument: () => trailingFunctionArgument,
  trailingOptionsArgument: () => trailingOptionsArgument
});
var init_utils = __esm2({
  "src/lib/utils/index.ts"() {
    init_argument_filters();
    init_exit_codes();
    init_git_output_streams();
    init_line_parser();
    init_simple_git_options();
    init_task_options();
    init_task_parser();
    init_util();
  }
});
var check_is_repo_exports = {};
__export2(check_is_repo_exports, {
  CheckRepoActions: () => CheckRepoActions,
  checkIsBareRepoTask: () => checkIsBareRepoTask,
  checkIsRepoRootTask: () => checkIsRepoRootTask,
  checkIsRepoTask: () => checkIsRepoTask
});
function checkIsRepoTask(action) {
  switch (action) {
    case "bare":
      return checkIsBareRepoTask();
    case "root":
      return checkIsRepoRootTask();
  }
  const commands = ["rev-parse", "--is-inside-work-tree"];
  return {
    commands,
    format: "utf-8",
    onError: onError5,
    parser
  };
}
function checkIsRepoRootTask() {
  const commands = ["rev-parse", "--git-dir"];
  return {
    commands,
    format: "utf-8",
    onError: onError5,
    parser(path3) {
      return /^\.(git)?$/.test(path3.trim());
    }
  };
}
function checkIsBareRepoTask() {
  const commands = ["rev-parse", "--is-bare-repository"];
  return {
    commands,
    format: "utf-8",
    onError: onError5,
    parser
  };
}
function isNotRepoMessage(error4) {
  return /(Not a git repository|Kein Git-Repository)/i.test(String(error4));
}
var CheckRepoActions;
var onError5;
var parser;
var init_check_is_repo = __esm2({
  "src/lib/tasks/check-is-repo.ts"() {
    init_utils();
    CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {
      CheckRepoActions2["BARE"] = "bare";
      CheckRepoActions2["IN_TREE"] = "tree";
      CheckRepoActions2["IS_REPO_ROOT"] = "root";
      return CheckRepoActions2;
    })(CheckRepoActions || {});
    onError5 = ({ exitCode }, error4, done11, fail19) => {
      if (exitCode === 128 && isNotRepoMessage(error4)) {
        return done11(Buffer.from("false"));
      }
      fail19(error4);
    };
    parser = (text) => {
      return text.trim() === "true";
    };
  }
});
function cleanSummaryParser(dryRun, text) {
  const summary5 = new CleanResponse(dryRun);
  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;
  toLinesWithContent(text).forEach((line) => {
    const removed = line.replace(regexp, "");
    summary5.paths.push(removed);
    (isFolderRegexp.test(removed) ? summary5.folders : summary5.files).push(removed);
  });
  return summary5;
}
var CleanResponse;
var removalRegexp;
var dryRunRemovalRegexp;
var isFolderRegexp;
var init_CleanSummary = __esm2({
  "src/lib/responses/CleanSummary.ts"() {
    init_utils();
    CleanResponse = class {
      constructor(dryRun) {
        this.dryRun = dryRun;
        this.paths = [];
        this.files = [];
        this.folders = [];
      }
    };
    removalRegexp = /^[a-z]+\s*/i;
    dryRunRemovalRegexp = /^[a-z]+\s+[a-z]+\s*/i;
    isFolderRegexp = /\/$/;
  }
});
var task_exports = {};
__export2(task_exports, {
  EMPTY_COMMANDS: () => EMPTY_COMMANDS,
  adhocExecTask: () => adhocExecTask,
  configurationErrorTask: () => configurationErrorTask,
  isBufferTask: () => isBufferTask,
  isEmptyTask: () => isEmptyTask,
  straightThroughBufferTask: () => straightThroughBufferTask,
  straightThroughStringTask: () => straightThroughStringTask
});
function adhocExecTask(parser4) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser: parser4
  };
}
function configurationErrorTask(error4) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser() {
      throw typeof error4 === "string" ? new TaskConfigurationError(error4) : error4;
    }
  };
}
function straightThroughStringTask(commands, trimmed2 = false) {
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return trimmed2 ? String(text).trim() : text;
    }
  };
}
function straightThroughBufferTask(commands) {
  return {
    commands,
    format: "buffer",
    parser(buffer4) {
      return buffer4;
    }
  };
}
function isBufferTask(task) {
  return task.format === "buffer";
}
function isEmptyTask(task) {
  return task.format === "empty" || !task.commands.length;
}
var EMPTY_COMMANDS;
var init_task = __esm2({
  "src/lib/tasks/task.ts"() {
    init_task_configuration_error();
    EMPTY_COMMANDS = [];
  }
});
var clean_exports = {};
__export2(clean_exports, {
  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,
  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,
  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,
  CleanOptions: () => CleanOptions,
  cleanTask: () => cleanTask,
  cleanWithOptionsTask: () => cleanWithOptionsTask,
  isCleanOptionsArray: () => isCleanOptionsArray
});
function cleanWithOptionsTask(mode, customArgs) {
  const { cleanMode, options, valid } = getCleanOptions(mode);
  if (!cleanMode) {
    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);
  }
  if (!valid.options) {
    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));
  }
  options.push(...customArgs);
  if (options.some(isInteractiveMode)) {
    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);
  }
  return cleanTask(cleanMode, options);
}
function cleanTask(mode, customArgs) {
  const commands = ["clean", `-${mode}`, ...customArgs];
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return cleanSummaryParser(mode === "n", text);
    }
  };
}
function isCleanOptionsArray(input2) {
  return Array.isArray(input2) && input2.every((test) => CleanOptionValues.has(test));
}
function getCleanOptions(input2) {
  let cleanMode;
  let options = [];
  let valid = { cleanMode: false, options: true };
  input2.replace(/[^a-z]i/g, "").split("").forEach((char) => {
    if (isCleanMode(char)) {
      cleanMode = char;
      valid.cleanMode = true;
    } else {
      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);
    }
  });
  return {
    cleanMode,
    options,
    valid
  };
}
function isCleanMode(cleanMode) {
  return cleanMode === "f" || cleanMode === "n";
}
function isKnownOption(option5) {
  return /^-[a-z]$/i.test(option5) && CleanOptionValues.has(option5.charAt(1));
}
function isInteractiveMode(option5) {
  if (/^-[^\-]/.test(option5)) {
    return option5.indexOf("i") > 0;
  }
  return option5 === "--interactive";
}
var CONFIG_ERROR_INTERACTIVE_MODE;
var CONFIG_ERROR_MODE_REQUIRED;
var CONFIG_ERROR_UNKNOWN_OPTION;
var CleanOptions;
var CleanOptionValues;
var init_clean = __esm2({
  "src/lib/tasks/clean.ts"() {
    init_CleanSummary();
    init_utils();
    init_task();
    CONFIG_ERROR_INTERACTIVE_MODE = "Git clean interactive mode is not supported";
    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter ("n" or "f") is required';
    CONFIG_ERROR_UNKNOWN_OPTION = "Git clean unknown option found in: ";
    CleanOptions = /* @__PURE__ */ ((CleanOptions2) => {
      CleanOptions2["DRY_RUN"] = "n";
      CleanOptions2["FORCE"] = "f";
      CleanOptions2["IGNORED_INCLUDED"] = "x";
      CleanOptions2["IGNORED_ONLY"] = "X";
      CleanOptions2["EXCLUDING"] = "e";
      CleanOptions2["QUIET"] = "q";
      CleanOptions2["RECURSIVE"] = "d";
      return CleanOptions2;
    })(CleanOptions || {});
    CleanOptionValues = /* @__PURE__ */ new Set([
      "i",
      ...asStringArray(Object.values(CleanOptions))
    ]);
  }
});
function configListParser(text) {
  const config2 = new ConfigList();
  for (const item of configParser(text)) {
    config2.addValue(item.file, String(item.key), item.value);
  }
  return config2;
}
function configGetParser(text, key) {
  let value = null;
  const values3 = [];
  const scopes = /* @__PURE__ */ new Map();
  for (const item of configParser(text, key)) {
    if (item.key !== key) {
      continue;
    }
    values3.push(value = item.value);
    if (!scopes.has(item.file)) {
      scopes.set(item.file, []);
    }
    scopes.get(item.file).push(value);
  }
  return {
    key,
    paths: Array.from(scopes.keys()),
    scopes,
    value,
    values: values3
  };
}
function configFilePath(filePath) {
  return filePath.replace(/^(file):/, "");
}
function* configParser(text, requestedKey = null) {
  const lines = text.split("\0");
  for (let i = 0, max5 = lines.length - 1; i < max5; ) {
    const file = configFilePath(lines[i++]);
    let value = lines[i++];
    let key = requestedKey;
    if (value.includes("\n")) {
      const line = splitOn(value, "\n");
      key = line[0];
      value = line[1];
    }
    yield { file, key, value };
  }
}
var ConfigList;
var init_ConfigList = __esm2({
  "src/lib/responses/ConfigList.ts"() {
    init_utils();
    ConfigList = class {
      constructor() {
        this.files = [];
        this.values = /* @__PURE__ */ Object.create(null);
      }
      get all() {
        if (!this._all) {
          this._all = this.files.reduce((all8, file) => {
            return Object.assign(all8, this.values[file]);
          }, {});
        }
        return this._all;
      }
      addFile(file) {
        if (!(file in this.values)) {
          const latest = last5(this.files);
          this.values[file] = latest ? Object.create(this.values[latest]) : {};
          this.files.push(file);
        }
        return this.values[file];
      }
      addValue(file, key, value) {
        const values3 = this.addFile(file);
        if (!values3.hasOwnProperty(key)) {
          values3[key] = value;
        } else if (Array.isArray(values3[key])) {
          values3[key].push(value);
        } else {
          values3[key] = [values3[key], value];
        }
        this._all = void 0;
      }
    };
  }
});
function asConfigScope(scope5, fallback) {
  if (typeof scope5 === "string" && GitConfigScope.hasOwnProperty(scope5)) {
    return scope5;
  }
  return fallback;
}
function addConfigTask(key, value, append22, scope5) {
  const commands = ["config", `--${scope5}`];
  if (append22) {
    commands.push("--add");
  }
  commands.push(key, value);
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return text;
    }
  };
}
function getConfigTask(key, scope5) {
  const commands = ["config", "--null", "--show-origin", "--get-all", key];
  if (scope5) {
    commands.splice(1, 0, `--${scope5}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configGetParser(text, key);
    }
  };
}
function listConfigTask(scope5) {
  const commands = ["config", "--list", "--show-origin", "--null"];
  if (scope5) {
    commands.push(`--${scope5}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configListParser(text);
    }
  };
}
function config_default() {
  return {
    addConfig(key, value, ...rest) {
      return this._runTask(
        addConfigTask(
          key,
          value,
          rest[0] === true,
          asConfigScope(
            rest[1],
            "local"
            /* local */
          )
        ),
        trailingFunctionArgument(arguments)
      );
    },
    getConfig(key, scope5) {
      return this._runTask(
        getConfigTask(key, asConfigScope(scope5, void 0)),
        trailingFunctionArgument(arguments)
      );
    },
    listConfig(...rest) {
      return this._runTask(
        listConfigTask(asConfigScope(rest[0], void 0)),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var GitConfigScope;
var init_config = __esm2({
  "src/lib/tasks/config.ts"() {
    init_ConfigList();
    init_utils();
    GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {
      GitConfigScope2["system"] = "system";
      GitConfigScope2["global"] = "global";
      GitConfigScope2["local"] = "local";
      GitConfigScope2["worktree"] = "worktree";
      return GitConfigScope2;
    })(GitConfigScope || {});
  }
});
function isDiffNameStatus(input2) {
  return diffNameStatus.has(input2);
}
var DiffNameStatus;
var diffNameStatus;
var init_diff_name_status = __esm2({
  "src/lib/tasks/diff-name-status.ts"() {
    DiffNameStatus = /* @__PURE__ */ ((DiffNameStatus2) => {
      DiffNameStatus2["ADDED"] = "A";
      DiffNameStatus2["COPIED"] = "C";
      DiffNameStatus2["DELETED"] = "D";
      DiffNameStatus2["MODIFIED"] = "M";
      DiffNameStatus2["RENAMED"] = "R";
      DiffNameStatus2["CHANGED"] = "T";
      DiffNameStatus2["UNMERGED"] = "U";
      DiffNameStatus2["UNKNOWN"] = "X";
      DiffNameStatus2["BROKEN"] = "B";
      return DiffNameStatus2;
    })(DiffNameStatus || {});
    diffNameStatus = new Set(Object.values(DiffNameStatus));
  }
});
function grepQueryBuilder(...params) {
  return new GrepQuery().param(...params);
}
function parseGrep(grep) {
  const paths = /* @__PURE__ */ new Set();
  const results = {};
  forEachLineWithContent(grep, (input2) => {
    const [path3, line, preview] = input2.split(NULL);
    paths.add(path3);
    (results[path3] = results[path3] || []).push({
      line: asNumber(line),
      path: path3,
      preview
    });
  });
  return {
    paths,
    results
  };
}
function grep_default() {
  return {
    grep(searchTerm) {
      const then = trailingFunctionArgument(arguments);
      const options = getTrailingOptions(arguments);
      for (const option5 of disallowedOptions) {
        if (options.includes(option5)) {
          return this._runTask(
            configurationErrorTask(`git.grep: use of "${option5}" is not supported.`),
            then
          );
        }
      }
      if (typeof searchTerm === "string") {
        searchTerm = grepQueryBuilder().param(searchTerm);
      }
      const commands = ["grep", "--null", "-n", "--full-name", ...options, ...searchTerm];
      return this._runTask(
        {
          commands,
          format: "utf-8",
          parser(stdOut) {
            return parseGrep(stdOut);
          }
        },
        then
      );
    }
  };
}
var disallowedOptions;
var Query;
var _a;
var GrepQuery;
var init_grep = __esm2({
  "src/lib/tasks/grep.ts"() {
    init_utils();
    init_task();
    disallowedOptions = ["-h"];
    Query = Symbol("grepQuery");
    GrepQuery = class {
      constructor() {
        this[_a] = [];
      }
      *[(_a = Query, Symbol.iterator)]() {
        for (const query of this[Query]) {
          yield query;
        }
      }
      and(...and) {
        and.length && this[Query].push("--and", "(", ...prefixedArray(and, "-e"), ")");
        return this;
      }
      param(...param) {
        this[Query].push(...prefixedArray(param, "-e"));
        return this;
      }
    };
  }
});
var reset_exports = {};
__export2(reset_exports, {
  ResetMode: () => ResetMode,
  getResetMode: () => getResetMode,
  resetTask: () => resetTask
});
function resetTask(mode, customArgs) {
  const commands = ["reset"];
  if (isValidResetMode(mode)) {
    commands.push(`--${mode}`);
  }
  commands.push(...customArgs);
  return straightThroughStringTask(commands);
}
function getResetMode(mode) {
  if (isValidResetMode(mode)) {
    return mode;
  }
  switch (typeof mode) {
    case "string":
    case "undefined":
      return "soft";
  }
  return;
}
function isValidResetMode(mode) {
  return ResetModes.includes(mode);
}
var ResetMode;
var ResetModes;
var init_reset = __esm2({
  "src/lib/tasks/reset.ts"() {
    init_task();
    ResetMode = /* @__PURE__ */ ((ResetMode2) => {
      ResetMode2["MIXED"] = "mixed";
      ResetMode2["SOFT"] = "soft";
      ResetMode2["HARD"] = "hard";
      ResetMode2["MERGE"] = "merge";
      ResetMode2["KEEP"] = "keep";
      return ResetMode2;
    })(ResetMode || {});
    ResetModes = Array.from(Object.values(ResetMode));
  }
});
function createLog() {
  return (0, import_debug.default)("simple-git");
}
function prefixedLogger(to, prefix, forward) {
  if (!prefix || !String(prefix).replace(/\s*/, "")) {
    return !forward ? to : (message, ...args2) => {
      to(message, ...args2);
      forward(message, ...args2);
    };
  }
  return (message, ...args2) => {
    to(`%s ${message}`, prefix, ...args2);
    if (forward) {
      forward(message, ...args2);
    }
  };
}
function childLoggerName(name, childDebugger, { namespace: parentNamespace }) {
  if (typeof name === "string") {
    return name;
  }
  const childNamespace = childDebugger && childDebugger.namespace || "";
  if (childNamespace.startsWith(parentNamespace)) {
    return childNamespace.substr(parentNamespace.length + 1);
  }
  return childNamespace || parentNamespace;
}
function createLogger(label, verbose, initialStep, infoDebugger = createLog()) {
  const labelPrefix = label && `[${label}]` || "";
  const spawned = [];
  const debugDebugger = typeof verbose === "string" ? infoDebugger.extend(verbose) : verbose;
  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);
  return step4(initialStep);
  function sibling(name, initial) {
    return append4(
      spawned,
      createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger)
    );
  }
  function step4(phase) {
    const stepPrefix = phase && `[${phase}]` || "";
    const debug22 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;
    const info3 = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug22);
    return Object.assign(debugDebugger ? debug22 : info3, {
      label,
      sibling,
      info: info3,
      step: step4
    });
  }
}
var init_git_logger = __esm2({
  "src/lib/git-logger.ts"() {
    init_utils();
    import_debug.default.formatters.L = (value) => String(filterHasLength(value) ? value.length : "-");
    import_debug.default.formatters.B = (value) => {
      if (Buffer.isBuffer(value)) {
        return value.toString("utf8");
      }
      return objectToString(value);
    };
  }
});
var _TasksPendingQueue;
var TasksPendingQueue;
var init_tasks_pending_queue = __esm2({
  "src/lib/runners/tasks-pending-queue.ts"() {
    init_git_error();
    init_git_logger();
    _TasksPendingQueue = class {
      constructor(logLabel = "GitExecutor") {
        this.logLabel = logLabel;
        this._queue = /* @__PURE__ */ new Map();
      }
      withProgress(task) {
        return this._queue.get(task);
      }
      createProgress(task) {
        const name = _TasksPendingQueue.getName(task.commands[0]);
        const logger = createLogger(this.logLabel, name);
        return {
          task,
          logger,
          name
        };
      }
      push(task) {
        const progress = this.createProgress(task);
        progress.logger("Adding task to the queue, commands = %o", task.commands);
        this._queue.set(task, progress);
        return progress;
      }
      fatal(err) {
        for (const [task, { logger }] of Array.from(this._queue.entries())) {
          if (task === err.task) {
            logger.info(`Failed %o`, err);
            logger(
              `Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`
            );
          } else {
            logger.info(
              `A fatal exception occurred in a previous task, the queue has been purged: %o`,
              err.message
            );
          }
          this.complete(task);
        }
        if (this._queue.size !== 0) {
          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);
        }
      }
      complete(task) {
        const progress = this.withProgress(task);
        if (progress) {
          this._queue.delete(task);
        }
      }
      attempt(task) {
        const progress = this.withProgress(task);
        if (!progress) {
          throw new GitError(void 0, "TasksPendingQueue: attempt called for an unknown task");
        }
        progress.logger("Starting task");
        return progress;
      }
      static getName(name = "empty") {
        return `task:${name}:${++_TasksPendingQueue.counter}`;
      }
    };
    TasksPendingQueue = _TasksPendingQueue;
    TasksPendingQueue.counter = 0;
  }
});
function pluginContext(task, commands) {
  return {
    method: first2(task.commands) || "",
    commands
  };
}
function onErrorReceived(target, logger) {
  return (err) => {
    logger(`[ERROR] child process exception %o`, err);
    target.push(Buffer.from(String(err.stack), "ascii"));
  };
}
function onDataReceived(target, name, logger, output) {
  return (buffer4) => {
    logger(`%s received %L bytes`, name, buffer4);
    output(`%B`, buffer4);
    target.push(buffer4);
  };
}
var GitExecutorChain;
var init_git_executor_chain = __esm2({
  "src/lib/runners/git-executor-chain.ts"() {
    init_git_error();
    init_task();
    init_utils();
    init_tasks_pending_queue();
    GitExecutorChain = class {
      constructor(_executor, _scheduler, _plugins) {
        this._executor = _executor;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = Promise.resolve();
        this._queue = new TasksPendingQueue();
      }
      get cwd() {
        return this._cwd || this._executor.cwd;
      }
      set cwd(cwd2) {
        this._cwd = cwd2;
      }
      get env() {
        return this._executor.env;
      }
      get outputHandler() {
        return this._executor.outputHandler;
      }
      chain() {
        return this;
      }
      push(task) {
        this._queue.push(task);
        return this._chain = this._chain.then(() => this.attemptTask(task));
      }
      attemptTask(task) {
        return __async(this, null, function* () {
          const onScheduleComplete = yield this._scheduler.next();
          const onQueueComplete = () => this._queue.complete(task);
          try {
            const { logger } = this._queue.attempt(task);
            return yield isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger);
          } catch (e) {
            throw this.onFatalException(task, e);
          } finally {
            onQueueComplete();
            onScheduleComplete();
          }
        });
      }
      onFatalException(task, e) {
        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));
        this._chain = Promise.resolve();
        this._queue.fatal(gitError);
        return gitError;
      }
      attemptRemoteTask(task, logger) {
        return __async(this, null, function* () {
          const binary = this._plugins.exec("spawn.binary", "", pluginContext(task, task.commands));
          const args2 = this._plugins.exec(
            "spawn.args",
            [...task.commands],
            pluginContext(task, task.commands)
          );
          const raw = yield this.gitResponse(
            task,
            binary,
            args2,
            this.outputHandler,
            logger.step("SPAWN")
          );
          const outputStreams = yield this.handleTaskData(task, args2, raw, logger.step("HANDLE"));
          logger(`passing response to task's parser as a %s`, task.format);
          if (isBufferTask(task)) {
            return callTaskParser(task.parser, outputStreams);
          }
          return callTaskParser(task.parser, outputStreams.asStrings());
        });
      }
      attemptEmptyTask(task, logger) {
        return __async(this, null, function* () {
          logger(`empty task bypassing child process to call to task's parser`);
          return task.parser(this);
        });
      }
      handleTaskData(task, args2, result, logger) {
        const { exitCode, rejection, stdOut, stdErr } = result;
        return new Promise((done11, fail19) => {
          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);
          const { error: error4 } = this._plugins.exec(
            "task.error",
            { error: rejection },
            __spreadValues(__spreadValues({}, pluginContext(task, args2)), result)
          );
          if (error4 && task.onError) {
            logger.info(`exitCode=%s handling with custom error handler`);
            return task.onError(
              result,
              error4,
              (newStdOut) => {
                logger.info(`custom error handler treated as success`);
                logger(`custom error returned a %s`, objectToString(newStdOut));
                done11(
                  new GitOutputStreams(
                    Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,
                    Buffer.concat(stdErr)
                  )
                );
              },
              fail19
            );
          }
          if (error4) {
            logger.info(
              `handling as error: exitCode=%s stdErr=%s rejection=%o`,
              exitCode,
              stdErr.length,
              rejection
            );
            return fail19(error4);
          }
          logger.info(`retrieving task output complete`);
          done11(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));
        });
      }
      gitResponse(task, command, args2, outputHandler, logger) {
        return __async(this, null, function* () {
          const outputLogger = logger.sibling("output");
          const spawnOptions = this._plugins.exec(
            "spawn.options",
            {
              cwd: this.cwd,
              env: this.env,
              windowsHide: true
            },
            pluginContext(task, task.commands)
          );
          return new Promise((done11) => {
            const stdOut = [];
            const stdErr = [];
            logger.info(`%s %o`, command, args2);
            logger("%O", spawnOptions);
            let rejection = this._beforeSpawn(task, args2);
            if (rejection) {
              return done11({
                stdOut,
                stdErr,
                exitCode: 9901,
                rejection
              });
            }
            this._plugins.exec("spawn.before", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args2)), {
              kill(reason) {
                rejection = reason || rejection;
              }
            }));
            const spawned = child_process.spawn(command, args2, spawnOptions);
            spawned.stdout.on(
              "data",
              onDataReceived(stdOut, "stdOut", logger, outputLogger.step("stdOut"))
            );
            spawned.stderr.on(
              "data",
              onDataReceived(stdErr, "stdErr", logger, outputLogger.step("stdErr"))
            );
            spawned.on("error", onErrorReceived(stdErr, logger));
            if (outputHandler) {
              logger(`Passing child process stdOut/stdErr to custom outputHandler`);
              outputHandler(command, spawned.stdout, spawned.stderr, [...args2]);
            }
            this._plugins.exec("spawn.after", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args2)), {
              spawned,
              close(exitCode, reason) {
                done11({
                  stdOut,
                  stdErr,
                  exitCode,
                  rejection: rejection || reason
                });
              },
              kill(reason) {
                if (spawned.killed) {
                  return;
                }
                rejection = reason;
                spawned.kill("SIGINT");
              }
            }));
          });
        });
      }
      _beforeSpawn(task, args2) {
        let rejection;
        this._plugins.exec("spawn.before", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args2)), {
          kill(reason) {
            rejection = reason || rejection;
          }
        }));
        return rejection;
      }
    };
  }
});
var git_executor_exports = {};
__export2(git_executor_exports, {
  GitExecutor: () => GitExecutor
});
var GitExecutor;
var init_git_executor = __esm2({
  "src/lib/runners/git-executor.ts"() {
    init_git_executor_chain();
    GitExecutor = class {
      constructor(cwd2, _scheduler, _plugins) {
        this.cwd = cwd2;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      chain() {
        return new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      push(task) {
        return this._chain.push(task);
      }
    };
  }
});
function taskCallback(task, response, callback = NOOP) {
  const onSuccess = (data) => {
    callback(null, data);
  };
  const onError22 = (err) => {
    if ((err == null ? void 0 : err.task) === task) {
      callback(
        err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err,
        void 0
      );
    }
  };
  response.then(onSuccess, onError22);
}
function addDeprecationNoticeToError(err) {
  let log5 = (name) => {
    console.warn(
      `simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`
    );
    log5 = NOOP;
  };
  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));
  function descriptorReducer(all8, name) {
    if (name in err) {
      return all8;
    }
    all8[name] = {
      enumerable: false,
      configurable: false,
      get() {
        log5(name);
        return err.git[name];
      }
    };
    return all8;
  }
}
var init_task_callback = __esm2({
  "src/lib/task-callback.ts"() {
    init_git_response_error();
    init_utils();
  }
});
function changeWorkingDirectoryTask(directory, root) {
  return adhocExecTask((instance) => {
    if (!folderExists(directory)) {
      throw new Error(`Git.cwd: cannot change to non-directory "${directory}"`);
    }
    return (root || instance).cwd = directory;
  });
}
var init_change_working_directory = __esm2({
  "src/lib/tasks/change-working-directory.ts"() {
    init_utils();
    init_task();
  }
});
function checkoutTask(args2) {
  const commands = ["checkout", ...args2];
  if (commands[1] === "-b" && commands.includes("-B")) {
    commands[1] = remove8(commands, "-B");
  }
  return straightThroughStringTask(commands);
}
function checkout_default() {
  return {
    checkout() {
      return this._runTask(
        checkoutTask(getTrailingOptions(arguments, 1)),
        trailingFunctionArgument(arguments)
      );
    },
    checkoutBranch(branchName, startPoint) {
      return this._runTask(
        checkoutTask(["-b", branchName, startPoint, ...getTrailingOptions(arguments)]),
        trailingFunctionArgument(arguments)
      );
    },
    checkoutLocalBranch(branchName) {
      return this._runTask(
        checkoutTask(["-b", branchName, ...getTrailingOptions(arguments)]),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var init_checkout = __esm2({
  "src/lib/tasks/checkout.ts"() {
    init_utils();
    init_task();
  }
});
function countObjectsResponse() {
  return {
    count: 0,
    garbage: 0,
    inPack: 0,
    packs: 0,
    prunePackable: 0,
    size: 0,
    sizeGarbage: 0,
    sizePack: 0
  };
}
function count_objects_default() {
  return {
    countObjects() {
      return this._runTask({
        commands: ["count-objects", "--verbose"],
        format: "utf-8",
        parser(stdOut) {
          return parseStringResponse(countObjectsResponse(), [parser2], stdOut);
        }
      });
    }
  };
}
var parser2;
var init_count_objects = __esm2({
  "src/lib/tasks/count-objects.ts"() {
    init_utils();
    parser2 = new LineParser(
      /([a-z-]+): (\d+)$/,
      (result, [key, value]) => {
        const property3 = asCamelCase(key);
        if (result.hasOwnProperty(property3)) {
          result[property3] = asNumber(value);
        }
      }
    );
  }
});
function parseCommitResult(stdOut) {
  const result = {
    author: null,
    branch: "",
    commit: "",
    root: false,
    summary: {
      changes: 0,
      insertions: 0,
      deletions: 0
    }
  };
  return parseStringResponse(result, parsers, stdOut);
}
var parsers;
var init_parse_commit = __esm2({
  "src/lib/parsers/parse-commit.ts"() {
    init_utils();
    parsers = [
      new LineParser(/^\[([^\s]+)( \([^)]+\))? ([^\]]+)/, (result, [branch, root, commit3]) => {
        result.branch = branch;
        result.commit = commit3;
        result.root = !!root;
      }),
      new LineParser(/\s*Author:\s(.+)/i, (result, [author]) => {
        const parts2 = author.split("<");
        const email = parts2.pop();
        if (!email || !email.includes("@")) {
          return;
        }
        result.author = {
          email: email.substr(0, email.length - 1),
          name: parts2.join("<").trim()
        };
      }),
      new LineParser(
        /(\d+)[^,]*(?:,\s*(\d+)[^,]*)(?:,\s*(\d+))/g,
        (result, [changes3, insertions, deletions]) => {
          result.summary.changes = parseInt(changes3, 10) || 0;
          result.summary.insertions = parseInt(insertions, 10) || 0;
          result.summary.deletions = parseInt(deletions, 10) || 0;
        }
      ),
      new LineParser(
        /^(\d+)[^,]*(?:,\s*(\d+)[^(]+\(([+-]))?/,
        (result, [changes3, lines, direction]) => {
          result.summary.changes = parseInt(changes3, 10) || 0;
          const count5 = parseInt(lines, 10) || 0;
          if (direction === "-") {
            result.summary.deletions = count5;
          } else if (direction === "+") {
            result.summary.insertions = count5;
          }
        }
      )
    ];
  }
});
function commitTask(message, files, customArgs) {
  const commands = [
    "-c",
    "core.abbrev=40",
    "commit",
    ...prefixedArray(message, "-m"),
    ...files,
    ...customArgs
  ];
  return {
    commands,
    format: "utf-8",
    parser: parseCommitResult
  };
}
function commit_default() {
  return {
    commit(message, ...rest) {
      const next = trailingFunctionArgument(arguments);
      const task = rejectDeprecatedSignatures(message) || commitTask(
        asArray(message),
        asArray(filterType(rest[0], filterStringOrStringArray, [])),
        [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]
      );
      return this._runTask(task, next);
    }
  };
  function rejectDeprecatedSignatures(message) {
    return !filterStringOrStringArray(message) && configurationErrorTask(
      `git.commit: requires the commit message to be supplied as a string/string[]`
    );
  }
}
var init_commit = __esm2({
  "src/lib/tasks/commit.ts"() {
    init_parse_commit();
    init_utils();
    init_task();
  }
});
function first_commit_default() {
  return {
    firstCommit() {
      return this._runTask(
        straightThroughStringTask(["rev-list", "--max-parents=0", "HEAD"], true),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var init_first_commit = __esm2({
  "src/lib/tasks/first-commit.ts"() {
    init_utils();
    init_task();
  }
});
function hashObjectTask(filePath, write3) {
  const commands = ["hash-object", filePath];
  if (write3) {
    commands.push("-w");
  }
  return straightThroughStringTask(commands, true);
}
var init_hash_object = __esm2({
  "src/lib/tasks/hash-object.ts"() {
    init_task();
  }
});
function parseInit(bare, path3, text) {
  const response = String(text).trim();
  let result;
  if (result = initResponseRegex.exec(response)) {
    return new InitSummary(bare, path3, false, result[1]);
  }
  if (result = reInitResponseRegex.exec(response)) {
    return new InitSummary(bare, path3, true, result[1]);
  }
  let gitDir = "";
  const tokens = response.split(" ");
  while (tokens.length) {
    const token = tokens.shift();
    if (token === "in") {
      gitDir = tokens.join(" ");
      break;
    }
  }
  return new InitSummary(bare, path3, /^re/i.test(response), gitDir);
}
var InitSummary;
var initResponseRegex;
var reInitResponseRegex;
var init_InitSummary = __esm2({
  "src/lib/responses/InitSummary.ts"() {
    InitSummary = class {
      constructor(bare, path3, existing, gitDir) {
        this.bare = bare;
        this.path = path3;
        this.existing = existing;
        this.gitDir = gitDir;
      }
    };
    initResponseRegex = /^Init.+ repository in (.+)$/;
    reInitResponseRegex = /^Rein.+ in (.+)$/;
  }
});
function hasBareCommand(command) {
  return command.includes(bareCommand);
}
function initTask(bare = false, path3, customArgs) {
  const commands = ["init", ...customArgs];
  if (bare && !hasBareCommand(commands)) {
    commands.splice(1, 0, bareCommand);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return parseInit(commands.includes("--bare"), path3, text);
    }
  };
}
var bareCommand;
var init_init = __esm2({
  "src/lib/tasks/init.ts"() {
    init_InitSummary();
    bareCommand = "--bare";
  }
});
function logFormatFromCommand(customArgs) {
  for (let i = 0; i < customArgs.length; i++) {
    const format5 = logFormatRegex.exec(customArgs[i]);
    if (format5) {
      return `--${format5[1]}`;
    }
  }
  return "";
}
function isLogFormat(customArg) {
  return logFormatRegex.test(customArg);
}
var logFormatRegex;
var init_log_format = __esm2({
  "src/lib/args/log-format.ts"() {
    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;
  }
});
var DiffSummary;
var init_DiffSummary = __esm2({
  "src/lib/responses/DiffSummary.ts"() {
    DiffSummary = class {
      constructor() {
        this.changed = 0;
        this.deletions = 0;
        this.insertions = 0;
        this.files = [];
      }
    };
  }
});
function getDiffParser(format5 = "") {
  const parser4 = diffSummaryParsers[format5];
  return (stdOut) => parseStringResponse(new DiffSummary(), parser4, stdOut, false);
}
var statParser;
var numStatParser;
var nameOnlyParser;
var nameStatusParser;
var diffSummaryParsers;
var init_parse_diff_summary = __esm2({
  "src/lib/parsers/parse-diff-summary.ts"() {
    init_log_format();
    init_DiffSummary();
    init_diff_name_status();
    init_utils();
    statParser = [
      new LineParser(
        /^(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/,
        (result, [file, changes3, alterations = ""]) => {
          result.files.push({
            file: file.trim(),
            changes: asNumber(changes3),
            insertions: alterations.replace(/[^+]/g, "").length,
            deletions: alterations.replace(/[^-]/g, "").length,
            binary: false
          });
        }
      ),
      new LineParser(
        /^(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/,
        (result, [file, before2, after3]) => {
          result.files.push({
            file: file.trim(),
            before: asNumber(before2),
            after: asNumber(after3),
            binary: true
          });
        }
      ),
      new LineParser(
        /(\d+) files? changed\s*((?:, \d+ [^,]+){0,2})/,
        (result, [changed, summary5]) => {
          const inserted = /(\d+) i/.exec(summary5);
          const deleted = /(\d+) d/.exec(summary5);
          result.changed = asNumber(changed);
          result.insertions = asNumber(inserted == null ? void 0 : inserted[1]);
          result.deletions = asNumber(deleted == null ? void 0 : deleted[1]);
        }
      )
    ];
    numStatParser = [
      new LineParser(
        /(\d+)\t(\d+)\t(.+)$/,
        (result, [changesInsert, changesDelete, file]) => {
          const insertions = asNumber(changesInsert);
          const deletions = asNumber(changesDelete);
          result.changed++;
          result.insertions += insertions;
          result.deletions += deletions;
          result.files.push({
            file,
            changes: insertions + deletions,
            insertions,
            deletions,
            binary: false
          });
        }
      ),
      new LineParser(/-\t-\t(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          after: 0,
          before: 0,
          binary: true
        });
      })
    ];
    nameOnlyParser = [
      new LineParser(/(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          changes: 0,
          insertions: 0,
          deletions: 0,
          binary: false
        });
      })
    ];
    nameStatusParser = [
      new LineParser(
        /([ACDMRTUXB])([0-9]{0,3})\t(.[^\t]*)(\t(.[^\t]*))?$/,
        (result, [status2, similarity, from, _to, to]) => {
          result.changed++;
          result.files.push({
            file: to != null ? to : from,
            changes: 0,
            insertions: 0,
            deletions: 0,
            binary: false,
            status: orVoid(isDiffNameStatus(status2) && status2),
            from: orVoid(!!to && from !== to && from),
            similarity: asNumber(similarity)
          });
        }
      )
    ];
    diffSummaryParsers = {
      [
        ""
        /* NONE */
      ]: statParser,
      [
        "--stat"
        /* STAT */
      ]: statParser,
      [
        "--numstat"
        /* NUM_STAT */
      ]: numStatParser,
      [
        "--name-status"
        /* NAME_STATUS */
      ]: nameStatusParser,
      [
        "--name-only"
        /* NAME_ONLY */
      ]: nameOnlyParser
    };
  }
});
function lineBuilder(tokens, fields) {
  return fields.reduce(
    (line, field, index) => {
      line[field] = tokens[index] || "";
      return line;
    },
    /* @__PURE__ */ Object.create({ diff: null })
  );
}
function createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = "") {
  const parseDiffResult = getDiffParser(logFormat);
  return function(stdOut) {
    const all8 = toLinesWithContent(
      stdOut.trim(),
      false,
      START_BOUNDARY
    ).map(function(item) {
      const lineDetail = item.split(COMMIT_BOUNDARY);
      const listLogLine = lineBuilder(lineDetail[0].split(splitter), fields);
      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {
        listLogLine.diff = parseDiffResult(lineDetail[1]);
      }
      return listLogLine;
    });
    return {
      all: all8,
      latest: all8.length && all8[0] || null,
      total: all8.length
    };
  };
}
var START_BOUNDARY;
var COMMIT_BOUNDARY;
var SPLITTER;
var defaultFieldNames;
var init_parse_list_log_summary = __esm2({
  "src/lib/parsers/parse-list-log-summary.ts"() {
    init_utils();
    init_parse_diff_summary();
    init_log_format();
    START_BOUNDARY = "\xF2\xF2\xF2\xF2\xF2\xF2 ";
    COMMIT_BOUNDARY = " \xF2\xF2";
    SPLITTER = " \xF2 ";
    defaultFieldNames = ["hash", "date", "message", "refs", "author_name", "author_email"];
  }
});
var diff_exports = {};
__export2(diff_exports, {
  diffSummaryTask: () => diffSummaryTask,
  validateLogFormatConfig: () => validateLogFormatConfig
});
function diffSummaryTask(customArgs) {
  let logFormat = logFormatFromCommand(customArgs);
  const commands = ["diff"];
  if (logFormat === "") {
    logFormat = "--stat";
    commands.push("--stat=4096");
  }
  commands.push(...customArgs);
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: getDiffParser(logFormat)
  };
}
function validateLogFormatConfig(customArgs) {
  const flags = customArgs.filter(isLogFormat);
  if (flags.length > 1) {
    return configurationErrorTask(
      `Summary flags are mutually exclusive - pick one of ${flags.join(",")}`
    );
  }
  if (flags.length && customArgs.includes("-z")) {
    return configurationErrorTask(
      `Summary flag ${flags} parsing is not compatible with null termination option '-z'`
    );
  }
}
var init_diff = __esm2({
  "src/lib/tasks/diff.ts"() {
    init_log_format();
    init_parse_diff_summary();
    init_task();
  }
});
function prettyFormat(format5, splitter) {
  const fields = [];
  const formatStr = [];
  Object.keys(format5).forEach((field) => {
    fields.push(field);
    formatStr.push(String(format5[field]));
  });
  return [fields, formatStr.join(splitter)];
}
function userOptions(input2) {
  return Object.keys(input2).reduce((out, key) => {
    if (!(key in excludeOptions)) {
      out[key] = input2[key];
    }
    return out;
  }, {});
}
function parseLogOptions(opt = {}, customArgs = []) {
  const splitter = filterType(opt.splitter, filterString, SPLITTER);
  const format5 = !filterPrimitives(opt.format) && opt.format ? opt.format : {
    hash: "%H",
    date: opt.strictDate === false ? "%ai" : "%aI",
    message: "%s",
    refs: "%D",
    body: opt.multiLine ? "%B" : "%b",
    author_name: opt.mailMap !== false ? "%aN" : "%an",
    author_email: opt.mailMap !== false ? "%aE" : "%ae"
  };
  const [fields, formatStr] = prettyFormat(format5, splitter);
  const suffix = [];
  const command = [
    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,
    ...customArgs
  ];
  const maxCount = opt.n || opt["max-count"] || opt.maxCount;
  if (maxCount) {
    command.push(`--max-count=${maxCount}`);
  }
  if (opt.from || opt.to) {
    const rangeOperator = opt.symmetric !== false ? "..." : "..";
    suffix.push(`${opt.from || ""}${rangeOperator}${opt.to || ""}`);
  }
  if (filterString(opt.file)) {
    command.push("--follow", pathspec(opt.file));
  }
  appendTaskOptions(userOptions(opt), command);
  return {
    fields,
    splitter,
    commands: [...command, ...suffix]
  };
}
function logTask(splitter, fields, customArgs) {
  const parser4 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));
  return {
    commands: ["log", ...customArgs],
    format: "utf-8",
    parser: parser4
  };
}
function log_default() {
  return {
    log(...rest) {
      const next = trailingFunctionArgument(arguments);
      const options = parseLogOptions(
        trailingOptionsArgument(arguments),
        filterType(arguments[0], filterArray)
      );
      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);
      return this._runTask(task, next);
    }
  };
  function createLogTask(options) {
    return logTask(options.splitter, options.fields, options.commands);
  }
  function rejectDeprecatedSignatures(from, to) {
    return filterString(from) && filterString(to) && configurationErrorTask(
      `git.log(string, string) should be replaced with git.log({ from: string, to: string })`
    );
  }
}
var excludeOptions;
var init_log = __esm2({
  "src/lib/tasks/log.ts"() {
    init_log_format();
    init_pathspec();
    init_parse_list_log_summary();
    init_utils();
    init_task();
    init_diff();
    excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {
      excludeOptions2[excludeOptions2["--pretty"] = 0] = "--pretty";
      excludeOptions2[excludeOptions2["max-count"] = 1] = "max-count";
      excludeOptions2[excludeOptions2["maxCount"] = 2] = "maxCount";
      excludeOptions2[excludeOptions2["n"] = 3] = "n";
      excludeOptions2[excludeOptions2["file"] = 4] = "file";
      excludeOptions2[excludeOptions2["format"] = 5] = "format";
      excludeOptions2[excludeOptions2["from"] = 6] = "from";
      excludeOptions2[excludeOptions2["to"] = 7] = "to";
      excludeOptions2[excludeOptions2["splitter"] = 8] = "splitter";
      excludeOptions2[excludeOptions2["symmetric"] = 9] = "symmetric";
      excludeOptions2[excludeOptions2["mailMap"] = 10] = "mailMap";
      excludeOptions2[excludeOptions2["multiLine"] = 11] = "multiLine";
      excludeOptions2[excludeOptions2["strictDate"] = 12] = "strictDate";
      return excludeOptions2;
    })(excludeOptions || {});
  }
});
var MergeSummaryConflict;
var MergeSummaryDetail;
var init_MergeSummary = __esm2({
  "src/lib/responses/MergeSummary.ts"() {
    MergeSummaryConflict = class {
      constructor(reason, file = null, meta) {
        this.reason = reason;
        this.file = file;
        this.meta = meta;
      }
      toString() {
        return `${this.file}:${this.reason}`;
      }
    };
    MergeSummaryDetail = class {
      constructor() {
        this.conflicts = [];
        this.merges = [];
        this.result = "success";
      }
      get failed() {
        return this.conflicts.length > 0;
      }
      get reason() {
        return this.result;
      }
      toString() {
        if (this.conflicts.length) {
          return `CONFLICTS: ${this.conflicts.join(", ")}`;
        }
        return "OK";
      }
    };
  }
});
var PullSummary;
var PullFailedSummary;
var init_PullSummary = __esm2({
  "src/lib/responses/PullSummary.ts"() {
    PullSummary = class {
      constructor() {
        this.remoteMessages = {
          all: []
        };
        this.created = [];
        this.deleted = [];
        this.files = [];
        this.deletions = {};
        this.insertions = {};
        this.summary = {
          changes: 0,
          deletions: 0,
          insertions: 0
        };
      }
    };
    PullFailedSummary = class {
      constructor() {
        this.remote = "";
        this.hash = {
          local: "",
          remote: ""
        };
        this.branch = {
          local: "",
          remote: ""
        };
        this.message = "";
      }
      toString() {
        return this.message;
      }
    };
  }
});
function objectEnumerationResult(remoteMessages) {
  return remoteMessages.objects = remoteMessages.objects || {
    compressing: 0,
    counting: 0,
    enumerating: 0,
    packReused: 0,
    reused: { count: 0, delta: 0 },
    total: { count: 0, delta: 0 }
  };
}
function asObjectCount(source) {
  const count5 = /^\s*(\d+)/.exec(source);
  const delta = /delta (\d+)/i.exec(source);
  return {
    count: asNumber(count5 && count5[1] || "0"),
    delta: asNumber(delta && delta[1] || "0")
  };
}
var remoteMessagesObjectParsers;
var init_parse_remote_objects = __esm2({
  "src/lib/parsers/parse-remote-objects.ts"() {
    init_utils();
    remoteMessagesObjectParsers = [
      new RemoteLineParser(
        /^remote:\s*(enumerating|counting|compressing) objects: (\d+),/i,
        (result, [action, count5]) => {
          const key = action.toLowerCase();
          const enumeration = objectEnumerationResult(result.remoteMessages);
          Object.assign(enumeration, { [key]: asNumber(count5) });
        }
      ),
      new RemoteLineParser(
        /^remote:\s*(enumerating|counting|compressing) objects: \d+% \(\d+\/(\d+)\),/i,
        (result, [action, count5]) => {
          const key = action.toLowerCase();
          const enumeration = objectEnumerationResult(result.remoteMessages);
          Object.assign(enumeration, { [key]: asNumber(count5) });
        }
      ),
      new RemoteLineParser(
        /total ([^,]+), reused ([^,]+), pack-reused (\d+)/i,
        (result, [total, reused, packReused]) => {
          const objects = objectEnumerationResult(result.remoteMessages);
          objects.total = asObjectCount(total);
          objects.reused = asObjectCount(reused);
          objects.packReused = asNumber(packReused);
        }
      )
    ];
  }
});
function parseRemoteMessages(_stdOut, stdErr) {
  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);
}
var parsers2;
var RemoteMessageSummary;
var init_parse_remote_messages = __esm2({
  "src/lib/parsers/parse-remote-messages.ts"() {
    init_utils();
    init_parse_remote_objects();
    parsers2 = [
      new RemoteLineParser(/^remote:\s*(.+)$/, (result, [text]) => {
        result.remoteMessages.all.push(text.trim());
        return false;
      }),
      ...remoteMessagesObjectParsers,
      new RemoteLineParser(
        [/create a (?:pull|merge) request/i, /\s(https?:\/\/\S+)$/],
        (result, [pullRequestUrl]) => {
          result.remoteMessages.pullRequestUrl = pullRequestUrl;
        }
      ),
      new RemoteLineParser(
        [/found (\d+) vulnerabilities.+\(([^)]+)\)/i, /\s(https?:\/\/\S+)$/],
        (result, [count5, summary5, url3]) => {
          result.remoteMessages.vulnerabilities = {
            count: asNumber(count5),
            summary: summary5,
            url: url3
          };
        }
      )
    ];
    RemoteMessageSummary = class {
      constructor() {
        this.all = [];
      }
    };
  }
});
function parsePullErrorResult(stdOut, stdErr) {
  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);
  return pullError.message && pullError;
}
var FILE_UPDATE_REGEX;
var SUMMARY_REGEX;
var ACTION_REGEX;
var parsers3;
var errorParsers;
var parsePullDetail;
var parsePullResult;
var init_parse_pull = __esm2({
  "src/lib/parsers/parse-pull.ts"() {
    init_PullSummary();
    init_utils();
    init_parse_remote_messages();
    FILE_UPDATE_REGEX = /^\s*(.+?)\s+\|\s+\d+\s*(\+*)(-*)/;
    SUMMARY_REGEX = /(\d+)\D+((\d+)\D+\(\+\))?(\D+(\d+)\D+\(-\))?/;
    ACTION_REGEX = /^(create|delete) mode \d+ (.+)/;
    parsers3 = [
      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {
        result.files.push(file);
        if (insertions) {
          result.insertions[file] = insertions.length;
        }
        if (deletions) {
          result.deletions[file] = deletions.length;
        }
      }),
      new LineParser(SUMMARY_REGEX, (result, [changes3, , insertions, , deletions]) => {
        if (insertions !== void 0 || deletions !== void 0) {
          result.summary.changes = +changes3 || 0;
          result.summary.insertions = +insertions || 0;
          result.summary.deletions = +deletions || 0;
          return true;
        }
        return false;
      }),
      new LineParser(ACTION_REGEX, (result, [action, file]) => {
        append4(result.files, file);
        append4(action === "create" ? result.created : result.deleted, file);
      })
    ];
    errorParsers = [
      new LineParser(/^from\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),
      new LineParser(/^fatal:\s(.+)$/, (result, [message]) => void (result.message = message)),
      new LineParser(
        /([a-z0-9]+)\.\.([a-z0-9]+)\s+(\S+)\s+->\s+(\S+)$/,
        (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {
          result.branch.local = branchLocal;
          result.hash.local = hashLocal;
          result.branch.remote = branchRemote;
          result.hash.remote = hashRemote;
        }
      )
    ];
    parsePullDetail = (stdOut, stdErr) => {
      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);
    };
    parsePullResult = (stdOut, stdErr) => {
      return Object.assign(
        new PullSummary(),
        parsePullDetail(stdOut, stdErr),
        parseRemoteMessages(stdOut, stdErr)
      );
    };
  }
});
var parsers4;
var parseMergeResult;
var parseMergeDetail;
var init_parse_merge = __esm2({
  "src/lib/parsers/parse-merge.ts"() {
    init_MergeSummary();
    init_utils();
    init_parse_pull();
    parsers4 = [
      new LineParser(/^Auto-merging\s+(.+)$/, (summary5, [autoMerge]) => {
        summary5.merges.push(autoMerge);
      }),
      new LineParser(/^CONFLICT\s+\((.+)\): Merge conflict in (.+)$/, (summary5, [reason, file]) => {
        summary5.conflicts.push(new MergeSummaryConflict(reason, file));
      }),
      new LineParser(
        /^CONFLICT\s+\((.+\/delete)\): (.+) deleted in (.+) and/,
        (summary5, [reason, file, deleteRef]) => {
          summary5.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));
        }
      ),
      new LineParser(/^CONFLICT\s+\((.+)\):/, (summary5, [reason]) => {
        summary5.conflicts.push(new MergeSummaryConflict(reason, null));
      }),
      new LineParser(/^Automatic merge failed;\s+(.+)$/, (summary5, [result]) => {
        summary5.result = result;
      })
    ];
    parseMergeResult = (stdOut, stdErr) => {
      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));
    };
    parseMergeDetail = (stdOut) => {
      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);
    };
  }
});
function mergeTask(customArgs) {
  if (!customArgs.length) {
    return configurationErrorTask("Git.merge requires at least one option");
  }
  return {
    commands: ["merge", ...customArgs],
    format: "utf-8",
    parser(stdOut, stdErr) {
      const merge12 = parseMergeResult(stdOut, stdErr);
      if (merge12.failed) {
        throw new GitResponseError(merge12);
      }
      return merge12;
    }
  };
}
var init_merge = __esm2({
  "src/lib/tasks/merge.ts"() {
    init_git_response_error();
    init_parse_merge();
    init_task();
  }
});
function pushResultPushedItem(local, remote, status2) {
  const deleted = status2.includes("deleted");
  const tag = status2.includes("tag") || /^refs\/tags/.test(local);
  const alreadyUpdated = !status2.includes("new");
  return {
    deleted,
    tag,
    branch: !tag,
    new: !alreadyUpdated,
    alreadyUpdated,
    local,
    remote
  };
}
var parsers5;
var parsePushResult;
var parsePushDetail;
var init_parse_push = __esm2({
  "src/lib/parsers/parse-push.ts"() {
    init_utils();
    init_parse_remote_messages();
    parsers5 = [
      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {
        result.repo = repo;
      }),
      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {
        result.ref = __spreadProps(__spreadValues({}, result.ref || {}), {
          local
        });
      }),
      new LineParser(/^[=*-]\s+([^:]+):(\S+)\s+\[(.+)]$/, (result, [local, remote, type]) => {
        result.pushed.push(pushResultPushedItem(local, remote, type));
      }),
      new LineParser(
        /^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/,
        (result, [local, remote, remoteName]) => {
          result.branch = __spreadProps(__spreadValues({}, result.branch || {}), {
            local,
            remote,
            remoteName
          });
        }
      ),
      new LineParser(
        /^([^:]+):(\S+)\s+([a-z0-9]+)\.\.([a-z0-9]+)$/,
        (result, [local, remote, from, to]) => {
          result.update = {
            head: {
              local,
              remote
            },
            hash: {
              from,
              to
            }
          };
        }
      )
    ];
    parsePushResult = (stdOut, stdErr) => {
      const pushDetail = parsePushDetail(stdOut, stdErr);
      const responseDetail = parseRemoteMessages(stdOut, stdErr);
      return __spreadValues(__spreadValues({}, pushDetail), responseDetail);
    };
    parsePushDetail = (stdOut, stdErr) => {
      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);
    };
  }
});
var push_exports = {};
__export2(push_exports, {
  pushTagsTask: () => pushTagsTask,
  pushTask: () => pushTask
});
function pushTagsTask(ref = {}, customArgs) {
  append4(customArgs, "--tags");
  return pushTask(ref, customArgs);
}
function pushTask(ref = {}, customArgs) {
  const commands = ["push", ...customArgs];
  if (ref.branch) {
    commands.splice(1, 0, ref.branch);
  }
  if (ref.remote) {
    commands.splice(1, 0, ref.remote);
  }
  remove8(commands, "-v");
  append4(commands, "--verbose");
  append4(commands, "--porcelain");
  return {
    commands,
    format: "utf-8",
    parser: parsePushResult
  };
}
var init_push = __esm2({
  "src/lib/tasks/push.ts"() {
    init_parse_push();
    init_utils();
  }
});
function show_default() {
  return {
    showBuffer() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      if (!commands.includes("--binary")) {
        commands.splice(1, 0, "--binary");
      }
      return this._runTask(
        straightThroughBufferTask(commands),
        trailingFunctionArgument(arguments)
      );
    },
    show() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      return this._runTask(
        straightThroughStringTask(commands),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var init_show = __esm2({
  "src/lib/tasks/show.ts"() {
    init_utils();
    init_task();
  }
});
var fromPathRegex;
var FileStatusSummary;
var init_FileStatusSummary = __esm2({
  "src/lib/responses/FileStatusSummary.ts"() {
    fromPathRegex = /^(.+)\0(.+)$/;
    FileStatusSummary = class {
      constructor(path3, index, working_dir) {
        this.path = path3;
        this.index = index;
        this.working_dir = working_dir;
        if (index === "R" || working_dir === "R") {
          const detail = fromPathRegex.exec(path3) || [null, path3, path3];
          this.from = detail[2] || "";
          this.path = detail[1] || "";
        }
      }
    };
  }
});
function renamedFile(line) {
  const [to, from] = line.split(NULL);
  return {
    from: from || to,
    to
  };
}
function parser3(indexX, indexY, handler) {
  return [`${indexX}${indexY}`, handler];
}
function conflicts(indexX, ...indexY) {
  return indexY.map((y) => parser3(indexX, y, (result, file) => append4(result.conflicted, file)));
}
function splitLine(result, lineStr) {
  const trimmed2 = lineStr.trim();
  switch (" ") {
    case trimmed2.charAt(2):
      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.substr(3));
    case trimmed2.charAt(1):
      return data(" ", trimmed2.charAt(0), trimmed2.substr(2));
    default:
      return;
  }
  function data(index, workingDir, path3) {
    const raw = `${index}${workingDir}`;
    const handler = parsers6.get(raw);
    if (handler) {
      handler(result, path3);
    }
    if (raw !== "##" && raw !== "!!") {
      result.files.push(new FileStatusSummary(path3, index, workingDir));
    }
  }
}
var StatusSummary;
var parsers6;
var parseStatusSummary;
var init_StatusSummary = __esm2({
  "src/lib/responses/StatusSummary.ts"() {
    init_utils();
    init_FileStatusSummary();
    StatusSummary = class {
      constructor() {
        this.not_added = [];
        this.conflicted = [];
        this.created = [];
        this.deleted = [];
        this.ignored = void 0;
        this.modified = [];
        this.renamed = [];
        this.files = [];
        this.staged = [];
        this.ahead = 0;
        this.behind = 0;
        this.current = null;
        this.tracking = null;
        this.detached = false;
        this.isClean = () => {
          return !this.files.length;
        };
      }
    };
    parsers6 = new Map([
      parser3(
        " ",
        "A",
        (result, file) => append4(result.created, file)
      ),
      parser3(
        " ",
        "D",
        (result, file) => append4(result.deleted, file)
      ),
      parser3(
        " ",
        "M",
        (result, file) => append4(result.modified, file)
      ),
      parser3(
        "A",
        " ",
        (result, file) => append4(result.created, file) && append4(result.staged, file)
      ),
      parser3(
        "A",
        "M",
        (result, file) => append4(result.created, file) && append4(result.staged, file) && append4(result.modified, file)
      ),
      parser3(
        "D",
        " ",
        (result, file) => append4(result.deleted, file) && append4(result.staged, file)
      ),
      parser3(
        "M",
        " ",
        (result, file) => append4(result.modified, file) && append4(result.staged, file)
      ),
      parser3(
        "M",
        "M",
        (result, file) => append4(result.modified, file) && append4(result.staged, file)
      ),
      parser3("R", " ", (result, file) => {
        append4(result.renamed, renamedFile(file));
      }),
      parser3("R", "M", (result, file) => {
        const renamed = renamedFile(file);
        append4(result.renamed, renamed);
        append4(result.modified, renamed.to);
      }),
      parser3("!", "!", (_result, _file) => {
        append4(_result.ignored = _result.ignored || [], _file);
      }),
      parser3(
        "?",
        "?",
        (result, file) => append4(result.not_added, file)
      ),
      ...conflicts(
        "A",
        "A",
        "U"
        /* UNMERGED */
      ),
      ...conflicts(
        "D",
        "D",
        "U"
        /* UNMERGED */
      ),
      ...conflicts(
        "U",
        "A",
        "D",
        "U"
        /* UNMERGED */
      ),
      [
        "##",
        (result, line) => {
          const aheadReg = /ahead (\d+)/;
          const behindReg = /behind (\d+)/;
          const currentReg = /^(.+?(?=(?:\.{3}|\s|$)))/;
          const trackingReg = /\.{3}(\S*)/;
          const onEmptyBranchReg = /\son\s([\S]+)$/;
          let regexResult;
          regexResult = aheadReg.exec(line);
          result.ahead = regexResult && +regexResult[1] || 0;
          regexResult = behindReg.exec(line);
          result.behind = regexResult && +regexResult[1] || 0;
          regexResult = currentReg.exec(line);
          result.current = regexResult && regexResult[1];
          regexResult = trackingReg.exec(line);
          result.tracking = regexResult && regexResult[1];
          regexResult = onEmptyBranchReg.exec(line);
          result.current = regexResult && regexResult[1] || result.current;
          result.detached = /\(no branch\)/.test(line);
        }
      ]
    ]);
    parseStatusSummary = function(text) {
      const lines = text.split(NULL);
      const status2 = new StatusSummary();
      for (let i = 0, l = lines.length; i < l; ) {
        let line = lines[i++].trim();
        if (!line) {
          continue;
        }
        if (line.charAt(0) === "R") {
          line += NULL + (lines[i++] || "");
        }
        splitLine(status2, line);
      }
      return status2;
    };
  }
});
function statusTask(customArgs) {
  const commands = [
    "status",
    "--porcelain",
    "-b",
    "-u",
    "--null",
    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))
  ];
  return {
    format: "utf-8",
    commands,
    parser(text) {
      return parseStatusSummary(text);
    }
  };
}
var ignoredOptions;
var init_status = __esm2({
  "src/lib/tasks/status.ts"() {
    init_StatusSummary();
    ignoredOptions = ["--null", "-z"];
  }
});
function versionResponse(major = 0, minor = 0, patch9 = 0, agent = "", installed = true) {
  return Object.defineProperty(
    {
      major,
      minor,
      patch: patch9,
      agent,
      installed
    },
    "toString",
    {
      value() {
        return `${this.major}.${this.minor}.${this.patch}`;
      },
      configurable: false,
      enumerable: false
    }
  );
}
function notInstalledResponse() {
  return versionResponse(0, 0, 0, "", false);
}
function version_default() {
  return {
    version() {
      return this._runTask({
        commands: ["--version"],
        format: "utf-8",
        parser: versionParser,
        onError(result, error4, done11, fail19) {
          if (result.exitCode === -2) {
            return done11(Buffer.from(NOT_INSTALLED));
          }
          fail19(error4);
        }
      });
    }
  };
}
function versionParser(stdOut) {
  if (stdOut === NOT_INSTALLED) {
    return notInstalledResponse();
  }
  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);
}
var NOT_INSTALLED;
var parsers7;
var init_version = __esm2({
  "src/lib/tasks/version.ts"() {
    init_utils();
    NOT_INSTALLED = "installed=false";
    parsers7 = [
      new LineParser(
        /version (\d+)\.(\d+)\.(\d+)(?:\s*\((.+)\))?/,
        (result, [major, minor, patch9, agent = ""]) => {
          Object.assign(
            result,
            versionResponse(asNumber(major), asNumber(minor), asNumber(patch9), agent)
          );
        }
      ),
      new LineParser(
        /version (\d+)\.(\d+)\.(\D+)(.+)?$/,
        (result, [major, minor, patch9, agent = ""]) => {
          Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch9, agent));
        }
      )
    ];
  }
});
var simple_git_api_exports = {};
__export2(simple_git_api_exports, {
  SimpleGitApi: () => SimpleGitApi
});
var SimpleGitApi;
var init_simple_git_api = __esm2({
  "src/lib/simple-git-api.ts"() {
    init_task_callback();
    init_change_working_directory();
    init_checkout();
    init_count_objects();
    init_commit();
    init_config();
    init_first_commit();
    init_grep();
    init_hash_object();
    init_init();
    init_log();
    init_merge();
    init_push();
    init_show();
    init_status();
    init_task();
    init_version();
    init_utils();
    SimpleGitApi = class {
      constructor(_executor) {
        this._executor = _executor;
      }
      _runTask(task, then) {
        const chain = this._executor.chain();
        const promise3 = chain.push(task);
        if (then) {
          taskCallback(task, promise3, then);
        }
        return Object.create(this, {
          then: { value: promise3.then.bind(promise3) },
          catch: { value: promise3.catch.bind(promise3) },
          _executor: { value: chain }
        });
      }
      add(files) {
        return this._runTask(
          straightThroughStringTask(["add", ...asArray(files)]),
          trailingFunctionArgument(arguments)
        );
      }
      cwd(directory) {
        const next = trailingFunctionArgument(arguments);
        if (typeof directory === "string") {
          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);
        }
        if (typeof (directory == null ? void 0 : directory.path) === "string") {
          return this._runTask(
            changeWorkingDirectoryTask(
              directory.path,
              directory.root && this._executor || void 0
            ),
            next
          );
        }
        return this._runTask(
          configurationErrorTask("Git.cwd: workingDirectory must be supplied as a string"),
          next
        );
      }
      hashObject(path3, write3) {
        return this._runTask(
          hashObjectTask(path3, write3 === true),
          trailingFunctionArgument(arguments)
        );
      }
      init(bare) {
        return this._runTask(
          initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
      merge() {
        return this._runTask(
          mergeTask(getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
      mergeFromTo(remote, branch) {
        if (!(filterString(remote) && filterString(branch))) {
          return this._runTask(
            configurationErrorTask(
              `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`
            )
          );
        }
        return this._runTask(
          mergeTask([remote, branch, ...getTrailingOptions(arguments)]),
          trailingFunctionArgument(arguments, false)
        );
      }
      outputHandler(handler) {
        this._executor.outputHandler = handler;
        return this;
      }
      push() {
        const task = pushTask(
          {
            remote: filterType(arguments[0], filterString),
            branch: filterType(arguments[1], filterString)
          },
          getTrailingOptions(arguments)
        );
        return this._runTask(task, trailingFunctionArgument(arguments));
      }
      stash() {
        return this._runTask(
          straightThroughStringTask(["stash", ...getTrailingOptions(arguments)]),
          trailingFunctionArgument(arguments)
        );
      }
      status() {
        return this._runTask(
          statusTask(getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
    };
    Object.assign(
      SimpleGitApi.prototype,
      checkout_default(),
      commit_default(),
      config_default(),
      count_objects_default(),
      first_commit_default(),
      grep_default(),
      log_default(),
      show_default(),
      version_default()
    );
  }
});
var scheduler_exports = {};
__export2(scheduler_exports, {
  Scheduler: () => Scheduler
});
var createScheduledTask;
var Scheduler;
var init_scheduler = __esm2({
  "src/lib/runners/scheduler.ts"() {
    init_utils();
    init_git_logger();
    createScheduledTask = /* @__PURE__ */ (() => {
      let id2 = 0;
      return () => {
        id2++;
        const { promise: promise3, done: done11 } = (0, import_promise_deferred.createDeferred)();
        return {
          promise: promise3,
          done: done11,
          id: id2
        };
      };
    })();
    Scheduler = class {
      constructor(concurrency = 2) {
        this.concurrency = concurrency;
        this.logger = createLogger("", "scheduler");
        this.pending = [];
        this.running = [];
        this.logger(`Constructed, concurrency=%s`, concurrency);
      }
      schedule() {
        if (!this.pending.length || this.running.length >= this.concurrency) {
          this.logger(
            `Schedule attempt ignored, pending=%s running=%s concurrency=%s`,
            this.pending.length,
            this.running.length,
            this.concurrency
          );
          return;
        }
        const task = append4(this.running, this.pending.shift());
        this.logger(`Attempting id=%s`, task.id);
        task.done(() => {
          this.logger(`Completing id=`, task.id);
          remove8(this.running, task);
          this.schedule();
        });
      }
      next() {
        const { promise: promise3, id: id2 } = append4(this.pending, createScheduledTask());
        this.logger(`Scheduling id=%s`, id2);
        this.schedule();
        return promise3;
      }
    };
  }
});
var apply_patch_exports = {};
__export2(apply_patch_exports, {
  applyPatchTask: () => applyPatchTask
});
function applyPatchTask(patches, customArgs) {
  return straightThroughStringTask(["apply", ...customArgs, ...patches]);
}
var init_apply_patch = __esm2({
  "src/lib/tasks/apply-patch.ts"() {
    init_task();
  }
});
function branchDeletionSuccess(branch, hash2) {
  return {
    branch,
    hash: hash2,
    success: true
  };
}
function branchDeletionFailure(branch) {
  return {
    branch,
    hash: null,
    success: false
  };
}
var BranchDeletionBatch;
var init_BranchDeleteSummary = __esm2({
  "src/lib/responses/BranchDeleteSummary.ts"() {
    BranchDeletionBatch = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.errors = [];
      }
      get success() {
        return !this.errors.length;
      }
    };
  }
});
function hasBranchDeletionError(data, processExitCode) {
  return processExitCode === 1 && deleteErrorRegex.test(data);
}
var deleteSuccessRegex;
var deleteErrorRegex;
var parsers8;
var parseBranchDeletions;
var init_parse_branch_delete = __esm2({
  "src/lib/parsers/parse-branch-delete.ts"() {
    init_BranchDeleteSummary();
    init_utils();
    deleteSuccessRegex = /(\S+)\s+\(\S+\s([^)]+)\)/;
    deleteErrorRegex = /^error[^']+'([^']+)'/m;
    parsers8 = [
      new LineParser(deleteSuccessRegex, (result, [branch, hash2]) => {
        const deletion = branchDeletionSuccess(branch, hash2);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      }),
      new LineParser(deleteErrorRegex, (result, [branch]) => {
        const deletion = branchDeletionFailure(branch);
        result.errors.push(deletion);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      })
    ];
    parseBranchDeletions = (stdOut, stdErr) => {
      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);
    };
  }
});
var BranchSummaryResult;
var init_BranchSummary = __esm2({
  "src/lib/responses/BranchSummary.ts"() {
    BranchSummaryResult = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.current = "";
        this.detached = false;
      }
      push(status2, detached, name, commit3, label) {
        if (status2 === "*") {
          this.detached = detached;
          this.current = name;
        }
        this.all.push(name);
        this.branches[name] = {
          current: status2 === "*",
          linkedWorkTree: status2 === "+",
          name,
          commit: commit3,
          label
        };
      }
    };
  }
});
function branchStatus(input2) {
  return input2 ? input2.charAt(0) : "";
}
function parseBranchSummary(stdOut) {
  return parseStringResponse(new BranchSummaryResult(), parsers9, stdOut);
}
var parsers9;
var init_parse_branch = __esm2({
  "src/lib/parsers/parse-branch.ts"() {
    init_BranchSummary();
    init_utils();
    parsers9 = [
      new LineParser(
        /^([*+]\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/,
        (result, [current2, name, commit3, label]) => {
          result.push(branchStatus(current2), true, name, commit3, label);
        }
      ),
      new LineParser(
        new RegExp("^([*+]\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$", "s"),
        (result, [current2, name, commit3, label]) => {
          result.push(branchStatus(current2), false, name, commit3, label);
        }
      )
    ];
  }
});
var branch_exports = {};
__export2(branch_exports, {
  branchLocalTask: () => branchLocalTask,
  branchTask: () => branchTask,
  containsDeleteBranchCommand: () => containsDeleteBranchCommand,
  deleteBranchTask: () => deleteBranchTask,
  deleteBranchesTask: () => deleteBranchesTask
});
function containsDeleteBranchCommand(commands) {
  const deleteCommands = ["-d", "-D", "--delete"];
  return commands.some((command) => deleteCommands.includes(command));
}
function branchTask(customArgs) {
  const isDelete = containsDeleteBranchCommand(customArgs);
  const commands = ["branch", ...customArgs];
  if (commands.length === 1) {
    commands.push("-a");
  }
  if (!commands.includes("-v")) {
    commands.splice(1, 0, "-v");
  }
  return {
    format: "utf-8",
    commands,
    parser(stdOut, stdErr) {
      if (isDelete) {
        return parseBranchDeletions(stdOut, stdErr).all[0];
      }
      return parseBranchSummary(stdOut);
    }
  };
}
function branchLocalTask() {
  const parser4 = parseBranchSummary;
  return {
    format: "utf-8",
    commands: ["branch", "-v"],
    parser: parser4
  };
}
function deleteBranchesTask(branches, forceDelete = false) {
  return {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", ...branches],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr);
    },
    onError({ exitCode, stdOut }, error4, done11, fail19) {
      if (!hasBranchDeletionError(String(error4), exitCode)) {
        return fail19(error4);
      }
      done11(stdOut);
    }
  };
}
function deleteBranchTask(branch, forceDelete = false) {
  const task = {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", branch],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr).branches[branch];
    },
    onError({ exitCode, stdErr, stdOut }, error4, _2, fail19) {
      if (!hasBranchDeletionError(String(error4), exitCode)) {
        return fail19(error4);
      }
      throw new GitResponseError(
        task.parser(bufferToString(stdOut), bufferToString(stdErr)),
        String(error4)
      );
    }
  };
  return task;
}
var init_branch = __esm2({
  "src/lib/tasks/branch.ts"() {
    init_git_response_error();
    init_parse_branch_delete();
    init_parse_branch();
    init_utils();
  }
});
var parseCheckIgnore;
var init_CheckIgnore = __esm2({
  "src/lib/responses/CheckIgnore.ts"() {
    parseCheckIgnore = (text) => {
      return text.split(/\n/g).map((line) => line.trim()).filter((file) => !!file);
    };
  }
});
var check_ignore_exports = {};
__export2(check_ignore_exports, {
  checkIgnoreTask: () => checkIgnoreTask
});
function checkIgnoreTask(paths) {
  return {
    commands: ["check-ignore", ...paths],
    format: "utf-8",
    parser: parseCheckIgnore
  };
}
var init_check_ignore = __esm2({
  "src/lib/tasks/check-ignore.ts"() {
    init_CheckIgnore();
  }
});
var clone_exports = {};
__export2(clone_exports, {
  cloneMirrorTask: () => cloneMirrorTask,
  cloneTask: () => cloneTask
});
function disallowedCommand(command) {
  return /^--upload-pack(=|$)/.test(command);
}
function cloneTask(repo, directory, customArgs) {
  const commands = ["clone", ...customArgs];
  filterString(repo) && commands.push(repo);
  filterString(directory) && commands.push(directory);
  const banned = commands.find(disallowedCommand);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return straightThroughStringTask(commands);
}
function cloneMirrorTask(repo, directory, customArgs) {
  append4(customArgs, "--mirror");
  return cloneTask(repo, directory, customArgs);
}
var init_clone = __esm2({
  "src/lib/tasks/clone.ts"() {
    init_task();
    init_utils();
  }
});
function parseFetchResult(stdOut, stdErr) {
  const result = {
    raw: stdOut,
    remote: null,
    branches: [],
    tags: [],
    updated: [],
    deleted: []
  };
  return parseStringResponse(result, parsers10, [stdOut, stdErr]);
}
var parsers10;
var init_parse_fetch = __esm2({
  "src/lib/parsers/parse-fetch.ts"() {
    init_utils();
    parsers10 = [
      new LineParser(/From (.+)$/, (result, [remote]) => {
        result.remote = remote;
      }),
      new LineParser(/\* \[new branch]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.branches.push({
          name,
          tracking
        });
      }),
      new LineParser(/\* \[new tag]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.tags.push({
          name,
          tracking
        });
      }),
      new LineParser(/- \[deleted]\s+\S+\s*-> (.+)$/, (result, [tracking]) => {
        result.deleted.push({
          tracking
        });
      }),
      new LineParser(
        /\s*([^.]+)\.\.(\S+)\s+(\S+)\s*-> (.+)$/,
        (result, [from, to, name, tracking]) => {
          result.updated.push({
            name,
            tracking,
            to,
            from
          });
        }
      )
    ];
  }
});
var fetch_exports = {};
__export2(fetch_exports, {
  fetchTask: () => fetchTask
});
function disallowedCommand2(command) {
  return /^--upload-pack(=|$)/.test(command);
}
function fetchTask(remote, branch, customArgs) {
  const commands = ["fetch", ...customArgs];
  if (remote && branch) {
    commands.push(remote, branch);
  }
  const banned = commands.find(disallowedCommand2);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return {
    commands,
    format: "utf-8",
    parser: parseFetchResult
  };
}
var init_fetch = __esm2({
  "src/lib/tasks/fetch.ts"() {
    init_parse_fetch();
    init_task();
  }
});
function parseMoveResult(stdOut) {
  return parseStringResponse({ moves: [] }, parsers11, stdOut);
}
var parsers11;
var init_parse_move = __esm2({
  "src/lib/parsers/parse-move.ts"() {
    init_utils();
    parsers11 = [
      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {
        result.moves.push({ from, to });
      })
    ];
  }
});
var move_exports = {};
__export2(move_exports, {
  moveTask: () => moveTask
});
function moveTask(from, to) {
  return {
    commands: ["mv", "-v", ...asArray(from), to],
    format: "utf-8",
    parser: parseMoveResult
  };
}
var init_move = __esm2({
  "src/lib/tasks/move.ts"() {
    init_parse_move();
    init_utils();
  }
});
var pull_exports2 = {};
__export2(pull_exports2, {
  pullTask: () => pullTask
});
function pullTask(remote, branch, customArgs) {
  const commands = ["pull", ...customArgs];
  if (remote && branch) {
    commands.splice(1, 0, remote, branch);
  }
  return {
    commands,
    format: "utf-8",
    parser(stdOut, stdErr) {
      return parsePullResult(stdOut, stdErr);
    },
    onError(result, _error, _done, fail19) {
      const pullError = parsePullErrorResult(
        bufferToString(result.stdOut),
        bufferToString(result.stdErr)
      );
      if (pullError) {
        return fail19(new GitResponseError(pullError));
      }
      fail19(_error);
    }
  };
}
var init_pull = __esm2({
  "src/lib/tasks/pull.ts"() {
    init_git_response_error();
    init_parse_pull();
    init_utils();
  }
});
function parseGetRemotes(text) {
  const remotes = {};
  forEach12(text, ([name]) => remotes[name] = { name });
  return Object.values(remotes);
}
function parseGetRemotesVerbose(text) {
  const remotes = {};
  forEach12(text, ([name, url3, purpose]) => {
    if (!remotes.hasOwnProperty(name)) {
      remotes[name] = {
        name,
        refs: { fetch: "", push: "" }
      };
    }
    if (purpose && url3) {
      remotes[name].refs[purpose.replace(/[^a-z]/g, "")] = url3;
    }
  });
  return Object.values(remotes);
}
function forEach12(text, handler) {
  forEachLineWithContent(text, (line) => handler(line.split(/\s+/)));
}
var init_GetRemoteSummary = __esm2({
  "src/lib/responses/GetRemoteSummary.ts"() {
    init_utils();
  }
});
var remote_exports = {};
__export2(remote_exports, {
  addRemoteTask: () => addRemoteTask,
  getRemotesTask: () => getRemotesTask,
  listRemotesTask: () => listRemotesTask,
  remoteTask: () => remoteTask,
  removeRemoteTask: () => removeRemoteTask
});
function addRemoteTask(remoteName, remoteRepo, customArgs) {
  return straightThroughStringTask(["remote", "add", ...customArgs, remoteName, remoteRepo]);
}
function getRemotesTask(verbose) {
  const commands = ["remote"];
  if (verbose) {
    commands.push("-v");
  }
  return {
    commands,
    format: "utf-8",
    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes
  };
}
function listRemotesTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "ls-remote") {
    commands.unshift("ls-remote");
  }
  return straightThroughStringTask(commands);
}
function remoteTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "remote") {
    commands.unshift("remote");
  }
  return straightThroughStringTask(commands);
}
function removeRemoteTask(remoteName) {
  return straightThroughStringTask(["remote", "remove", remoteName]);
}
var init_remote = __esm2({
  "src/lib/tasks/remote.ts"() {
    init_GetRemoteSummary();
    init_task();
  }
});
var stash_list_exports = {};
__export2(stash_list_exports, {
  stashListTask: () => stashListTask
});
function stashListTask(opt = {}, customArgs) {
  const options = parseLogOptions(opt);
  const commands = ["stash", "list", ...options.commands, ...customArgs];
  const parser4 = createListLogSummaryParser(
    options.splitter,
    options.fields,
    logFormatFromCommand(commands)
  );
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: parser4
  };
}
var init_stash_list = __esm2({
  "src/lib/tasks/stash-list.ts"() {
    init_log_format();
    init_parse_list_log_summary();
    init_diff();
    init_log();
  }
});
var sub_module_exports = {};
__export2(sub_module_exports, {
  addSubModuleTask: () => addSubModuleTask,
  initSubModuleTask: () => initSubModuleTask,
  subModuleTask: () => subModuleTask,
  updateSubModuleTask: () => updateSubModuleTask
});
function addSubModuleTask(repo, path3) {
  return subModuleTask(["add", repo, path3]);
}
function initSubModuleTask(customArgs) {
  return subModuleTask(["init", ...customArgs]);
}
function subModuleTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "submodule") {
    commands.unshift("submodule");
  }
  return straightThroughStringTask(commands);
}
function updateSubModuleTask(customArgs) {
  return subModuleTask(["update", ...customArgs]);
}
var init_sub_module = __esm2({
  "src/lib/tasks/sub-module.ts"() {
    init_task();
  }
});
function singleSorted(a2, b) {
  const aIsNum = isNaN(a2);
  const bIsNum = isNaN(b);
  if (aIsNum !== bIsNum) {
    return aIsNum ? 1 : -1;
  }
  return aIsNum ? sorted(a2, b) : 0;
}
function sorted(a2, b) {
  return a2 === b ? 0 : a2 > b ? 1 : -1;
}
function trimmed(input2) {
  return input2.trim();
}
function toNumber(input2) {
  if (typeof input2 === "string") {
    return parseInt(input2.replace(/^\D+/g, ""), 10) || 0;
  }
  return 0;
}
var TagList;
var parseTagList;
var init_TagList = __esm2({
  "src/lib/responses/TagList.ts"() {
    TagList = class {
      constructor(all8, latest) {
        this.all = all8;
        this.latest = latest;
      }
    };
    parseTagList = function(data, customSort = false) {
      const tags = data.split("\n").map(trimmed).filter(Boolean);
      if (!customSort) {
        tags.sort(function(tagA, tagB) {
          const partsA = tagA.split(".");
          const partsB = tagB.split(".");
          if (partsA.length === 1 || partsB.length === 1) {
            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));
          }
          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {
            const diff8 = sorted(toNumber(partsA[i]), toNumber(partsB[i]));
            if (diff8) {
              return diff8;
            }
          }
          return 0;
        });
      }
      const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(".") >= 0);
      return new TagList(tags, latest);
    };
  }
});
var tag_exports = {};
__export2(tag_exports, {
  addAnnotatedTagTask: () => addAnnotatedTagTask,
  addTagTask: () => addTagTask,
  tagListTask: () => tagListTask
});
function tagListTask(customArgs = []) {
  const hasCustomSort = customArgs.some((option5) => /^--sort=/.test(option5));
  return {
    format: "utf-8",
    commands: ["tag", "-l", ...customArgs],
    parser(text) {
      return parseTagList(text, hasCustomSort);
    }
  };
}
function addTagTask(name) {
  return {
    format: "utf-8",
    commands: ["tag", name],
    parser() {
      return { name };
    }
  };
}
function addAnnotatedTagTask(name, tagMessage) {
  return {
    format: "utf-8",
    commands: ["tag", "-a", "-m", tagMessage, name],
    parser() {
      return { name };
    }
  };
}
var init_tag = __esm2({
  "src/lib/tasks/tag.ts"() {
    init_TagList();
  }
});
var require_git = __commonJS2({
  "src/git.js"(exports, module) {
    var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS(git_executor_exports));
    var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS(simple_git_api_exports));
    var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS(scheduler_exports));
    var { configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS(task_exports));
    var {
      asArray: asArray2,
      filterArray: filterArray2,
      filterPrimitives: filterPrimitives2,
      filterString: filterString2,
      filterStringOrStringArray: filterStringOrStringArray2,
      filterType: filterType2,
      getTrailingOptions: getTrailingOptions2,
      trailingFunctionArgument: trailingFunctionArgument2,
      trailingOptionsArgument: trailingOptionsArgument2
    } = (init_utils(), __toCommonJS(utils_exports));
    var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS(apply_patch_exports));
    var {
      branchTask: branchTask2,
      branchLocalTask: branchLocalTask2,
      deleteBranchesTask: deleteBranchesTask2,
      deleteBranchTask: deleteBranchTask2
    } = (init_branch(), __toCommonJS(branch_exports));
    var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS(check_ignore_exports));
    var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS(check_is_repo_exports));
    var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS(clone_exports));
    var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS(clean_exports));
    var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS(diff_exports));
    var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS(fetch_exports));
    var { moveTask: moveTask2 } = (init_move(), __toCommonJS(move_exports));
    var { pullTask: pullTask2 } = (init_pull(), __toCommonJS(pull_exports2));
    var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS(push_exports));
    var {
      addRemoteTask: addRemoteTask2,
      getRemotesTask: getRemotesTask2,
      listRemotesTask: listRemotesTask2,
      remoteTask: remoteTask2,
      removeRemoteTask: removeRemoteTask2
    } = (init_remote(), __toCommonJS(remote_exports));
    var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS(reset_exports));
    var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS(stash_list_exports));
    var {
      addSubModuleTask: addSubModuleTask2,
      initSubModuleTask: initSubModuleTask2,
      subModuleTask: subModuleTask2,
      updateSubModuleTask: updateSubModuleTask2
    } = (init_sub_module(), __toCommonJS(sub_module_exports));
    var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS(tag_exports));
    var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS(task_exports));
    function Git22(options, plugins) {
      this._plugins = plugins;
      this._executor = new GitExecutor2(
        options.baseDir,
        new Scheduler2(options.maxConcurrentProcesses),
        plugins
      );
      this._trimmed = options.trimmed;
    }
    (Git22.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git22;
    Git22.prototype.customBinary = function(command) {
      this._plugins.reconfigure("binary", command);
      return this;
    };
    Git22.prototype.env = function(name, value) {
      if (arguments.length === 1 && typeof name === "object") {
        this._executor.env = name;
      } else {
        (this._executor.env = this._executor.env || {})[name] = value;
      }
      return this;
    };
    Git22.prototype.stashList = function(options) {
      return this._runTask(
        stashListTask2(
          trailingOptionsArgument2(arguments) || {},
          filterArray2(options) && options || []
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    function createCloneTask(api, task, repoPath, localPath) {
      if (typeof repoPath !== "string") {
        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);
      }
      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));
    }
    Git22.prototype.clone = function() {
      return this._runTask(
        createCloneTask("clone", cloneTask2, ...arguments),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.mirror = function() {
      return this._runTask(
        createCloneTask("mirror", cloneMirrorTask2, ...arguments),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.mv = function(from, to) {
      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.checkoutLatestTag = function(then) {
      var git = this;
      return this.pull(function() {
        git.tags(function(err, tags) {
          git.checkout(tags.latest, then);
        });
      });
    };
    Git22.prototype.pull = function(remote, branch, options, then) {
      return this._runTask(
        pullTask2(
          filterType2(remote, filterString2),
          filterType2(branch, filterString2),
          getTrailingOptions2(arguments)
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.fetch = function(remote, branch) {
      return this._runTask(
        fetchTask2(
          filterType2(remote, filterString2),
          filterType2(branch, filterString2),
          getTrailingOptions2(arguments)
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.silent = function(silence) {
      console.warn(
        "simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3"
      );
      return this;
    };
    Git22.prototype.tags = function(options, then) {
      return this._runTask(
        tagListTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.rebase = function() {
      return this._runTask(
        straightThroughStringTask2(["rebase", ...getTrailingOptions2(arguments)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.reset = function(mode) {
      return this._runTask(
        resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.revert = function(commit3) {
      const next = trailingFunctionArgument2(arguments);
      if (typeof commit3 !== "string") {
        return this._runTask(configurationErrorTask2("Commit must be a string"), next);
      }
      return this._runTask(
        straightThroughStringTask2(["revert", ...getTrailingOptions2(arguments, 0, true), commit3]),
        next
      );
    };
    Git22.prototype.addTag = function(name) {
      const task = typeof name === "string" ? addTagTask2(name) : configurationErrorTask2("Git.addTag requires a tag name");
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git22.prototype.addAnnotatedTag = function(tagName, tagMessage) {
      return this._runTask(
        addAnnotatedTagTask2(tagName, tagMessage),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {
      return this._runTask(
        deleteBranchTask2(branchName, typeof forceDelete === "boolean" ? forceDelete : false),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {
      return this._runTask(
        deleteBranchesTask2(branchNames, typeof forceDelete === "boolean" ? forceDelete : false),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.branch = function(options, then) {
      return this._runTask(
        branchTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.branchLocal = function(then) {
      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.raw = function(commands) {
      const createRestCommands = !Array.isArray(commands);
      const command = [].slice.call(createRestCommands ? arguments : commands, 0);
      for (let i = 0; i < command.length && createRestCommands; i++) {
        if (!filterPrimitives2(command[i])) {
          command.splice(i, command.length - i);
          break;
        }
      }
      command.push(...getTrailingOptions2(arguments, 0, true));
      var next = trailingFunctionArgument2(arguments);
      if (!command.length) {
        return this._runTask(
          configurationErrorTask2("Raw: must supply one or more command to execute"),
          next
        );
      }
      return this._runTask(straightThroughStringTask2(command, this._trimmed), next);
    };
    Git22.prototype.submoduleAdd = function(repo, path3, then) {
      return this._runTask(addSubModuleTask2(repo, path3), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.submoduleUpdate = function(args2, then) {
      return this._runTask(
        updateSubModuleTask2(getTrailingOptions2(arguments, true)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.submoduleInit = function(args2, then) {
      return this._runTask(
        initSubModuleTask2(getTrailingOptions2(arguments, true)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.subModule = function(options, then) {
      return this._runTask(
        subModuleTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.listRemote = function() {
      return this._runTask(
        listRemotesTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.addRemote = function(remoteName, remoteRepo, then) {
      return this._runTask(
        addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.removeRemote = function(remoteName, then) {
      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.getRemotes = function(verbose, then) {
      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.remote = function(options, then) {
      return this._runTask(
        remoteTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.tag = function(options, then) {
      const command = getTrailingOptions2(arguments);
      if (command[0] !== "tag") {
        command.unshift("tag");
      }
      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.updateServerInfo = function(then) {
      return this._runTask(
        straightThroughStringTask2(["update-server-info"]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.pushTags = function(remote, then) {
      const task = pushTagsTask2(
        { remote: filterType2(remote, filterString2) },
        getTrailingOptions2(arguments)
      );
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git22.prototype.rm = function(files) {
      return this._runTask(
        straightThroughStringTask2(["rm", "-f", ...asArray2(files)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.rmKeepLocal = function(files) {
      return this._runTask(
        straightThroughStringTask2(["rm", "--cached", ...asArray2(files)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.catFile = function(options, then) {
      return this._catFile("utf-8", arguments);
    };
    Git22.prototype.binaryCatFile = function() {
      return this._catFile("buffer", arguments);
    };
    Git22.prototype._catFile = function(format5, args2) {
      var handler = trailingFunctionArgument2(args2);
      var command = ["cat-file"];
      var options = args2[0];
      if (typeof options === "string") {
        return this._runTask(
          configurationErrorTask2("Git.catFile: options must be supplied as an array of strings"),
          handler
        );
      }
      if (Array.isArray(options)) {
        command.push.apply(command, options);
      }
      const task = format5 === "buffer" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);
      return this._runTask(task, handler);
    };
    Git22.prototype.diff = function(options, then) {
      const task = filterString2(options) ? configurationErrorTask2(
        "git.diff: supplying options as a single string is no longer supported, switch to an array of strings"
      ) : straightThroughStringTask2(["diff", ...getTrailingOptions2(arguments)]);
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git22.prototype.diffSummary = function() {
      return this._runTask(
        diffSummaryTask2(getTrailingOptions2(arguments, 1)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.applyPatch = function(patches) {
      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(
        `git.applyPatch requires one or more string patches as the first argument`
      ) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git22.prototype.revparse = function() {
      const commands = ["rev-parse", ...getTrailingOptions2(arguments, true)];
      return this._runTask(
        straightThroughStringTask2(commands, true),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.clean = function(mode, options, then) {
      const usingCleanOptionsArray = isCleanOptionsArray2(mode);
      const cleanMode = usingCleanOptionsArray && mode.join("") || filterType2(mode, filterString2) || "";
      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));
      return this._runTask(
        cleanWithOptionsTask2(cleanMode, customArgs),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.exec = function(then) {
      const task = {
        commands: [],
        format: "utf-8",
        parser() {
          if (typeof then === "function") {
            then();
          }
        }
      };
      return this._runTask(task);
    };
    Git22.prototype.clearQueue = function() {
      return this;
    };
    Git22.prototype.checkIgnore = function(pathnames, then) {
      return this._runTask(
        checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))),
        trailingFunctionArgument2(arguments)
      );
    };
    Git22.prototype.checkIsRepo = function(checkType, then) {
      return this._runTask(
        checkIsRepoTask2(filterType2(checkType, filterString2)),
        trailingFunctionArgument2(arguments)
      );
    };
    module.exports = Git22;
  }
});
init_pathspec();
init_git_error();
var GitConstructError = class extends GitError {
  constructor(config2, message) {
    super(void 0, message);
    this.config = config2;
  }
};
init_git_error();
init_git_error();
var GitPluginError = class extends GitError {
  constructor(task, plugin, message) {
    super(task, message);
    this.task = task;
    this.plugin = plugin;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
init_git_response_error();
init_task_configuration_error();
init_check_is_repo();
init_clean();
init_config();
init_diff_name_status();
init_grep();
init_reset();
function abortPlugin(signal) {
  if (!signal) {
    return;
  }
  const onSpawnAfter = {
    type: "spawn.after",
    action(_data, context8) {
      function kill() {
        context8.kill(new GitPluginError(void 0, "abort", "Abort signal received"));
      }
      signal.addEventListener("abort", kill);
      context8.spawned.on("close", () => signal.removeEventListener("abort", kill));
    }
  };
  const onSpawnBefore = {
    type: "spawn.before",
    action(_data, context8) {
      if (signal.aborted) {
        context8.kill(new GitPluginError(void 0, "abort", "Abort already signaled"));
      }
    }
  };
  return [onSpawnBefore, onSpawnAfter];
}
function isConfigSwitch(arg) {
  return typeof arg === "string" && arg.trim().toLowerCase() === "-c";
}
function preventProtocolOverride(arg, next) {
  if (!isConfigSwitch(arg)) {
    return;
  }
  if (!/^\s*protocol(.[a-z]+)?.allow/.test(next)) {
    return;
  }
  throw new GitPluginError(
    void 0,
    "unsafe",
    "Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol"
  );
}
function preventUploadPack(arg, method) {
  if (/^\s*--(upload|receive)-pack/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`
    );
  }
  if (method === "clone" && /^\s*-u\b/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of clone with option -u is not permitted without enabling allowUnsafePack`
    );
  }
  if (method === "push" && /^\s*--exec\b/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of push with option --exec is not permitted without enabling allowUnsafePack`
    );
  }
}
function blockUnsafeOperationsPlugin({
  allowUnsafeProtocolOverride = false,
  allowUnsafePack = false
} = {}) {
  return {
    type: "spawn.args",
    action(args2, context8) {
      args2.forEach((current2, index) => {
        const next = index < args2.length ? args2[index + 1] : "";
        allowUnsafeProtocolOverride || preventProtocolOverride(current2, next);
        allowUnsafePack || preventUploadPack(current2, context8.method);
      });
      return args2;
    }
  };
}
init_utils();
function commandConfigPrefixingPlugin(configuration) {
  const prefix = prefixedArray(configuration, "-c");
  return {
    type: "spawn.args",
    action(data) {
      return [...prefix, ...data];
    }
  };
}
init_utils();
var never7 = (0, import_promise_deferred2.deferred)().promise;
function completionDetectionPlugin({
  onClose = true,
  onExit: onExit4 = 50
} = {}) {
  function createEvents() {
    let exitCode = -1;
    const events = {
      close: (0, import_promise_deferred2.deferred)(),
      closeTimeout: (0, import_promise_deferred2.deferred)(),
      exit: (0, import_promise_deferred2.deferred)(),
      exitTimeout: (0, import_promise_deferred2.deferred)()
    };
    const result = Promise.race([
      onClose === false ? never7 : events.closeTimeout.promise,
      onExit4 === false ? never7 : events.exitTimeout.promise
    ]);
    configureTimeout(onClose, events.close, events.closeTimeout);
    configureTimeout(onExit4, events.exit, events.exitTimeout);
    return {
      close(code) {
        exitCode = code;
        events.close.done();
      },
      exit(code) {
        exitCode = code;
        events.exit.done();
      },
      get exitCode() {
        return exitCode;
      },
      result
    };
  }
  function configureTimeout(flag, event, timeout5) {
    if (flag === false) {
      return;
    }
    (flag === true ? event.promise : event.promise.then(() => delay3(flag))).then(timeout5.done);
  }
  return {
    type: "spawn.after",
    action(_0, _1) {
      return __async(this, arguments, function* (_data, { spawned, close: close2 }) {
        var _a3, _b;
        const events = createEvents();
        let deferClose = true;
        let quickClose = () => void (deferClose = false);
        (_a3 = spawned.stdout) == null ? void 0 : _a3.on("data", quickClose);
        (_b = spawned.stderr) == null ? void 0 : _b.on("data", quickClose);
        spawned.on("error", quickClose);
        spawned.on("close", (code) => events.close(code));
        spawned.on("exit", (code) => events.exit(code));
        try {
          yield events.result;
          if (deferClose) {
            yield delay3(50);
          }
          close2(events.exitCode);
        } catch (err) {
          close2(events.exitCode, err);
        }
      });
    }
  };
}
init_utils();
var WRONG_NUMBER_ERR = `Invalid value supplied for custom binary, requires a single string or an array containing either one or two strings`;
var WRONG_CHARS_ERR = `Invalid value supplied for custom binary, restricted characters must be removed or supply the unsafe.allowUnsafeCustomBinary option`;
function isBadArgument(arg) {
  return !arg || !/^([a-z]:)?([a-z0-9/.\\_-]+)$/i.test(arg);
}
function toBinaryConfig(input2, allowUnsafe) {
  if (input2.length < 1 || input2.length > 2) {
    throw new GitPluginError(void 0, "binary", WRONG_NUMBER_ERR);
  }
  const isBad = input2.some(isBadArgument);
  if (isBad) {
    if (allowUnsafe) {
      console.warn(WRONG_CHARS_ERR);
    } else {
      throw new GitPluginError(void 0, "binary", WRONG_CHARS_ERR);
    }
  }
  const [binary, prefix] = input2;
  return {
    binary,
    prefix
  };
}
function customBinaryPlugin(plugins, input2 = ["git"], allowUnsafe = false) {
  let config2 = toBinaryConfig(asArray(input2), allowUnsafe);
  plugins.on("binary", (input22) => {
    config2 = toBinaryConfig(asArray(input22), allowUnsafe);
  });
  plugins.append("spawn.binary", () => {
    return config2.binary;
  });
  plugins.append("spawn.args", (data) => {
    return config2.prefix ? [config2.prefix, ...data] : data;
  });
}
init_git_error();
function isTaskError(result) {
  return !!(result.exitCode && result.stdErr.length);
}
function getErrorMessage(result) {
  return Buffer.concat([...result.stdOut, ...result.stdErr]);
}
function errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {
  return (error4, result) => {
    if (!overwrite && error4 || !isError(result)) {
      return error4;
    }
    return errorMessage(result);
  };
}
function errorDetectionPlugin(config2) {
  return {
    type: "task.error",
    action(data, context8) {
      const error4 = config2(data.error, {
        stdErr: context8.stdErr,
        stdOut: context8.stdOut,
        exitCode: context8.exitCode
      });
      if (Buffer.isBuffer(error4)) {
        return { error: new GitError(void 0, error4.toString("utf-8")) };
      }
      return {
        error: error4
      };
    }
  };
}
init_utils();
var PluginStore = class {
  constructor() {
    this.plugins = /* @__PURE__ */ new Set();
    this.events = new events.EventEmitter();
  }
  on(type, listener) {
    this.events.on(type, listener);
  }
  reconfigure(type, data) {
    this.events.emit(type, data);
  }
  append(type, action) {
    const plugin = append4(this.plugins, { type, action });
    return () => this.plugins.delete(plugin);
  }
  add(plugin) {
    const plugins = [];
    asArray(plugin).forEach((plugin2) => plugin2 && this.plugins.add(append4(plugins, plugin2)));
    return () => {
      plugins.forEach((plugin2) => this.plugins.delete(plugin2));
    };
  }
  exec(type, data, context8) {
    let output = data;
    const contextual = Object.freeze(Object.create(context8));
    for (const plugin of this.plugins) {
      if (plugin.type === type) {
        output = plugin.action(output, contextual);
      }
    }
    return output;
  }
};
init_utils();
function progressMonitorPlugin(progress) {
  const progressCommand = "--progress";
  const progressMethods = ["checkout", "clone", "fetch", "pull", "push"];
  const onProgress = {
    type: "spawn.after",
    action(_data, context8) {
      var _a2;
      if (!context8.commands.includes(progressCommand)) {
        return;
      }
      (_a2 = context8.spawned.stderr) == null ? void 0 : _a2.on("data", (chunk5) => {
        const message = /^([\s\S]+?):\s*(\d+)% \((\d+)\/(\d+)\)/.exec(chunk5.toString("utf8"));
        if (!message) {
          return;
        }
        progress({
          method: context8.method,
          stage: progressEventStage(message[1]),
          progress: asNumber(message[2]),
          processed: asNumber(message[3]),
          total: asNumber(message[4])
        });
      });
    }
  };
  const onArgs = {
    type: "spawn.args",
    action(args2, context8) {
      if (!progressMethods.includes(context8.method)) {
        return args2;
      }
      return including(args2, progressCommand);
    }
  };
  return [onArgs, onProgress];
}
function progressEventStage(input2) {
  return String(input2.toLowerCase().split(" ", 1)) || "unknown";
}
init_utils();
function spawnOptionsPlugin(spawnOptions) {
  const options = pick2(spawnOptions, ["uid", "gid"]);
  return {
    type: "spawn.options",
    action(data) {
      return __spreadValues(__spreadValues({}, options), data);
    }
  };
}
function timeoutPlugin({
  block,
  stdErr = true,
  stdOut = true
}) {
  if (block > 0) {
    return {
      type: "spawn.after",
      action(_data, context8) {
        var _a2, _b;
        let timeout5;
        function wait() {
          timeout5 && clearTimeout(timeout5);
          timeout5 = setTimeout(kill, block);
        }
        function stop2() {
          var _a3, _b2;
          (_a3 = context8.spawned.stdout) == null ? void 0 : _a3.off("data", wait);
          (_b2 = context8.spawned.stderr) == null ? void 0 : _b2.off("data", wait);
          context8.spawned.off("exit", stop2);
          context8.spawned.off("close", stop2);
          timeout5 && clearTimeout(timeout5);
        }
        function kill() {
          stop2();
          context8.kill(new GitPluginError(void 0, "timeout", `block timeout reached`));
        }
        stdOut && ((_a2 = context8.spawned.stdout) == null ? void 0 : _a2.on("data", wait));
        stdErr && ((_b = context8.spawned.stderr) == null ? void 0 : _b.on("data", wait));
        context8.spawned.on("exit", stop2);
        context8.spawned.on("close", stop2);
        wait();
      }
    };
  }
}
init_pathspec();
function suffixPathsPlugin() {
  return {
    type: "spawn.args",
    action(data) {
      const prefix = [];
      let suffix;
      function append22(args2) {
        (suffix = suffix || []).push(...args2);
      }
      for (let i = 0; i < data.length; i++) {
        const param = data[i];
        if (isPathSpec(param)) {
          append22(toPaths(param));
          continue;
        }
        if (param === "--") {
          append22(
            data.slice(i + 1).flatMap((item) => isPathSpec(item) && toPaths(item) || item)
          );
          break;
        }
        prefix.push(param);
      }
      return !suffix ? prefix : [...prefix, "--", ...suffix.map(String)];
    }
  };
}
init_utils();
var Git = require_git();
function gitInstanceFactory(baseDir, options) {
  var _a2;
  const plugins = new PluginStore();
  const config2 = createInstanceConfig(
    baseDir && (typeof baseDir === "string" ? { baseDir } : baseDir) || {},
    options
  );
  if (!folderExists(config2.baseDir)) {
    throw new GitConstructError(
      config2,
      `Cannot use simple-git on a directory that does not exist`
    );
  }
  if (Array.isArray(config2.config)) {
    plugins.add(commandConfigPrefixingPlugin(config2.config));
  }
  plugins.add(blockUnsafeOperationsPlugin(config2.unsafe));
  plugins.add(suffixPathsPlugin());
  plugins.add(completionDetectionPlugin(config2.completion));
  config2.abort && plugins.add(abortPlugin(config2.abort));
  config2.progress && plugins.add(progressMonitorPlugin(config2.progress));
  config2.timeout && plugins.add(timeoutPlugin(config2.timeout));
  config2.spawnOptions && plugins.add(spawnOptionsPlugin(config2.spawnOptions));
  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));
  config2.errors && plugins.add(errorDetectionPlugin(config2.errors));
  customBinaryPlugin(plugins, config2.binary, (_a2 = config2.unsafe) == null ? void 0 : _a2.allowUnsafeCustomBinary);
  return new Git(config2, plugins);
}
init_git_response_error();
var simpleGit = gitInstanceFactory;

// src/utils/config.ts
var input = (name) => Config_exports.nested(Config_exports.nonEmptyString(name), "input");

// src/Git.ts
var GitError2 = class extends Data_exports.TaggedError("GitError") {
  get message() {
    return this.cause.message;
  }
};
var Git2 = class extends Effect_exports.Service()("app/Git", {
  effect: Effect_exports.gen(function* () {
    const githubActor = Config_exports.nonEmptyString("github_actor");
    const githubActorEmail = githubActor.pipe(
      Config_exports.map((actor) => `${actor}@users.noreply.github.com`)
    );
    const userName = yield* input("git_user").pipe(
      Config_exports.orElse(() => githubActor)
    );
    const userEmail = yield* input("git_email").pipe(
      Config_exports.orElse(() => githubActorEmail)
    );
    const clone4 = Effect_exports.fn("Git.clone")(
      (url3, directory) => Effect_exports.tryPromise({
        try: () => simpleGit().clone(url3, directory),
        catch: (cause3) => new GitError2({ cause: cause3 })
      })
    );
    const open = Effect_exports.fn("Git.open")(
      function* (directory, ref) {
        const git = simpleGit(directory);
        const use = Effect_exports.fn("Git.use", { attributes: { directory } })(
          (f2) => Effect_exports.tryPromise({
            try: () => f2(git),
            catch: (cause3) => new GitError2({ cause: cause3 })
          })
        );
        const getCheckoutInfo = Effect_exports.fn("Git.getCheckoutInfo")(
          function* (ref2) {
            const lowerRef = ref2.toLowerCase();
            if (lowerRef.startsWith("refs/heads/")) {
              const branch = ref2.substring("refs/heads/".length);
              return { ref: branch, startPoint: `refs/remotes/origin/${branch}` };
            }
            if (lowerRef.startsWith("refs/pull/")) {
              const branch = ref2.substring("refs/pull/".length);
              return { ref: `refs/remotes/pull/${branch}` };
            }
            if (lowerRef.startsWith("refs/tags/")) {
              return { ref: ref2 };
            }
            if (lowerRef.startsWith("refs/")) {
              return { ref: ref2 };
            }
            const branches = yield* use((git2) => git2.branch(["--list", "--remote", `origin/${ref2}`]));
            if (branches.all.length > 0) {
              return { ref: ref2, startPoint: `refs/remotes/origin/${ref2}` };
            }
            const tags = yield* use((git2) => git2.tags(["--list", ref2]));
            if (tags.all.length > 0) {
              return { ref: `refs/tags/${ref2}` };
            }
            return yield* new GitError2({
              cause: new GitError(void 0, `Could not find matching ref for ${ref2}`)
            });
          }
        );
        yield* use(
          (git2) => git2.addConfig("user.name", userName).addConfig("user.email", userEmail)
        );
        const info3 = yield* getCheckoutInfo(ref);
        yield* use(
          (git2) => info3.startPoint ? git2.checkoutBranch(info3.ref, info3.startPoint) : git2.checkout(info3.ref).then(constVoid)
        );
        return {
          use,
          path: directory
        };
      }
    );
    return {
      clone: clone4,
      open
    };
  })
}) {
};

// node_modules/.pnpm/@rollup+plugin-node-resolve@16.0.1_@rollup+wasm-node@4.37.0/node_modules/@rollup/plugin-node-resolve/dist/es/index.js
var import_deepmerge = __toESM(require_cjs());
var import_is_module = __toESM(require_is_module());
var import_resolve = __toESM(require_resolve());
var import_picomatch = __toESM(require_picomatch2());
function isArray2(arg) {
  return Array.isArray(arg);
}
function ensureArray(thing) {
  if (isArray2(thing))
    return thing;
  if (thing == null)
    return [];
  return [thing];
}
var normalizePathRegExp = new RegExp(`\\${p2.win32.sep}`, "g");
var normalizePath = function normalizePath2(filename) {
  return filename.replace(normalizePathRegExp, p2.posix.sep);
};
function getMatcherString(id2, resolutionBase) {
  if (resolutionBase === false || p2.isAbsolute(id2) || id2.startsWith("**")) {
    return normalizePath(id2);
  }
  const basePath = normalizePath(p2.resolve(resolutionBase || "")).replace(/[-^$*+?.()|[\]{}]/g, "\\$&");
  return p2.posix.join(basePath, normalizePath(id2));
}
var createFilter = function createFilter2(include, exclude3, options) {
  const resolutionBase = options && options.resolve;
  const getMatcher = (id2) => id2 instanceof RegExp ? id2 : {
    test: (what) => {
      const pattern = getMatcherString(id2, resolutionBase);
      const fn2 = (0, import_picomatch.default)(pattern, { dot: true });
      const result = fn2(what);
      return result;
    }
  };
  const includeMatchers = ensureArray(include).map(getMatcher);
  const excludeMatchers = ensureArray(exclude3).map(getMatcher);
  if (!includeMatchers.length && !excludeMatchers.length)
    return (id2) => typeof id2 === "string" && !id2.includes("\0");
  return function result(id2) {
    if (typeof id2 !== "string")
      return false;
    if (id2.includes("\0"))
      return false;
    const pathId = normalizePath(id2);
    for (let i = 0; i < excludeMatchers.length; ++i) {
      const matcher = excludeMatchers[i];
      if (matcher instanceof RegExp) {
        matcher.lastIndex = 0;
      }
      if (matcher.test(pathId))
        return false;
    }
    for (let i = 0; i < includeMatchers.length; ++i) {
      const matcher = includeMatchers[i];
      if (matcher instanceof RegExp) {
        matcher.lastIndex = 0;
      }
      if (matcher.test(pathId))
        return true;
    }
    return !includeMatchers.length;
  };
};
var reservedWords = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
var builtins = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
var forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(" "));
forbiddenIdentifiers.add("");

// node_modules/.pnpm/@rollup+plugin-node-resolve@16.0.1_@rollup+wasm-node@4.37.0/node_modules/@rollup/plugin-node-resolve/dist/es/index.js
var version = "16.0.1";
var peerDependencies = {
  rollup: "^2.78.0||^3.0.0||^4.0.0"
};
util.promisify(fs__default.default.access);
var readFile$1 = util.promisify(fs__default.default.readFile);
var realpath = util.promisify(fs__default.default.realpath);
var stat = util.promisify(fs__default.default.stat);
async function fileExists(filePath) {
  try {
    const res = await stat(filePath);
    return res.isFile();
  } catch {
    return false;
  }
}
async function resolveSymlink(path3) {
  return await fileExists(path3) ? realpath(path3) : path3;
}
var onError6 = (error4) => {
  if (error4.code === "ENOENT") {
    return false;
  }
  throw error4;
};
var makeCache = (fn2) => {
  const cache3 = /* @__PURE__ */ new Map();
  const wrapped = async (param, done11) => {
    if (cache3.has(param) === false) {
      cache3.set(
        param,
        fn2(param).catch((err) => {
          cache3.delete(param);
          throw err;
        })
      );
    }
    try {
      const result = cache3.get(param);
      const value = await result;
      return done11(null, value);
    } catch (error4) {
      return done11(error4);
    }
  };
  wrapped.clear = () => cache3.clear();
  return wrapped;
};
var isDirCached = makeCache(async (file) => {
  try {
    const stats = await stat(file);
    return stats.isDirectory();
  } catch (error4) {
    return onError6(error4);
  }
});
var isFileCached = makeCache(async (file) => {
  try {
    const stats = await stat(file);
    return stats.isFile();
  } catch (error4) {
    return onError6(error4);
  }
});
var readCachedFile = makeCache(readFile$1);
function handleDeprecatedOptions(opts) {
  const warnings = [];
  if (opts.customResolveOptions) {
    const { customResolveOptions } = opts;
    if (customResolveOptions.moduleDirectory) {
      opts.moduleDirectories = Array.isArray(customResolveOptions.moduleDirectory) ? customResolveOptions.moduleDirectory : [customResolveOptions.moduleDirectory];
      warnings.push(
        "node-resolve: The `customResolveOptions.moduleDirectory` option has been deprecated. Use `moduleDirectories`, which must be an array."
      );
    }
    if (customResolveOptions.preserveSymlinks) {
      throw new Error(
        "node-resolve: `customResolveOptions.preserveSymlinks` is no longer an option. We now always use the rollup `preserveSymlinks` option."
      );
    }
    [
      "basedir",
      "package",
      "extensions",
      "includeCoreModules",
      "readFile",
      "isFile",
      "isDirectory",
      "realpath",
      "packageFilter",
      "pathFilter",
      "paths",
      "packageIterator"
    ].forEach((resolveOption) => {
      if (customResolveOptions[resolveOption]) {
        throw new Error(
          `node-resolve: \`customResolveOptions.${resolveOption}\` is no longer an option. If you need this, please open an issue.`
        );
      }
    });
  }
  return { warnings };
}
function getPackageName(id2) {
  if (id2.startsWith(".") || id2.startsWith("/")) {
    return null;
  }
  const split3 = id2.split("/");
  if (split3[0][0] === "@") {
    return `${split3[0]}/${split3[1]}`;
  }
  return split3[0];
}
function getMainFields(options) {
  let mainFields;
  if (options.mainFields) {
    ({ mainFields } = options);
  } else {
    mainFields = ["module", "main"];
  }
  if (options.browser && mainFields.indexOf("browser") === -1) {
    return ["browser"].concat(mainFields);
  }
  if (!mainFields.length) {
    throw new Error("Please ensure at least one `mainFields` value is specified");
  }
  return mainFields;
}
function getPackageInfo(options) {
  const {
    cache: cache3,
    extensions,
    pkg,
    mainFields,
    preserveSymlinks,
    useBrowserOverrides,
    rootDir,
    ignoreSideEffectsForRoot
  } = options;
  let { pkgPath } = options;
  if (cache3.has(pkgPath)) {
    return cache3.get(pkgPath);
  }
  if (!preserveSymlinks) {
    pkgPath = fs.realpathSync(pkgPath);
  }
  const pkgRoot = p2.dirname(pkgPath);
  const packageInfo = {
    // copy as we are about to munge the `main` field of `pkg`.
    packageJson: { ...pkg },
    // path to package.json file
    packageJsonPath: pkgPath,
    // directory containing the package.json
    root: pkgRoot,
    // which main field was used during resolution of this module (main, module, or browser)
    resolvedMainField: "main",
    // whether the browser map was used to resolve the entry point to this module
    browserMappedMain: false,
    // the entry point of the module with respect to the selected main field and any
    // relevant browser mappings.
    resolvedEntryPoint: ""
  };
  let overriddenMain = false;
  for (let i = 0; i < mainFields.length; i++) {
    const field = mainFields[i];
    if (typeof pkg[field] === "string") {
      pkg.main = pkg[field];
      packageInfo.resolvedMainField = field;
      overriddenMain = true;
      break;
    }
  }
  const internalPackageInfo = {
    cachedPkg: pkg,
    hasModuleSideEffects: () => null,
    hasPackageEntry: overriddenMain !== false || mainFields.indexOf("main") !== -1,
    packageBrowserField: useBrowserOverrides && typeof pkg.browser === "object" && Object.keys(pkg.browser).reduce((browser, key) => {
      let resolved = pkg.browser[key];
      if (resolved && resolved[0] === ".") {
        resolved = p2.resolve(pkgRoot, resolved);
      }
      browser[key] = resolved;
      if (key[0] === ".") {
        const absoluteKey = p2.resolve(pkgRoot, key);
        browser[absoluteKey] = resolved;
        if (!p2.extname(key)) {
          extensions.reduce((subBrowser, ext) => {
            subBrowser[absoluteKey + ext] = subBrowser[key];
            return subBrowser;
          }, browser);
        }
      }
      return browser;
    }, {}),
    packageInfo
  };
  const browserMap = internalPackageInfo.packageBrowserField;
  if (useBrowserOverrides && typeof pkg.browser === "object" && // eslint-disable-next-line no-prototype-builtins
  browserMap.hasOwnProperty(pkg.main)) {
    packageInfo.resolvedEntryPoint = browserMap[pkg.main];
    packageInfo.browserMappedMain = true;
  } else {
    packageInfo.resolvedEntryPoint = p2.resolve(pkgRoot, pkg.main || "index.js");
    packageInfo.browserMappedMain = false;
  }
  if (!ignoreSideEffectsForRoot || rootDir !== pkgRoot) {
    const packageSideEffects = pkg.sideEffects;
    if (typeof packageSideEffects === "boolean") {
      internalPackageInfo.hasModuleSideEffects = () => packageSideEffects;
    } else if (Array.isArray(packageSideEffects)) {
      const finalPackageSideEffects = packageSideEffects.map((sideEffect) => {
        if (sideEffect.includes("/")) {
          return sideEffect;
        }
        return `**/${sideEffect}`;
      });
      internalPackageInfo.hasModuleSideEffects = createFilter(finalPackageSideEffects, null, {
        resolve: pkgRoot
      });
    }
  }
  cache3.set(pkgPath, internalPackageInfo);
  return internalPackageInfo;
}
function normalizeInput(input2) {
  if (Array.isArray(input2)) {
    return input2;
  } else if (typeof input2 === "object") {
    return Object.values(input2);
  }
  return [input2];
}
function isModuleDir(current2, moduleDirs) {
  return moduleDirs.some((dir3) => current2.endsWith(dir3));
}
async function findPackageJson(base2, moduleDirs) {
  const { root } = p2__default.default.parse(base2);
  let current2 = base2;
  while (current2 !== root && !isModuleDir(current2, moduleDirs)) {
    const pkgJsonPath = p2__default.default.join(current2, "package.json");
    if (await fileExists(pkgJsonPath)) {
      const pkgJsonString = fs__default.default.readFileSync(pkgJsonPath, "utf-8");
      return { pkgJson: JSON.parse(pkgJsonString), pkgPath: current2, pkgJsonPath };
    }
    current2 = p2__default.default.resolve(current2, "..");
  }
  return null;
}
function isUrl(str) {
  try {
    return !!new URL(str);
  } catch (_2) {
    return false;
  }
}
function isConditions(exports) {
  return typeof exports === "object" && Object.keys(exports).every((k) => !k.startsWith("."));
}
function isMappings(exports) {
  return typeof exports === "object" && !isConditions(exports);
}
function isMixedExports(exports) {
  const keys5 = Object.keys(exports);
  return keys5.some((k) => k.startsWith(".")) && keys5.some((k) => !k.startsWith("."));
}
function createBaseErrorMsg(importSpecifier3, importer) {
  return `Could not resolve import "${importSpecifier3}" in ${importer}`;
}
function createErrorMsg(context8, reason, isImports) {
  const { importSpecifier: importSpecifier3, importer, pkgJsonPath } = context8;
  const base2 = createBaseErrorMsg(importSpecifier3, importer);
  const field = isImports ? "imports" : "exports";
  return `${base2} using ${field} defined in ${pkgJsonPath}.${reason ? ` ${reason}` : ""}`;
}
var ResolveError = class extends Error {
};
var InvalidConfigurationError = class extends ResolveError {
  constructor(context8, reason) {
    super(createErrorMsg(context8, `Invalid "exports" field. ${reason}`));
  }
};
var InvalidModuleSpecifierError = class extends ResolveError {
  constructor(context8, isImports, reason) {
    super(createErrorMsg(context8, reason, isImports));
  }
};
var InvalidPackageTargetError = class extends ResolveError {
  constructor(context8, reason) {
    super(createErrorMsg(context8, reason));
  }
};
function includesInvalidSegments(pathSegments, moduleDirs) {
  const invalidSegments = ["", ".", "..", ...moduleDirs];
  return pathSegments.some((v2) => invalidSegments.includes(v2) || invalidSegments.includes(decodeURI(v2)));
}
async function resolvePackageTarget(context8, { target, patternMatch, isImports }) {
  if (typeof target === "string") {
    if (!target.startsWith("./")) {
      if (!isImports || ["/", "../"].some((p3) => target.startsWith(p3)) || isUrl(target)) {
        throw new InvalidPackageTargetError(context8, `Invalid mapping: "${target}".`);
      }
      if (typeof patternMatch === "string") {
        const result2 = await context8.resolveId(target.replace(/\*/g, patternMatch), context8.pkgURL.href);
        return result2 ? url$1.pathToFileURL(result2.location).href : null;
      }
      const result = await context8.resolveId(target, context8.pkgURL.href);
      return result ? url$1.pathToFileURL(result.location).href : null;
    }
    if (context8.allowExportsFolderMapping) {
      target = target.replace(/\/$/, "/*");
    }
    {
      const pathSegments = target.split(/\/|\\/);
      const firstDot = pathSegments.indexOf(".");
      firstDot !== -1 && pathSegments.slice(firstDot);
      if (firstDot !== -1 && firstDot < pathSegments.length - 1 && includesInvalidSegments(pathSegments.slice(firstDot + 1), context8.moduleDirs)) {
        throw new InvalidPackageTargetError(context8, `Invalid mapping: "${target}".`);
      }
    }
    const resolvedTarget = new URL(target, context8.pkgURL);
    if (!resolvedTarget.href.startsWith(context8.pkgURL.href)) {
      throw new InvalidPackageTargetError(context8, `Resolved to ${resolvedTarget.href} which is outside package ${context8.pkgURL.href}`);
    }
    if (!patternMatch) {
      return resolvedTarget;
    }
    if (includesInvalidSegments(patternMatch.split(/\/|\\/), context8.moduleDirs)) {
      throw new InvalidModuleSpecifierError(context8);
    }
    return resolvedTarget.href.replace(/\*/g, patternMatch);
  }
  if (Array.isArray(target)) {
    if (target.length === 0) {
      return null;
    }
    let lastError = null;
    for (const item of target) {
      try {
        const resolved = await resolvePackageTarget(context8, {
          target: item,
          patternMatch,
          isImports
        });
        if (resolved !== void 0) {
          return resolved;
        }
      } catch (error4) {
        if (!(error4 instanceof InvalidPackageTargetError)) {
          throw error4;
        } else {
          lastError = error4;
        }
      }
    }
    if (lastError) {
      throw lastError;
    }
    return null;
  }
  if (target && typeof target === "object") {
    for (const [key, value] of Object.entries(target)) {
      if (key === "default" || context8.conditions.includes(key)) {
        const resolved = await resolvePackageTarget(context8, {
          target: value,
          patternMatch,
          isImports
        });
        if (resolved !== void 0) {
          return resolved;
        }
      }
    }
    return void 0;
  }
  if (target === null) {
    return null;
  }
  throw new InvalidPackageTargetError(context8, `Invalid exports field.`);
}
function nodePatternKeyCompare(keyA, keyB) {
  const baseLengthA = keyA.includes("*") ? keyA.indexOf("*") + 1 : keyA.length;
  const baseLengthB = keyB.includes("*") ? keyB.indexOf("*") + 1 : keyB.length;
  const rval = baseLengthB - baseLengthA;
  if (rval !== 0)
    return rval;
  if (!keyA.includes("*"))
    return 1;
  if (!keyB.includes("*"))
    return -1;
  return keyB.length - keyA.length;
}
async function resolvePackageImportsExports(context8, { matchKey, matchObj, isImports }) {
  if (!matchKey.includes("*") && matchKey in matchObj) {
    const target = matchObj[matchKey];
    const resolved = await resolvePackageTarget(context8, { target, patternMatch: "", isImports });
    return resolved;
  }
  const expansionKeys = Object.keys(matchObj).filter((k) => k.endsWith("/") || k.includes("*")).sort(nodePatternKeyCompare);
  for (const expansionKey of expansionKeys) {
    const indexOfAsterisk = expansionKey.indexOf("*");
    const patternBase = indexOfAsterisk === -1 ? expansionKey : expansionKey.substring(0, indexOfAsterisk);
    if (matchKey.startsWith(patternBase) && matchKey !== patternBase) {
      const patternTrailer = indexOfAsterisk !== -1 ? expansionKey.substring(indexOfAsterisk + 1) : "";
      if (patternTrailer.length === 0 || // or if matchKey ends with patternTrailer and the length of matchKey is greater than or equal to the length of expansionKey, then
      matchKey.endsWith(patternTrailer) && matchKey.length >= expansionKey.length) {
        const target = matchObj[expansionKey];
        const patternMatch = matchKey.substring(patternBase.length, matchKey.length - patternTrailer.length);
        const resolved = await resolvePackageTarget(context8, {
          target,
          patternMatch,
          isImports
        });
        return resolved;
      }
    }
  }
  throw new InvalidModuleSpecifierError(context8, isImports);
}
async function resolvePackageExports(context8, subpath, exports) {
  if (isMixedExports(exports)) {
    throw new InvalidConfigurationError(context8, "All keys must either start with ./, or without one.");
  }
  if (subpath === ".") {
    let mainExport;
    if (typeof exports === "string" || Array.isArray(exports) || isConditions(exports)) {
      mainExport = exports;
    } else if (isMappings(exports)) {
      mainExport = exports["."];
    }
    if (mainExport) {
      const resolved = await resolvePackageTarget(context8, {
        target: mainExport,
        patternMatch: "",
        isImports: false
      });
      if (resolved) {
        return resolved;
      }
    }
  } else if (isMappings(exports)) {
    const resolvedMatch = await resolvePackageImportsExports(context8, {
      matchKey: subpath,
      matchObj: exports,
      isImports: false
    });
    if (resolvedMatch) {
      return resolvedMatch;
    }
  }
  throw new InvalidModuleSpecifierError(context8);
}
async function resolvePackageImports({ importSpecifier: importSpecifier3, importer, moduleDirs, conditions, resolveId: resolveId2 }) {
  const result = await findPackageJson(importer, moduleDirs);
  if (!result) {
    throw new Error(`${createBaseErrorMsg(importSpecifier3, importer)}. Could not find a parent package.json.`);
  }
  const { pkgPath, pkgJsonPath, pkgJson } = result;
  const pkgURL = url$1.pathToFileURL(`${pkgPath}/`);
  const context8 = {
    importer,
    importSpecifier: importSpecifier3,
    moduleDirs,
    pkgURL,
    pkgJsonPath,
    conditions,
    resolveId: resolveId2
  };
  if (!importSpecifier3.startsWith("#")) {
    throw new InvalidModuleSpecifierError(context8, true, "Invalid import specifier.");
  }
  if (importSpecifier3 === "#" || importSpecifier3.startsWith("#/")) {
    throw new InvalidModuleSpecifierError(context8, true, "Invalid import specifier.");
  }
  const { imports } = pkgJson;
  if (!imports) {
    throw new InvalidModuleSpecifierError(context8, true);
  }
  return resolvePackageImportsExports(context8, {
    matchKey: importSpecifier3,
    matchObj: imports,
    isImports: true
  });
}
var resolveImportPath = util.promisify(import_resolve.default);
var readFile = util.promisify(fs__default.default.readFile);
async function getPackageJson(importer, pkgName, resolveOptions, moduleDirectories) {
  if (importer) {
    const selfPackageJsonResult = await findPackageJson(importer, moduleDirectories);
    if (selfPackageJsonResult && selfPackageJsonResult.pkgJson.name === pkgName) {
      return selfPackageJsonResult;
    }
  }
  try {
    const pkgJsonPath = await resolveImportPath(`${pkgName}/package.json`, resolveOptions);
    const pkgJson = JSON.parse(await readFile(pkgJsonPath, "utf-8"));
    return { pkgJsonPath, pkgJson, pkgPath: p2.dirname(pkgJsonPath) };
  } catch (_2) {
    return null;
  }
}
async function resolveIdClassic({
  importSpecifier: importSpecifier3,
  packageInfoCache,
  extensions,
  mainFields,
  preserveSymlinks,
  useBrowserOverrides,
  baseDir,
  moduleDirectories,
  modulePaths,
  rootDir,
  ignoreSideEffectsForRoot
}) {
  let hasModuleSideEffects = () => null;
  let hasPackageEntry = true;
  let packageBrowserField = false;
  let packageInfo;
  const filter10 = (pkg, pkgPath) => {
    const info3 = getPackageInfo({
      cache: packageInfoCache,
      extensions,
      pkg,
      pkgPath,
      mainFields,
      preserveSymlinks,
      useBrowserOverrides,
      rootDir,
      ignoreSideEffectsForRoot
    });
    ({ packageInfo, hasModuleSideEffects, hasPackageEntry, packageBrowserField } = info3);
    return info3.cachedPkg;
  };
  const resolveOptions = {
    basedir: baseDir,
    readFile: readCachedFile,
    isFile: isFileCached,
    isDirectory: isDirCached,
    extensions,
    includeCoreModules: false,
    moduleDirectory: moduleDirectories,
    paths: modulePaths,
    preserveSymlinks,
    packageFilter: filter10
  };
  let location;
  try {
    location = await resolveImportPath(importSpecifier3, resolveOptions);
  } catch (error4) {
    if (error4.code !== "MODULE_NOT_FOUND") {
      throw error4;
    }
    return null;
  }
  return {
    location: preserveSymlinks ? location : await resolveSymlink(location),
    hasModuleSideEffects,
    hasPackageEntry,
    packageBrowserField,
    packageInfo
  };
}
async function resolveWithExportMap({
  importer,
  importSpecifier: importSpecifier3,
  exportConditions,
  packageInfoCache,
  extensions,
  mainFields,
  preserveSymlinks,
  useBrowserOverrides,
  baseDir,
  moduleDirectories,
  modulePaths,
  rootDir,
  ignoreSideEffectsForRoot,
  allowExportsFolderMapping
}) {
  if (importSpecifier3.startsWith("#")) {
    const resolveResult = await resolvePackageImports({
      importSpecifier: importSpecifier3,
      importer,
      moduleDirs: moduleDirectories,
      conditions: exportConditions,
      resolveId(id2) {
        return resolveIdClassic({
          importSpecifier: id2,
          packageInfoCache,
          extensions,
          mainFields,
          preserveSymlinks,
          useBrowserOverrides,
          baseDir,
          moduleDirectories,
          modulePaths
        });
      }
    });
    const location = url$1.fileURLToPath(resolveResult);
    return {
      location: preserveSymlinks ? location : await resolveSymlink(location),
      hasModuleSideEffects: () => null,
      hasPackageEntry: true,
      packageBrowserField: false,
      // eslint-disable-next-line no-undefined
      packageInfo: void 0
    };
  }
  const pkgName = getPackageName(importSpecifier3);
  if (pkgName) {
    let hasModuleSideEffects = () => null;
    let hasPackageEntry = true;
    let packageBrowserField = false;
    let packageInfo;
    const filter10 = (pkg, pkgPath) => {
      const info3 = getPackageInfo({
        cache: packageInfoCache,
        extensions,
        pkg,
        pkgPath,
        mainFields,
        preserveSymlinks,
        useBrowserOverrides,
        rootDir,
        ignoreSideEffectsForRoot
      });
      ({ packageInfo, hasModuleSideEffects, hasPackageEntry, packageBrowserField } = info3);
      return info3.cachedPkg;
    };
    const resolveOptions = {
      basedir: baseDir,
      readFile: readCachedFile,
      isFile: isFileCached,
      isDirectory: isDirCached,
      extensions,
      includeCoreModules: false,
      moduleDirectory: moduleDirectories,
      paths: modulePaths,
      preserveSymlinks,
      packageFilter: filter10
    };
    const result = await getPackageJson(importer, pkgName, resolveOptions, moduleDirectories);
    if (result && result.pkgJson.exports) {
      const { pkgJson, pkgJsonPath } = result;
      const subpath = pkgName === importSpecifier3 ? "." : `.${importSpecifier3.substring(pkgName.length)}`;
      const pkgDr = pkgJsonPath.replace("package.json", "");
      const pkgURL = url$1.pathToFileURL(pkgDr);
      const context8 = {
        importer,
        importSpecifier: importSpecifier3,
        moduleDirs: moduleDirectories,
        pkgURL,
        pkgJsonPath,
        allowExportsFolderMapping,
        conditions: exportConditions
      };
      const resolvedPackageExport = await resolvePackageExports(context8, subpath, pkgJson.exports);
      const location = url$1.fileURLToPath(resolvedPackageExport);
      if (location) {
        return {
          location: preserveSymlinks ? location : await resolveSymlink(location),
          hasModuleSideEffects,
          hasPackageEntry,
          packageBrowserField,
          packageInfo
        };
      }
    }
  }
  return null;
}
async function resolveWithClassic({
  importer,
  importSpecifierList,
  exportConditions,
  warn: warn4,
  packageInfoCache,
  extensions,
  mainFields,
  preserveSymlinks,
  useBrowserOverrides,
  baseDir,
  moduleDirectories,
  modulePaths,
  rootDir,
  ignoreSideEffectsForRoot
}) {
  for (let i = 0; i < importSpecifierList.length; i++) {
    const result = await resolveIdClassic({
      importSpecifier: importSpecifierList[i],
      packageInfoCache,
      extensions,
      mainFields,
      preserveSymlinks,
      useBrowserOverrides,
      baseDir,
      moduleDirectories,
      modulePaths,
      rootDir,
      ignoreSideEffectsForRoot
    });
    if (result) {
      return result;
    }
  }
  return null;
}
async function resolveImportSpecifiers({
  importer,
  importSpecifierList,
  exportConditions,
  warn: warn4,
  packageInfoCache,
  extensions,
  mainFields,
  preserveSymlinks,
  useBrowserOverrides,
  baseDir,
  moduleDirectories,
  modulePaths,
  rootDir,
  ignoreSideEffectsForRoot,
  allowExportsFolderMapping
}) {
  try {
    const exportMapRes = await resolveWithExportMap({
      importer,
      importSpecifier: importSpecifierList[0],
      exportConditions,
      packageInfoCache,
      extensions,
      mainFields,
      preserveSymlinks,
      useBrowserOverrides,
      baseDir,
      moduleDirectories,
      modulePaths,
      rootDir,
      ignoreSideEffectsForRoot,
      allowExportsFolderMapping
    });
    if (exportMapRes) return exportMapRes;
  } catch (error4) {
    if (error4 instanceof ResolveError) {
      warn4(error4);
      return null;
    }
    throw error4;
  }
  return resolveWithClassic({
    importer,
    importSpecifierList,
    exportConditions,
    warn: warn4,
    packageInfoCache,
    extensions,
    mainFields,
    preserveSymlinks,
    useBrowserOverrides,
    baseDir,
    moduleDirectories,
    modulePaths,
    rootDir,
    ignoreSideEffectsForRoot
  });
}
var versionRegexp = /\^(\d+\.\d+\.\d+)/g;
function validateVersion(actualVersion, peerDependencyVersion) {
  let minMajor = Infinity;
  let minMinor = Infinity;
  let minPatch = Infinity;
  let foundVersion;
  while (foundVersion = versionRegexp.exec(peerDependencyVersion)) {
    const [foundMajor, foundMinor, foundPatch] = foundVersion[1].split(".").map(Number);
    if (foundMajor < minMajor) {
      minMajor = foundMajor;
      minMinor = foundMinor;
      minPatch = foundPatch;
    }
  }
  if (!actualVersion) {
    throw new Error(
      `Insufficient Rollup version: "@rollup/plugin-node-resolve" requires at least rollup@${minMajor}.${minMinor}.${minPatch}.`
    );
  }
  const [major, minor, patch9] = actualVersion.split(".").map(Number);
  if (major < minMajor || major === minMajor && (minor < minMinor || minor === minMinor && patch9 < minPatch)) {
    throw new Error(
      `Insufficient rollup version: "@rollup/plugin-node-resolve" requires at least rollup@${minMajor}.${minMinor}.${minPatch} but found rollup@${actualVersion}.`
    );
  }
}
var ES6_BROWSER_EMPTY = "\0node-resolve:empty.js";
var deepFreeze = (object) => {
  Object.freeze(object);
  for (const value of Object.values(object)) {
    if (typeof value === "object" && !Object.isFrozen(value)) {
      deepFreeze(value);
    }
  }
  return object;
};
var baseConditions = ["default", "module"];
var baseConditionsEsm = [...baseConditions, "import"];
var baseConditionsCjs = [...baseConditions, "require"];
var defaults = {
  dedupe: [],
  // It's important that .mjs is listed before .js so that Rollup will interpret npm modules
  // which deploy both ESM .mjs and CommonJS .js files as ESM.
  extensions: [".mjs", ".js", ".json", ".node"],
  resolveOnly: [],
  moduleDirectories: ["node_modules"],
  modulePaths: [],
  ignoreSideEffectsForRoot: false,
  // TODO: set to false in next major release or remove
  allowExportsFolderMapping: true
};
var nodeImportPrefix = /^node:/;
deepFreeze((0, import_deepmerge.default)({}, defaults));
function nodeResolve(opts = {}) {
  const { warnings } = handleDeprecatedOptions(opts);
  const options = { ...defaults, ...opts };
  const { extensions, jail, moduleDirectories, modulePaths, ignoreSideEffectsForRoot } = options;
  const exportConditions = options.exportConditions || [];
  const devProdCondition = exportConditions.includes("development") || exportConditions.includes("production") ? [] : [
    process.env.NODE_ENV && process.env.NODE_ENV !== "production" ? "development" : "production"
  ];
  const conditionsEsm = [...baseConditionsEsm, ...exportConditions, ...devProdCondition];
  const conditionsCjs = [...baseConditionsCjs, ...exportConditions, ...devProdCondition];
  const packageInfoCache = /* @__PURE__ */ new Map();
  const idToPackageInfo = /* @__PURE__ */ new Map();
  const mainFields = getMainFields(options);
  const useBrowserOverrides = mainFields.indexOf("browser") !== -1;
  const isPreferBuiltinsSet = Object.prototype.hasOwnProperty.call(options, "preferBuiltins");
  const preferBuiltins = isPreferBuiltinsSet ? options.preferBuiltins : true;
  const rootDir = p2.resolve(options.rootDir || process.cwd());
  let { dedupe: dedupe2 } = options;
  let rollupOptions;
  if (moduleDirectories.some((name) => name.includes("/"))) {
    throw new Error(
      "`moduleDirectories` option must only contain directory names. If you want to load modules from somewhere not supported by the default module resolution algorithm, see `modulePaths`."
    );
  }
  if (typeof dedupe2 !== "function") {
    dedupe2 = (importee) => options.dedupe.includes(importee) || options.dedupe.includes(getPackageName(importee));
  }
  const allowPatterns = (patterns) => {
    const regexPatterns = patterns.map((pattern) => {
      if (pattern instanceof RegExp) {
        return pattern;
      }
      const normalized = pattern.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
      return new RegExp(`^${normalized}$`);
    });
    return (id2) => !regexPatterns.length || regexPatterns.some((pattern) => pattern.test(id2));
  };
  const resolveOnly = typeof options.resolveOnly === "function" ? options.resolveOnly : allowPatterns(options.resolveOnly);
  const browserMapCache = /* @__PURE__ */ new Map();
  let preserveSymlinks;
  const resolveLikeNode = async (context8, importee, importer, custom3) => {
    const [importPath, params] = importee.split("?");
    const importSuffix = `${params ? `?${params}` : ""}`;
    importee = importPath;
    const baseDir = !importer || dedupe2(importee) ? rootDir : p2.dirname(importer);
    const browser = browserMapCache.get(importer);
    if (useBrowserOverrides && browser) {
      const resolvedImportee = p2.resolve(baseDir, importee);
      if (browser[importee] === false || browser[resolvedImportee] === false) {
        return { id: ES6_BROWSER_EMPTY };
      }
      const browserImportee = importee[0] !== "." && browser[importee] || browser[resolvedImportee] || browser[`${resolvedImportee}.js`] || browser[`${resolvedImportee}.json`];
      if (browserImportee) {
        importee = browserImportee;
      }
    }
    const parts2 = importee.split(/[/\\]/);
    let id2 = parts2.shift();
    let isRelativeImport = false;
    if (id2[0] === "@" && parts2.length > 0) {
      id2 += `/${parts2.shift()}`;
    } else if (id2[0] === ".") {
      id2 = p2.resolve(baseDir, importee);
      isRelativeImport = true;
    }
    if (!isRelativeImport && !resolveOnly(id2)) {
      if (normalizeInput(rollupOptions.input).includes(importee)) {
        return null;
      }
      return false;
    }
    const importSpecifierList = [importee];
    if (importer === void 0 && !importee[0].match(/^\.?\.?\//)) {
      importSpecifierList.push(`./${importee}`);
    }
    if (importer && /\.(ts|mts|cts|tsx)$/.test(importer)) {
      for (const [importeeExt, resolvedExt] of [
        [".js", ".ts"],
        [".js", ".tsx"],
        [".jsx", ".tsx"],
        [".mjs", ".mts"],
        [".cjs", ".cts"]
      ]) {
        if (importee.endsWith(importeeExt) && extensions.includes(resolvedExt)) {
          importSpecifierList.push(importee.slice(0, -importeeExt.length) + resolvedExt);
        }
      }
    }
    const warn4 = (...args2) => context8.warn(...args2);
    const isRequire = custom3 && custom3["node-resolve"] && custom3["node-resolve"].isRequire;
    const exportConditions2 = isRequire ? conditionsCjs : conditionsEsm;
    if (useBrowserOverrides && !exportConditions2.includes("browser"))
      exportConditions2.push("browser");
    const resolvedWithoutBuiltins = await resolveImportSpecifiers({
      importer,
      importSpecifierList,
      exportConditions: exportConditions2,
      warn: warn4,
      packageInfoCache,
      extensions,
      mainFields,
      preserveSymlinks,
      useBrowserOverrides,
      baseDir,
      moduleDirectories,
      modulePaths,
      rootDir,
      ignoreSideEffectsForRoot,
      allowExportsFolderMapping: options.allowExportsFolderMapping
    });
    const importeeIsBuiltin = ve.builtinModules.includes(importee.replace(nodeImportPrefix, ""));
    const preferImporteeIsBuiltin = typeof preferBuiltins === "function" ? preferBuiltins(importee) : preferBuiltins;
    const resolved = importeeIsBuiltin && preferImporteeIsBuiltin ? {
      packageInfo: void 0,
      hasModuleSideEffects: () => null,
      hasPackageEntry: true,
      packageBrowserField: false
    } : resolvedWithoutBuiltins;
    if (!resolved) {
      return null;
    }
    const { packageInfo, hasModuleSideEffects, hasPackageEntry, packageBrowserField } = resolved;
    let { location } = resolved;
    if (packageBrowserField) {
      if (Object.prototype.hasOwnProperty.call(packageBrowserField, location)) {
        if (!packageBrowserField[location]) {
          browserMapCache.set(location, packageBrowserField);
          return { id: ES6_BROWSER_EMPTY };
        }
        location = packageBrowserField[location];
      }
      browserMapCache.set(location, packageBrowserField);
    }
    if (hasPackageEntry && !preserveSymlinks) {
      const exists4 = await fileExists(location);
      if (exists4) {
        location = await realpath(location);
      }
    }
    idToPackageInfo.set(location, packageInfo);
    if (hasPackageEntry) {
      if (importeeIsBuiltin && preferImporteeIsBuiltin) {
        if (!isPreferBuiltinsSet && resolvedWithoutBuiltins && resolved !== importee) {
          context8.warn({
            message: `preferring built-in module '${importee}' over local alternative at '${resolvedWithoutBuiltins.location}', pass 'preferBuiltins: false' to disable this behavior or 'preferBuiltins: true' to disable this warning.or passing a function to 'preferBuiltins' to provide more fine-grained control over which built-in modules to prefer.`,
            pluginCode: "PREFER_BUILTINS"
          });
        }
        return false;
      } else if (jail && location.indexOf(p2.normalize(jail.trim(p2.sep))) !== 0) {
        return null;
      }
    }
    if (options.modulesOnly && await fileExists(location)) {
      const code = await readFile$1(location, "utf-8");
      if ((0, import_is_module.default)(code)) {
        return {
          id: `${location}${importSuffix}`,
          moduleSideEffects: hasModuleSideEffects(location)
        };
      }
      return null;
    }
    return {
      id: `${location}${importSuffix}`,
      moduleSideEffects: hasModuleSideEffects(location)
    };
  };
  return {
    name: "node-resolve",
    version,
    buildStart(buildOptions2) {
      validateVersion(this.meta.rollupVersion, peerDependencies.rollup);
      rollupOptions = buildOptions2;
      for (const warning of warnings) {
        this.warn(warning);
      }
      ({ preserveSymlinks } = buildOptions2);
    },
    generateBundle() {
      readCachedFile.clear();
      isFileCached.clear();
      isDirCached.clear();
    },
    resolveId: {
      order: "post",
      async handler(importee, importer, resolveOptions) {
        if (importee === ES6_BROWSER_EMPTY) {
          return importee;
        }
        if (importee && importee.includes("\0")) return null;
        const { custom: custom3 = {} } = resolveOptions;
        const { "node-resolve": { resolved: alreadyResolved } = {} } = custom3;
        if (alreadyResolved) {
          return alreadyResolved;
        }
        if (importer && importer.includes("\0")) {
          importer = void 0;
        }
        const resolved = await resolveLikeNode(this, importee, importer, custom3);
        if (resolved) {
          const resolvedResolved = await this.resolve(resolved.id, importer, {
            ...resolveOptions,
            skipSelf: false,
            custom: { ...custom3, "node-resolve": { ...custom3["node-resolve"], resolved, importee } }
          });
          if (resolvedResolved) {
            if (resolvedResolved.external) {
              return false;
            }
            if (resolvedResolved.id !== resolved.id) {
              return resolvedResolved;
            }
            return { ...resolved, meta: resolvedResolved.meta };
          }
        }
        return resolved;
      }
    },
    load(importee) {
      if (importee === ES6_BROWSER_EMPTY) {
        return "export default {};";
      }
      return null;
    },
    getPackageInfoForId(id2) {
      return idToPackageInfo.get(id2);
    }
  };
}

// node_modules/.pnpm/smob@1.5.0/node_modules/smob/dist/index.mjs
var PriorityName;
(function(PriorityName2) {
  PriorityName2["LEFT"] = "left";
  PriorityName2["RIGHT"] = "right";
})(PriorityName || (PriorityName = {}));
function isObject2(item) {
  return !!item && typeof item === "object" && !Array.isArray(item);
}
function isSafeKey(key) {
  return key !== "__proto__" && key !== "prototype" && key !== "constructor";
}
function isEqual2(x2, y) {
  if (Object.is(x2, y)) return true;
  if (x2 instanceof Date && y instanceof Date) {
    return x2.getTime() === y.getTime();
  }
  if (x2 instanceof RegExp && y instanceof RegExp) {
    return x2.toString() === y.toString();
  }
  if (isObject2(x2) && isObject2(y)) {
    const keysX = Reflect.ownKeys(x2);
    const keysY = Reflect.ownKeys(y);
    if (keysX.length !== keysY.length) {
      return false;
    }
    for (let i = 0; i < keysX.length; i++) {
      const key = keysX[i];
      if (!Reflect.has(y, key) || !isEqual2(x2[key], y[key])) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(x2) && Array.isArray(y)) {
    if (x2.length !== y.length) {
      return false;
    }
    for (let i = 0; i < x2.length; i++) {
      if (!isEqual2(x2[i], y[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function distinctArray(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = arr.length - 1; j > i; j--) {
      if (isEqual2(arr[i], arr[j])) {
        arr.splice(j, 1);
      }
    }
  }
  return arr;
}
var gT = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
})();
function polyfillClone(input2) {
  const map26 = /* @__PURE__ */ new WeakMap();
  const fn2 = (value) => {
    if (Array.isArray(value)) {
      if (map26.has(value)) {
        return map26.get(value);
      }
      const cloned = [];
      map26.set(value, cloned);
      value.map((el) => cloned.push(fn2(el)));
      return cloned;
    }
    if (isObject2(value)) {
      if (map26.has(value)) {
        return map26.get(value);
      }
      const output = {};
      const keys5 = Object.keys(value);
      map26.set(value, output);
      for (let i = 0; i < keys5.length; i++) {
        output[keys5[i]] = fn2(value[keys5[i]]);
      }
      return output;
    }
    return value;
  };
  return fn2(input2);
}
function clone2(value) {
  if (gT.structuredClone) {
    return gT.structuredClone(value);
  }
  return polyfillClone(value);
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function buildOptions(options = {}) {
  var _options_array;
  options.array = (_options_array = options.array) != null ? _options_array : true;
  var _options_arrayDistinct;
  options.arrayDistinct = (_options_arrayDistinct = options.arrayDistinct) != null ? _options_arrayDistinct : false;
  var _options_clone;
  options.clone = (_options_clone = options.clone) != null ? _options_clone : false;
  var _options_inPlace;
  options.inPlace = (_options_inPlace = options.inPlace) != null ? _options_inPlace : false;
  options.priority = options.priority || PriorityName.LEFT;
  options.arrayPriority = options.arrayPriority || options.priority;
  return options;
}
function togglePriority(priority) {
  return priority === PriorityName.LEFT ? `${PriorityName.RIGHT}` : `${PriorityName.LEFT}`;
}
function baseMerger(context8, ...sources) {
  let target;
  let source;
  let { priority } = context8.options;
  if (sources.length >= 2) {
    if (Array.isArray(sources.at(0)) && Array.isArray(sources.at(-1))) {
      priority = context8.options.arrayPriority;
    }
  }
  if (priority === PriorityName.RIGHT) {
    target = sources.pop();
    source = sources.pop();
  } else {
    target = sources.shift();
    source = sources.shift();
  }
  if (!source) {
    if (Array.isArray(target) && context8.options.arrayDistinct) {
      return distinctArray(target);
    }
    return target;
  }
  if (Array.isArray(target) && Array.isArray(source)) {
    target.push(...source);
    if (context8.options.arrayPriority === PriorityName.RIGHT) {
      return baseMerger(context8, ...sources, target);
    }
    return baseMerger(context8, target, ...sources);
  }
  context8.map.set(source, true);
  if (isObject2(target) && isObject2(source)) {
    const keys5 = Object.keys(source);
    for (let i = 0; i < keys5.length; i++) {
      const key = keys5[i];
      if (hasOwnProperty(target, key)) {
        if (!isSafeKey(key)) {
          continue;
        }
        if (context8.options.strategy) {
          const applied = context8.options.strategy(target, key, source[key]);
          if (typeof applied !== "undefined") {
            continue;
          }
        }
        if (isObject2(target[key]) && isObject2(source[key])) {
          if (context8.map.has(source[key])) {
            const sourceKeys = Object.keys(source[key]);
            for (let j = 0; j < sourceKeys.length; j++) {
              if (isSafeKey(sourceKeys[j]) && !hasOwnProperty(target[key], sourceKeys[j])) {
                target[key][sourceKeys[j]] = source[key][sourceKeys[j]];
              }
            }
            continue;
          }
          if (context8.options.priority === PriorityName.RIGHT) {
            target[key] = baseMerger(context8, source[key], target[key]);
          } else {
            target[key] = baseMerger(context8, target[key], source[key]);
          }
          continue;
        }
        if (context8.options.array && Array.isArray(target[key]) && Array.isArray(source[key])) {
          const arrayPriority = context8.options.priority !== context8.options.arrayPriority ? togglePriority(context8.options.arrayPriority) : context8.options.arrayPriority;
          switch (arrayPriority) {
            case PriorityName.LEFT:
              Object.assign(target, {
                [key]: baseMerger(context8, target[key], source[key])
              });
              break;
            case PriorityName.RIGHT:
              Object.assign(target, {
                [key]: baseMerger(context8, source[key], target[key])
              });
              break;
          }
        }
      } else {
        Object.assign(target, {
          [key]: source[key]
        });
      }
    }
  }
  context8.map = /* @__PURE__ */ new WeakMap();
  if (context8.options.priority === PriorityName.RIGHT) {
    return baseMerger(context8, ...sources, target);
  }
  return baseMerger(context8, target, ...sources);
}
function createMerger(input2) {
  const options = buildOptions(input2);
  return (...sources) => {
    if (!sources.length) {
      throw new SyntaxError("At least one input element is required.");
    }
    const ctx = {
      options,
      map: /* @__PURE__ */ new WeakMap()
    };
    if (options.clone) {
      return baseMerger(ctx, ...clone2(sources));
    }
    if (!options.inPlace) {
      if (Array.isArray(sources.at(0)) && options.arrayPriority === PriorityName.LEFT) {
        sources.unshift([]);
        return baseMerger(ctx, ...sources);
      }
      if (Array.isArray(sources.at(-1)) && options.arrayPriority === PriorityName.RIGHT) {
        sources.push([]);
        return baseMerger(ctx, ...sources);
      }
      if (options.priority === PriorityName.LEFT) {
        sources.unshift({});
      } else {
        sources.push({});
      }
    }
    return baseMerger(ctx, ...sources);
  };
}
var merge11 = createMerger();

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/utils/index.js
function characters(str) {
  return str.split("");
}
function member(name, array6) {
  return array6.includes(name);
}
var DefaultsError = class extends Error {
  constructor(msg, defs) {
    super();
    this.name = "DefaultsError";
    this.message = msg;
    this.defs = defs;
  }
};
function defaults2(args2, defs, croak) {
  if (args2 === true) {
    args2 = {};
  } else if (args2 != null && typeof args2 === "object") {
    args2 = { ...args2 };
  }
  const ret = args2 || {};
  if (croak) {
    for (const i in ret) if (HOP(ret, i) && !HOP(defs, i)) {
      throw new DefaultsError("`" + i + "` is not a supported option", defs);
    }
  }
  for (const i in defs) if (HOP(defs, i)) {
    if (!args2 || !HOP(args2, i)) {
      ret[i] = defs[i];
    } else if (i === "ecma") {
      let ecma = args2[i] | 0;
      if (ecma > 5 && ecma < 2015) ecma += 2009;
      ret[i] = ecma;
    } else {
      ret[i] = args2 && HOP(args2, i) ? args2[i] : defs[i];
    }
  }
  return ret;
}
function noop() {
}
function return_false() {
  return false;
}
function return_true() {
  return true;
}
function return_this() {
  return this;
}
function return_null() {
  return null;
}
var MAP = function() {
  function MAP2(a2, tw, allow_splicing = true) {
    const new_a = [];
    for (let i = 0; i < a2.length; ++i) {
      let item = a2[i];
      let ret = item.transform(tw, allow_splicing);
      if (ret instanceof AST_Node) {
        new_a.push(ret);
      } else if (ret instanceof Splice) {
        new_a.push(...ret.v);
      }
    }
    return new_a;
  }
  MAP2.splice = function(val) {
    return new Splice(val);
  };
  MAP2.skip = {};
  function Splice(val) {
    this.v = val;
  }
  return MAP2;
}();
function make_node(ctor, orig, props) {
  if (!props) props = {};
  if (orig) {
    if (!props.start) props.start = orig.start;
    if (!props.end) props.end = orig.end;
  }
  return new ctor(props);
}
function push_uniq(array6, el) {
  if (!array6.includes(el))
    array6.push(el);
}
function string_template(text, props) {
  return text.replace(/{(.+?)}/g, function(str, p3) {
    return props && props[p3];
  });
}
function remove9(array6, el) {
  for (var i = array6.length; --i >= 0; ) {
    if (array6[i] === el) array6.splice(i, 1);
  }
}
function mergeSort(array6, cmp) {
  if (array6.length < 2) return array6.slice();
  function merge12(a2, b) {
    var r = [], ai = 0, bi = 0, i = 0;
    while (ai < a2.length && bi < b.length) {
      cmp(a2[ai], b[bi]) <= 0 ? r[i++] = a2[ai++] : r[i++] = b[bi++];
    }
    if (ai < a2.length) r.push.apply(r, a2.slice(ai));
    if (bi < b.length) r.push.apply(r, b.slice(bi));
    return r;
  }
  function _ms(a2) {
    if (a2.length <= 1)
      return a2;
    var m2 = Math.floor(a2.length / 2), left3 = a2.slice(0, m2), right3 = a2.slice(m2);
    left3 = _ms(left3);
    right3 = _ms(right3);
    return merge12(left3, right3);
  }
  return _ms(array6);
}
function makePredicate(words) {
  if (!Array.isArray(words)) words = words.split(" ");
  return new Set(words.sort());
}
function map_add(map26, key, value) {
  if (map26.has(key)) {
    map26.get(key).push(value);
  } else {
    map26.set(key, [value]);
  }
}
function map_from_object(obj) {
  var map26 = /* @__PURE__ */ new Map();
  for (var key in obj) {
    if (HOP(obj, key) && key.charAt(0) === "$") {
      map26.set(key.substr(1), obj[key]);
    }
  }
  return map26;
}
function map_to_object(map26) {
  var obj = /* @__PURE__ */ Object.create(null);
  map26.forEach(function(value, key) {
    obj["$" + key] = value;
  });
  return obj;
}
function HOP(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function keep_name(keep_setting, name) {
  return keep_setting === true || keep_setting instanceof RegExp && keep_setting.test(name);
}
var lineTerminatorEscape = {
  "\0": "0",
  "\n": "n",
  "\r": "r",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
function regexp_source_fix(source) {
  return source.replace(/[\0\n\r\u2028\u2029]/g, function(match18, offset) {
    var escaped = source[offset - 1] == "\\" && (source[offset - 2] != "\\" || /(?:^|[^\\])(?:\\{2})*$/.test(source.slice(0, offset - 1)));
    return (escaped ? "" : "\\") + lineTerminatorEscape[match18];
  });
}
var re_safe_regexp = /^[\\/|\0\s\w^$.[\]()]*$/;
var regexp_is_safe = (source) => re_safe_regexp.test(source);
var all_flags = "dgimsuyv";
function sort_regexp_flags(flags) {
  const existing_flags = new Set(flags.split(""));
  let out = "";
  for (const flag of all_flags) {
    if (existing_flags.has(flag)) {
      out += flag;
      existing_flags.delete(flag);
    }
  }
  if (existing_flags.size) {
    existing_flags.forEach((flag) => {
      out += flag;
    });
  }
  return out;
}
function has_annotation(node, annotation) {
  return node._annotations & annotation;
}
function set_annotation(node, annotation) {
  node._annotations |= annotation;
}
function clear_annotation(node, annotation) {
  node._annotations &= -9;
}

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/parse.js
var LATEST_RAW = "";
var TEMPLATE_RAWS = /* @__PURE__ */ new Map();
var KEYWORDS = "break case catch class const continue debugger default delete do else export extends finally for function if in instanceof let new return switch throw try typeof var void while with";
var KEYWORDS_ATOM = "false null true";
var RESERVED_WORDS = "enum import super this " + KEYWORDS_ATOM + " " + KEYWORDS;
var ALL_RESERVED_WORDS = "implements interface package private protected public static " + RESERVED_WORDS;
var KEYWORDS_BEFORE_EXPRESSION = "return new delete throw else case yield await";
KEYWORDS = makePredicate(KEYWORDS);
RESERVED_WORDS = makePredicate(RESERVED_WORDS);
KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);
ALL_RESERVED_WORDS = makePredicate(ALL_RESERVED_WORDS);
var OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^"));
var RE_NUM_LITERAL = /[0-9a-f]/i;
var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
var RE_OCT_NUMBER = /^0[0-7]+$/;
var RE_ES6_OCT_NUMBER = /^0o[0-7]+$/i;
var RE_BIN_NUMBER = /^0b[01]+$/i;
var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;
var RE_BIG_INT = /^(0[xob])?[0-9a-f]+n$/i;
var OPERATORS = makePredicate([
  "in",
  "instanceof",
  "typeof",
  "new",
  "void",
  "delete",
  "++",
  "--",
  "+",
  "-",
  "!",
  "~",
  "&",
  "|",
  "^",
  "*",
  "**",
  "/",
  "%",
  ">>",
  "<<",
  ">>>",
  "<",
  ">",
  "<=",
  ">=",
  "==",
  "===",
  "!=",
  "!==",
  "?",
  "=",
  "+=",
  "-=",
  "||=",
  "&&=",
  "??=",
  "/=",
  "*=",
  "**=",
  "%=",
  ">>=",
  "<<=",
  ">>>=",
  "|=",
  "^=",
  "&=",
  "&&",
  "??",
  "||"
]);
var WHITESPACE_CHARS = makePredicate(characters(" \xA0\n\r	\f\v\u200B\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF"));
var NEWLINE_CHARS = makePredicate(characters("\n\r\u2028\u2029"));
var PUNC_AFTER_EXPRESSION = makePredicate(characters(";]),:"));
var PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,;:"));
var PUNC_CHARS = makePredicate(characters("[]{}(),;:"));
var UNICODE = {
  ID_Start: /[$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
  ID_Continue: /(?:[$0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF])+/
};
function get_full_char(str, pos) {
  if (is_surrogate_pair_head(str.charCodeAt(pos))) {
    if (is_surrogate_pair_tail(str.charCodeAt(pos + 1))) {
      return str.charAt(pos) + str.charAt(pos + 1);
    }
  } else if (is_surrogate_pair_tail(str.charCodeAt(pos))) {
    if (is_surrogate_pair_head(str.charCodeAt(pos - 1))) {
      return str.charAt(pos - 1) + str.charAt(pos);
    }
  }
  return str.charAt(pos);
}
function get_full_char_code(str, pos) {
  if (is_surrogate_pair_head(str.charCodeAt(pos))) {
    return 65536 + (str.charCodeAt(pos) - 55296 << 10) + str.charCodeAt(pos + 1) - 56320;
  }
  return str.charCodeAt(pos);
}
function get_full_char_length(str) {
  var surrogates = 0;
  for (var i = 0; i < str.length; i++) {
    if (is_surrogate_pair_head(str.charCodeAt(i)) && is_surrogate_pair_tail(str.charCodeAt(i + 1))) {
      surrogates++;
      i++;
    }
  }
  return str.length - surrogates;
}
function from_char_code(code) {
  if (code > 65535) {
    code -= 65536;
    return String.fromCharCode((code >> 10) + 55296) + String.fromCharCode(code % 1024 + 56320);
  }
  return String.fromCharCode(code);
}
function is_surrogate_pair_head(code) {
  return code >= 55296 && code <= 56319;
}
function is_surrogate_pair_tail(code) {
  return code >= 56320 && code <= 57343;
}
function is_digit(code) {
  return code >= 48 && code <= 57;
}
function is_identifier_start(ch) {
  return UNICODE.ID_Start.test(ch);
}
function is_identifier_char(ch) {
  return UNICODE.ID_Continue.test(ch);
}
var BASIC_IDENT = /^[a-z_$][a-z0-9_$]*$/i;
function is_basic_identifier_string(str) {
  return BASIC_IDENT.test(str);
}
function is_identifier_string(str, allow_surrogates) {
  if (BASIC_IDENT.test(str)) {
    return true;
  }
  if (!allow_surrogates && /[\ud800-\udfff]/.test(str)) {
    return false;
  }
  var match18 = UNICODE.ID_Start.exec(str);
  if (!match18 || match18.index !== 0) {
    return false;
  }
  str = str.slice(match18[0].length);
  if (!str) {
    return true;
  }
  match18 = UNICODE.ID_Continue.exec(str);
  return !!match18 && match18[0].length === str.length;
}
function parse_js_number(num, allow_e = true) {
  if (!allow_e && num.includes("e")) {
    return NaN;
  }
  if (RE_HEX_NUMBER.test(num)) {
    return parseInt(num.substr(2), 16);
  } else if (RE_OCT_NUMBER.test(num)) {
    return parseInt(num.substr(1), 8);
  } else if (RE_ES6_OCT_NUMBER.test(num)) {
    return parseInt(num.substr(2), 8);
  } else if (RE_BIN_NUMBER.test(num)) {
    return parseInt(num.substr(2), 2);
  } else if (RE_DEC_NUMBER.test(num)) {
    return parseFloat(num);
  } else {
    var val = parseFloat(num);
    if (val == num) return val;
  }
}
var JS_Parse_Error = class extends Error {
  constructor(message, filename, line, col, pos) {
    super();
    this.name = "SyntaxError";
    this.message = message;
    this.filename = filename;
    this.line = line;
    this.col = col;
    this.pos = pos;
  }
};
function js_error(message, filename, line, col, pos) {
  throw new JS_Parse_Error(message, filename, line, col, pos);
}
function is_token(token, type, val) {
  return token.type == type && (val == null || token.value == val);
}
var EX_EOF = {};
function tokenizer($TEXT, filename, html5_comments, shebang) {
  var S = {
    text: $TEXT,
    filename,
    pos: 0,
    tokpos: 0,
    line: 1,
    tokline: 0,
    col: 0,
    tokcol: 0,
    newline_before: false,
    regex_allowed: false,
    brace_counter: 0,
    template_braces: [],
    comments_before: [],
    directives: {},
    directive_stack: []
  };
  function peek2() {
    return get_full_char(S.text, S.pos);
  }
  function is_option_chain_op() {
    const must_be_dot = S.text.charCodeAt(S.pos + 1) === 46;
    if (!must_be_dot) return false;
    const cannot_be_digit = S.text.charCodeAt(S.pos + 2);
    return cannot_be_digit < 48 || cannot_be_digit > 57;
  }
  function next(signal_eof, in_string) {
    var ch = get_full_char(S.text, S.pos++);
    if (signal_eof && !ch)
      throw EX_EOF;
    if (NEWLINE_CHARS.has(ch)) {
      S.newline_before = S.newline_before || !in_string;
      ++S.line;
      S.col = 0;
      if (ch == "\r" && peek2() == "\n") {
        ++S.pos;
        ch = "\n";
      }
    } else {
      if (ch.length > 1) {
        ++S.pos;
        ++S.col;
      }
      ++S.col;
    }
    return ch;
  }
  function forward(i) {
    while (i--) next();
  }
  function looking_at(str) {
    return S.text.substr(S.pos, str.length) == str;
  }
  function find_eol() {
    var text = S.text;
    for (var i = S.pos, n2 = S.text.length; i < n2; ++i) {
      var ch = text[i];
      if (NEWLINE_CHARS.has(ch))
        return i;
    }
    return -1;
  }
  function find4(what, signal_eof) {
    var pos = S.text.indexOf(what, S.pos);
    if (pos == -1) throw EX_EOF;
    return pos;
  }
  function start_token() {
    S.tokline = S.line;
    S.tokcol = S.col;
    S.tokpos = S.pos;
  }
  var prev_was_dot = false;
  var previous_token = null;
  function token(type, value, is_comment) {
    S.regex_allowed = type == "operator" && !UNARY_POSTFIX.has(value) || type == "keyword" && KEYWORDS_BEFORE_EXPRESSION.has(value) || type == "punc" && PUNC_BEFORE_EXPRESSION.has(value) || type == "arrow";
    if (type == "punc" && (value == "." || value == "?.")) {
      prev_was_dot = true;
    } else if (!is_comment) {
      prev_was_dot = false;
    }
    const line = S.tokline;
    const col = S.tokcol;
    const pos = S.tokpos;
    const nlb = S.newline_before;
    const file = filename;
    let comments_before = [];
    let comments_after = [];
    if (!is_comment) {
      comments_before = S.comments_before;
      comments_after = S.comments_before = [];
    }
    S.newline_before = false;
    const tok = new AST_Token(type, value, line, col, pos, nlb, comments_before, comments_after, file);
    if (!is_comment) previous_token = tok;
    return tok;
  }
  function skip_whitespace() {
    while (WHITESPACE_CHARS.has(peek2()))
      next();
  }
  function read_while(pred) {
    var ret = "", ch, i = 0;
    while ((ch = peek2()) && pred(ch, i++))
      ret += next();
    return ret;
  }
  function parse_error(err) {
    js_error(err, filename, S.tokline, S.tokcol, S.tokpos);
  }
  function read_num(prefix) {
    var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".", is_big_int = false, numeric_separator = false;
    var num = read_while(function(ch, i) {
      if (is_big_int) return false;
      var code = ch.charCodeAt(0);
      switch (code) {
        case 95:
          return numeric_separator = true;
        case 98:
        case 66:
          return has_x = true;
        // Can occur in hex sequence, don't return false yet
        case 111:
        case 79:
        // oO
        case 120:
        case 88:
          return has_x ? false : has_x = true;
        case 101:
        case 69:
          return has_x ? true : has_e ? false : has_e = after_e = true;
        case 45:
          return after_e || i == 0 && !prefix;
        case 43:
          return after_e;
        case (after_e = false, 46):
          return !has_dot && !has_x && !has_e ? has_dot = true : false;
      }
      if (ch === "n") {
        is_big_int = true;
        return true;
      }
      return RE_NUM_LITERAL.test(ch);
    });
    if (prefix) num = prefix + num;
    LATEST_RAW = num;
    if (RE_OCT_NUMBER.test(num) && next_token.has_directive("use strict")) {
      parse_error("Legacy octal literals are not allowed in strict mode");
    }
    if (numeric_separator) {
      if (num.endsWith("_")) {
        parse_error("Numeric separators are not allowed at the end of numeric literals");
      } else if (num.includes("__")) {
        parse_error("Only one underscore is allowed as numeric separator");
      }
      num = num.replace(/_/g, "");
    }
    if (num.endsWith("n")) {
      const without_n = num.slice(0, -1);
      const allow_e = RE_HEX_NUMBER.test(without_n);
      const valid2 = parse_js_number(without_n, allow_e);
      if (!has_dot && RE_BIG_INT.test(num) && !isNaN(valid2))
        return token("big_int", without_n);
      parse_error("Invalid or unexpected token");
    }
    var valid = parse_js_number(num);
    if (!isNaN(valid)) {
      return token("num", valid);
    } else {
      parse_error("Invalid syntax: " + num);
    }
  }
  function is_octal(ch) {
    return ch >= "0" && ch <= "7";
  }
  function read_escaped_char(in_string, strict_hex, template_string) {
    var ch = next(true, in_string);
    switch (ch.charCodeAt(0)) {
      case 110:
        return "\n";
      case 114:
        return "\r";
      case 116:
        return "	";
      case 98:
        return "\b";
      case 118:
        return "\v";
      // \v
      case 102:
        return "\f";
      case 120:
        return String.fromCharCode(hex_bytes(2, strict_hex));
      // \x
      case 117:
        if (peek2() == "{") {
          next(true);
          if (peek2() === "}")
            parse_error("Expecting hex-character between {}");
          while (peek2() == "0") next(true);
          var result, length3 = find4("}") - S.pos;
          if (length3 > 6 || (result = hex_bytes(length3, strict_hex)) > 1114111) {
            parse_error("Unicode reference out of bounds");
          }
          next(true);
          return from_char_code(result);
        }
        return String.fromCharCode(hex_bytes(4, strict_hex));
      case 10:
        return "";
      // newline
      case 13:
        if (peek2() == "\n") {
          next(true, in_string);
          return "";
        }
    }
    if (is_octal(ch)) {
      if (template_string && strict_hex) {
        const represents_null_character = ch === "0" && !is_octal(peek2());
        if (!represents_null_character) {
          parse_error("Octal escape sequences are not allowed in template strings");
        }
      }
      return read_octal_escape_sequence(ch, strict_hex);
    }
    return ch;
  }
  function read_octal_escape_sequence(ch, strict_octal) {
    var p3 = peek2();
    if (p3 >= "0" && p3 <= "7") {
      ch += next(true);
      if (ch[0] <= "3" && (p3 = peek2()) >= "0" && p3 <= "7")
        ch += next(true);
    }
    if (ch === "0") return "\0";
    if (ch.length > 0 && next_token.has_directive("use strict") && strict_octal)
      parse_error("Legacy octal escape sequences are not allowed in strict mode");
    return String.fromCharCode(parseInt(ch, 8));
  }
  function hex_bytes(n2, strict_hex) {
    var num = 0;
    for (; n2 > 0; --n2) {
      if (!strict_hex && isNaN(parseInt(peek2(), 16))) {
        return parseInt(num, 16) || "";
      }
      var digit = next(true);
      if (isNaN(parseInt(digit, 16)))
        parse_error("Invalid hex-character pattern in string");
      num += digit;
    }
    return parseInt(num, 16);
  }
  var read_string = with_eof_error("Unterminated string constant", function() {
    const start_pos = S.pos;
    var quote = next(), ret = [];
    for (; ; ) {
      var ch = next(true, true);
      if (ch == "\\") ch = read_escaped_char(true, true);
      else if (ch == "\r" || ch == "\n") parse_error("Unterminated string constant");
      else if (ch == quote) break;
      ret.push(ch);
    }
    var tok = token("string", ret.join(""));
    LATEST_RAW = S.text.slice(start_pos, S.pos);
    tok.quote = quote;
    return tok;
  });
  var read_template_characters = with_eof_error("Unterminated template", function(begin) {
    if (begin) {
      S.template_braces.push(S.brace_counter);
    }
    var content = "", raw = "", ch, tok;
    next(true, true);
    while ((ch = next(true, true)) != "`") {
      if (ch == "\r") {
        if (peek2() == "\n") ++S.pos;
        ch = "\n";
      } else if (ch == "$" && peek2() == "{") {
        next(true, true);
        S.brace_counter++;
        tok = token(begin ? "template_head" : "template_substitution", content);
        TEMPLATE_RAWS.set(tok, raw);
        tok.template_end = false;
        return tok;
      }
      raw += ch;
      if (ch == "\\") {
        var tmp = S.pos;
        var prev_is_tag = previous_token && (previous_token.type === "name" || previous_token.type === "punc" && (previous_token.value === ")" || previous_token.value === "]"));
        ch = read_escaped_char(true, !prev_is_tag, true);
        raw += S.text.substr(tmp, S.pos - tmp);
      }
      content += ch;
    }
    S.template_braces.pop();
    tok = token(begin ? "template_head" : "template_substitution", content);
    TEMPLATE_RAWS.set(tok, raw);
    tok.template_end = true;
    return tok;
  });
  function skip_line_comment(type) {
    var regex_allowed = S.regex_allowed;
    var i = find_eol(), ret;
    if (i == -1) {
      ret = S.text.substr(S.pos);
      S.pos = S.text.length;
    } else {
      ret = S.text.substring(S.pos, i);
      S.pos = i;
    }
    S.col = S.tokcol + (S.pos - S.tokpos);
    S.comments_before.push(token(type, ret, true));
    S.regex_allowed = regex_allowed;
    return next_token;
  }
  var skip_multiline_comment = with_eof_error("Unterminated multiline comment", function() {
    var regex_allowed = S.regex_allowed;
    var i = find4("*/");
    var text = S.text.substring(S.pos, i).replace(/\r\n|\r|\u2028|\u2029/g, "\n");
    forward(get_full_char_length(text) + 2);
    S.comments_before.push(token("comment2", text, true));
    S.newline_before = S.newline_before || text.includes("\n");
    S.regex_allowed = regex_allowed;
    return next_token;
  });
  var read_name = with_eof_error("Unterminated identifier name", function() {
    var name = [], ch, escaped = false;
    var read_escaped_identifier_char = function() {
      escaped = true;
      next();
      if (peek2() !== "u") {
        parse_error("Expecting UnicodeEscapeSequence -- uXXXX or u{XXXX}");
      }
      return read_escaped_char(false, true);
    };
    if ((ch = peek2()) === "\\") {
      ch = read_escaped_identifier_char();
      if (!is_identifier_start(ch)) {
        parse_error("First identifier char is an invalid identifier char");
      }
    } else if (is_identifier_start(ch)) {
      next();
    } else {
      return "";
    }
    name.push(ch);
    while ((ch = peek2()) != null) {
      if ((ch = peek2()) === "\\") {
        ch = read_escaped_identifier_char();
        if (!is_identifier_char(ch)) {
          parse_error("Invalid escaped identifier char");
        }
      } else {
        if (!is_identifier_char(ch)) {
          break;
        }
        next();
      }
      name.push(ch);
    }
    const name_str = name.join("");
    if (RESERVED_WORDS.has(name_str) && escaped) {
      parse_error("Escaped characters are not allowed in keywords");
    }
    return name_str;
  });
  var read_regexp = with_eof_error("Unterminated regular expression", function(source) {
    var prev_backslash = false, ch, in_class = false;
    while (ch = next(true)) if (NEWLINE_CHARS.has(ch)) {
      parse_error("Unexpected line terminator");
    } else if (prev_backslash) {
      if (/^[\u0000-\u007F]$/.test(ch)) {
        source += "\\" + ch;
      } else {
        source += ch;
      }
      prev_backslash = false;
    } else if (ch == "[") {
      in_class = true;
      source += ch;
    } else if (ch == "]" && in_class) {
      in_class = false;
      source += ch;
    } else if (ch == "/" && !in_class) {
      break;
    } else if (ch == "\\") {
      prev_backslash = true;
    } else {
      source += ch;
    }
    const flags = read_name();
    return token("regexp", "/" + source + "/" + flags);
  });
  function read_operator(prefix) {
    function grow(op) {
      if (!peek2()) return op;
      var bigger = op + peek2();
      if (OPERATORS.has(bigger)) {
        next();
        return grow(bigger);
      } else {
        return op;
      }
    }
    return token("operator", grow(prefix || next()));
  }
  function handle_slash() {
    next();
    switch (peek2()) {
      case "/":
        next();
        return skip_line_comment("comment1");
      case "*":
        next();
        return skip_multiline_comment();
    }
    return S.regex_allowed ? read_regexp("") : read_operator("/");
  }
  function handle_eq_sign() {
    next();
    if (peek2() === ">") {
      next();
      return token("arrow", "=>");
    } else {
      return read_operator("=");
    }
  }
  function handle_dot() {
    next();
    if (is_digit(peek2().charCodeAt(0))) {
      return read_num(".");
    }
    if (peek2() === ".") {
      next();
      next();
      return token("expand", "...");
    }
    return token("punc", ".");
  }
  function read_word() {
    var word = read_name();
    if (prev_was_dot) return token("name", word);
    return KEYWORDS_ATOM.has(word) ? token("atom", word) : !KEYWORDS.has(word) ? token("name", word) : OPERATORS.has(word) ? token("operator", word) : token("keyword", word);
  }
  function read_private_word() {
    next();
    return token("privatename", read_name());
  }
  function with_eof_error(eof_error, cont) {
    return function(x2) {
      try {
        return cont(x2);
      } catch (ex) {
        if (ex === EX_EOF) parse_error(eof_error);
        else throw ex;
      }
    };
  }
  function next_token(force_regexp) {
    if (force_regexp != null)
      return read_regexp(force_regexp);
    if (shebang && S.pos == 0 && looking_at("#!")) {
      start_token();
      forward(2);
      skip_line_comment("comment5");
    }
    for (; ; ) {
      skip_whitespace();
      start_token();
      if (html5_comments) {
        if (looking_at("<!--")) {
          forward(4);
          skip_line_comment("comment3");
          continue;
        }
        if (looking_at("-->") && S.newline_before) {
          forward(3);
          skip_line_comment("comment4");
          continue;
        }
      }
      var ch = peek2();
      if (!ch) return token("eof");
      var code = ch.charCodeAt(0);
      switch (code) {
        case 34:
        case 39:
          return read_string();
        case 46:
          return handle_dot();
        case 47: {
          var tok = handle_slash();
          if (tok === next_token) continue;
          return tok;
        }
        case 61:
          return handle_eq_sign();
        case 63: {
          if (!is_option_chain_op()) break;
          next();
          next();
          return token("punc", "?.");
        }
        case 96:
          return read_template_characters(true);
        case 123:
          S.brace_counter++;
          break;
        case 125:
          S.brace_counter--;
          if (S.template_braces.length > 0 && S.template_braces[S.template_braces.length - 1] === S.brace_counter)
            return read_template_characters(false);
          break;
      }
      if (is_digit(code)) return read_num();
      if (PUNC_CHARS.has(ch)) return token("punc", next());
      if (OPERATOR_CHARS.has(ch)) return read_operator();
      if (code == 92 || is_identifier_start(ch)) return read_word();
      if (code == 35) return read_private_word();
      break;
    }
    parse_error("Unexpected character '" + ch + "'");
  }
  next_token.next = next;
  next_token.peek = peek2;
  next_token.context = function(nc) {
    if (nc) S = nc;
    return S;
  };
  next_token.add_directive = function(directive3) {
    S.directive_stack[S.directive_stack.length - 1].push(directive3);
    if (S.directives[directive3] === void 0) {
      S.directives[directive3] = 1;
    } else {
      S.directives[directive3]++;
    }
  };
  next_token.push_directives_stack = function() {
    S.directive_stack.push([]);
  };
  next_token.pop_directives_stack = function() {
    var directives2 = S.directive_stack[S.directive_stack.length - 1];
    for (var i = 0; i < directives2.length; i++) {
      S.directives[directives2[i]]--;
    }
    S.directive_stack.pop();
  };
  next_token.has_directive = function(directive3) {
    return S.directives[directive3] > 0;
  };
  return next_token;
}
var UNARY_PREFIX = makePredicate([
  "typeof",
  "void",
  "delete",
  "--",
  "++",
  "!",
  "~",
  "-",
  "+"
]);
var UNARY_POSTFIX = makePredicate(["--", "++"]);
var ASSIGNMENT = makePredicate(["=", "+=", "-=", "??=", "&&=", "||=", "/=", "*=", "**=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&="]);
var LOGICAL_ASSIGNMENT = makePredicate(["??=", "&&=", "||="]);
var PRECEDENCE = function(a2, ret) {
  for (var i = 0; i < a2.length; ++i) {
    for (const op of a2[i]) {
      ret[op] = i + 1;
    }
  }
  return ret;
}(
  [
    ["||"],
    ["??"],
    ["&&"],
    ["|"],
    ["^"],
    ["&"],
    ["==", "===", "!=", "!=="],
    ["<", ">", "<=", ">=", "in", "instanceof"],
    [">>", "<<", ">>>"],
    ["+", "-"],
    ["*", "/", "%"],
    ["**"]
  ],
  {}
);
var ATOMIC_START_TOKEN = makePredicate(["atom", "num", "big_int", "string", "regexp", "name"]);
function parse($TEXT, options) {
  const outer_comments_before_counts = /* @__PURE__ */ new WeakMap();
  options = defaults2(options, {
    bare_returns: false,
    ecma: null,
    // Legacy
    expression: false,
    filename: null,
    html5_comments: true,
    module: false,
    shebang: true,
    strict: false,
    toplevel: null
  }, true);
  var S = {
    input: typeof $TEXT == "string" ? tokenizer(
      $TEXT,
      options.filename,
      options.html5_comments,
      options.shebang
    ) : $TEXT,
    token: null,
    prev: null,
    peeked: null,
    in_function: 0,
    in_async: -1,
    in_generator: -1,
    in_directives: true,
    in_loop: 0,
    labels: []
  };
  S.token = next();
  function is(type, value) {
    return is_token(S.token, type, value);
  }
  function peek2() {
    return S.peeked || (S.peeked = S.input());
  }
  function next() {
    S.prev = S.token;
    if (!S.peeked) peek2();
    S.token = S.peeked;
    S.peeked = null;
    S.in_directives = S.in_directives && (S.token.type == "string" || is("punc", ";"));
    return S.token;
  }
  function prev() {
    return S.prev;
  }
  function croak(msg, line, col, pos) {
    var ctx = S.input.context();
    js_error(
      msg,
      ctx.filename,
      line != null ? line : ctx.tokline,
      col != null ? col : ctx.tokcol,
      pos != null ? pos : ctx.tokpos
    );
  }
  function token_error(token, msg) {
    croak(msg, token.line, token.col);
  }
  function unexpected(token) {
    if (token == null)
      token = S.token;
    token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
  }
  function expect_token(type, val) {
    if (is(type, val)) {
      return next();
    }
    token_error(S.token, "Unexpected token " + S.token.type + " \xAB" + S.token.value + "\xBB, expected " + type + " \xAB" + val + "\xBB");
  }
  function expect(punc) {
    return expect_token("punc", punc);
  }
  function has_newline_before(token) {
    return token.nlb || !token.comments_before.every((comment) => !comment.nlb);
  }
  function can_insert_semicolon() {
    return !options.strict && (is("eof") || is("punc", "}") || has_newline_before(S.token));
  }
  function is_in_generator() {
    return S.in_generator === S.in_function;
  }
  function is_in_async() {
    return S.in_async === S.in_function;
  }
  function can_await() {
    return S.in_async === S.in_function || S.in_function === 0 && S.input.has_directive("use strict");
  }
  function semicolon3(optional) {
    if (is("punc", ";")) next();
    else if (!optional && !can_insert_semicolon()) unexpected();
  }
  function parenthesised() {
    expect("(");
    var exp = expression(true);
    expect(")");
    return exp;
  }
  function embed_tokens(parser4) {
    return function _embed_tokens_wrapper(...args2) {
      const start3 = S.token;
      const expr = parser4(...args2);
      expr.start = start3;
      expr.end = prev();
      return expr;
    };
  }
  function handle_regexp() {
    if (is("operator", "/") || is("operator", "/=")) {
      S.peeked = null;
      S.token = S.input(S.token.value.substr(1));
    }
  }
  var statement = embed_tokens(function statement2(is_export_default, is_for_body, is_if_body) {
    handle_regexp();
    switch (S.token.type) {
      case "string":
        if (S.in_directives) {
          var token = peek2();
          if (!LATEST_RAW.includes("\\") && (is_token(token, "punc", ";") || is_token(token, "punc", "}") || has_newline_before(token) || is_token(token, "eof"))) {
            S.input.add_directive(S.token.value);
          } else {
            S.in_directives = false;
          }
        }
        var dir3 = S.in_directives, stat2 = simple_statement();
        return dir3 && stat2.body instanceof AST_String ? new AST_Directive(stat2.body) : stat2;
      case "template_head":
      case "num":
      case "big_int":
      case "regexp":
      case "operator":
      case "atom":
        return simple_statement();
      case "name":
      case "privatename":
        if (is("privatename") && !S.in_class)
          croak("Private field must be used in an enclosing class");
        if (S.token.value == "async" && is_token(peek2(), "keyword", "function")) {
          next();
          next();
          if (is_for_body) {
            croak("functions are not allowed as the body of a loop");
          }
          return function_(AST_Defun, false, true, is_export_default);
        }
        if (S.token.value == "import" && !is_token(peek2(), "punc", "(") && !is_token(peek2(), "punc", ".")) {
          next();
          var node = import_statement();
          semicolon3();
          return node;
        }
        return is_token(peek2(), "punc", ":") ? labeled_statement() : simple_statement();
      case "punc":
        switch (S.token.value) {
          case "{":
            return new AST_BlockStatement({
              start: S.token,
              body: block_(),
              end: prev()
            });
          case "[":
          case "(":
            return simple_statement();
          case ";":
            S.in_directives = false;
            next();
            return new AST_EmptyStatement();
          default:
            unexpected();
        }
      case "keyword":
        switch (S.token.value) {
          case "break":
            next();
            return break_cont(AST_Break);
          case "continue":
            next();
            return break_cont(AST_Continue);
          case "debugger":
            next();
            semicolon3();
            return new AST_Debugger();
          case "do":
            next();
            var body = in_loop(statement2);
            expect_token("keyword", "while");
            var condition = parenthesised();
            semicolon3(true);
            return new AST_Do({
              body,
              condition
            });
          case "while":
            next();
            return new AST_While({
              condition: parenthesised(),
              body: in_loop(function() {
                return statement2(false, true);
              })
            });
          case "for":
            next();
            return for_();
          case "class":
            next();
            if (is_for_body) {
              croak("classes are not allowed as the body of a loop");
            }
            if (is_if_body) {
              croak("classes are not allowed as the body of an if");
            }
            return class_(AST_DefClass, is_export_default);
          case "function":
            next();
            if (is_for_body) {
              croak("functions are not allowed as the body of a loop");
            }
            return function_(AST_Defun, false, false, is_export_default);
          case "if":
            next();
            return if_3();
          case "return":
            if (S.in_function == 0 && !options.bare_returns)
              croak("'return' outside of function");
            next();
            var value = null;
            if (is("punc", ";")) {
              next();
            } else if (!can_insert_semicolon()) {
              value = expression(true);
              semicolon3();
            }
            return new AST_Return({
              value
            });
          case "switch":
            next();
            return new AST_Switch({
              expression: parenthesised(),
              body: in_loop(switch_body_)
            });
          case "throw":
            next();
            if (has_newline_before(S.token))
              croak("Illegal newline after 'throw'");
            var value = expression(true);
            semicolon3();
            return new AST_Throw({
              value
            });
          case "try":
            next();
            return try_4();
          case "var":
            next();
            var node = var_();
            semicolon3();
            return node;
          case "let":
            next();
            var node = let_6();
            semicolon3();
            return node;
          case "const":
            next();
            var node = const_();
            semicolon3();
            return node;
          case "with":
            if (S.input.has_directive("use strict")) {
              croak("Strict mode may not include a with statement");
            }
            next();
            return new AST_With({
              expression: parenthesised(),
              body: statement2()
            });
          case "export":
            if (!is_token(peek2(), "punc", "(")) {
              next();
              var node = export_statement();
              if (is("punc", ";")) semicolon3();
              return node;
            }
        }
    }
    unexpected();
  });
  function labeled_statement() {
    var label = as_symbol(AST_Label);
    if (label.name === "await" && is_in_async()) {
      token_error(S.prev, "await cannot be used as label inside async function");
    }
    if (S.labels.some((l) => l.name === label.name)) {
      croak("Label " + label.name + " defined twice");
    }
    expect(":");
    S.labels.push(label);
    var stat2 = statement();
    S.labels.pop();
    if (!(stat2 instanceof AST_IterationStatement)) {
      label.references.forEach(function(ref) {
        if (ref instanceof AST_Continue) {
          ref = ref.label.start;
          croak(
            "Continue label `" + label.name + "` refers to non-IterationStatement.",
            ref.line,
            ref.col,
            ref.pos
          );
        }
      });
    }
    return new AST_LabeledStatement({ body: stat2, label });
  }
  function simple_statement(tmp) {
    return new AST_SimpleStatement({ body: (tmp = expression(true), semicolon3(), tmp) });
  }
  function break_cont(type) {
    var label = null, ldef;
    if (!can_insert_semicolon()) {
      label = as_symbol(AST_LabelRef, true);
    }
    if (label != null) {
      ldef = S.labels.find((l) => l.name === label.name);
      if (!ldef)
        croak("Undefined label " + label.name);
      label.thedef = ldef;
    } else if (S.in_loop == 0)
      croak(type.TYPE + " not inside a loop or switch");
    semicolon3();
    var stat2 = new type({ label });
    if (ldef) ldef.references.push(stat2);
    return stat2;
  }
  function for_() {
    var for_await_error = "`for await` invalid in this context";
    var await_tok = S.token;
    if (await_tok.type == "name" && await_tok.value == "await") {
      if (!can_await()) {
        token_error(await_tok, for_await_error);
      }
      next();
    } else {
      await_tok = false;
    }
    expect("(");
    var init2 = null;
    if (!is("punc", ";")) {
      init2 = is("keyword", "var") ? (next(), var_(true)) : is("keyword", "let") ? (next(), let_6(true)) : is("keyword", "const") ? (next(), const_(true)) : expression(true, true);
      var is_in = is("operator", "in");
      var is_of = is("name", "of");
      if (await_tok && !is_of) {
        token_error(await_tok, for_await_error);
      }
      if (is_in || is_of) {
        if (init2 instanceof AST_Definitions) {
          if (init2.definitions.length > 1)
            token_error(init2.start, "Only one variable declaration allowed in for..in loop");
        } else if (!(is_assignable(init2) || (init2 = to_destructuring(init2)) instanceof AST_Destructuring)) {
          token_error(init2.start, "Invalid left-hand side in for..in loop");
        }
        next();
        if (is_in) {
          return for_in(init2);
        } else {
          return for_of(init2, !!await_tok);
        }
      }
    } else if (await_tok) {
      token_error(await_tok, for_await_error);
    }
    return regular_for(init2);
  }
  function regular_for(init2) {
    expect(";");
    var test = is("punc", ";") ? null : expression(true);
    expect(";");
    var step4 = is("punc", ")") ? null : expression(true);
    expect(")");
    return new AST_For({
      init: init2,
      condition: test,
      step: step4,
      body: in_loop(function() {
        return statement(false, true);
      })
    });
  }
  function for_of(init2, is_await) {
    var lhs = init2 instanceof AST_Definitions ? init2.definitions[0].name : null;
    var obj = expression(true);
    expect(")");
    return new AST_ForOf({
      await: is_await,
      init: init2,
      name: lhs,
      object: obj,
      body: in_loop(function() {
        return statement(false, true);
      })
    });
  }
  function for_in(init2) {
    var obj = expression(true);
    expect(")");
    return new AST_ForIn({
      init: init2,
      object: obj,
      body: in_loop(function() {
        return statement(false, true);
      })
    });
  }
  var arrow_function = function(start3, argnames, is_async) {
    if (has_newline_before(S.token)) {
      croak("Unexpected newline before arrow (=>)");
    }
    expect_token("arrow", "=>");
    var body = _function_body(is("punc", "{"), false, is_async);
    var end6 = body instanceof Array && body.length ? body[body.length - 1].end : body instanceof Array ? start3 : body.end;
    return new AST_Arrow({
      start: start3,
      end: end6,
      async: is_async,
      argnames,
      body
    });
  };
  var function_ = function(ctor, is_generator_property, is_async, is_export_default) {
    var in_statement = ctor === AST_Defun;
    var is_generator = is("operator", "*");
    if (is_generator) {
      next();
    }
    var name = is("name") ? as_symbol(in_statement ? AST_SymbolDefun : AST_SymbolLambda) : null;
    if (in_statement && !name) {
      if (is_export_default) {
        ctor = AST_Function;
      } else {
        unexpected();
      }
    }
    if (name && ctor !== AST_Accessor && !(name instanceof AST_SymbolDeclaration))
      unexpected(prev());
    var args2 = [];
    var body = _function_body(true, is_generator || is_generator_property, is_async, name, args2);
    return new ctor({
      start: args2.start,
      end: body.end,
      is_generator,
      async: is_async,
      name,
      argnames: args2,
      body
    });
  };
  class UsedParametersTracker {
    constructor(is_parameter, strict, duplicates_ok = false) {
      this.is_parameter = is_parameter;
      this.duplicates_ok = duplicates_ok;
      this.parameters = /* @__PURE__ */ new Set();
      this.duplicate = null;
      this.default_assignment = false;
      this.spread = false;
      this.strict_mode = !!strict;
    }
    add_parameter(token) {
      if (this.parameters.has(token.value)) {
        if (this.duplicate === null) {
          this.duplicate = token;
        }
        this.check_strict();
      } else {
        this.parameters.add(token.value);
        if (this.is_parameter) {
          switch (token.value) {
            case "arguments":
            case "eval":
            case "yield":
              if (this.strict_mode) {
                token_error(token, "Unexpected " + token.value + " identifier as parameter inside strict mode");
              }
              break;
            default:
              if (RESERVED_WORDS.has(token.value)) {
                unexpected();
              }
          }
        }
      }
    }
    mark_default_assignment(token) {
      if (this.default_assignment === false) {
        this.default_assignment = token;
      }
    }
    mark_spread(token) {
      if (this.spread === false) {
        this.spread = token;
      }
    }
    mark_strict_mode() {
      this.strict_mode = true;
    }
    is_strict() {
      return this.default_assignment !== false || this.spread !== false || this.strict_mode;
    }
    check_strict() {
      if (this.is_strict() && this.duplicate !== null && !this.duplicates_ok) {
        token_error(this.duplicate, "Parameter " + this.duplicate.value + " was used already");
      }
    }
  }
  function parameters(params) {
    var used_parameters = new UsedParametersTracker(true, S.input.has_directive("use strict"));
    expect("(");
    while (!is("punc", ")")) {
      var param = parameter(used_parameters);
      params.push(param);
      if (!is("punc", ")")) {
        expect(",");
      }
      if (param instanceof AST_Expansion) {
        break;
      }
    }
    next();
  }
  function parameter(used_parameters, symbol_type) {
    var param;
    var expand2 = false;
    if (used_parameters === void 0) {
      used_parameters = new UsedParametersTracker(true, S.input.has_directive("use strict"));
    }
    if (is("expand", "...")) {
      expand2 = S.token;
      used_parameters.mark_spread(S.token);
      next();
    }
    param = binding_element(used_parameters, symbol_type);
    if (is("operator", "=") && expand2 === false) {
      used_parameters.mark_default_assignment(S.token);
      next();
      param = new AST_DefaultAssign({
        start: param.start,
        left: param,
        operator: "=",
        right: expression(false),
        end: S.token
      });
    }
    if (expand2 !== false) {
      if (!is("punc", ")")) {
        unexpected();
      }
      param = new AST_Expansion({
        start: expand2,
        expression: param,
        end: expand2
      });
    }
    used_parameters.check_strict();
    return param;
  }
  function binding_element(used_parameters, symbol_type) {
    var elements = [];
    var first3 = true;
    var is_expand = false;
    var expand_token;
    var first_token = S.token;
    if (used_parameters === void 0) {
      const strict = S.input.has_directive("use strict");
      const duplicates_ok = symbol_type === AST_SymbolVar;
      used_parameters = new UsedParametersTracker(false, strict, duplicates_ok);
    }
    symbol_type = symbol_type === void 0 ? AST_SymbolFunarg : symbol_type;
    if (is("punc", "[")) {
      next();
      while (!is("punc", "]")) {
        if (first3) {
          first3 = false;
        } else {
          expect(",");
        }
        if (is("expand", "...")) {
          is_expand = true;
          expand_token = S.token;
          used_parameters.mark_spread(S.token);
          next();
        }
        if (is("punc")) {
          switch (S.token.value) {
            case ",":
              elements.push(new AST_Hole({
                start: S.token,
                end: S.token
              }));
              continue;
            case "]":
              break;
            case "[":
            case "{":
              elements.push(binding_element(used_parameters, symbol_type));
              break;
            default:
              unexpected();
          }
        } else if (is("name")) {
          used_parameters.add_parameter(S.token);
          elements.push(as_symbol(symbol_type));
        } else {
          croak("Invalid function parameter");
        }
        if (is("operator", "=") && is_expand === false) {
          used_parameters.mark_default_assignment(S.token);
          next();
          elements[elements.length - 1] = new AST_DefaultAssign({
            start: elements[elements.length - 1].start,
            left: elements[elements.length - 1],
            operator: "=",
            right: expression(false),
            end: S.token
          });
        }
        if (is_expand) {
          if (!is("punc", "]")) {
            croak("Rest element must be last element");
          }
          elements[elements.length - 1] = new AST_Expansion({
            start: expand_token,
            expression: elements[elements.length - 1],
            end: expand_token
          });
        }
      }
      expect("]");
      used_parameters.check_strict();
      return new AST_Destructuring({
        start: first_token,
        names: elements,
        is_array: true,
        end: prev()
      });
    } else if (is("punc", "{")) {
      next();
      while (!is("punc", "}")) {
        if (first3) {
          first3 = false;
        } else {
          expect(",");
        }
        if (is("expand", "...")) {
          is_expand = true;
          expand_token = S.token;
          used_parameters.mark_spread(S.token);
          next();
        }
        if (is("name") && (is_token(peek2(), "punc") || is_token(peek2(), "operator")) && [",", "}", "="].includes(peek2().value)) {
          used_parameters.add_parameter(S.token);
          var start3 = prev();
          var value = as_symbol(symbol_type);
          if (is_expand) {
            elements.push(new AST_Expansion({
              start: expand_token,
              expression: value,
              end: value.end
            }));
          } else {
            elements.push(new AST_ObjectKeyVal({
              start: start3,
              key: value.name,
              value,
              end: value.end
            }));
          }
        } else if (is("punc", "}")) {
          continue;
        } else {
          var property_token = S.token;
          var property3 = as_property_name();
          if (property3 === null) {
            unexpected(prev());
          } else if (prev().type === "name" && !is("punc", ":")) {
            elements.push(new AST_ObjectKeyVal({
              start: prev(),
              key: property3,
              value: new symbol_type({
                start: prev(),
                name: property3,
                end: prev()
              }),
              end: prev()
            }));
          } else {
            expect(":");
            elements.push(new AST_ObjectKeyVal({
              start: property_token,
              quote: property_token.quote,
              key: property3,
              value: binding_element(used_parameters, symbol_type),
              end: prev()
            }));
          }
        }
        if (is_expand) {
          if (!is("punc", "}")) {
            croak("Rest element must be last element");
          }
        } else if (is("operator", "=")) {
          used_parameters.mark_default_assignment(S.token);
          next();
          elements[elements.length - 1].value = new AST_DefaultAssign({
            start: elements[elements.length - 1].value.start,
            left: elements[elements.length - 1].value,
            operator: "=",
            right: expression(false),
            end: S.token
          });
        }
      }
      expect("}");
      used_parameters.check_strict();
      return new AST_Destructuring({
        start: first_token,
        names: elements,
        is_array: false,
        end: prev()
      });
    } else if (is("name")) {
      used_parameters.add_parameter(S.token);
      return as_symbol(symbol_type);
    } else {
      croak("Invalid function parameter");
    }
  }
  function params_or_seq_(allow_arrows, maybe_sequence) {
    var spread_token;
    var invalid_sequence;
    var trailing_comma;
    var a2 = [];
    expect("(");
    while (!is("punc", ")")) {
      if (spread_token) unexpected(spread_token);
      if (is("expand", "...")) {
        spread_token = S.token;
        if (maybe_sequence) invalid_sequence = S.token;
        next();
        a2.push(new AST_Expansion({
          start: prev(),
          expression: expression(),
          end: S.token
        }));
      } else {
        a2.push(expression());
      }
      if (!is("punc", ")")) {
        expect(",");
        if (is("punc", ")")) {
          trailing_comma = prev();
          if (maybe_sequence) invalid_sequence = trailing_comma;
        }
      }
    }
    expect(")");
    if (allow_arrows && is("arrow", "=>")) {
      if (spread_token && trailing_comma) unexpected(trailing_comma);
    } else if (invalid_sequence) {
      unexpected(invalid_sequence);
    }
    return a2;
  }
  function _function_body(block, generator, is_async, name, args2) {
    var loop3 = S.in_loop;
    var labels = S.labels;
    var current_generator = S.in_generator;
    var current_async = S.in_async;
    ++S.in_function;
    if (generator)
      S.in_generator = S.in_function;
    if (is_async)
      S.in_async = S.in_function;
    if (args2) parameters(args2);
    if (block)
      S.in_directives = true;
    S.in_loop = 0;
    S.labels = [];
    if (block) {
      S.input.push_directives_stack();
      var a2 = block_();
      if (name) _verify_symbol(name);
      if (args2) args2.forEach(_verify_symbol);
      S.input.pop_directives_stack();
    } else {
      var a2 = [new AST_Return({
        start: S.token,
        value: expression(false),
        end: S.token
      })];
    }
    --S.in_function;
    S.in_loop = loop3;
    S.labels = labels;
    S.in_generator = current_generator;
    S.in_async = current_async;
    return a2;
  }
  function _await_expression() {
    if (!can_await()) {
      croak(
        "Unexpected await expression outside async function",
        S.prev.line,
        S.prev.col,
        S.prev.pos
      );
    }
    return new AST_Await({
      start: prev(),
      end: S.token,
      expression: maybe_unary(true)
    });
  }
  function _yield_expression() {
    if (!is_in_generator()) {
      croak(
        "Unexpected yield expression outside generator function",
        S.prev.line,
        S.prev.col,
        S.prev.pos
      );
    }
    var start3 = S.token;
    var star = false;
    var has_expression = true;
    if (can_insert_semicolon() || is("punc") && PUNC_AFTER_EXPRESSION.has(S.token.value)) {
      has_expression = false;
    } else if (is("operator", "*")) {
      star = true;
      next();
    }
    return new AST_Yield({
      start: start3,
      is_star: star,
      expression: has_expression ? expression() : null,
      end: prev()
    });
  }
  function if_3() {
    var cond = parenthesised(), body = statement(false, false, true), belse = null;
    if (is("keyword", "else")) {
      next();
      belse = statement(false, false, true);
    }
    return new AST_If({
      condition: cond,
      body,
      alternative: belse
    });
  }
  function block_() {
    expect("{");
    var a2 = [];
    while (!is("punc", "}")) {
      if (is("eof")) unexpected();
      a2.push(statement());
    }
    next();
    return a2;
  }
  function switch_body_() {
    expect("{");
    var a2 = [], cur = null, branch = null, tmp;
    while (!is("punc", "}")) {
      if (is("eof")) unexpected();
      if (is("keyword", "case")) {
        if (branch) branch.end = prev();
        cur = [];
        branch = new AST_Case({
          start: (tmp = S.token, next(), tmp),
          expression: expression(true),
          body: cur
        });
        a2.push(branch);
        expect(":");
      } else if (is("keyword", "default")) {
        if (branch) branch.end = prev();
        cur = [];
        branch = new AST_Default({
          start: (tmp = S.token, next(), expect(":"), tmp),
          body: cur
        });
        a2.push(branch);
      } else {
        if (!cur) unexpected();
        cur.push(statement());
      }
    }
    if (branch) branch.end = prev();
    next();
    return a2;
  }
  function try_4() {
    var body, bcatch = null, bfinally = null;
    body = new AST_TryBlock({
      start: S.token,
      body: block_(),
      end: prev()
    });
    if (is("keyword", "catch")) {
      var start3 = S.token;
      next();
      if (is("punc", "{")) {
        var name = null;
      } else {
        expect("(");
        var name = parameter(void 0, AST_SymbolCatch);
        expect(")");
      }
      bcatch = new AST_Catch({
        start: start3,
        argname: name,
        body: block_(),
        end: prev()
      });
    }
    if (is("keyword", "finally")) {
      var start3 = S.token;
      next();
      bfinally = new AST_Finally({
        start: start3,
        body: block_(),
        end: prev()
      });
    }
    if (!bcatch && !bfinally)
      croak("Missing catch/finally blocks");
    return new AST_Try({
      body,
      bcatch,
      bfinally
    });
  }
  function vardefs(no_in, kind) {
    var var_defs = [];
    var def;
    for (; ; ) {
      var sym_type = kind === "var" ? AST_SymbolVar : kind === "const" ? AST_SymbolConst : kind === "let" ? AST_SymbolLet : null;
      if (is("punc", "{") || is("punc", "[")) {
        def = new AST_VarDef({
          start: S.token,
          name: binding_element(void 0, sym_type),
          value: is("operator", "=") ? (expect_token("operator", "="), expression(false, no_in)) : null,
          end: prev()
        });
      } else {
        def = new AST_VarDef({
          start: S.token,
          name: as_symbol(sym_type),
          value: is("operator", "=") ? (next(), expression(false, no_in)) : !no_in && kind === "const" ? croak("Missing initializer in const declaration") : null,
          end: prev()
        });
        if (def.name.name == "import") croak("Unexpected token: import");
      }
      var_defs.push(def);
      if (!is("punc", ","))
        break;
      next();
    }
    return var_defs;
  }
  var var_ = function(no_in) {
    return new AST_Var({
      start: prev(),
      definitions: vardefs(no_in, "var"),
      end: prev()
    });
  };
  var let_6 = function(no_in) {
    return new AST_Let({
      start: prev(),
      definitions: vardefs(no_in, "let"),
      end: prev()
    });
  };
  var const_ = function(no_in) {
    return new AST_Const({
      start: prev(),
      definitions: vardefs(no_in, "const"),
      end: prev()
    });
  };
  var new_ = function(allow_calls) {
    var start3 = S.token;
    expect_token("operator", "new");
    if (is("punc", ".")) {
      next();
      expect_token("name", "target");
      return subscripts(new AST_NewTarget({
        start: start3,
        end: prev()
      }), allow_calls);
    }
    var newexp = expr_atom(false), args2;
    if (is("punc", "(")) {
      next();
      args2 = expr_list(")", true);
    } else {
      args2 = [];
    }
    var call = new AST_New({
      start: start3,
      expression: newexp,
      args: args2,
      end: prev()
    });
    annotate(call);
    return subscripts(call, allow_calls);
  };
  function as_atom_node() {
    var tok = S.token, ret;
    switch (tok.type) {
      case "name":
        ret = _make_symbol(AST_SymbolRef);
        break;
      case "num":
        ret = new AST_Number({
          start: tok,
          end: tok,
          value: tok.value,
          raw: LATEST_RAW
        });
        break;
      case "big_int":
        ret = new AST_BigInt({ start: tok, end: tok, value: tok.value });
        break;
      case "string":
        ret = new AST_String({
          start: tok,
          end: tok,
          value: tok.value,
          quote: tok.quote
        });
        annotate(ret);
        break;
      case "regexp":
        const [_2, source, flags] = tok.value.match(/^\/(.*)\/(\w*)$/);
        ret = new AST_RegExp({ start: tok, end: tok, value: { source, flags } });
        break;
      case "atom":
        switch (tok.value) {
          case "false":
            ret = new AST_False({ start: tok, end: tok });
            break;
          case "true":
            ret = new AST_True({ start: tok, end: tok });
            break;
          case "null":
            ret = new AST_Null({ start: tok, end: tok });
            break;
        }
        break;
    }
    next();
    return ret;
  }
  function to_fun_args(ex, default_seen_above) {
    var insert_default = function(ex2, default_value) {
      if (default_value) {
        return new AST_DefaultAssign({
          start: ex2.start,
          left: ex2,
          operator: "=",
          right: default_value,
          end: default_value.end
        });
      }
      return ex2;
    };
    if (ex instanceof AST_Object) {
      return insert_default(new AST_Destructuring({
        start: ex.start,
        end: ex.end,
        is_array: false,
        names: ex.properties.map((prop) => to_fun_args(prop))
      }), default_seen_above);
    } else if (ex instanceof AST_ObjectKeyVal) {
      ex.value = to_fun_args(ex.value);
      return insert_default(ex, default_seen_above);
    } else if (ex instanceof AST_Hole) {
      return ex;
    } else if (ex instanceof AST_Destructuring) {
      ex.names = ex.names.map((name) => to_fun_args(name));
      return insert_default(ex, default_seen_above);
    } else if (ex instanceof AST_SymbolRef) {
      return insert_default(new AST_SymbolFunarg({
        name: ex.name,
        start: ex.start,
        end: ex.end
      }), default_seen_above);
    } else if (ex instanceof AST_Expansion) {
      ex.expression = to_fun_args(ex.expression);
      return insert_default(ex, default_seen_above);
    } else if (ex instanceof AST_Array) {
      return insert_default(new AST_Destructuring({
        start: ex.start,
        end: ex.end,
        is_array: true,
        names: ex.elements.map((elm) => to_fun_args(elm))
      }), default_seen_above);
    } else if (ex instanceof AST_Assign) {
      return insert_default(to_fun_args(ex.left, ex.right), default_seen_above);
    } else if (ex instanceof AST_DefaultAssign) {
      ex.left = to_fun_args(ex.left);
      return ex;
    } else {
      croak("Invalid function parameter", ex.start.line, ex.start.col);
    }
  }
  var expr_atom = function(allow_calls, allow_arrows) {
    if (is("operator", "new")) {
      return new_(allow_calls);
    }
    if (is("name", "import") && is_token(peek2(), "punc", ".")) {
      return import_meta(allow_calls);
    }
    var start3 = S.token;
    var peeked;
    var async3 = is("name", "async") && (peeked = peek2()).value != "[" && peeked.type != "arrow" && as_atom_node();
    if (is("punc")) {
      switch (S.token.value) {
        case "(":
          if (async3 && !allow_calls) break;
          var exprs = params_or_seq_(allow_arrows, !async3);
          if (allow_arrows && is("arrow", "=>")) {
            return arrow_function(start3, exprs.map((e) => to_fun_args(e)), !!async3);
          }
          var ex = async3 ? new AST_Call({
            expression: async3,
            args: exprs
          }) : to_expr_or_sequence(start3, exprs);
          if (ex.start) {
            const outer_comments_before = start3.comments_before.length;
            outer_comments_before_counts.set(start3, outer_comments_before);
            ex.start.comments_before.unshift(...start3.comments_before);
            start3.comments_before = ex.start.comments_before;
            if (outer_comments_before == 0 && start3.comments_before.length > 0) {
              var comment = start3.comments_before[0];
              if (!comment.nlb) {
                comment.nlb = start3.nlb;
                start3.nlb = false;
              }
            }
            start3.comments_after = ex.start.comments_after;
          }
          ex.start = start3;
          var end6 = prev();
          if (ex.end) {
            end6.comments_before = ex.end.comments_before;
            ex.end.comments_after.push(...end6.comments_after);
            end6.comments_after = ex.end.comments_after;
          }
          ex.end = end6;
          if (ex instanceof AST_Call) annotate(ex);
          return subscripts(ex, allow_calls);
        case "[":
          return subscripts(array_(), allow_calls);
        case "{":
          return subscripts(object_or_destructuring_(), allow_calls);
      }
      if (!async3) unexpected();
    }
    if (allow_arrows && is("name") && is_token(peek2(), "arrow")) {
      var param = new AST_SymbolFunarg({
        name: S.token.value,
        start: start3,
        end: start3
      });
      next();
      return arrow_function(start3, [param], !!async3);
    }
    if (is("keyword", "function")) {
      next();
      var func = function_(AST_Function, false, !!async3);
      func.start = start3;
      func.end = prev();
      return subscripts(func, allow_calls);
    }
    if (async3) return subscripts(async3, allow_calls);
    if (is("keyword", "class")) {
      next();
      var cls = class_(AST_ClassExpression);
      cls.start = start3;
      cls.end = prev();
      return subscripts(cls, allow_calls);
    }
    if (is("template_head")) {
      return subscripts(template_string(), allow_calls);
    }
    if (ATOMIC_START_TOKEN.has(S.token.type)) {
      return subscripts(as_atom_node(), allow_calls);
    }
    unexpected();
  };
  function template_string() {
    var segments = [], start3 = S.token;
    segments.push(new AST_TemplateSegment({
      start: S.token,
      raw: TEMPLATE_RAWS.get(S.token),
      value: S.token.value,
      end: S.token
    }));
    while (!S.token.template_end) {
      next();
      handle_regexp();
      segments.push(expression(true));
      segments.push(new AST_TemplateSegment({
        start: S.token,
        raw: TEMPLATE_RAWS.get(S.token),
        value: S.token.value,
        end: S.token
      }));
    }
    next();
    return new AST_TemplateString({
      start: start3,
      segments,
      end: S.token
    });
  }
  function expr_list(closing, allow_trailing_comma, allow_empty) {
    var first3 = true, a2 = [];
    while (!is("punc", closing)) {
      if (first3) first3 = false;
      else expect(",");
      if (allow_trailing_comma && is("punc", closing)) break;
      if (is("punc", ",") && allow_empty) {
        a2.push(new AST_Hole({ start: S.token, end: S.token }));
      } else if (is("expand", "...")) {
        next();
        a2.push(new AST_Expansion({ start: prev(), expression: expression(), end: S.token }));
      } else {
        a2.push(expression(false));
      }
    }
    next();
    return a2;
  }
  var array_ = embed_tokens(function() {
    expect("[");
    return new AST_Array({
      elements: expr_list("]", !options.strict, true)
    });
  });
  var create_accessor = embed_tokens((is_generator, is_async) => {
    return function_(AST_Accessor, is_generator, is_async);
  });
  var object_or_destructuring_ = embed_tokens(function object_or_destructuring_2() {
    var start3 = S.token, first3 = true, a2 = [];
    expect("{");
    while (!is("punc", "}")) {
      if (first3) first3 = false;
      else expect(",");
      if (!options.strict && is("punc", "}"))
        break;
      start3 = S.token;
      if (start3.type == "expand") {
        next();
        a2.push(new AST_Expansion({
          start: start3,
          expression: expression(false),
          end: prev()
        }));
        continue;
      }
      if (is("privatename")) {
        croak("private fields are not allowed in an object");
      }
      var name = as_property_name();
      var value;
      if (!is("punc", ":")) {
        var concise = concise_method_or_getset(name, start3);
        if (concise) {
          a2.push(concise);
          continue;
        }
        value = new AST_SymbolRef({
          start: prev(),
          name,
          end: prev()
        });
      } else if (name === null) {
        unexpected(prev());
      } else {
        next();
        value = expression(false);
      }
      if (is("operator", "=")) {
        next();
        value = new AST_Assign({
          start: start3,
          left: value,
          operator: "=",
          right: expression(false),
          logical: false,
          end: prev()
        });
      }
      const kv = new AST_ObjectKeyVal({
        start: start3,
        quote: start3.quote,
        key: name instanceof AST_Node ? name : "" + name,
        value,
        end: prev()
      });
      a2.push(annotate(kv));
    }
    next();
    return new AST_Object({ properties: a2 });
  });
  function class_(KindOfClass, is_export_default) {
    var start3, method, class_name, extends_, a2 = [];
    S.input.push_directives_stack();
    S.input.add_directive("use strict");
    if (S.token.type == "name" && S.token.value != "extends") {
      class_name = as_symbol(KindOfClass === AST_DefClass ? AST_SymbolDefClass : AST_SymbolClass);
    }
    if (KindOfClass === AST_DefClass && !class_name) {
      if (is_export_default) {
        KindOfClass = AST_ClassExpression;
      } else {
        unexpected();
      }
    }
    if (S.token.value == "extends") {
      next();
      extends_ = expression(true);
    }
    expect("{");
    const save_in_class = S.in_class;
    S.in_class = true;
    while (is("punc", ";")) {
      next();
    }
    while (!is("punc", "}")) {
      start3 = S.token;
      method = concise_method_or_getset(as_property_name(), start3, true);
      if (!method) {
        unexpected();
      }
      a2.push(method);
      while (is("punc", ";")) {
        next();
      }
    }
    S.in_class = save_in_class;
    S.input.pop_directives_stack();
    next();
    return new KindOfClass({
      start: start3,
      name: class_name,
      extends: extends_,
      properties: a2,
      end: prev()
    });
  }
  function concise_method_or_getset(name, start3, is_class) {
    const get_symbol_ast = (name2, SymbolClass = AST_SymbolMethod) => {
      if (typeof name2 === "string" || typeof name2 === "number") {
        return new SymbolClass({
          start: start3,
          name: "" + name2,
          end: prev()
        });
      } else if (name2 === null) {
        unexpected();
      }
      return name2;
    };
    const is_not_method_start = () => !is("punc", "(") && !is("punc", ",") && !is("punc", "}") && !is("punc", ";") && !is("operator", "=");
    var is_async = false;
    var is_static = false;
    var is_generator = false;
    var is_private = false;
    var accessor_type = null;
    if (is_class && name === "static" && is_not_method_start()) {
      const static_block = class_static_block();
      if (static_block != null) {
        return static_block;
      }
      is_static = true;
      name = as_property_name();
    }
    if (name === "async" && is_not_method_start()) {
      is_async = true;
      name = as_property_name();
    }
    if (prev().type === "operator" && prev().value === "*") {
      is_generator = true;
      name = as_property_name();
    }
    if ((name === "get" || name === "set") && is_not_method_start()) {
      accessor_type = name;
      name = as_property_name();
    }
    if (prev().type === "privatename") {
      is_private = true;
    }
    const property_token = prev();
    if (accessor_type != null) {
      if (!is_private) {
        const AccessorClass = accessor_type === "get" ? AST_ObjectGetter : AST_ObjectSetter;
        name = get_symbol_ast(name);
        return annotate(new AccessorClass({
          start: start3,
          static: is_static,
          key: name,
          quote: name instanceof AST_SymbolMethod ? property_token.quote : void 0,
          value: create_accessor(),
          end: prev()
        }));
      } else {
        const AccessorClass = accessor_type === "get" ? AST_PrivateGetter : AST_PrivateSetter;
        return annotate(new AccessorClass({
          start: start3,
          static: is_static,
          key: get_symbol_ast(name),
          value: create_accessor(),
          end: prev()
        }));
      }
    }
    if (is("punc", "(")) {
      name = get_symbol_ast(name);
      const AST_MethodVariant = is_private ? AST_PrivateMethod : AST_ConciseMethod;
      var node = new AST_MethodVariant({
        start: start3,
        static: is_static,
        is_generator,
        async: is_async,
        key: name,
        quote: name instanceof AST_SymbolMethod ? property_token.quote : void 0,
        value: create_accessor(is_generator, is_async),
        end: prev()
      });
      return annotate(node);
    }
    if (is_class) {
      const key = get_symbol_ast(name, AST_SymbolClassProperty);
      const quote = key instanceof AST_SymbolClassProperty ? property_token.quote : void 0;
      const AST_ClassPropertyVariant = is_private ? AST_ClassPrivateProperty : AST_ClassProperty;
      if (is("operator", "=")) {
        next();
        return annotate(
          new AST_ClassPropertyVariant({
            start: start3,
            static: is_static,
            quote,
            key,
            value: expression(false),
            end: prev()
          })
        );
      } else if (is("name") || is("privatename") || is("punc", "[") || is("operator", "*") || is("punc", ";") || is("punc", "}")) {
        return annotate(
          new AST_ClassPropertyVariant({
            start: start3,
            static: is_static,
            quote,
            key,
            end: prev()
          })
        );
      }
    }
  }
  function class_static_block() {
    if (!is("punc", "{")) {
      return null;
    }
    const start3 = S.token;
    const body = [];
    next();
    while (!is("punc", "}")) {
      body.push(statement());
    }
    next();
    return new AST_ClassStaticBlock({ start: start3, body, end: prev() });
  }
  function maybe_import_attributes() {
    if ((is("keyword", "with") || is("name", "assert")) && !has_newline_before(S.token)) {
      next();
      return object_or_destructuring_();
    }
    return null;
  }
  function import_statement() {
    var start3 = prev();
    var imported_name;
    var imported_names;
    if (is("name")) {
      imported_name = as_symbol(AST_SymbolImport);
    }
    if (is("punc", ",")) {
      next();
    }
    imported_names = map_names(true);
    if (imported_names || imported_name) {
      expect_token("name", "from");
    }
    var mod_str = S.token;
    if (mod_str.type !== "string") {
      unexpected();
    }
    next();
    const attributes = maybe_import_attributes();
    return new AST_Import({
      start: start3,
      imported_name,
      imported_names,
      module_name: new AST_String({
        start: mod_str,
        value: mod_str.value,
        quote: mod_str.quote,
        end: mod_str
      }),
      attributes,
      end: S.token
    });
  }
  function import_meta(allow_calls) {
    var start3 = S.token;
    expect_token("name", "import");
    expect_token("punc", ".");
    expect_token("name", "meta");
    return subscripts(new AST_ImportMeta({
      start: start3,
      end: prev()
    }), allow_calls);
  }
  function map_name(is_import) {
    function make_symbol(type2, quote) {
      return new type2({
        name: as_property_name(),
        quote: quote || void 0,
        start: prev(),
        end: prev()
      });
    }
    var foreign_type = is_import ? AST_SymbolImportForeign : AST_SymbolExportForeign;
    var type = is_import ? AST_SymbolImport : AST_SymbolExport;
    var start3 = S.token;
    var foreign_name;
    var name;
    if (is_import) {
      foreign_name = make_symbol(foreign_type, start3.quote);
    } else {
      name = make_symbol(type, start3.quote);
    }
    if (is("name", "as")) {
      next();
      if (is_import) {
        name = make_symbol(type);
      } else {
        foreign_name = make_symbol(foreign_type, S.token.quote);
      }
    } else if (is_import) {
      name = new type(foreign_name);
    } else {
      foreign_name = new foreign_type(name);
    }
    return new AST_NameMapping({
      start: start3,
      foreign_name,
      name,
      end: prev()
    });
  }
  function map_nameAsterisk(is_import, import_or_export_foreign_name) {
    var foreign_type = is_import ? AST_SymbolImportForeign : AST_SymbolExportForeign;
    var type = is_import ? AST_SymbolImport : AST_SymbolExport;
    var start3 = S.token;
    var name, foreign_name;
    var end6 = prev();
    if (is_import) {
      name = import_or_export_foreign_name;
    } else {
      foreign_name = import_or_export_foreign_name;
    }
    name = name || new type({
      start: start3,
      name: "*",
      end: end6
    });
    foreign_name = foreign_name || new foreign_type({
      start: start3,
      name: "*",
      end: end6
    });
    return new AST_NameMapping({
      start: start3,
      foreign_name,
      name,
      end: end6
    });
  }
  function map_names(is_import) {
    var names;
    if (is("punc", "{")) {
      next();
      names = [];
      while (!is("punc", "}")) {
        names.push(map_name(is_import));
        if (is("punc", ",")) {
          next();
        }
      }
      next();
    } else if (is("operator", "*")) {
      var name;
      next();
      if (is("name", "as")) {
        next();
        name = is_import ? as_symbol(AST_SymbolImport) : as_symbol_or_string(AST_SymbolExportForeign);
      }
      names = [map_nameAsterisk(is_import, name)];
    }
    return names;
  }
  function export_statement() {
    var start3 = S.token;
    var is_default;
    var exported_names;
    if (is("keyword", "default")) {
      is_default = true;
      next();
    } else if (exported_names = map_names(false)) {
      if (is("name", "from")) {
        next();
        var mod_str = S.token;
        if (mod_str.type !== "string") {
          unexpected();
        }
        next();
        const attributes = maybe_import_attributes();
        return new AST_Export({
          start: start3,
          is_default,
          exported_names,
          module_name: new AST_String({
            start: mod_str,
            value: mod_str.value,
            quote: mod_str.quote,
            end: mod_str
          }),
          end: prev(),
          attributes
        });
      } else {
        return new AST_Export({
          start: start3,
          is_default,
          exported_names,
          end: prev()
        });
      }
    }
    var node;
    var exported_value;
    var exported_definition;
    if (is("punc", "{") || is_default && (is("keyword", "class") || is("keyword", "function")) && is_token(peek2(), "punc")) {
      exported_value = expression(false);
      semicolon3();
    } else if ((node = statement(is_default)) instanceof AST_Definitions && is_default) {
      unexpected(node.start);
    } else if (node instanceof AST_Definitions || node instanceof AST_Defun || node instanceof AST_DefClass) {
      exported_definition = node;
    } else if (node instanceof AST_ClassExpression || node instanceof AST_Function) {
      exported_value = node;
    } else if (node instanceof AST_SimpleStatement) {
      exported_value = node.body;
    } else {
      unexpected(node.start);
    }
    return new AST_Export({
      start: start3,
      is_default,
      exported_value,
      exported_definition,
      end: prev(),
      attributes: null
    });
  }
  function as_property_name() {
    var tmp = S.token;
    switch (tmp.type) {
      case "punc":
        if (tmp.value === "[") {
          next();
          var ex = expression(false);
          expect("]");
          return ex;
        } else unexpected(tmp);
      case "operator":
        if (tmp.value === "*") {
          next();
          return null;
        }
        if (!["delete", "in", "instanceof", "new", "typeof", "void"].includes(tmp.value)) {
          unexpected(tmp);
        }
      /* falls through */
      case "name":
      case "privatename":
      case "string":
      case "num":
      case "big_int":
      case "keyword":
      case "atom":
        next();
        return tmp.value;
      default:
        unexpected(tmp);
    }
  }
  function as_name() {
    var tmp = S.token;
    if (tmp.type != "name" && tmp.type != "privatename") unexpected();
    next();
    return tmp.value;
  }
  function _make_symbol(type) {
    var name = S.token.value;
    return new (name == "this" ? AST_This : name == "super" ? AST_Super : type)({
      name: String(name),
      start: S.token,
      end: S.token
    });
  }
  function _verify_symbol(sym) {
    var name = sym.name;
    if (is_in_generator() && name == "yield") {
      token_error(sym.start, "Yield cannot be used as identifier inside generators");
    }
    if (S.input.has_directive("use strict")) {
      if (name == "yield") {
        token_error(sym.start, "Unexpected yield identifier inside strict mode");
      }
      if (sym instanceof AST_SymbolDeclaration && (name == "arguments" || name == "eval")) {
        token_error(sym.start, "Unexpected " + name + " in strict mode");
      }
    }
  }
  function as_symbol(type, noerror) {
    if (!is("name")) {
      if (!noerror) croak("Name expected");
      return null;
    }
    var sym = _make_symbol(type);
    _verify_symbol(sym);
    next();
    return sym;
  }
  function as_symbol_or_string(type) {
    if (!is("name")) {
      if (!is("string")) {
        croak("Name or string expected");
      }
      var tok = S.token;
      var ret = new type({
        start: tok,
        end: tok,
        name: tok.value,
        quote: tok.quote
      });
      next();
      return ret;
    }
    var sym = _make_symbol(type);
    _verify_symbol(sym);
    next();
    return sym;
  }
  function annotate(node, before_token = node.start) {
    var comments = before_token.comments_before;
    const comments_outside_parens = outer_comments_before_counts.get(before_token);
    var i = comments_outside_parens != null ? comments_outside_parens : comments.length;
    while (--i >= 0) {
      var comment = comments[i];
      if (/[@#]__/.test(comment.value)) {
        if (/[@#]__PURE__/.test(comment.value)) {
          set_annotation(node, _PURE);
          break;
        }
        if (/[@#]__INLINE__/.test(comment.value)) {
          set_annotation(node, _INLINE);
          break;
        }
        if (/[@#]__NOINLINE__/.test(comment.value)) {
          set_annotation(node, _NOINLINE);
          break;
        }
        if (/[@#]__KEY__/.test(comment.value)) {
          set_annotation(node, _KEY);
          break;
        }
        if (/[@#]__MANGLE_PROP__/.test(comment.value)) {
          set_annotation(node, _MANGLEPROP);
          break;
        }
      }
    }
    return node;
  }
  var subscripts = function(expr, allow_calls, is_chain) {
    var start3 = expr.start;
    if (is("punc", ".")) {
      next();
      if (is("privatename") && !S.in_class)
        croak("Private field must be used in an enclosing class");
      const AST_DotVariant = is("privatename") ? AST_DotHash : AST_Dot;
      return annotate(subscripts(new AST_DotVariant({
        start: start3,
        expression: expr,
        optional: false,
        property: as_name(),
        end: prev()
      }), allow_calls, is_chain));
    }
    if (is("punc", "[")) {
      next();
      var prop = expression(true);
      expect("]");
      return annotate(subscripts(new AST_Sub({
        start: start3,
        expression: expr,
        optional: false,
        property: prop,
        end: prev()
      }), allow_calls, is_chain));
    }
    if (allow_calls && is("punc", "(")) {
      next();
      var call = new AST_Call({
        start: start3,
        expression: expr,
        optional: false,
        args: call_args(),
        end: prev()
      });
      annotate(call);
      return subscripts(call, true, is_chain);
    }
    if (is("punc", "?.")) {
      next();
      let chain_contents;
      if (allow_calls && is("punc", "(")) {
        next();
        const call2 = new AST_Call({
          start: start3,
          optional: true,
          expression: expr,
          args: call_args(),
          end: prev()
        });
        annotate(call2);
        chain_contents = subscripts(call2, true, true);
      } else if (is("name") || is("privatename")) {
        if (is("privatename") && !S.in_class)
          croak("Private field must be used in an enclosing class");
        const AST_DotVariant = is("privatename") ? AST_DotHash : AST_Dot;
        chain_contents = annotate(subscripts(new AST_DotVariant({
          start: start3,
          expression: expr,
          optional: true,
          property: as_name(),
          end: prev()
        }), allow_calls, true));
      } else if (is("punc", "[")) {
        next();
        const property3 = expression(true);
        expect("]");
        chain_contents = annotate(subscripts(new AST_Sub({
          start: start3,
          expression: expr,
          optional: true,
          property: property3,
          end: prev()
        }), allow_calls, true));
      }
      if (!chain_contents) unexpected();
      if (chain_contents instanceof AST_Chain) return chain_contents;
      return new AST_Chain({
        start: start3,
        expression: chain_contents,
        end: prev()
      });
    }
    if (is("template_head")) {
      if (is_chain) {
        unexpected();
      }
      return subscripts(new AST_PrefixedTemplateString({
        start: start3,
        prefix: expr,
        template_string: template_string(),
        end: prev()
      }), allow_calls);
    }
    return expr;
  };
  function call_args() {
    var args2 = [];
    while (!is("punc", ")")) {
      if (is("expand", "...")) {
        next();
        args2.push(new AST_Expansion({
          start: prev(),
          expression: expression(false),
          end: prev()
        }));
      } else {
        args2.push(expression(false));
      }
      if (!is("punc", ")")) {
        expect(",");
      }
    }
    next();
    return args2;
  }
  var maybe_unary = function(allow_calls, allow_arrows) {
    var start3 = S.token;
    if (start3.type == "name" && start3.value == "await" && can_await()) {
      next();
      return _await_expression();
    }
    if (is("operator") && UNARY_PREFIX.has(start3.value)) {
      next();
      handle_regexp();
      var ex = make_unary(AST_UnaryPrefix, start3, maybe_unary(allow_calls));
      ex.start = start3;
      ex.end = prev();
      return ex;
    }
    var val = expr_atom(allow_calls, allow_arrows);
    while (is("operator") && UNARY_POSTFIX.has(S.token.value) && !has_newline_before(S.token)) {
      if (val instanceof AST_Arrow) unexpected();
      val = make_unary(AST_UnaryPostfix, S.token, val);
      val.start = start3;
      val.end = S.token;
      next();
    }
    return val;
  };
  function make_unary(ctor, token, expr) {
    var op = token.value;
    switch (op) {
      case "++":
      case "--":
        if (!is_assignable(expr))
          croak("Invalid use of " + op + " operator", token.line, token.col, token.pos);
        break;
      case "delete":
        if (expr instanceof AST_SymbolRef && S.input.has_directive("use strict"))
          croak("Calling delete on expression not allowed in strict mode", expr.start.line, expr.start.col, expr.start.pos);
        break;
    }
    return new ctor({ operator: op, expression: expr });
  }
  var expr_op = function(left3, min_prec, no_in) {
    var op = is("operator") ? S.token.value : null;
    if (op == "in" && no_in) op = null;
    if (op == "**" && left3 instanceof AST_UnaryPrefix && !is_token(left3.start, "punc", "(") && left3.operator !== "--" && left3.operator !== "++")
      unexpected(left3.start);
    var prec = op != null ? PRECEDENCE[op] : null;
    if (prec != null && (prec > min_prec || op === "**" && min_prec === prec)) {
      next();
      var right3 = expr_ops(no_in, prec, true);
      return expr_op(new AST_Binary({
        start: left3.start,
        left: left3,
        operator: op,
        right: right3,
        end: right3.end
      }), min_prec, no_in);
    }
    return left3;
  };
  function expr_ops(no_in, min_prec, allow_calls, allow_arrows) {
    if (!no_in && min_prec < PRECEDENCE["in"] && is("privatename")) {
      if (!S.in_class) {
        croak("Private field must be used in an enclosing class");
      }
      const start3 = S.token;
      const key = new AST_SymbolPrivateProperty({
        start: start3,
        name: start3.value,
        end: start3
      });
      next();
      expect_token("operator", "in");
      const private_in = new AST_PrivateIn({
        start: start3,
        key,
        value: expr_ops(no_in, PRECEDENCE["in"], true),
        end: prev()
      });
      return expr_op(private_in, 0, no_in);
    } else {
      return expr_op(maybe_unary(allow_calls, allow_arrows), min_prec, no_in);
    }
  }
  var maybe_conditional = function(no_in) {
    var start3 = S.token;
    var expr = expr_ops(no_in, 0, true, true);
    if (is("operator", "?")) {
      next();
      var yes = expression(false);
      expect(":");
      return new AST_Conditional({
        start: start3,
        condition: expr,
        consequent: yes,
        alternative: expression(false, no_in),
        end: prev()
      });
    }
    return expr;
  };
  function is_assignable(expr) {
    return expr instanceof AST_PropAccess || expr instanceof AST_SymbolRef;
  }
  function to_destructuring(node) {
    if (node instanceof AST_Object) {
      node = new AST_Destructuring({
        start: node.start,
        names: node.properties.map(to_destructuring),
        is_array: false,
        end: node.end
      });
    } else if (node instanceof AST_Array) {
      var names = [];
      for (var i = 0; i < node.elements.length; i++) {
        if (node.elements[i] instanceof AST_Expansion) {
          if (i + 1 !== node.elements.length) {
            token_error(node.elements[i].start, "Spread must the be last element in destructuring array");
          }
          node.elements[i].expression = to_destructuring(node.elements[i].expression);
        }
        names.push(to_destructuring(node.elements[i]));
      }
      node = new AST_Destructuring({
        start: node.start,
        names,
        is_array: true,
        end: node.end
      });
    } else if (node instanceof AST_ObjectProperty) {
      node.value = to_destructuring(node.value);
    } else if (node instanceof AST_Assign) {
      node = new AST_DefaultAssign({
        start: node.start,
        left: node.left,
        operator: "=",
        right: node.right,
        end: node.end
      });
    }
    return node;
  }
  var maybe_assign = function(no_in) {
    handle_regexp();
    var start3 = S.token;
    if (start3.type == "name" && start3.value == "yield") {
      if (is_in_generator()) {
        next();
        return _yield_expression();
      } else if (S.input.has_directive("use strict")) {
        token_error(S.token, "Unexpected yield identifier inside strict mode");
      }
    }
    var left3 = maybe_conditional(no_in);
    var val = S.token.value;
    if (is("operator") && ASSIGNMENT.has(val)) {
      if (is_assignable(left3) || (left3 = to_destructuring(left3)) instanceof AST_Destructuring) {
        next();
        return new AST_Assign({
          start: start3,
          left: left3,
          operator: val,
          right: maybe_assign(no_in),
          logical: LOGICAL_ASSIGNMENT.has(val),
          end: prev()
        });
      }
      croak("Invalid assignment");
    }
    return left3;
  };
  var to_expr_or_sequence = function(start3, exprs) {
    if (exprs.length === 1) {
      return exprs[0];
    } else if (exprs.length > 1) {
      return new AST_Sequence({ start: start3, expressions: exprs, end: peek2() });
    } else {
      croak("Invalid parenthesized expression");
    }
  };
  var expression = function(commas, no_in) {
    var start3 = S.token;
    var exprs = [];
    while (true) {
      exprs.push(maybe_assign(no_in));
      if (!commas || !is("punc", ",")) break;
      next();
      commas = true;
    }
    return to_expr_or_sequence(start3, exprs);
  };
  function in_loop(cont) {
    ++S.in_loop;
    var ret = cont();
    --S.in_loop;
    return ret;
  }
  if (options.expression) {
    return expression(true);
  }
  return function parse_toplevel() {
    var start3 = S.token;
    var body = [];
    S.input.push_directives_stack();
    if (options.module) S.input.add_directive("use strict");
    while (!is("eof")) {
      body.push(statement());
    }
    S.input.pop_directives_stack();
    var end6 = prev();
    var toplevel = options.toplevel;
    if (toplevel) {
      toplevel.body = toplevel.body.concat(body);
      toplevel.end = end6;
    } else {
      toplevel = new AST_Toplevel({ start: start3, body, end: end6 });
    }
    TEMPLATE_RAWS = /* @__PURE__ */ new Map();
    return toplevel;
  }();
}

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/ast.js
function DEFNODE(type, props, ctor, methods, base2 = AST_Node) {
  if (!props) props = [];
  else props = props.split(/\s+/);
  var self_props = props;
  if (base2 && base2.PROPS)
    props = props.concat(base2.PROPS);
  const proto14 = base2 && Object.create(base2.prototype);
  if (proto14) {
    ctor.prototype = proto14;
    ctor.BASE = base2;
  }
  if (base2) base2.SUBCLASSES.push(ctor);
  ctor.prototype.CTOR = ctor;
  ctor.prototype.constructor = ctor;
  ctor.PROPS = props || null;
  ctor.SELF_PROPS = self_props;
  ctor.SUBCLASSES = [];
  if (type) {
    ctor.prototype.TYPE = ctor.TYPE = type;
  }
  if (methods) {
    for (let i in methods) if (HOP(methods, i)) {
      if (i[0] === "$") {
        ctor[i.substr(1)] = methods[i];
      } else {
        ctor.prototype[i] = methods[i];
      }
    }
  }
  ctor.DEFMETHOD = function(name, method) {
    this.prototype[name] = method;
  };
  return ctor;
}
var has_tok_flag = (tok, flag) => Boolean(tok.flags & flag);
var set_tok_flag = (tok, flag, truth) => {
  if (truth) {
    tok.flags |= flag;
  } else {
    tok.flags &= ~flag;
  }
};
var TOK_FLAG_NLB = 1;
var TOK_FLAG_QUOTE_SINGLE = 2;
var TOK_FLAG_QUOTE_EXISTS = 4;
var TOK_FLAG_TEMPLATE_END = 8;
var AST_Token = class {
  constructor(type, value, line, col, pos, nlb, comments_before, comments_after, file) {
    this.flags = nlb ? 1 : 0;
    this.type = type;
    this.value = value;
    this.line = line;
    this.col = col;
    this.pos = pos;
    this.comments_before = comments_before;
    this.comments_after = comments_after;
    this.file = file;
    Object.seal(this);
  }
  // Return a string summary of the token for node.js console.log
  [Symbol.for("nodejs.util.inspect.custom")](_depth, options) {
    const special = (str) => options.stylize(str, "special");
    const quote = typeof this.value === "string" && this.value.includes("`") ? "'" : "`";
    const value = `${quote}${this.value}${quote}`;
    return `${special("[AST_Token")} ${value} at ${this.line}:${this.col}${special("]")}`;
  }
  get nlb() {
    return has_tok_flag(this, TOK_FLAG_NLB);
  }
  set nlb(new_nlb) {
    set_tok_flag(this, TOK_FLAG_NLB, new_nlb);
  }
  get quote() {
    return !has_tok_flag(this, TOK_FLAG_QUOTE_EXISTS) ? "" : has_tok_flag(this, TOK_FLAG_QUOTE_SINGLE) ? "'" : '"';
  }
  set quote(quote_type) {
    set_tok_flag(this, TOK_FLAG_QUOTE_SINGLE, quote_type === "'");
    set_tok_flag(this, TOK_FLAG_QUOTE_EXISTS, !!quote_type);
  }
  get template_end() {
    return has_tok_flag(this, TOK_FLAG_TEMPLATE_END);
  }
  set template_end(new_template_end) {
    set_tok_flag(this, TOK_FLAG_TEMPLATE_END, new_template_end);
  }
};
var AST_Node = DEFNODE("Node", "start end", function AST_Node2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  _clone: function(deep) {
    if (deep) {
      var self2 = this.clone();
      return self2.transform(new TreeTransformer(function(node) {
        if (node !== self2) {
          return node.clone(true);
        }
      }));
    }
    return new this.CTOR(this);
  },
  clone: function(deep) {
    return this._clone(deep);
  },
  $documentation: "Base class of all AST nodes",
  $propdoc: {
    start: "[AST_Token] The first token of this node",
    end: "[AST_Token] The last token of this node"
  },
  _walk: function(visitor) {
    return visitor._visit(this);
  },
  walk: function(visitor) {
    return this._walk(visitor);
  },
  _children_backwards: () => {
  }
}, null);
var AST_Statement = DEFNODE("Statement", null, function AST_Statement2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Base class of all statements"
});
var AST_Debugger = DEFNODE("Debugger", null, function AST_Debugger2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Represents a debugger statement"
}, AST_Statement);
var AST_Directive = DEFNODE("Directive", "value quote", function AST_Directive2(props) {
  if (props) {
    this.value = props.value;
    this.quote = props.quote;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: 'Represents a directive, like "use strict";',
  $propdoc: {
    value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
    quote: "[string] the original quote character"
  }
}, AST_Statement);
var AST_SimpleStatement = DEFNODE("SimpleStatement", "body", function AST_SimpleStatement2(props) {
  if (props) {
    this.body = props.body;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
  $propdoc: {
    body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.body._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.body);
  }
}, AST_Statement);
function walk_body(node, visitor) {
  const body = node.body;
  for (var i = 0, len = body.length; i < len; i++) {
    body[i]._walk(visitor);
  }
}
function clone_block_scope(deep) {
  var clone4 = this._clone(deep);
  if (this.block_scope) {
    clone4.block_scope = this.block_scope.clone();
  }
  return clone4;
}
var AST_Block = DEFNODE("Block", "body block_scope", function AST_Block2(props) {
  if (props) {
    this.body = props.body;
    this.block_scope = props.block_scope;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A body of statements (usually braced)",
  $propdoc: {
    body: "[AST_Statement*] an array of statements",
    block_scope: "[AST_Scope] the block scope"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      walk_body(this, visitor);
    });
  },
  _children_backwards(push2) {
    let i = this.body.length;
    while (i--) push2(this.body[i]);
  },
  clone: clone_block_scope
}, AST_Statement);
var AST_BlockStatement = DEFNODE("BlockStatement", null, function AST_BlockStatement2(props) {
  if (props) {
    this.body = props.body;
    this.block_scope = props.block_scope;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A block statement"
}, AST_Block);
var AST_EmptyStatement = DEFNODE("EmptyStatement", null, function AST_EmptyStatement2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "The empty statement (empty block or simply a semicolon)"
}, AST_Statement);
var AST_StatementWithBody = DEFNODE("StatementWithBody", "body", function AST_StatementWithBody2(props) {
  if (props) {
    this.body = props.body;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
  $propdoc: {
    body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
  }
}, AST_Statement);
var AST_LabeledStatement = DEFNODE("LabeledStatement", "label", function AST_LabeledStatement2(props) {
  if (props) {
    this.label = props.label;
    this.body = props.body;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Statement with a label",
  $propdoc: {
    label: "[AST_Label] a label definition"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.label._walk(visitor);
      this.body._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.body);
    push2(this.label);
  },
  clone: function(deep) {
    var node = this._clone(deep);
    if (deep) {
      var label = node.label;
      var def = this.label;
      node.walk(new TreeWalker(function(node2) {
        if (node2 instanceof AST_LoopControl && node2.label && node2.label.thedef === def) {
          node2.label.thedef = label;
          label.references.push(node2);
        }
      }));
    }
    return node;
  }
}, AST_StatementWithBody);
var AST_IterationStatement = DEFNODE(
  "IterationStatement",
  "block_scope",
  function AST_IterationStatement2(props) {
    if (props) {
      this.block_scope = props.block_scope;
      this.body = props.body;
      this.start = props.start;
      this.end = props.end;
    }
    this.flags = 0;
  },
  {
    $documentation: "Internal class.  All loops inherit from it.",
    $propdoc: {
      block_scope: "[AST_Scope] the block scope for this iteration statement."
    },
    clone: clone_block_scope
  },
  AST_StatementWithBody
);
var AST_DWLoop = DEFNODE("DWLoop", "condition", function AST_DWLoop2(props) {
  if (props) {
    this.condition = props.condition;
    this.block_scope = props.block_scope;
    this.body = props.body;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Base class for do/while statements",
  $propdoc: {
    condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
  }
}, AST_IterationStatement);
var AST_Do = DEFNODE("Do", null, function AST_Do2(props) {
  if (props) {
    this.condition = props.condition;
    this.block_scope = props.block_scope;
    this.body = props.body;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `do` statement",
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.body._walk(visitor);
      this.condition._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.condition);
    push2(this.body);
  }
}, AST_DWLoop);
var AST_While = DEFNODE("While", null, function AST_While2(props) {
  if (props) {
    this.condition = props.condition;
    this.block_scope = props.block_scope;
    this.body = props.body;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `while` statement",
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.condition._walk(visitor);
      this.body._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.body);
    push2(this.condition);
  }
}, AST_DWLoop);
var AST_For = DEFNODE("For", "init condition step", function AST_For2(props) {
  if (props) {
    this.init = props.init;
    this.condition = props.condition;
    this.step = props.step;
    this.block_scope = props.block_scope;
    this.body = props.body;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `for` statement",
  $propdoc: {
    init: "[AST_Node?] the `for` initialization code, or null if empty",
    condition: "[AST_Node?] the `for` termination clause, or null if empty",
    step: "[AST_Node?] the `for` update clause, or null if empty"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      if (this.init) this.init._walk(visitor);
      if (this.condition) this.condition._walk(visitor);
      if (this.step) this.step._walk(visitor);
      this.body._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.body);
    if (this.step) push2(this.step);
    if (this.condition) push2(this.condition);
    if (this.init) push2(this.init);
  }
}, AST_IterationStatement);
var AST_ForIn = DEFNODE("ForIn", "init object", function AST_ForIn2(props) {
  if (props) {
    this.init = props.init;
    this.object = props.object;
    this.block_scope = props.block_scope;
    this.body = props.body;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `for ... in` statement",
  $propdoc: {
    init: "[AST_Node] the `for/in` initialization code",
    object: "[AST_Node] the object that we're looping through"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.init._walk(visitor);
      this.object._walk(visitor);
      this.body._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.body);
    if (this.object) push2(this.object);
    if (this.init) push2(this.init);
  }
}, AST_IterationStatement);
var AST_ForOf = DEFNODE("ForOf", "await", function AST_ForOf2(props) {
  if (props) {
    this.await = props.await;
    this.init = props.init;
    this.object = props.object;
    this.block_scope = props.block_scope;
    this.body = props.body;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `for ... of` statement"
}, AST_ForIn);
var AST_With = DEFNODE("With", "expression", function AST_With2(props) {
  if (props) {
    this.expression = props.expression;
    this.body = props.body;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `with` statement",
  $propdoc: {
    expression: "[AST_Node] the `with` expression"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.expression._walk(visitor);
      this.body._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.body);
    push2(this.expression);
  }
}, AST_StatementWithBody);
var AST_Scope = DEFNODE(
  "Scope",
  "variables uses_with uses_eval parent_scope enclosed cname",
  function AST_Scope2(props) {
    if (props) {
      this.variables = props.variables;
      this.uses_with = props.uses_with;
      this.uses_eval = props.uses_eval;
      this.parent_scope = props.parent_scope;
      this.enclosed = props.enclosed;
      this.cname = props.cname;
      this.body = props.body;
      this.block_scope = props.block_scope;
      this.start = props.start;
      this.end = props.end;
    }
    this.flags = 0;
  },
  {
    $documentation: "Base class for all statements introducing a lexical scope",
    $propdoc: {
      variables: "[Map/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
      uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
      uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
      parent_scope: "[AST_Scope?/S] link to the parent scope",
      enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
      cname: "[integer/S] current index for mangling variables (used internally by the mangler)"
    },
    get_defun_scope: function() {
      var self2 = this;
      while (self2.is_block_scope()) {
        self2 = self2.parent_scope;
      }
      return self2;
    },
    clone: function(deep, toplevel) {
      var node = this._clone(deep);
      if (deep && this.variables && toplevel && !this._block_scope) {
        node.figure_out_scope({}, {
          toplevel,
          parent_scope: this.parent_scope
        });
      } else {
        if (this.variables) node.variables = new Map(this.variables);
        if (this.enclosed) node.enclosed = this.enclosed.slice();
        if (this._block_scope) node._block_scope = this._block_scope;
      }
      return node;
    },
    pinned: function() {
      return this.uses_eval || this.uses_with;
    }
  },
  AST_Block
);
var AST_Toplevel = DEFNODE("Toplevel", "globals", function AST_Toplevel2(props) {
  if (props) {
    this.globals = props.globals;
    this.variables = props.variables;
    this.uses_with = props.uses_with;
    this.uses_eval = props.uses_eval;
    this.parent_scope = props.parent_scope;
    this.enclosed = props.enclosed;
    this.cname = props.cname;
    this.body = props.body;
    this.block_scope = props.block_scope;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "The toplevel scope",
  $propdoc: {
    globals: "[Map/S] a map of name -> SymbolDef for all undeclared names"
  },
  wrap_commonjs: function(name) {
    var body = this.body;
    var wrapped_tl = "(function(exports){'$ORIG';})(typeof " + name + "=='undefined'?(" + name + "={}):" + name + ");";
    wrapped_tl = parse(wrapped_tl);
    wrapped_tl = wrapped_tl.transform(new TreeTransformer(function(node) {
      if (node instanceof AST_Directive && node.value == "$ORIG") {
        return MAP.splice(body);
      }
    }));
    return wrapped_tl;
  },
  wrap_enclose: function(args_values) {
    if (typeof args_values != "string") args_values = "";
    var index = args_values.indexOf(":");
    if (index < 0) index = args_values.length;
    var body = this.body;
    return parse([
      "(function(",
      args_values.slice(0, index),
      '){"$ORIG"})(',
      args_values.slice(index + 1),
      ")"
    ].join("")).transform(new TreeTransformer(function(node) {
      if (node instanceof AST_Directive && node.value == "$ORIG") {
        return MAP.splice(body);
      }
    }));
  }
}, AST_Scope);
var AST_Expansion = DEFNODE("Expansion", "expression", function AST_Expansion2(props) {
  if (props) {
    this.expression = props.expression;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "An expandible argument, such as ...rest, a splat, such as [1,2,...all], or an expansion in a variable declaration, such as var [first, ...rest] = list",
  $propdoc: {
    expression: "[AST_Node] the thing to be expanded"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.expression.walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.expression);
  }
});
var AST_Lambda = DEFNODE(
  "Lambda",
  "name argnames uses_arguments is_generator async",
  function AST_Lambda2(props) {
    if (props) {
      this.name = props.name;
      this.argnames = props.argnames;
      this.uses_arguments = props.uses_arguments;
      this.is_generator = props.is_generator;
      this.async = props.async;
      this.variables = props.variables;
      this.uses_with = props.uses_with;
      this.uses_eval = props.uses_eval;
      this.parent_scope = props.parent_scope;
      this.enclosed = props.enclosed;
      this.cname = props.cname;
      this.body = props.body;
      this.block_scope = props.block_scope;
      this.start = props.start;
      this.end = props.end;
    }
    this.flags = 0;
  },
  {
    $documentation: "Base class for functions",
    $propdoc: {
      name: "[AST_SymbolDeclaration?] the name of this function",
      argnames: "[AST_SymbolFunarg|AST_Destructuring|AST_Expansion|AST_DefaultAssign*] array of function arguments, destructurings, or expanding arguments",
      uses_arguments: "[boolean/S] tells whether this function accesses the arguments array",
      is_generator: "[boolean] is this a generator method",
      async: "[boolean] is this method async"
    },
    args_as_names: function() {
      var out = [];
      for (var i = 0; i < this.argnames.length; i++) {
        if (this.argnames[i] instanceof AST_Destructuring) {
          out.push(...this.argnames[i].all_symbols());
        } else {
          out.push(this.argnames[i]);
        }
      }
      return out;
    },
    _walk: function(visitor) {
      return visitor._visit(this, function() {
        if (this.name) this.name._walk(visitor);
        var argnames = this.argnames;
        for (var i = 0, len = argnames.length; i < len; i++) {
          argnames[i]._walk(visitor);
        }
        walk_body(this, visitor);
      });
    },
    _children_backwards(push2) {
      let i = this.body.length;
      while (i--) push2(this.body[i]);
      i = this.argnames.length;
      while (i--) push2(this.argnames[i]);
      if (this.name) push2(this.name);
    },
    is_braceless() {
      return this.body[0] instanceof AST_Return && this.body[0].value;
    },
    // Default args and expansion don't count, so .argnames.length doesn't cut it
    length_property() {
      let length3 = 0;
      for (const arg of this.argnames) {
        if (arg instanceof AST_SymbolFunarg || arg instanceof AST_Destructuring) {
          length3++;
        }
      }
      return length3;
    }
  },
  AST_Scope
);
var AST_Accessor = DEFNODE("Accessor", null, function AST_Accessor2(props) {
  if (props) {
    this.name = props.name;
    this.argnames = props.argnames;
    this.uses_arguments = props.uses_arguments;
    this.is_generator = props.is_generator;
    this.async = props.async;
    this.variables = props.variables;
    this.uses_with = props.uses_with;
    this.uses_eval = props.uses_eval;
    this.parent_scope = props.parent_scope;
    this.enclosed = props.enclosed;
    this.cname = props.cname;
    this.body = props.body;
    this.block_scope = props.block_scope;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A setter/getter function.  The `name` property is always null."
}, AST_Lambda);
var AST_Function = DEFNODE("Function", null, function AST_Function2(props) {
  if (props) {
    this.name = props.name;
    this.argnames = props.argnames;
    this.uses_arguments = props.uses_arguments;
    this.is_generator = props.is_generator;
    this.async = props.async;
    this.variables = props.variables;
    this.uses_with = props.uses_with;
    this.uses_eval = props.uses_eval;
    this.parent_scope = props.parent_scope;
    this.enclosed = props.enclosed;
    this.cname = props.cname;
    this.body = props.body;
    this.block_scope = props.block_scope;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A function expression"
}, AST_Lambda);
var AST_Arrow = DEFNODE("Arrow", null, function AST_Arrow2(props) {
  if (props) {
    this.name = props.name;
    this.argnames = props.argnames;
    this.uses_arguments = props.uses_arguments;
    this.is_generator = props.is_generator;
    this.async = props.async;
    this.variables = props.variables;
    this.uses_with = props.uses_with;
    this.uses_eval = props.uses_eval;
    this.parent_scope = props.parent_scope;
    this.enclosed = props.enclosed;
    this.cname = props.cname;
    this.body = props.body;
    this.block_scope = props.block_scope;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "An ES6 Arrow function ((a) => b)"
}, AST_Lambda);
var AST_Defun = DEFNODE("Defun", null, function AST_Defun2(props) {
  if (props) {
    this.name = props.name;
    this.argnames = props.argnames;
    this.uses_arguments = props.uses_arguments;
    this.is_generator = props.is_generator;
    this.async = props.async;
    this.variables = props.variables;
    this.uses_with = props.uses_with;
    this.uses_eval = props.uses_eval;
    this.parent_scope = props.parent_scope;
    this.enclosed = props.enclosed;
    this.cname = props.cname;
    this.body = props.body;
    this.block_scope = props.block_scope;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A function definition"
}, AST_Lambda);
var AST_Destructuring = DEFNODE("Destructuring", "names is_array", function AST_Destructuring2(props) {
  if (props) {
    this.names = props.names;
    this.is_array = props.is_array;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A destructuring of several names. Used in destructuring assignment and with destructuring function argument names",
  $propdoc: {
    "names": "[AST_Node*] Array of properties or elements",
    "is_array": "[Boolean] Whether the destructuring represents an object or array"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.names.forEach(function(name) {
        name._walk(visitor);
      });
    });
  },
  _children_backwards(push2) {
    let i = this.names.length;
    while (i--) push2(this.names[i]);
  },
  all_symbols: function() {
    var out = [];
    walk2(this, (node) => {
      if (node instanceof AST_SymbolDeclaration) {
        out.push(node);
      }
      if (node instanceof AST_Lambda) {
        return true;
      }
    });
    return out;
  }
});
var AST_PrefixedTemplateString = DEFNODE(
  "PrefixedTemplateString",
  "template_string prefix",
  function AST_PrefixedTemplateString2(props) {
    if (props) {
      this.template_string = props.template_string;
      this.prefix = props.prefix;
      this.start = props.start;
      this.end = props.end;
    }
    this.flags = 0;
  },
  {
    $documentation: "A templatestring with a prefix, such as String.raw`foobarbaz`",
    $propdoc: {
      template_string: "[AST_TemplateString] The template string",
      prefix: "[AST_Node] The prefix, which will get called."
    },
    _walk: function(visitor) {
      return visitor._visit(this, function() {
        this.prefix._walk(visitor);
        this.template_string._walk(visitor);
      });
    },
    _children_backwards(push2) {
      push2(this.template_string);
      push2(this.prefix);
    }
  }
);
var AST_TemplateString = DEFNODE("TemplateString", "segments", function AST_TemplateString2(props) {
  if (props) {
    this.segments = props.segments;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A template string literal",
  $propdoc: {
    segments: "[AST_Node*] One or more segments, starting with AST_TemplateSegment. AST_Node may follow AST_TemplateSegment, but each AST_Node must be followed by AST_TemplateSegment."
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.segments.forEach(function(seg) {
        seg._walk(visitor);
      });
    });
  },
  _children_backwards(push2) {
    let i = this.segments.length;
    while (i--) push2(this.segments[i]);
  }
});
var AST_TemplateSegment = DEFNODE("TemplateSegment", "value raw", function AST_TemplateSegment2(props) {
  if (props) {
    this.value = props.value;
    this.raw = props.raw;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A segment of a template string literal",
  $propdoc: {
    value: "Content of the segment",
    raw: "Raw source of the segment"
  }
});
var AST_Jump = DEFNODE("Jump", null, function AST_Jump2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Base class for \u201Cjumps\u201D (for now that's `return`, `throw`, `break` and `continue`)"
}, AST_Statement);
var AST_Exit = DEFNODE("Exit", "value", function AST_Exit2(props) {
  if (props) {
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Base class for \u201Cexits\u201D (`return` and `throw`)",
  $propdoc: {
    value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
  },
  _walk: function(visitor) {
    return visitor._visit(this, this.value && function() {
      this.value._walk(visitor);
    });
  },
  _children_backwards(push2) {
    if (this.value) push2(this.value);
  }
}, AST_Jump);
var AST_Return = DEFNODE("Return", null, function AST_Return2(props) {
  if (props) {
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `return` statement"
}, AST_Exit);
var AST_Throw = DEFNODE("Throw", null, function AST_Throw2(props) {
  if (props) {
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `throw` statement"
}, AST_Exit);
var AST_LoopControl = DEFNODE("LoopControl", "label", function AST_LoopControl2(props) {
  if (props) {
    this.label = props.label;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Base class for loop control statements (`break` and `continue`)",
  $propdoc: {
    label: "[AST_LabelRef?] the label, or null if none"
  },
  _walk: function(visitor) {
    return visitor._visit(this, this.label && function() {
      this.label._walk(visitor);
    });
  },
  _children_backwards(push2) {
    if (this.label) push2(this.label);
  }
}, AST_Jump);
var AST_Break = DEFNODE("Break", null, function AST_Break2(props) {
  if (props) {
    this.label = props.label;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `break` statement"
}, AST_LoopControl);
var AST_Continue = DEFNODE("Continue", null, function AST_Continue2(props) {
  if (props) {
    this.label = props.label;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `continue` statement"
}, AST_LoopControl);
var AST_Await = DEFNODE("Await", "expression", function AST_Await2(props) {
  if (props) {
    this.expression = props.expression;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "An `await` statement",
  $propdoc: {
    expression: "[AST_Node] the mandatory expression being awaited"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.expression._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.expression);
  }
});
var AST_Yield = DEFNODE("Yield", "expression is_star", function AST_Yield2(props) {
  if (props) {
    this.expression = props.expression;
    this.is_star = props.is_star;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `yield` statement",
  $propdoc: {
    expression: "[AST_Node?] the value returned or thrown by this statement; could be null (representing undefined) but only when is_star is set to false",
    is_star: "[Boolean] Whether this is a yield or yield* statement"
  },
  _walk: function(visitor) {
    return visitor._visit(this, this.expression && function() {
      this.expression._walk(visitor);
    });
  },
  _children_backwards(push2) {
    if (this.expression) push2(this.expression);
  }
});
var AST_If = DEFNODE("If", "condition alternative", function AST_If2(props) {
  if (props) {
    this.condition = props.condition;
    this.alternative = props.alternative;
    this.body = props.body;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `if` statement",
  $propdoc: {
    condition: "[AST_Node] the `if` condition",
    alternative: "[AST_Statement?] the `else` part, or null if not present"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.condition._walk(visitor);
      this.body._walk(visitor);
      if (this.alternative) this.alternative._walk(visitor);
    });
  },
  _children_backwards(push2) {
    if (this.alternative) {
      push2(this.alternative);
    }
    push2(this.body);
    push2(this.condition);
  }
}, AST_StatementWithBody);
var AST_Switch = DEFNODE("Switch", "expression", function AST_Switch2(props) {
  if (props) {
    this.expression = props.expression;
    this.body = props.body;
    this.block_scope = props.block_scope;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `switch` statement",
  $propdoc: {
    expression: "[AST_Node] the `switch` \u201Cdiscriminant\u201D"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.expression._walk(visitor);
      walk_body(this, visitor);
    });
  },
  _children_backwards(push2) {
    let i = this.body.length;
    while (i--) push2(this.body[i]);
    push2(this.expression);
  }
}, AST_Block);
var AST_SwitchBranch = DEFNODE("SwitchBranch", null, function AST_SwitchBranch2(props) {
  if (props) {
    this.body = props.body;
    this.block_scope = props.block_scope;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Base class for `switch` branches"
}, AST_Block);
var AST_Default = DEFNODE("Default", null, function AST_Default2(props) {
  if (props) {
    this.body = props.body;
    this.block_scope = props.block_scope;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `default` switch branch"
}, AST_SwitchBranch);
var AST_Case = DEFNODE("Case", "expression", function AST_Case2(props) {
  if (props) {
    this.expression = props.expression;
    this.body = props.body;
    this.block_scope = props.block_scope;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `case` switch branch",
  $propdoc: {
    expression: "[AST_Node] the `case` expression"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.expression._walk(visitor);
      walk_body(this, visitor);
    });
  },
  _children_backwards(push2) {
    let i = this.body.length;
    while (i--) push2(this.body[i]);
    push2(this.expression);
  }
}, AST_SwitchBranch);
var AST_Try = DEFNODE("Try", "body bcatch bfinally", function AST_Try2(props) {
  if (props) {
    this.body = props.body;
    this.bcatch = props.bcatch;
    this.bfinally = props.bfinally;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `try` statement",
  $propdoc: {
    body: "[AST_TryBlock] the try block",
    bcatch: "[AST_Catch?] the catch block, or null if not present",
    bfinally: "[AST_Finally?] the finally block, or null if not present"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.body._walk(visitor);
      if (this.bcatch) this.bcatch._walk(visitor);
      if (this.bfinally) this.bfinally._walk(visitor);
    });
  },
  _children_backwards(push2) {
    if (this.bfinally) push2(this.bfinally);
    if (this.bcatch) push2(this.bcatch);
    push2(this.body);
  }
}, AST_Statement);
var AST_TryBlock = DEFNODE("TryBlock", null, function AST_TryBlock2(props) {
  if (props) {
    this.body = props.body;
    this.block_scope = props.block_scope;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "The `try` block of a try statement"
}, AST_Block);
var AST_Catch = DEFNODE("Catch", "argname", function AST_Catch2(props) {
  if (props) {
    this.argname = props.argname;
    this.body = props.body;
    this.block_scope = props.block_scope;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `catch` node; only makes sense as part of a `try` statement",
  $propdoc: {
    argname: "[AST_SymbolCatch|AST_Destructuring|AST_Expansion|AST_DefaultAssign] symbol for the exception"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      if (this.argname) this.argname._walk(visitor);
      walk_body(this, visitor);
    });
  },
  _children_backwards(push2) {
    let i = this.body.length;
    while (i--) push2(this.body[i]);
    if (this.argname) push2(this.argname);
  }
}, AST_Block);
var AST_Finally = DEFNODE("Finally", null, function AST_Finally2(props) {
  if (props) {
    this.body = props.body;
    this.block_scope = props.block_scope;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `finally` node; only makes sense as part of a `try` statement"
}, AST_Block);
var AST_Definitions = DEFNODE("Definitions", "definitions", function AST_Definitions2(props) {
  if (props) {
    this.definitions = props.definitions;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
  $propdoc: {
    definitions: "[AST_VarDef*] array of variable definitions"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      var definitions = this.definitions;
      for (var i = 0, len = definitions.length; i < len; i++) {
        definitions[i]._walk(visitor);
      }
    });
  },
  _children_backwards(push2) {
    let i = this.definitions.length;
    while (i--) push2(this.definitions[i]);
  }
}, AST_Statement);
var AST_Var = DEFNODE("Var", null, function AST_Var2(props) {
  if (props) {
    this.definitions = props.definitions;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `var` statement"
}, AST_Definitions);
var AST_Let = DEFNODE("Let", null, function AST_Let2(props) {
  if (props) {
    this.definitions = props.definitions;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `let` statement"
}, AST_Definitions);
var AST_Const = DEFNODE("Const", null, function AST_Const2(props) {
  if (props) {
    this.definitions = props.definitions;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A `const` statement"
}, AST_Definitions);
var AST_VarDef = DEFNODE("VarDef", "name value", function AST_VarDef2(props) {
  if (props) {
    this.name = props.name;
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A variable declaration; only appears in a AST_Definitions node",
  $propdoc: {
    name: "[AST_Destructuring|AST_SymbolConst|AST_SymbolLet|AST_SymbolVar] name of the variable",
    value: "[AST_Node?] initializer, or null of there's no initializer"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.name._walk(visitor);
      if (this.value) this.value._walk(visitor);
    });
  },
  _children_backwards(push2) {
    if (this.value) push2(this.value);
    push2(this.name);
  },
  declarations_as_names() {
    if (this.name instanceof AST_SymbolDeclaration) {
      return [this];
    } else {
      return this.name.all_symbols();
    }
  }
});
var AST_NameMapping = DEFNODE("NameMapping", "foreign_name name", function AST_NameMapping2(props) {
  if (props) {
    this.foreign_name = props.foreign_name;
    this.name = props.name;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "The part of the export/import statement that declare names from a module.",
  $propdoc: {
    foreign_name: "[AST_SymbolExportForeign|AST_SymbolImportForeign] The name being exported/imported (as specified in the module)",
    name: "[AST_SymbolExport|AST_SymbolImport] The name as it is visible to this module."
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.foreign_name._walk(visitor);
      this.name._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.name);
    push2(this.foreign_name);
  }
});
var AST_Import = DEFNODE(
  "Import",
  "imported_name imported_names module_name attributes",
  function AST_Import2(props) {
    if (props) {
      this.imported_name = props.imported_name;
      this.imported_names = props.imported_names;
      this.module_name = props.module_name;
      this.attributes = props.attributes;
      this.start = props.start;
      this.end = props.end;
    }
    this.flags = 0;
  },
  {
    $documentation: "An `import` statement",
    $propdoc: {
      imported_name: "[AST_SymbolImport] The name of the variable holding the module's default export.",
      imported_names: "[AST_NameMapping*] The names of non-default imported variables",
      module_name: "[AST_String] String literal describing where this module came from",
      attributes: "[AST_Object?] The import attributes (with {...})"
    },
    _walk: function(visitor) {
      return visitor._visit(this, function() {
        if (this.imported_name) {
          this.imported_name._walk(visitor);
        }
        if (this.imported_names) {
          this.imported_names.forEach(function(name_import) {
            name_import._walk(visitor);
          });
        }
        this.module_name._walk(visitor);
      });
    },
    _children_backwards(push2) {
      push2(this.module_name);
      if (this.imported_names) {
        let i = this.imported_names.length;
        while (i--) push2(this.imported_names[i]);
      }
      if (this.imported_name) push2(this.imported_name);
    }
  }
);
var AST_ImportMeta = DEFNODE("ImportMeta", null, function AST_ImportMeta2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A reference to import.meta"
});
var AST_Export = DEFNODE(
  "Export",
  "exported_definition exported_value is_default exported_names module_name attributes",
  function AST_Export2(props) {
    if (props) {
      this.exported_definition = props.exported_definition;
      this.exported_value = props.exported_value;
      this.is_default = props.is_default;
      this.exported_names = props.exported_names;
      this.module_name = props.module_name;
      this.attributes = props.attributes;
      this.start = props.start;
      this.end = props.end;
    }
    this.flags = 0;
  },
  {
    $documentation: "An `export` statement",
    $propdoc: {
      exported_definition: "[AST_Defun|AST_Definitions|AST_DefClass?] An exported definition",
      exported_value: "[AST_Node?] An exported value",
      exported_names: "[AST_NameMapping*?] List of exported names",
      module_name: "[AST_String?] Name of the file to load exports from",
      is_default: "[Boolean] Whether this is the default exported value of this module",
      attributes: "[AST_Object?] The import attributes"
    },
    _walk: function(visitor) {
      return visitor._visit(this, function() {
        if (this.exported_definition) {
          this.exported_definition._walk(visitor);
        }
        if (this.exported_value) {
          this.exported_value._walk(visitor);
        }
        if (this.exported_names) {
          this.exported_names.forEach(function(name_export) {
            name_export._walk(visitor);
          });
        }
        if (this.module_name) {
          this.module_name._walk(visitor);
        }
      });
    },
    _children_backwards(push2) {
      if (this.module_name) push2(this.module_name);
      if (this.exported_names) {
        let i = this.exported_names.length;
        while (i--) push2(this.exported_names[i]);
      }
      if (this.exported_value) push2(this.exported_value);
      if (this.exported_definition) push2(this.exported_definition);
    }
  },
  AST_Statement
);
var AST_Call = DEFNODE(
  "Call",
  "expression args optional _annotations",
  function AST_Call2(props) {
    if (props) {
      this.expression = props.expression;
      this.args = props.args;
      this.optional = props.optional;
      this._annotations = props._annotations;
      this.start = props.start;
      this.end = props.end;
      this.initialize();
    }
    this.flags = 0;
  },
  {
    $documentation: "A function call expression",
    $propdoc: {
      expression: "[AST_Node] expression to invoke as function",
      args: "[AST_Node*] array of arguments",
      optional: "[boolean] whether this is an optional call (IE ?.() )",
      _annotations: "[number] bitfield containing information about the call"
    },
    initialize() {
      if (this._annotations == null) this._annotations = 0;
    },
    _walk(visitor) {
      return visitor._visit(this, function() {
        var args2 = this.args;
        for (var i = 0, len = args2.length; i < len; i++) {
          args2[i]._walk(visitor);
        }
        this.expression._walk(visitor);
      });
    },
    _children_backwards(push2) {
      let i = this.args.length;
      while (i--) push2(this.args[i]);
      push2(this.expression);
    }
  }
);
var AST_New = DEFNODE("New", null, function AST_New2(props) {
  if (props) {
    this.expression = props.expression;
    this.args = props.args;
    this.optional = props.optional;
    this._annotations = props._annotations;
    this.start = props.start;
    this.end = props.end;
    this.initialize();
  }
  this.flags = 0;
}, {
  $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
}, AST_Call);
var AST_Sequence = DEFNODE("Sequence", "expressions", function AST_Sequence2(props) {
  if (props) {
    this.expressions = props.expressions;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A sequence expression (comma-separated expressions)",
  $propdoc: {
    expressions: "[AST_Node*] array of expressions (at least two)"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.expressions.forEach(function(node) {
        node._walk(visitor);
      });
    });
  },
  _children_backwards(push2) {
    let i = this.expressions.length;
    while (i--) push2(this.expressions[i]);
  }
});
var AST_PropAccess = DEFNODE(
  "PropAccess",
  "expression property optional",
  function AST_PropAccess2(props) {
    if (props) {
      this.expression = props.expression;
      this.property = props.property;
      this.optional = props.optional;
      this.start = props.start;
      this.end = props.end;
    }
    this.flags = 0;
  },
  {
    $documentation: 'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',
    $propdoc: {
      expression: "[AST_Node] the \u201Ccontainer\u201D expression",
      property: "[AST_Node|string] the property to access.  For AST_Dot & AST_DotHash this is always a plain string, while for AST_Sub it's an arbitrary AST_Node",
      optional: "[boolean] whether this is an optional property access (IE ?.)"
    }
  }
);
var AST_Dot = DEFNODE("Dot", "quote", function AST_Dot2(props) {
  if (props) {
    this.quote = props.quote;
    this.expression = props.expression;
    this.property = props.property;
    this.optional = props.optional;
    this._annotations = props._annotations;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A dotted property access expression",
  $propdoc: {
    quote: "[string] the original quote character when transformed from AST_Sub"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.expression._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.expression);
  }
}, AST_PropAccess);
var AST_DotHash = DEFNODE("DotHash", "", function AST_DotHash2(props) {
  if (props) {
    this.expression = props.expression;
    this.property = props.property;
    this.optional = props.optional;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A dotted property access to a private property",
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.expression._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.expression);
  }
}, AST_PropAccess);
var AST_Sub = DEFNODE("Sub", null, function AST_Sub2(props) {
  if (props) {
    this.expression = props.expression;
    this.property = props.property;
    this.optional = props.optional;
    this._annotations = props._annotations;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: 'Index-style property access, i.e. `a["foo"]`',
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.expression._walk(visitor);
      this.property._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.property);
    push2(this.expression);
  }
}, AST_PropAccess);
var AST_Chain = DEFNODE("Chain", "expression", function AST_Chain2(props) {
  if (props) {
    this.expression = props.expression;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A chain expression like a?.b?.(c)?.[d]",
  $propdoc: {
    expression: "[AST_Call|AST_Dot|AST_DotHash|AST_Sub] chain element."
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.expression._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.expression);
  }
});
var AST_Unary = DEFNODE("Unary", "operator expression", function AST_Unary2(props) {
  if (props) {
    this.operator = props.operator;
    this.expression = props.expression;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Base class for unary expressions",
  $propdoc: {
    operator: "[string] the operator",
    expression: "[AST_Node] expression that this unary operator applies to"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.expression._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.expression);
  }
});
var AST_UnaryPrefix = DEFNODE("UnaryPrefix", null, function AST_UnaryPrefix2(props) {
  if (props) {
    this.operator = props.operator;
    this.expression = props.expression;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
}, AST_Unary);
var AST_UnaryPostfix = DEFNODE("UnaryPostfix", null, function AST_UnaryPostfix2(props) {
  if (props) {
    this.operator = props.operator;
    this.expression = props.expression;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Unary postfix expression, i.e. `i++`"
}, AST_Unary);
var AST_Binary = DEFNODE("Binary", "operator left right", function AST_Binary2(props) {
  if (props) {
    this.operator = props.operator;
    this.left = props.left;
    this.right = props.right;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Binary expression, i.e. `a + b`",
  $propdoc: {
    left: "[AST_Node] left-hand side expression",
    operator: "[string] the operator",
    right: "[AST_Node] right-hand side expression"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.left._walk(visitor);
      this.right._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.right);
    push2(this.left);
  }
});
var AST_Conditional = DEFNODE(
  "Conditional",
  "condition consequent alternative",
  function AST_Conditional2(props) {
    if (props) {
      this.condition = props.condition;
      this.consequent = props.consequent;
      this.alternative = props.alternative;
      this.start = props.start;
      this.end = props.end;
    }
    this.flags = 0;
  },
  {
    $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
    $propdoc: {
      condition: "[AST_Node]",
      consequent: "[AST_Node]",
      alternative: "[AST_Node]"
    },
    _walk: function(visitor) {
      return visitor._visit(this, function() {
        this.condition._walk(visitor);
        this.consequent._walk(visitor);
        this.alternative._walk(visitor);
      });
    },
    _children_backwards(push2) {
      push2(this.alternative);
      push2(this.consequent);
      push2(this.condition);
    }
  }
);
var AST_Assign = DEFNODE("Assign", "logical", function AST_Assign2(props) {
  if (props) {
    this.logical = props.logical;
    this.operator = props.operator;
    this.left = props.left;
    this.right = props.right;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "An assignment expression \u2014 `a = b + 5`",
  $propdoc: {
    logical: "Whether it's a logical assignment"
  }
}, AST_Binary);
var AST_DefaultAssign = DEFNODE("DefaultAssign", null, function AST_DefaultAssign2(props) {
  if (props) {
    this.operator = props.operator;
    this.left = props.left;
    this.right = props.right;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A default assignment expression like in `(a = 3) => a`"
}, AST_Binary);
var AST_Array = DEFNODE("Array", "elements", function AST_Array2(props) {
  if (props) {
    this.elements = props.elements;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "An array literal",
  $propdoc: {
    elements: "[AST_Node*] array of elements"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      var elements = this.elements;
      for (var i = 0, len = elements.length; i < len; i++) {
        elements[i]._walk(visitor);
      }
    });
  },
  _children_backwards(push2) {
    let i = this.elements.length;
    while (i--) push2(this.elements[i]);
  }
});
var AST_Object = DEFNODE("Object", "properties", function AST_Object2(props) {
  if (props) {
    this.properties = props.properties;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "An object literal",
  $propdoc: {
    properties: "[AST_ObjectProperty*] array of properties"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      var properties = this.properties;
      for (var i = 0, len = properties.length; i < len; i++) {
        properties[i]._walk(visitor);
      }
    });
  },
  _children_backwards(push2) {
    let i = this.properties.length;
    while (i--) push2(this.properties[i]);
  }
});
var AST_ObjectProperty = DEFNODE("ObjectProperty", "key value", function AST_ObjectProperty2(props) {
  if (props) {
    this.key = props.key;
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
    this._annotations = props._annotations;
  }
  this.flags = 0;
}, {
  $documentation: "Base class for literal object properties",
  $propdoc: {
    key: "[string|AST_Node] property name. For ObjectKeyVal this is a string. For getters, setters and computed property this is an AST_Node.",
    value: "[AST_Node] property value.  For getters, setters and methods this is an AST_Accessor."
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      if (this.key instanceof AST_Node)
        this.key._walk(visitor);
      this.value._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.value);
    if (this.key instanceof AST_Node) push2(this.key);
  }
});
var AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", "quote", function AST_ObjectKeyVal2(props) {
  if (props) {
    this.quote = props.quote;
    this.key = props.key;
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
    this._annotations = props._annotations;
  }
  this.flags = 0;
}, {
  $documentation: "A key: value object property",
  $propdoc: {
    quote: "[string] the original quote character"
  },
  computed_key() {
    return this.key instanceof AST_Node;
  }
}, AST_ObjectProperty);
var AST_PrivateSetter = DEFNODE("PrivateSetter", "static", function AST_PrivateSetter2(props) {
  if (props) {
    this.static = props.static;
    this.key = props.key;
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $propdoc: {
    static: "[boolean] whether this is a static private setter"
  },
  $documentation: "A private setter property",
  computed_key() {
    return false;
  }
}, AST_ObjectProperty);
var AST_PrivateGetter = DEFNODE("PrivateGetter", "static", function AST_PrivateGetter2(props) {
  if (props) {
    this.static = props.static;
    this.key = props.key;
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $propdoc: {
    static: "[boolean] whether this is a static private getter"
  },
  $documentation: "A private getter property",
  computed_key() {
    return false;
  }
}, AST_ObjectProperty);
var AST_ObjectSetter = DEFNODE("ObjectSetter", "quote static", function AST_ObjectSetter2(props) {
  if (props) {
    this.quote = props.quote;
    this.static = props.static;
    this.key = props.key;
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
    this._annotations = props._annotations;
  }
  this.flags = 0;
}, {
  $propdoc: {
    quote: "[string|undefined] the original quote character, if any",
    static: "[boolean] whether this is a static setter (classes only)"
  },
  $documentation: "An object setter property",
  computed_key() {
    return !(this.key instanceof AST_SymbolMethod);
  }
}, AST_ObjectProperty);
var AST_ObjectGetter = DEFNODE("ObjectGetter", "quote static", function AST_ObjectGetter2(props) {
  if (props) {
    this.quote = props.quote;
    this.static = props.static;
    this.key = props.key;
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
    this._annotations = props._annotations;
  }
  this.flags = 0;
}, {
  $propdoc: {
    quote: "[string|undefined] the original quote character, if any",
    static: "[boolean] whether this is a static getter (classes only)"
  },
  $documentation: "An object getter property",
  computed_key() {
    return !(this.key instanceof AST_SymbolMethod);
  }
}, AST_ObjectProperty);
var AST_ConciseMethod = DEFNODE("ConciseMethod", "quote static is_generator async", function AST_ConciseMethod2(props) {
  if (props) {
    this.quote = props.quote;
    this.static = props.static;
    this.is_generator = props.is_generator;
    this.async = props.async;
    this.key = props.key;
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
    this._annotations = props._annotations;
  }
  this.flags = 0;
}, {
  $propdoc: {
    quote: "[string|undefined] the original quote character, if any",
    static: "[boolean] is this method static (classes only)",
    is_generator: "[boolean] is this a generator method",
    async: "[boolean] is this method async"
  },
  $documentation: "An ES6 concise method inside an object or class",
  computed_key() {
    return !(this.key instanceof AST_SymbolMethod);
  }
}, AST_ObjectProperty);
var AST_PrivateMethod = DEFNODE("PrivateMethod", "", function AST_PrivateMethod2(props) {
  if (props) {
    this.quote = props.quote;
    this.static = props.static;
    this.is_generator = props.is_generator;
    this.async = props.async;
    this.key = props.key;
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A private class method inside a class",
  computed_key() {
    return false;
  }
}, AST_ObjectProperty);
var AST_Class = DEFNODE(
  "Class",
  "name extends properties",
  function AST_Class2(props) {
    if (props) {
      this.name = props.name;
      this.extends = props.extends;
      this.properties = props.properties;
      this.variables = props.variables;
      this.uses_with = props.uses_with;
      this.uses_eval = props.uses_eval;
      this.parent_scope = props.parent_scope;
      this.enclosed = props.enclosed;
      this.cname = props.cname;
      this.body = props.body;
      this.block_scope = props.block_scope;
      this.start = props.start;
      this.end = props.end;
    }
    this.flags = 0;
  },
  {
    $propdoc: {
      name: "[AST_SymbolClass|AST_SymbolDefClass?] optional class name.",
      extends: "[AST_Node]? optional parent class",
      properties: "[AST_ObjectProperty|AST_ClassStaticBlock]* array of properties or static blocks"
    },
    $documentation: "An ES6 class",
    _walk: function(visitor) {
      return visitor._visit(this, function() {
        if (this.name) {
          this.name._walk(visitor);
        }
        if (this.extends) {
          this.extends._walk(visitor);
        }
        this.properties.forEach((prop) => prop._walk(visitor));
      });
    },
    _children_backwards(push2) {
      let i = this.properties.length;
      while (i--) push2(this.properties[i]);
      if (this.extends) push2(this.extends);
      if (this.name) push2(this.name);
    },
    /** go through the bits that are executed instantly, not when the class is `new`'d. Doesn't walk the name. */
    visit_nondeferred_class_parts(visitor) {
      if (this.extends) {
        this.extends._walk(visitor);
      }
      this.properties.forEach((prop) => {
        if (prop instanceof AST_ClassStaticBlock) {
          prop._walk(visitor);
          return;
        }
        if (prop.computed_key()) {
          visitor.push(prop);
          prop.key._walk(visitor);
          visitor.pop();
        }
        if (prop instanceof AST_ClassPrivateProperty && prop.static && prop.value || prop instanceof AST_ClassProperty && prop.static && prop.value) {
          visitor.push(prop);
          prop.value._walk(visitor);
          visitor.pop();
        }
      });
    },
    /** go through the bits that are executed later, when the class is `new`'d or a static method is called */
    visit_deferred_class_parts(visitor) {
      this.properties.forEach((prop) => {
        if (prop instanceof AST_ConciseMethod || prop instanceof AST_PrivateMethod) {
          prop.walk(visitor);
        } else if (prop instanceof AST_ClassProperty && !prop.static && prop.value || prop instanceof AST_ClassPrivateProperty && !prop.static && prop.value) {
          visitor.push(prop);
          prop.value._walk(visitor);
          visitor.pop();
        }
      });
    },
    is_self_referential: function() {
      const this_id = this.name && this.name.definition().id;
      let found2 = false;
      let class_this = true;
      this.visit_nondeferred_class_parts(new TreeWalker((node, descend) => {
        if (found2) return true;
        if (node instanceof AST_This) return found2 = class_this;
        if (node instanceof AST_SymbolRef) return found2 = node.definition().id === this_id;
        if (node instanceof AST_Lambda && !(node instanceof AST_Arrow)) {
          const class_this_save = class_this;
          class_this = false;
          descend();
          class_this = class_this_save;
          return true;
        }
      }));
      return found2;
    }
  },
  AST_Scope
  /* TODO a class might have a scope but it's not a scope */
);
var AST_ClassProperty = DEFNODE("ClassProperty", "static quote", function AST_ClassProperty2(props) {
  if (props) {
    this.static = props.static;
    this.quote = props.quote;
    this.key = props.key;
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
    this._annotations = props._annotations;
  }
  this.flags = 0;
}, {
  $documentation: "A class property",
  $propdoc: {
    static: "[boolean] whether this is a static key",
    quote: "[string] which quote is being used"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      if (this.key instanceof AST_Node)
        this.key._walk(visitor);
      if (this.value instanceof AST_Node)
        this.value._walk(visitor);
    });
  },
  _children_backwards(push2) {
    if (this.value instanceof AST_Node) push2(this.value);
    if (this.key instanceof AST_Node) push2(this.key);
  },
  computed_key() {
    return !(this.key instanceof AST_SymbolClassProperty);
  }
}, AST_ObjectProperty);
var AST_ClassPrivateProperty = DEFNODE("ClassPrivateProperty", "", function AST_ClassPrivateProperty2(props) {
  if (props) {
    this.static = props.static;
    this.quote = props.quote;
    this.key = props.key;
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A class property for a private property",
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      if (this.value instanceof AST_Node)
        this.value._walk(visitor);
    });
  },
  _children_backwards(push2) {
    if (this.value instanceof AST_Node) push2(this.value);
  },
  computed_key() {
    return false;
  }
}, AST_ObjectProperty);
var AST_PrivateIn = DEFNODE("PrivateIn", "key value", function AST_PrivateIn2(props) {
  if (props) {
    this.key = props.key;
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "An `in` binop when the key is private, eg #x in this",
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      this.key._walk(visitor);
      this.value._walk(visitor);
    });
  },
  _children_backwards(push2) {
    push2(this.value);
    push2(this.key);
  }
});
var AST_DefClass = DEFNODE("DefClass", null, function AST_DefClass2(props) {
  if (props) {
    this.name = props.name;
    this.extends = props.extends;
    this.properties = props.properties;
    this.variables = props.variables;
    this.uses_with = props.uses_with;
    this.uses_eval = props.uses_eval;
    this.parent_scope = props.parent_scope;
    this.enclosed = props.enclosed;
    this.cname = props.cname;
    this.body = props.body;
    this.block_scope = props.block_scope;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A class definition"
}, AST_Class);
var AST_ClassStaticBlock = DEFNODE("ClassStaticBlock", "body block_scope", function AST_ClassStaticBlock2(props) {
  this.body = props.body;
  this.block_scope = props.block_scope;
  this.start = props.start;
  this.end = props.end;
}, {
  $documentation: "A block containing statements to be executed in the context of the class",
  $propdoc: {
    body: "[AST_Statement*] an array of statements"
  },
  _walk: function(visitor) {
    return visitor._visit(this, function() {
      walk_body(this, visitor);
    });
  },
  _children_backwards(push2) {
    let i = this.body.length;
    while (i--) push2(this.body[i]);
  },
  clone: clone_block_scope,
  computed_key() {
    return false;
  }
}, AST_Scope);
var AST_ClassExpression = DEFNODE("ClassExpression", null, function AST_ClassExpression2(props) {
  if (props) {
    this.name = props.name;
    this.extends = props.extends;
    this.properties = props.properties;
    this.variables = props.variables;
    this.uses_with = props.uses_with;
    this.uses_eval = props.uses_eval;
    this.parent_scope = props.parent_scope;
    this.enclosed = props.enclosed;
    this.cname = props.cname;
    this.body = props.body;
    this.block_scope = props.block_scope;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A class expression."
}, AST_Class);
var AST_Symbol = DEFNODE("Symbol", "scope name thedef", function AST_Symbol2(props) {
  if (props) {
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $propdoc: {
    name: "[string] name of this symbol",
    scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
    thedef: "[SymbolDef/S] the definition of this symbol"
  },
  $documentation: "Base class for all symbols"
});
var AST_NewTarget = DEFNODE("NewTarget", null, function AST_NewTarget2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A reference to new.target"
});
var AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", function AST_SymbolDeclaration2(props) {
  if (props) {
    this.init = props.init;
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)"
}, AST_Symbol);
var AST_SymbolVar = DEFNODE("SymbolVar", null, function AST_SymbolVar2(props) {
  if (props) {
    this.init = props.init;
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Symbol defining a variable"
}, AST_SymbolDeclaration);
var AST_SymbolBlockDeclaration = DEFNODE(
  "SymbolBlockDeclaration",
  null,
  function AST_SymbolBlockDeclaration2(props) {
    if (props) {
      this.init = props.init;
      this.scope = props.scope;
      this.name = props.name;
      this.thedef = props.thedef;
      this.start = props.start;
      this.end = props.end;
    }
    this.flags = 0;
  },
  {
    $documentation: "Base class for block-scoped declaration symbols"
  },
  AST_SymbolDeclaration
);
var AST_SymbolConst = DEFNODE("SymbolConst", null, function AST_SymbolConst2(props) {
  if (props) {
    this.init = props.init;
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A constant declaration"
}, AST_SymbolBlockDeclaration);
var AST_SymbolLet = DEFNODE("SymbolLet", null, function AST_SymbolLet2(props) {
  if (props) {
    this.init = props.init;
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A block-scoped `let` declaration"
}, AST_SymbolBlockDeclaration);
var AST_SymbolFunarg = DEFNODE("SymbolFunarg", null, function AST_SymbolFunarg2(props) {
  if (props) {
    this.init = props.init;
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Symbol naming a function argument"
}, AST_SymbolVar);
var AST_SymbolDefun = DEFNODE("SymbolDefun", null, function AST_SymbolDefun2(props) {
  if (props) {
    this.init = props.init;
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Symbol defining a function"
}, AST_SymbolDeclaration);
var AST_SymbolMethod = DEFNODE("SymbolMethod", null, function AST_SymbolMethod2(props) {
  if (props) {
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Symbol in an object defining a method"
}, AST_Symbol);
var AST_SymbolClassProperty = DEFNODE("SymbolClassProperty", null, function AST_SymbolClassProperty2(props) {
  if (props) {
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Symbol for a class property"
}, AST_Symbol);
var AST_SymbolLambda = DEFNODE("SymbolLambda", null, function AST_SymbolLambda2(props) {
  if (props) {
    this.init = props.init;
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Symbol naming a function expression"
}, AST_SymbolDeclaration);
var AST_SymbolDefClass = DEFNODE("SymbolDefClass", null, function AST_SymbolDefClass2(props) {
  if (props) {
    this.init = props.init;
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Symbol naming a class's name in a class declaration. Lexically scoped to its containing scope, and accessible within the class."
}, AST_SymbolBlockDeclaration);
var AST_SymbolClass = DEFNODE("SymbolClass", null, function AST_SymbolClass2(props) {
  if (props) {
    this.init = props.init;
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Symbol naming a class's name. Lexically scoped to the class."
}, AST_SymbolDeclaration);
var AST_SymbolCatch = DEFNODE("SymbolCatch", null, function AST_SymbolCatch2(props) {
  if (props) {
    this.init = props.init;
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Symbol naming the exception in catch"
}, AST_SymbolBlockDeclaration);
var AST_SymbolImport = DEFNODE("SymbolImport", null, function AST_SymbolImport2(props) {
  if (props) {
    this.init = props.init;
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Symbol referring to an imported name"
}, AST_SymbolBlockDeclaration);
var AST_SymbolImportForeign = DEFNODE("SymbolImportForeign", null, function AST_SymbolImportForeign2(props) {
  if (props) {
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.quote = props.quote;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A symbol imported from a module, but it is defined in the other module, and its real name is irrelevant for this module's purposes"
}, AST_Symbol);
var AST_Label = DEFNODE("Label", "references", function AST_Label2(props) {
  if (props) {
    this.references = props.references;
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
    this.initialize();
  }
  this.flags = 0;
}, {
  $documentation: "Symbol naming a label (declaration)",
  $propdoc: {
    references: "[AST_LoopControl*] a list of nodes referring to this label"
  },
  initialize: function() {
    this.references = [];
    this.thedef = this;
  }
}, AST_Symbol);
var AST_SymbolRef = DEFNODE("SymbolRef", null, function AST_SymbolRef2(props) {
  if (props) {
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Reference to some symbol (not definition/declaration)"
}, AST_Symbol);
var AST_SymbolExport = DEFNODE("SymbolExport", null, function AST_SymbolExport2(props) {
  if (props) {
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.quote = props.quote;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Symbol referring to a name to export"
}, AST_SymbolRef);
var AST_SymbolExportForeign = DEFNODE("SymbolExportForeign", null, function AST_SymbolExportForeign2(props) {
  if (props) {
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.quote = props.quote;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A symbol exported from this module, but it is used in the other module, and its real name is irrelevant for this module's purposes"
}, AST_Symbol);
var AST_LabelRef = DEFNODE("LabelRef", null, function AST_LabelRef2(props) {
  if (props) {
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Reference to a label symbol"
}, AST_Symbol);
var AST_SymbolPrivateProperty = DEFNODE("SymbolPrivateProperty", null, function AST_SymbolPrivateProperty2(props) {
  if (props) {
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A symbol that refers to a private property"
}, AST_Symbol);
var AST_This = DEFNODE("This", null, function AST_This2(props) {
  if (props) {
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "The `this` symbol"
}, AST_Symbol);
var AST_Super = DEFNODE("Super", null, function AST_Super2(props) {
  if (props) {
    this.scope = props.scope;
    this.name = props.name;
    this.thedef = props.thedef;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "The `super` symbol"
}, AST_This);
var AST_Constant = DEFNODE("Constant", null, function AST_Constant2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Base class for all constants",
  getValue: function() {
    return this.value;
  }
});
var AST_String = DEFNODE("String", "value quote", function AST_String2(props) {
  if (props) {
    this.value = props.value;
    this.quote = props.quote;
    this.start = props.start;
    this.end = props.end;
    this._annotations = props._annotations;
  }
  this.flags = 0;
}, {
  $documentation: "A string literal",
  $propdoc: {
    value: "[string] the contents of this string",
    quote: "[string] the original quote character"
  }
}, AST_Constant);
var AST_Number = DEFNODE("Number", "value raw", function AST_Number2(props) {
  if (props) {
    this.value = props.value;
    this.raw = props.raw;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A number literal",
  $propdoc: {
    value: "[number] the numeric value",
    raw: "[string] numeric value as string"
  }
}, AST_Constant);
var AST_BigInt = DEFNODE("BigInt", "value", function AST_BigInt2(props) {
  if (props) {
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A big int literal",
  $propdoc: {
    value: "[string] big int value"
  }
}, AST_Constant);
var AST_RegExp = DEFNODE("RegExp", "value", function AST_RegExp2(props) {
  if (props) {
    this.value = props.value;
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A regexp literal",
  $propdoc: {
    value: "[RegExp] the actual regexp"
  }
}, AST_Constant);
var AST_Atom = DEFNODE("Atom", null, function AST_Atom2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Base class for atoms"
}, AST_Constant);
var AST_Null = DEFNODE("Null", null, function AST_Null2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "The `null` atom",
  value: null
}, AST_Atom);
var AST_NaN = DEFNODE("NaN", null, function AST_NaN2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "The impossible value",
  value: 0 / 0
}, AST_Atom);
var AST_Undefined = DEFNODE("Undefined", null, function AST_Undefined2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "The `undefined` value",
  value: /* @__PURE__ */ function() {
  }()
}, AST_Atom);
var AST_Hole = DEFNODE("Hole", null, function AST_Hole2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "A hole in an array",
  value: /* @__PURE__ */ function() {
  }()
}, AST_Atom);
var AST_Infinity = DEFNODE("Infinity", null, function AST_Infinity2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "The `Infinity` value",
  value: 1 / 0
}, AST_Atom);
var AST_Boolean = DEFNODE("Boolean", null, function AST_Boolean2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "Base class for booleans"
}, AST_Atom);
var AST_False = DEFNODE("False", null, function AST_False2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "The `false` atom",
  value: false
}, AST_Boolean);
var AST_True = DEFNODE("True", null, function AST_True2(props) {
  if (props) {
    this.start = props.start;
    this.end = props.end;
  }
  this.flags = 0;
}, {
  $documentation: "The `true` atom",
  value: true
}, AST_Boolean);
function walk2(node, cb, to_visit = [node]) {
  const push2 = to_visit.push.bind(to_visit);
  while (to_visit.length) {
    const node2 = to_visit.pop();
    const ret = cb(node2, to_visit);
    if (ret) {
      if (ret === walk_abort) return true;
      continue;
    }
    node2._children_backwards(push2);
  }
  return false;
}
function walk_parent(node, cb, initial_stack) {
  const to_visit = [node];
  const push2 = to_visit.push.bind(to_visit);
  const stack = initial_stack ? initial_stack.slice() : [];
  const parent_pop_indices = [];
  let current2;
  const info3 = {
    parent: (n2 = 0) => {
      if (n2 === -1) {
        return current2;
      }
      if (initial_stack && n2 >= stack.length) {
        n2 -= stack.length;
        return initial_stack[initial_stack.length - (n2 + 1)];
      }
      return stack[stack.length - (1 + n2)];
    }
  };
  while (to_visit.length) {
    current2 = to_visit.pop();
    while (parent_pop_indices.length && to_visit.length == parent_pop_indices[parent_pop_indices.length - 1]) {
      stack.pop();
      parent_pop_indices.pop();
    }
    const ret = cb(current2, info3);
    if (ret) {
      if (ret === walk_abort) return true;
      continue;
    }
    const visit_length = to_visit.length;
    current2._children_backwards(push2);
    if (to_visit.length > visit_length) {
      stack.push(current2);
      parent_pop_indices.push(visit_length - 1);
    }
  }
  return false;
}
var walk_abort = Symbol("abort walk");
var TreeWalker = class {
  constructor(callback) {
    this.visit = callback;
    this.stack = [];
    this.directives = /* @__PURE__ */ Object.create(null);
  }
  _visit(node, descend) {
    this.push(node);
    var ret = this.visit(node, descend ? function() {
      descend.call(node);
    } : noop);
    if (!ret && descend) {
      descend.call(node);
    }
    this.pop();
    return ret;
  }
  parent(n2) {
    return this.stack[this.stack.length - 2 - (n2 || 0)];
  }
  push(node) {
    if (node instanceof AST_Lambda) {
      this.directives = Object.create(this.directives);
    } else if (node instanceof AST_Directive && !this.directives[node.value]) {
      this.directives[node.value] = node;
    } else if (node instanceof AST_Class) {
      this.directives = Object.create(this.directives);
      if (!this.directives["use strict"]) {
        this.directives["use strict"] = node;
      }
    }
    this.stack.push(node);
  }
  pop() {
    var node = this.stack.pop();
    if (node instanceof AST_Lambda || node instanceof AST_Class) {
      this.directives = Object.getPrototypeOf(this.directives);
    }
  }
  self() {
    return this.stack[this.stack.length - 1];
  }
  find_parent(type) {
    var stack = this.stack;
    for (var i = stack.length; --i >= 0; ) {
      var x2 = stack[i];
      if (x2 instanceof type) return x2;
    }
  }
  find_scope() {
    var stack = this.stack;
    for (var i = stack.length; --i >= 0; ) {
      const p3 = stack[i];
      if (p3 instanceof AST_Toplevel) return p3;
      if (p3 instanceof AST_Lambda) return p3;
      if (p3.block_scope) return p3.block_scope;
    }
  }
  has_directive(type) {
    var dir3 = this.directives[type];
    if (dir3) return dir3;
    var node = this.stack[this.stack.length - 1];
    if (node instanceof AST_Scope && node.body) {
      for (var i = 0; i < node.body.length; ++i) {
        var st = node.body[i];
        if (!(st instanceof AST_Directive)) break;
        if (st.value == type) return st;
      }
    }
  }
  loopcontrol_target(node) {
    var stack = this.stack;
    if (node.label) for (var i = stack.length; --i >= 0; ) {
      var x2 = stack[i];
      if (x2 instanceof AST_LabeledStatement && x2.label.name == node.label.name)
        return x2.body;
    }
    else for (var i = stack.length; --i >= 0; ) {
      var x2 = stack[i];
      if (x2 instanceof AST_IterationStatement || node instanceof AST_Break && x2 instanceof AST_Switch)
        return x2;
    }
  }
};
var TreeTransformer = class extends TreeWalker {
  constructor(before2, after3) {
    super();
    this.before = before2;
    this.after = after3;
  }
};
var _PURE = 1;
var _INLINE = 2;
var _NOINLINE = 4;
var _KEY = 8;
var _MANGLEPROP = 16;

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/transform.js
function def_transform(node, descend) {
  node.DEFMETHOD("transform", function(tw, in_list) {
    let transformed = void 0;
    tw.push(this);
    if (tw.before) transformed = tw.before(this, descend, in_list);
    if (transformed === void 0) {
      transformed = this;
      descend(transformed, tw);
      if (tw.after) {
        const after_ret = tw.after(transformed, in_list);
        if (after_ret !== void 0) transformed = after_ret;
      }
    }
    tw.pop();
    return transformed;
  });
}
def_transform(AST_Node, noop);
def_transform(AST_LabeledStatement, function(self2, tw) {
  self2.label = self2.label.transform(tw);
  self2.body = self2.body.transform(tw);
});
def_transform(AST_SimpleStatement, function(self2, tw) {
  self2.body = self2.body.transform(tw);
});
def_transform(AST_Block, function(self2, tw) {
  self2.body = MAP(self2.body, tw);
});
def_transform(AST_Do, function(self2, tw) {
  self2.body = self2.body.transform(tw);
  self2.condition = self2.condition.transform(tw);
});
def_transform(AST_While, function(self2, tw) {
  self2.condition = self2.condition.transform(tw);
  self2.body = self2.body.transform(tw);
});
def_transform(AST_For, function(self2, tw) {
  if (self2.init) self2.init = self2.init.transform(tw);
  if (self2.condition) self2.condition = self2.condition.transform(tw);
  if (self2.step) self2.step = self2.step.transform(tw);
  self2.body = self2.body.transform(tw);
});
def_transform(AST_ForIn, function(self2, tw) {
  self2.init = self2.init.transform(tw);
  self2.object = self2.object.transform(tw);
  self2.body = self2.body.transform(tw);
});
def_transform(AST_With, function(self2, tw) {
  self2.expression = self2.expression.transform(tw);
  self2.body = self2.body.transform(tw);
});
def_transform(AST_Exit, function(self2, tw) {
  if (self2.value) self2.value = self2.value.transform(tw);
});
def_transform(AST_LoopControl, function(self2, tw) {
  if (self2.label) self2.label = self2.label.transform(tw);
});
def_transform(AST_If, function(self2, tw) {
  self2.condition = self2.condition.transform(tw);
  self2.body = self2.body.transform(tw);
  if (self2.alternative) self2.alternative = self2.alternative.transform(tw);
});
def_transform(AST_Switch, function(self2, tw) {
  self2.expression = self2.expression.transform(tw);
  self2.body = MAP(self2.body, tw);
});
def_transform(AST_Case, function(self2, tw) {
  self2.expression = self2.expression.transform(tw);
  self2.body = MAP(self2.body, tw);
});
def_transform(AST_Try, function(self2, tw) {
  self2.body = self2.body.transform(tw);
  if (self2.bcatch) self2.bcatch = self2.bcatch.transform(tw);
  if (self2.bfinally) self2.bfinally = self2.bfinally.transform(tw);
});
def_transform(AST_Catch, function(self2, tw) {
  if (self2.argname) self2.argname = self2.argname.transform(tw);
  self2.body = MAP(self2.body, tw);
});
def_transform(AST_Definitions, function(self2, tw) {
  self2.definitions = MAP(self2.definitions, tw);
});
def_transform(AST_VarDef, function(self2, tw) {
  self2.name = self2.name.transform(tw);
  if (self2.value) self2.value = self2.value.transform(tw);
});
def_transform(AST_Destructuring, function(self2, tw) {
  self2.names = MAP(self2.names, tw);
});
def_transform(AST_Lambda, function(self2, tw) {
  if (self2.name) self2.name = self2.name.transform(tw);
  self2.argnames = MAP(
    self2.argnames,
    tw,
    /* allow_splicing */
    false
  );
  if (self2.body instanceof AST_Node) {
    self2.body = self2.body.transform(tw);
  } else {
    self2.body = MAP(self2.body, tw);
  }
});
def_transform(AST_Call, function(self2, tw) {
  self2.expression = self2.expression.transform(tw);
  self2.args = MAP(
    self2.args,
    tw,
    /* allow_splicing */
    false
  );
});
def_transform(AST_Sequence, function(self2, tw) {
  const result = MAP(self2.expressions, tw);
  self2.expressions = result.length ? result : [new AST_Number({ value: 0 })];
});
def_transform(AST_PropAccess, function(self2, tw) {
  self2.expression = self2.expression.transform(tw);
});
def_transform(AST_Sub, function(self2, tw) {
  self2.expression = self2.expression.transform(tw);
  self2.property = self2.property.transform(tw);
});
def_transform(AST_Chain, function(self2, tw) {
  self2.expression = self2.expression.transform(tw);
});
def_transform(AST_Yield, function(self2, tw) {
  if (self2.expression) self2.expression = self2.expression.transform(tw);
});
def_transform(AST_Await, function(self2, tw) {
  self2.expression = self2.expression.transform(tw);
});
def_transform(AST_Unary, function(self2, tw) {
  self2.expression = self2.expression.transform(tw);
});
def_transform(AST_Binary, function(self2, tw) {
  self2.left = self2.left.transform(tw);
  self2.right = self2.right.transform(tw);
});
def_transform(AST_PrivateIn, function(self2, tw) {
  self2.key = self2.key.transform(tw);
  self2.value = self2.value.transform(tw);
});
def_transform(AST_Conditional, function(self2, tw) {
  self2.condition = self2.condition.transform(tw);
  self2.consequent = self2.consequent.transform(tw);
  self2.alternative = self2.alternative.transform(tw);
});
def_transform(AST_Array, function(self2, tw) {
  self2.elements = MAP(self2.elements, tw);
});
def_transform(AST_Object, function(self2, tw) {
  self2.properties = MAP(self2.properties, tw);
});
def_transform(AST_ObjectProperty, function(self2, tw) {
  if (self2.key instanceof AST_Node) {
    self2.key = self2.key.transform(tw);
  }
  if (self2.value) self2.value = self2.value.transform(tw);
});
def_transform(AST_Class, function(self2, tw) {
  if (self2.name) self2.name = self2.name.transform(tw);
  if (self2.extends) self2.extends = self2.extends.transform(tw);
  self2.properties = MAP(self2.properties, tw);
});
def_transform(AST_ClassStaticBlock, function(self2, tw) {
  self2.body = MAP(self2.body, tw);
});
def_transform(AST_Expansion, function(self2, tw) {
  self2.expression = self2.expression.transform(tw);
});
def_transform(AST_NameMapping, function(self2, tw) {
  self2.foreign_name = self2.foreign_name.transform(tw);
  self2.name = self2.name.transform(tw);
});
def_transform(AST_Import, function(self2, tw) {
  if (self2.imported_name) self2.imported_name = self2.imported_name.transform(tw);
  if (self2.imported_names) MAP(self2.imported_names, tw);
  self2.module_name = self2.module_name.transform(tw);
});
def_transform(AST_Export, function(self2, tw) {
  if (self2.exported_definition) self2.exported_definition = self2.exported_definition.transform(tw);
  if (self2.exported_value) self2.exported_value = self2.exported_value.transform(tw);
  if (self2.exported_names) MAP(self2.exported_names, tw);
  if (self2.module_name) self2.module_name = self2.module_name.transform(tw);
});
def_transform(AST_TemplateString, function(self2, tw) {
  self2.segments = MAP(self2.segments, tw);
});
def_transform(AST_PrefixedTemplateString, function(self2, tw) {
  self2.prefix = self2.prefix.transform(tw);
  self2.template_string = self2.template_string.transform(tw);
});

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/mozilla-ast.js
(function() {
  var normalize_directives = function(body) {
    for (var i = 0; i < body.length; i++) {
      if (body[i] instanceof AST_Statement && body[i].body instanceof AST_String) {
        body[i] = new AST_Directive({
          start: body[i].start,
          end: body[i].end,
          value: body[i].body.value
        });
      } else {
        return body;
      }
    }
    return body;
  };
  function import_attributes_from_moz(attributes) {
    if (attributes && attributes.length > 0) {
      return new AST_Object({
        start: my_start_token(attributes),
        end: my_end_token(attributes),
        properties: attributes.map(
          (attr) => new AST_ObjectKeyVal({
            start: my_start_token(attr),
            end: my_end_token(attr),
            key: attr.key.name || attr.key.value,
            value: from_moz(attr.value)
          })
        )
      });
    }
    return null;
  }
  var MOZ_TO_ME = {
    Program: function(M2) {
      return new AST_Toplevel({
        start: my_start_token(M2),
        end: my_end_token(M2),
        body: normalize_directives(M2.body.map(from_moz))
      });
    },
    ArrayPattern: function(M2) {
      return new AST_Destructuring({
        start: my_start_token(M2),
        end: my_end_token(M2),
        names: M2.elements.map(function(elm) {
          if (elm === null) {
            return new AST_Hole();
          }
          return from_moz(elm);
        }),
        is_array: true
      });
    },
    ObjectPattern: function(M2) {
      return new AST_Destructuring({
        start: my_start_token(M2),
        end: my_end_token(M2),
        names: M2.properties.map(from_moz),
        is_array: false
      });
    },
    AssignmentPattern: function(M2) {
      return new AST_DefaultAssign({
        start: my_start_token(M2),
        end: my_end_token(M2),
        left: from_moz(M2.left),
        operator: "=",
        right: from_moz(M2.right)
      });
    },
    SpreadElement: function(M2) {
      return new AST_Expansion({
        start: my_start_token(M2),
        end: my_end_token(M2),
        expression: from_moz(M2.argument)
      });
    },
    RestElement: function(M2) {
      return new AST_Expansion({
        start: my_start_token(M2),
        end: my_end_token(M2),
        expression: from_moz(M2.argument)
      });
    },
    TemplateElement: function(M2) {
      return new AST_TemplateSegment({
        start: my_start_token(M2),
        end: my_end_token(M2),
        value: M2.value.cooked,
        raw: M2.value.raw
      });
    },
    TemplateLiteral: function(M2) {
      var segments = [];
      for (var i = 0; i < M2.quasis.length; i++) {
        segments.push(from_moz(M2.quasis[i]));
        if (M2.expressions[i]) {
          segments.push(from_moz(M2.expressions[i]));
        }
      }
      return new AST_TemplateString({
        start: my_start_token(M2),
        end: my_end_token(M2),
        segments
      });
    },
    TaggedTemplateExpression: function(M2) {
      return new AST_PrefixedTemplateString({
        start: my_start_token(M2),
        end: my_end_token(M2),
        template_string: from_moz(M2.quasi),
        prefix: from_moz(M2.tag)
      });
    },
    FunctionDeclaration: function(M2) {
      return new AST_Defun({
        start: my_start_token(M2),
        end: my_end_token(M2),
        name: from_moz(M2.id),
        argnames: M2.params.map(from_moz),
        is_generator: M2.generator,
        async: M2.async,
        body: normalize_directives(from_moz(M2.body).body)
      });
    },
    FunctionExpression: function(M2) {
      return new AST_Function({
        start: my_start_token(M2),
        end: my_end_token(M2),
        name: from_moz(M2.id),
        argnames: M2.params.map(from_moz),
        is_generator: M2.generator,
        async: M2.async,
        body: normalize_directives(from_moz(M2.body).body)
      });
    },
    ArrowFunctionExpression: function(M2) {
      const body = M2.body.type === "BlockStatement" ? from_moz(M2.body).body : [make_node(AST_Return, {}, { value: from_moz(M2.body) })];
      return new AST_Arrow({
        start: my_start_token(M2),
        end: my_end_token(M2),
        argnames: M2.params.map(from_moz),
        body,
        async: M2.async
      });
    },
    ExpressionStatement: function(M2) {
      return new AST_SimpleStatement({
        start: my_start_token(M2),
        end: my_end_token(M2),
        body: from_moz(M2.expression)
      });
    },
    TryStatement: function(M2) {
      var handlers = M2.handlers || [M2.handler];
      if (handlers.length > 1 || M2.guardedHandlers && M2.guardedHandlers.length) {
        throw new Error("Multiple catch clauses are not supported.");
      }
      return new AST_Try({
        start: my_start_token(M2),
        end: my_end_token(M2),
        body: new AST_TryBlock(from_moz(M2.block)),
        bcatch: from_moz(handlers[0]),
        bfinally: M2.finalizer ? new AST_Finally(from_moz(M2.finalizer)) : null
      });
    },
    Property: function(M2) {
      var key = M2.key;
      var args2 = {
        start: my_start_token(key || M2.value),
        end: my_end_token(M2.value),
        key: key.type == "Identifier" ? key.name : key.value,
        value: from_moz(M2.value)
      };
      if (M2.computed) {
        args2.key = from_moz(M2.key);
      }
      if (M2.method) {
        args2.is_generator = M2.value.generator;
        args2.async = M2.value.async;
        if (!M2.computed) {
          args2.key = new AST_SymbolMethod({ name: args2.key });
        } else {
          args2.key = from_moz(M2.key);
        }
        return new AST_ConciseMethod(args2);
      }
      if (M2.kind == "init") {
        if (key.type != "Identifier" && key.type != "Literal") {
          args2.key = from_moz(key);
        }
        return new AST_ObjectKeyVal(args2);
      }
      if (typeof args2.key === "string" || typeof args2.key === "number") {
        args2.key = new AST_SymbolMethod({
          name: args2.key
        });
      }
      args2.value = new AST_Accessor(args2.value);
      if (M2.kind == "get") return new AST_ObjectGetter(args2);
      if (M2.kind == "set") return new AST_ObjectSetter(args2);
      if (M2.kind == "method") {
        args2.async = M2.value.async;
        args2.is_generator = M2.value.generator;
        args2.quote = M2.computed ? '"' : null;
        return new AST_ConciseMethod(args2);
      }
    },
    MethodDefinition: function(M2) {
      const is_private = M2.key.type === "PrivateIdentifier";
      const key = M2.computed ? from_moz(M2.key) : new AST_SymbolMethod({ name: M2.key.name || M2.key.value });
      var args2 = {
        start: my_start_token(M2),
        end: my_end_token(M2),
        key,
        value: from_moz(M2.value),
        static: M2.static
      };
      if (M2.kind == "get") {
        return new (is_private ? AST_PrivateGetter : AST_ObjectGetter)(args2);
      }
      if (M2.kind == "set") {
        return new (is_private ? AST_PrivateSetter : AST_ObjectSetter)(args2);
      }
      args2.is_generator = M2.value.generator;
      args2.async = M2.value.async;
      return new (is_private ? AST_PrivateMethod : AST_ConciseMethod)(args2);
    },
    FieldDefinition: function(M2) {
      let key;
      if (M2.computed) {
        key = from_moz(M2.key);
      } else {
        if (M2.key.type !== "Identifier") throw new Error("Non-Identifier key in FieldDefinition");
        key = from_moz(M2.key);
      }
      return new AST_ClassProperty({
        start: my_start_token(M2),
        end: my_end_token(M2),
        key,
        value: from_moz(M2.value),
        static: M2.static
      });
    },
    PropertyDefinition: function(M2) {
      let key;
      if (M2.computed) {
        key = from_moz(M2.key);
      } else if (M2.key.type === "PrivateIdentifier") {
        return new AST_ClassPrivateProperty({
          start: my_start_token(M2),
          end: my_end_token(M2),
          key: from_moz(M2.key),
          value: from_moz(M2.value),
          static: M2.static
        });
      } else {
        if (M2.key.type !== "Identifier") {
          throw new Error("Non-Identifier key in PropertyDefinition");
        }
        key = from_moz(M2.key);
      }
      return new AST_ClassProperty({
        start: my_start_token(M2),
        end: my_end_token(M2),
        key,
        value: from_moz(M2.value),
        static: M2.static
      });
    },
    PrivateIdentifier: function(M2) {
      return new AST_SymbolPrivateProperty({
        start: my_start_token(M2),
        end: my_end_token(M2),
        name: M2.name
      });
    },
    StaticBlock: function(M2) {
      return new AST_ClassStaticBlock({
        start: my_start_token(M2),
        end: my_end_token(M2),
        body: M2.body.map(from_moz)
      });
    },
    ArrayExpression: function(M2) {
      return new AST_Array({
        start: my_start_token(M2),
        end: my_end_token(M2),
        elements: M2.elements.map(function(elem) {
          return elem === null ? new AST_Hole() : from_moz(elem);
        })
      });
    },
    ObjectExpression: function(M2) {
      return new AST_Object({
        start: my_start_token(M2),
        end: my_end_token(M2),
        properties: M2.properties.map(function(prop) {
          if (prop.type === "SpreadElement") {
            return from_moz(prop);
          }
          prop.type = "Property";
          return from_moz(prop);
        })
      });
    },
    SequenceExpression: function(M2) {
      return new AST_Sequence({
        start: my_start_token(M2),
        end: my_end_token(M2),
        expressions: M2.expressions.map(from_moz)
      });
    },
    MemberExpression: function(M2) {
      if (M2.property.type === "PrivateIdentifier") {
        return new AST_DotHash({
          start: my_start_token(M2),
          end: my_end_token(M2),
          property: M2.property.name,
          expression: from_moz(M2.object),
          optional: M2.optional || false
        });
      }
      return new (M2.computed ? AST_Sub : AST_Dot)({
        start: my_start_token(M2),
        end: my_end_token(M2),
        property: M2.computed ? from_moz(M2.property) : M2.property.name,
        expression: from_moz(M2.object),
        optional: M2.optional || false
      });
    },
    ChainExpression: function(M2) {
      return new AST_Chain({
        start: my_start_token(M2),
        end: my_end_token(M2),
        expression: from_moz(M2.expression)
      });
    },
    SwitchCase: function(M2) {
      return new (M2.test ? AST_Case : AST_Default)({
        start: my_start_token(M2),
        end: my_end_token(M2),
        expression: from_moz(M2.test),
        body: M2.consequent.map(from_moz)
      });
    },
    VariableDeclaration: function(M2) {
      return new (M2.kind === "const" ? AST_Const : M2.kind === "let" ? AST_Let : AST_Var)({
        start: my_start_token(M2),
        end: my_end_token(M2),
        definitions: M2.declarations.map(from_moz)
      });
    },
    ImportDeclaration: function(M2) {
      var imported_name = null;
      var imported_names = null;
      M2.specifiers.forEach(function(specifier) {
        if (specifier.type === "ImportSpecifier" || specifier.type === "ImportNamespaceSpecifier") {
          if (!imported_names) {
            imported_names = [];
          }
          imported_names.push(from_moz(specifier));
        } else if (specifier.type === "ImportDefaultSpecifier") {
          imported_name = from_moz(specifier);
        }
      });
      return new AST_Import({
        start: my_start_token(M2),
        end: my_end_token(M2),
        imported_name,
        imported_names,
        module_name: from_moz(M2.source),
        attributes: import_attributes_from_moz(M2.attributes || M2.assertions)
      });
    },
    ImportSpecifier: function(M2) {
      return new AST_NameMapping({
        start: my_start_token(M2),
        end: my_end_token(M2),
        foreign_name: from_moz(M2.imported),
        name: from_moz(M2.local)
      });
    },
    ImportDefaultSpecifier: function(M2) {
      return from_moz(M2.local);
    },
    ImportNamespaceSpecifier: function(M2) {
      return new AST_NameMapping({
        start: my_start_token(M2),
        end: my_end_token(M2),
        foreign_name: new AST_SymbolImportForeign({ name: "*" }),
        name: from_moz(M2.local)
      });
    },
    ImportExpression: function(M2) {
      const args2 = [from_moz(M2.source)];
      if (M2.options) {
        args2.push(from_moz(M2.options));
      }
      return new AST_Call({
        start: my_start_token(M2),
        end: my_end_token(M2),
        expression: from_moz({
          type: "Identifier",
          name: "import"
        }),
        optional: false,
        args: args2
      });
    },
    ExportAllDeclaration: function(M2) {
      var foreign_name = M2.exported == null ? new AST_SymbolExportForeign({ name: "*" }) : from_moz(M2.exported);
      return new AST_Export({
        start: my_start_token(M2),
        end: my_end_token(M2),
        exported_names: [
          new AST_NameMapping({
            name: new AST_SymbolExportForeign({ name: "*" }),
            foreign_name
          })
        ],
        module_name: from_moz(M2.source),
        attributes: import_attributes_from_moz(M2.attributes || M2.assertions)
      });
    },
    ExportNamedDeclaration: function(M2) {
      return new AST_Export({
        start: my_start_token(M2),
        end: my_end_token(M2),
        exported_definition: from_moz(M2.declaration),
        exported_names: M2.specifiers && M2.specifiers.length ? M2.specifiers.map(from_moz) : null,
        module_name: from_moz(M2.source),
        attributes: import_attributes_from_moz(M2.attributes || M2.assertions)
      });
    },
    ExportDefaultDeclaration: function(M2) {
      return new AST_Export({
        start: my_start_token(M2),
        end: my_end_token(M2),
        exported_value: from_moz(M2.declaration),
        is_default: true
      });
    },
    ExportSpecifier: function(M2) {
      return new AST_NameMapping({
        foreign_name: from_moz(M2.exported),
        name: from_moz(M2.local)
      });
    },
    Literal: function(M2) {
      var val = M2.value, args2 = {
        start: my_start_token(M2),
        end: my_end_token(M2)
      };
      var rx = M2.regex;
      if (rx && rx.pattern) {
        args2.value = {
          source: rx.pattern,
          flags: rx.flags
        };
        return new AST_RegExp(args2);
      } else if (rx) {
        const rx_source = M2.raw || val;
        const match18 = rx_source.match(/^\/(.*)\/(\w*)$/);
        if (!match18) throw new Error("Invalid regex source " + rx_source);
        const [_2, source, flags] = match18;
        args2.value = { source, flags };
        return new AST_RegExp(args2);
      }
      const bi = typeof M2.value === "bigint" ? M2.value.toString() : M2.bigint;
      if (typeof bi === "string") {
        args2.value = bi;
        return new AST_BigInt(args2);
      }
      if (val === null) return new AST_Null(args2);
      switch (typeof val) {
        case "string":
          args2.quote = '"';
          var p3 = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];
          if (p3.type == "ImportSpecifier") {
            args2.name = val;
            return new AST_SymbolImportForeign(args2);
          } else if (p3.type == "ExportSpecifier") {
            args2.name = val;
            if (M2 == p3.exported) {
              return new AST_SymbolExportForeign(args2);
            } else {
              return new AST_SymbolExport(args2);
            }
          } else if (p3.type == "ExportAllDeclaration" && M2 == p3.exported) {
            args2.name = val;
            return new AST_SymbolExportForeign(args2);
          }
          args2.value = val;
          return new AST_String(args2);
        case "number":
          args2.value = val;
          args2.raw = M2.raw || val.toString();
          return new AST_Number(args2);
        case "boolean":
          return new (val ? AST_True : AST_False)(args2);
      }
    },
    MetaProperty: function(M2) {
      if (M2.meta.name === "new" && M2.property.name === "target") {
        return new AST_NewTarget({
          start: my_start_token(M2),
          end: my_end_token(M2)
        });
      } else if (M2.meta.name === "import" && M2.property.name === "meta") {
        return new AST_ImportMeta({
          start: my_start_token(M2),
          end: my_end_token(M2)
        });
      }
    },
    Identifier: function(M2) {
      var p3 = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];
      return new (p3.type == "LabeledStatement" ? AST_Label : p3.type == "VariableDeclarator" && p3.id === M2 ? p3.kind == "const" ? AST_SymbolConst : p3.kind == "let" ? AST_SymbolLet : AST_SymbolVar : /Import.*Specifier/.test(p3.type) ? p3.local === M2 ? AST_SymbolImport : AST_SymbolImportForeign : p3.type == "ExportSpecifier" ? p3.local === M2 ? AST_SymbolExport : AST_SymbolExportForeign : p3.type == "FunctionExpression" ? p3.id === M2 ? AST_SymbolLambda : AST_SymbolFunarg : p3.type == "FunctionDeclaration" ? p3.id === M2 ? AST_SymbolDefun : AST_SymbolFunarg : p3.type == "ArrowFunctionExpression" ? p3.params.includes(M2) ? AST_SymbolFunarg : AST_SymbolRef : p3.type == "ClassExpression" ? p3.id === M2 ? AST_SymbolClass : AST_SymbolRef : p3.type == "Property" ? p3.key === M2 && p3.computed || p3.value === M2 ? AST_SymbolRef : AST_SymbolMethod : p3.type == "PropertyDefinition" || p3.type === "FieldDefinition" ? p3.key === M2 && p3.computed || p3.value === M2 ? AST_SymbolRef : AST_SymbolClassProperty : p3.type == "ClassDeclaration" ? p3.id === M2 ? AST_SymbolDefClass : AST_SymbolRef : p3.type == "MethodDefinition" ? p3.computed ? AST_SymbolRef : AST_SymbolMethod : p3.type == "CatchClause" ? AST_SymbolCatch : p3.type == "BreakStatement" || p3.type == "ContinueStatement" ? AST_LabelRef : AST_SymbolRef)({
        start: my_start_token(M2),
        end: my_end_token(M2),
        name: M2.name
      });
    },
    EmptyStatement: function(M2) {
      return new AST_EmptyStatement({
        start: my_start_token(M2),
        end: my_end_token(M2)
      });
    },
    BlockStatement: function(M2) {
      return new AST_BlockStatement({
        start: my_start_token(M2),
        end: my_end_token(M2),
        body: M2.body.map(from_moz)
      });
    },
    IfStatement: function(M2) {
      return new AST_If({
        start: my_start_token(M2),
        end: my_end_token(M2),
        condition: from_moz(M2.test),
        body: from_moz(M2.consequent),
        alternative: from_moz(M2.alternate)
      });
    },
    LabeledStatement: function(M2) {
      return new AST_LabeledStatement({
        start: my_start_token(M2),
        end: my_end_token(M2),
        label: from_moz(M2.label),
        body: from_moz(M2.body)
      });
    },
    BreakStatement: function(M2) {
      return new AST_Break({
        start: my_start_token(M2),
        end: my_end_token(M2),
        label: from_moz(M2.label)
      });
    },
    ContinueStatement: function(M2) {
      return new AST_Continue({
        start: my_start_token(M2),
        end: my_end_token(M2),
        label: from_moz(M2.label)
      });
    },
    WithStatement: function(M2) {
      return new AST_With({
        start: my_start_token(M2),
        end: my_end_token(M2),
        expression: from_moz(M2.object),
        body: from_moz(M2.body)
      });
    },
    SwitchStatement: function(M2) {
      return new AST_Switch({
        start: my_start_token(M2),
        end: my_end_token(M2),
        expression: from_moz(M2.discriminant),
        body: M2.cases.map(from_moz)
      });
    },
    ReturnStatement: function(M2) {
      return new AST_Return({
        start: my_start_token(M2),
        end: my_end_token(M2),
        value: from_moz(M2.argument)
      });
    },
    ThrowStatement: function(M2) {
      return new AST_Throw({
        start: my_start_token(M2),
        end: my_end_token(M2),
        value: from_moz(M2.argument)
      });
    },
    WhileStatement: function(M2) {
      return new AST_While({
        start: my_start_token(M2),
        end: my_end_token(M2),
        condition: from_moz(M2.test),
        body: from_moz(M2.body)
      });
    },
    DoWhileStatement: function(M2) {
      return new AST_Do({
        start: my_start_token(M2),
        end: my_end_token(M2),
        condition: from_moz(M2.test),
        body: from_moz(M2.body)
      });
    },
    ForStatement: function(M2) {
      return new AST_For({
        start: my_start_token(M2),
        end: my_end_token(M2),
        init: from_moz(M2.init),
        condition: from_moz(M2.test),
        step: from_moz(M2.update),
        body: from_moz(M2.body)
      });
    },
    ForInStatement: function(M2) {
      return new AST_ForIn({
        start: my_start_token(M2),
        end: my_end_token(M2),
        init: from_moz(M2.left),
        object: from_moz(M2.right),
        body: from_moz(M2.body)
      });
    },
    ForOfStatement: function(M2) {
      return new AST_ForOf({
        start: my_start_token(M2),
        end: my_end_token(M2),
        init: from_moz(M2.left),
        object: from_moz(M2.right),
        body: from_moz(M2.body),
        await: M2.await
      });
    },
    AwaitExpression: function(M2) {
      return new AST_Await({
        start: my_start_token(M2),
        end: my_end_token(M2),
        expression: from_moz(M2.argument)
      });
    },
    YieldExpression: function(M2) {
      return new AST_Yield({
        start: my_start_token(M2),
        end: my_end_token(M2),
        expression: from_moz(M2.argument),
        is_star: M2.delegate
      });
    },
    DebuggerStatement: function(M2) {
      return new AST_Debugger({
        start: my_start_token(M2),
        end: my_end_token(M2)
      });
    },
    VariableDeclarator: function(M2) {
      return new AST_VarDef({
        start: my_start_token(M2),
        end: my_end_token(M2),
        name: from_moz(M2.id),
        value: from_moz(M2.init)
      });
    },
    CatchClause: function(M2) {
      return new AST_Catch({
        start: my_start_token(M2),
        end: my_end_token(M2),
        argname: from_moz(M2.param),
        body: from_moz(M2.body).body
      });
    },
    ThisExpression: function(M2) {
      return new AST_This({
        start: my_start_token(M2),
        end: my_end_token(M2)
      });
    },
    Super: function(M2) {
      return new AST_Super({
        start: my_start_token(M2),
        end: my_end_token(M2)
      });
    },
    BinaryExpression: function(M2) {
      if (M2.left.type === "PrivateIdentifier") {
        return new AST_PrivateIn({
          start: my_start_token(M2),
          end: my_end_token(M2),
          key: new AST_SymbolPrivateProperty({
            start: my_start_token(M2.left),
            end: my_end_token(M2.left),
            name: M2.left.name
          }),
          value: from_moz(M2.right)
        });
      }
      return new AST_Binary({
        start: my_start_token(M2),
        end: my_end_token(M2),
        operator: M2.operator,
        left: from_moz(M2.left),
        right: from_moz(M2.right)
      });
    },
    LogicalExpression: function(M2) {
      return new AST_Binary({
        start: my_start_token(M2),
        end: my_end_token(M2),
        operator: M2.operator,
        left: from_moz(M2.left),
        right: from_moz(M2.right)
      });
    },
    AssignmentExpression: function(M2) {
      return new AST_Assign({
        start: my_start_token(M2),
        end: my_end_token(M2),
        operator: M2.operator,
        left: from_moz(M2.left),
        right: from_moz(M2.right)
      });
    },
    ConditionalExpression: function(M2) {
      return new AST_Conditional({
        start: my_start_token(M2),
        end: my_end_token(M2),
        condition: from_moz(M2.test),
        consequent: from_moz(M2.consequent),
        alternative: from_moz(M2.alternate)
      });
    },
    NewExpression: function(M2) {
      return new AST_New({
        start: my_start_token(M2),
        end: my_end_token(M2),
        expression: from_moz(M2.callee),
        args: M2.arguments.map(from_moz)
      });
    },
    CallExpression: function(M2) {
      return new AST_Call({
        start: my_start_token(M2),
        end: my_end_token(M2),
        expression: from_moz(M2.callee),
        optional: M2.optional,
        args: M2.arguments.map(from_moz)
      });
    }
  };
  MOZ_TO_ME.UpdateExpression = MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M2) {
    var prefix = "prefix" in M2 ? M2.prefix : M2.type == "UnaryExpression" ? true : false;
    return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({
      start: my_start_token(M2),
      end: my_end_token(M2),
      operator: M2.operator,
      expression: from_moz(M2.argument)
    });
  };
  MOZ_TO_ME.ClassDeclaration = MOZ_TO_ME.ClassExpression = function From_Moz_Class(M2) {
    return new (M2.type === "ClassDeclaration" ? AST_DefClass : AST_ClassExpression)({
      start: my_start_token(M2),
      end: my_end_token(M2),
      name: from_moz(M2.id),
      extends: from_moz(M2.superClass),
      properties: M2.body.body.map(from_moz)
    });
  };
  def_to_moz(AST_EmptyStatement, function To_Moz_EmptyStatement() {
    return {
      type: "EmptyStatement"
    };
  });
  def_to_moz(AST_BlockStatement, function To_Moz_BlockStatement(M2) {
    return {
      type: "BlockStatement",
      body: M2.body.map(to_moz)
    };
  });
  def_to_moz(AST_If, function To_Moz_IfStatement(M2) {
    return {
      type: "IfStatement",
      test: to_moz(M2.condition),
      consequent: to_moz(M2.body),
      alternate: to_moz(M2.alternative)
    };
  });
  def_to_moz(AST_LabeledStatement, function To_Moz_LabeledStatement(M2) {
    return {
      type: "LabeledStatement",
      label: to_moz(M2.label),
      body: to_moz(M2.body)
    };
  });
  def_to_moz(AST_Break, function To_Moz_BreakStatement(M2) {
    return {
      type: "BreakStatement",
      label: to_moz(M2.label)
    };
  });
  def_to_moz(AST_Continue, function To_Moz_ContinueStatement(M2) {
    return {
      type: "ContinueStatement",
      label: to_moz(M2.label)
    };
  });
  def_to_moz(AST_With, function To_Moz_WithStatement(M2) {
    return {
      type: "WithStatement",
      object: to_moz(M2.expression),
      body: to_moz(M2.body)
    };
  });
  def_to_moz(AST_Switch, function To_Moz_SwitchStatement(M2) {
    return {
      type: "SwitchStatement",
      discriminant: to_moz(M2.expression),
      cases: M2.body.map(to_moz)
    };
  });
  def_to_moz(AST_Return, function To_Moz_ReturnStatement(M2) {
    return {
      type: "ReturnStatement",
      argument: to_moz(M2.value)
    };
  });
  def_to_moz(AST_Throw, function To_Moz_ThrowStatement(M2) {
    return {
      type: "ThrowStatement",
      argument: to_moz(M2.value)
    };
  });
  def_to_moz(AST_While, function To_Moz_WhileStatement(M2) {
    return {
      type: "WhileStatement",
      test: to_moz(M2.condition),
      body: to_moz(M2.body)
    };
  });
  def_to_moz(AST_Do, function To_Moz_DoWhileStatement(M2) {
    return {
      type: "DoWhileStatement",
      test: to_moz(M2.condition),
      body: to_moz(M2.body)
    };
  });
  def_to_moz(AST_For, function To_Moz_ForStatement(M2) {
    return {
      type: "ForStatement",
      init: to_moz(M2.init),
      test: to_moz(M2.condition),
      update: to_moz(M2.step),
      body: to_moz(M2.body)
    };
  });
  def_to_moz(AST_ForIn, function To_Moz_ForInStatement(M2) {
    return {
      type: "ForInStatement",
      left: to_moz(M2.init),
      right: to_moz(M2.object),
      body: to_moz(M2.body)
    };
  });
  def_to_moz(AST_ForOf, function To_Moz_ForOfStatement(M2) {
    return {
      type: "ForOfStatement",
      left: to_moz(M2.init),
      right: to_moz(M2.object),
      body: to_moz(M2.body),
      await: M2.await
    };
  });
  def_to_moz(AST_Await, function To_Moz_AwaitExpression(M2) {
    return {
      type: "AwaitExpression",
      argument: to_moz(M2.expression)
    };
  });
  def_to_moz(AST_Yield, function To_Moz_YieldExpression(M2) {
    return {
      type: "YieldExpression",
      argument: to_moz(M2.expression),
      delegate: M2.is_star
    };
  });
  def_to_moz(AST_Debugger, function To_Moz_DebuggerStatement() {
    return {
      type: "DebuggerStatement"
    };
  });
  def_to_moz(AST_VarDef, function To_Moz_VariableDeclarator(M2) {
    return {
      type: "VariableDeclarator",
      id: to_moz(M2.name),
      init: to_moz(M2.value)
    };
  });
  def_to_moz(AST_Catch, function To_Moz_CatchClause(M2) {
    return {
      type: "CatchClause",
      param: to_moz(M2.argname),
      body: to_moz_block(M2)
    };
  });
  def_to_moz(AST_This, function To_Moz_ThisExpression() {
    return {
      type: "ThisExpression"
    };
  });
  def_to_moz(AST_Super, function To_Moz_Super() {
    return {
      type: "Super"
    };
  });
  def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M2) {
    return {
      type: "BinaryExpression",
      operator: M2.operator,
      left: to_moz(M2.left),
      right: to_moz(M2.right)
    };
  });
  def_to_moz(AST_Binary, function To_Moz_LogicalExpression(M2) {
    return {
      type: "LogicalExpression",
      operator: M2.operator,
      left: to_moz(M2.left),
      right: to_moz(M2.right)
    };
  });
  def_to_moz(AST_Assign, function To_Moz_AssignmentExpression(M2) {
    return {
      type: "AssignmentExpression",
      operator: M2.operator,
      left: to_moz(M2.left),
      right: to_moz(M2.right)
    };
  });
  def_to_moz(AST_Conditional, function To_Moz_ConditionalExpression(M2) {
    return {
      type: "ConditionalExpression",
      test: to_moz(M2.condition),
      consequent: to_moz(M2.consequent),
      alternate: to_moz(M2.alternative)
    };
  });
  def_to_moz(AST_New, function To_Moz_NewExpression(M2) {
    return {
      type: "NewExpression",
      callee: to_moz(M2.expression),
      arguments: M2.args.map(to_moz)
    };
  });
  def_to_moz(AST_Call, function To_Moz_CallExpression(M2) {
    if (M2.expression instanceof AST_SymbolRef && M2.expression.name === "import") {
      const [source, options] = M2.args.map(to_moz);
      return {
        type: "ImportExpression",
        source,
        options
      };
    }
    return {
      type: "CallExpression",
      callee: to_moz(M2.expression),
      optional: M2.optional,
      arguments: M2.args.map(to_moz)
    };
  });
  def_to_moz(AST_Toplevel, function To_Moz_Program(M2) {
    return to_moz_scope("Program", M2);
  });
  def_to_moz(AST_Expansion, function To_Moz_Spread(M2) {
    return {
      type: to_moz_in_destructuring() ? "RestElement" : "SpreadElement",
      argument: to_moz(M2.expression)
    };
  });
  def_to_moz(AST_PrefixedTemplateString, function To_Moz_TaggedTemplateExpression(M2) {
    return {
      type: "TaggedTemplateExpression",
      tag: to_moz(M2.prefix),
      quasi: to_moz(M2.template_string)
    };
  });
  def_to_moz(AST_TemplateString, function To_Moz_TemplateLiteral(M2) {
    var quasis = [];
    var expressions = [];
    for (var i = 0; i < M2.segments.length; i++) {
      if (i % 2 !== 0) {
        expressions.push(to_moz(M2.segments[i]));
      } else {
        quasis.push({
          type: "TemplateElement",
          value: {
            raw: M2.segments[i].raw,
            cooked: M2.segments[i].value
          },
          tail: i === M2.segments.length - 1
        });
      }
    }
    return {
      type: "TemplateLiteral",
      quasis,
      expressions
    };
  });
  def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M2) {
    return {
      type: "FunctionDeclaration",
      id: to_moz(M2.name),
      params: M2.argnames.map(to_moz),
      generator: M2.is_generator,
      async: M2.async,
      body: to_moz_scope("BlockStatement", M2)
    };
  });
  def_to_moz(AST_Function, function To_Moz_FunctionExpression(M2, parent) {
    var is_generator = parent.is_generator !== void 0 ? parent.is_generator : M2.is_generator;
    return {
      type: "FunctionExpression",
      id: to_moz(M2.name),
      params: M2.argnames.map(to_moz),
      generator: is_generator,
      async: M2.async,
      body: to_moz_scope("BlockStatement", M2)
    };
  });
  def_to_moz(AST_Arrow, function To_Moz_ArrowFunctionExpression(M2) {
    var body = {
      type: "BlockStatement",
      body: M2.body.map(to_moz)
    };
    return {
      type: "ArrowFunctionExpression",
      params: M2.argnames.map(to_moz),
      async: M2.async,
      body
    };
  });
  def_to_moz(AST_Destructuring, function To_Moz_ObjectPattern(M2) {
    if (M2.is_array) {
      return {
        type: "ArrayPattern",
        elements: M2.names.map(to_moz)
      };
    }
    return {
      type: "ObjectPattern",
      properties: M2.names.map(to_moz)
    };
  });
  def_to_moz(AST_Directive, function To_Moz_Directive(M2) {
    return {
      type: "ExpressionStatement",
      expression: {
        type: "Literal",
        value: M2.value,
        raw: M2.print_to_string()
      },
      directive: M2.value
    };
  });
  def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M2) {
    return {
      type: "ExpressionStatement",
      expression: to_moz(M2.body)
    };
  });
  def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M2) {
    return {
      type: "SwitchCase",
      test: to_moz(M2.expression),
      consequent: M2.body.map(to_moz)
    };
  });
  def_to_moz(AST_Try, function To_Moz_TryStatement(M2) {
    return {
      type: "TryStatement",
      block: to_moz_block(M2.body),
      handler: to_moz(M2.bcatch),
      guardedHandlers: [],
      finalizer: to_moz(M2.bfinally)
    };
  });
  def_to_moz(AST_Catch, function To_Moz_CatchClause(M2) {
    return {
      type: "CatchClause",
      param: to_moz(M2.argname),
      guard: null,
      body: to_moz_block(M2)
    };
  });
  def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M2) {
    return {
      type: "VariableDeclaration",
      kind: M2 instanceof AST_Const ? "const" : M2 instanceof AST_Let ? "let" : "var",
      declarations: M2.definitions.map(to_moz)
    };
  });
  function import_attributes_to_moz(attribute) {
    const import_attributes = [];
    if (attribute) {
      for (const { key, value } of attribute.properties) {
        const key_moz = is_basic_identifier_string(key) ? { type: "Identifier", name: key } : { type: "Literal", value: key, raw: JSON.stringify(key) };
        import_attributes.push({
          type: "ImportAttribute",
          key: key_moz,
          value: to_moz(value)
        });
      }
    }
    return import_attributes;
  }
  def_to_moz(AST_Export, function To_Moz_ExportDeclaration(M2) {
    if (M2.exported_names) {
      var first_exported = M2.exported_names[0];
      var first_exported_name = first_exported.name;
      if (first_exported_name.name === "*" && !first_exported_name.quote) {
        var foreign_name = first_exported.foreign_name;
        var exported = foreign_name.name === "*" && !foreign_name.quote ? null : to_moz(foreign_name);
        return {
          type: "ExportAllDeclaration",
          source: to_moz(M2.module_name),
          exported,
          attributes: import_attributes_to_moz(M2.attributes)
        };
      }
      return {
        type: "ExportNamedDeclaration",
        specifiers: M2.exported_names.map(function(name_mapping) {
          return {
            type: "ExportSpecifier",
            exported: to_moz(name_mapping.foreign_name),
            local: to_moz(name_mapping.name)
          };
        }),
        declaration: to_moz(M2.exported_definition),
        source: to_moz(M2.module_name),
        attributes: import_attributes_to_moz(M2.attributes)
      };
    }
    return {
      type: M2.is_default ? "ExportDefaultDeclaration" : "ExportNamedDeclaration",
      declaration: to_moz(M2.exported_value || M2.exported_definition)
    };
  });
  def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M2) {
    var specifiers = [];
    if (M2.imported_name) {
      specifiers.push({
        type: "ImportDefaultSpecifier",
        local: to_moz(M2.imported_name)
      });
    }
    if (M2.imported_names) {
      var first_imported_foreign_name = M2.imported_names[0].foreign_name;
      if (first_imported_foreign_name.name === "*" && !first_imported_foreign_name.quote) {
        specifiers.push({
          type: "ImportNamespaceSpecifier",
          local: to_moz(M2.imported_names[0].name)
        });
      } else {
        M2.imported_names.forEach(function(name_mapping) {
          specifiers.push({
            type: "ImportSpecifier",
            local: to_moz(name_mapping.name),
            imported: to_moz(name_mapping.foreign_name)
          });
        });
      }
    }
    return {
      type: "ImportDeclaration",
      specifiers,
      source: to_moz(M2.module_name),
      attributes: import_attributes_to_moz(M2.attributes)
    };
  });
  def_to_moz(AST_ImportMeta, function To_Moz_MetaProperty() {
    return {
      type: "MetaProperty",
      meta: {
        type: "Identifier",
        name: "import"
      },
      property: {
        type: "Identifier",
        name: "meta"
      }
    };
  });
  def_to_moz(AST_Sequence, function To_Moz_SequenceExpression(M2) {
    return {
      type: "SequenceExpression",
      expressions: M2.expressions.map(to_moz)
    };
  });
  def_to_moz(AST_DotHash, function To_Moz_PrivateMemberExpression(M2) {
    return {
      type: "MemberExpression",
      object: to_moz(M2.expression),
      computed: false,
      property: {
        type: "PrivateIdentifier",
        name: M2.property
      },
      optional: M2.optional
    };
  });
  def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M2) {
    var isComputed = M2 instanceof AST_Sub;
    return {
      type: "MemberExpression",
      object: to_moz(M2.expression),
      computed: isComputed,
      property: isComputed ? to_moz(M2.property) : { type: "Identifier", name: M2.property },
      optional: M2.optional
    };
  });
  def_to_moz(AST_Chain, function To_Moz_ChainExpression(M2) {
    return {
      type: "ChainExpression",
      expression: to_moz(M2.expression)
    };
  });
  def_to_moz(AST_Unary, function To_Moz_Unary(M2) {
    return {
      type: M2.operator == "++" || M2.operator == "--" ? "UpdateExpression" : "UnaryExpression",
      operator: M2.operator,
      prefix: M2 instanceof AST_UnaryPrefix,
      argument: to_moz(M2.expression)
    };
  });
  def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M2) {
    if (M2.operator == "=" && to_moz_in_destructuring()) {
      return {
        type: "AssignmentPattern",
        left: to_moz(M2.left),
        right: to_moz(M2.right)
      };
    }
    const type = M2.operator == "&&" || M2.operator == "||" || M2.operator === "??" ? "LogicalExpression" : "BinaryExpression";
    return {
      type,
      left: to_moz(M2.left),
      operator: M2.operator,
      right: to_moz(M2.right)
    };
  });
  def_to_moz(AST_PrivateIn, function To_Moz_BinaryExpression_PrivateIn(M2) {
    return {
      type: "BinaryExpression",
      left: { type: "PrivateIdentifier", name: M2.key.name },
      operator: "in",
      right: to_moz(M2.value)
    };
  });
  def_to_moz(AST_Array, function To_Moz_ArrayExpression(M2) {
    return {
      type: "ArrayExpression",
      elements: M2.elements.map(to_moz)
    };
  });
  def_to_moz(AST_Object, function To_Moz_ObjectExpression(M2) {
    return {
      type: "ObjectExpression",
      properties: M2.properties.map(to_moz)
    };
  });
  def_to_moz(AST_ObjectProperty, function To_Moz_Property(M2, parent) {
    var key = M2.key instanceof AST_Node ? to_moz(M2.key) : {
      type: "Identifier",
      value: M2.key
    };
    if (typeof M2.key === "number") {
      key = {
        type: "Literal",
        value: Number(M2.key)
      };
    }
    if (typeof M2.key === "string") {
      key = {
        type: "Identifier",
        name: M2.key
      };
    }
    var kind;
    var string_or_num = typeof M2.key === "string" || typeof M2.key === "number";
    var computed = string_or_num ? false : !(M2.key instanceof AST_Symbol) || M2.key instanceof AST_SymbolRef;
    if (M2 instanceof AST_ObjectKeyVal) {
      kind = "init";
      computed = !string_or_num;
    } else if (M2 instanceof AST_ObjectGetter) {
      kind = "get";
    } else if (M2 instanceof AST_ObjectSetter) {
      kind = "set";
    }
    if (M2 instanceof AST_PrivateGetter || M2 instanceof AST_PrivateSetter) {
      const kind2 = M2 instanceof AST_PrivateGetter ? "get" : "set";
      return {
        type: "MethodDefinition",
        computed: false,
        kind: kind2,
        static: M2.static,
        key: {
          type: "PrivateIdentifier",
          name: M2.key.name
        },
        value: to_moz(M2.value)
      };
    }
    if (M2 instanceof AST_ClassPrivateProperty) {
      return {
        type: "PropertyDefinition",
        key: {
          type: "PrivateIdentifier",
          name: M2.key.name
        },
        value: to_moz(M2.value),
        computed: false,
        static: M2.static
      };
    }
    if (M2 instanceof AST_ClassProperty) {
      return {
        type: "PropertyDefinition",
        key,
        value: to_moz(M2.value),
        computed,
        static: M2.static
      };
    }
    if (parent instanceof AST_Class) {
      return {
        type: "MethodDefinition",
        computed,
        kind,
        static: M2.static,
        key: to_moz(M2.key),
        value: to_moz(M2.value)
      };
    }
    return {
      type: "Property",
      computed,
      kind,
      key,
      value: to_moz(M2.value)
    };
  });
  def_to_moz(AST_ConciseMethod, function To_Moz_MethodDefinition(M2, parent) {
    if (parent instanceof AST_Object) {
      return {
        type: "Property",
        computed: !(M2.key instanceof AST_Symbol) || M2.key instanceof AST_SymbolRef,
        kind: "init",
        method: true,
        shorthand: false,
        key: to_moz(M2.key),
        value: to_moz(M2.value)
      };
    }
    return {
      type: "MethodDefinition",
      kind: M2.key === "constructor" ? "constructor" : "method",
      key: to_moz(M2.key),
      value: to_moz(M2.value),
      computed: !(M2.key instanceof AST_Symbol) || M2.key instanceof AST_SymbolRef,
      static: M2.static
    };
  });
  def_to_moz(AST_PrivateMethod, function To_Moz_MethodDefinition(M2) {
    return {
      type: "MethodDefinition",
      kind: "method",
      key: { type: "PrivateIdentifier", name: M2.key.name },
      value: to_moz(M2.value),
      computed: false,
      static: M2.static
    };
  });
  def_to_moz(AST_Class, function To_Moz_Class(M2) {
    var type = M2 instanceof AST_ClassExpression ? "ClassExpression" : "ClassDeclaration";
    return {
      type,
      superClass: to_moz(M2.extends),
      id: M2.name ? to_moz(M2.name) : null,
      body: {
        type: "ClassBody",
        body: M2.properties.map(to_moz)
      }
    };
  });
  def_to_moz(AST_ClassStaticBlock, function To_Moz_StaticBlock(M2) {
    return {
      type: "StaticBlock",
      body: M2.body.map(to_moz)
    };
  });
  def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {
    return {
      type: "MetaProperty",
      meta: {
        type: "Identifier",
        name: "new"
      },
      property: {
        type: "Identifier",
        name: "target"
      }
    };
  });
  def_to_moz(AST_Symbol, function To_Moz_Identifier(M2, parent) {
    if (M2 instanceof AST_SymbolMethod && parent.quote || (M2 instanceof AST_SymbolImportForeign || M2 instanceof AST_SymbolExportForeign || M2 instanceof AST_SymbolExport) && M2.quote) {
      return {
        type: "Literal",
        value: M2.name
      };
    }
    var def = M2.definition();
    return {
      type: "Identifier",
      name: def ? def.mangled_name || def.name : M2.name
    };
  });
  def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M2) {
    const pattern = M2.value.source;
    const flags = M2.value.flags;
    return {
      type: "Literal",
      value: null,
      raw: M2.print_to_string(),
      regex: { pattern, flags }
    };
  });
  def_to_moz(AST_Constant, function To_Moz_Literal(M2) {
    var value = M2.value;
    return {
      type: "Literal",
      value,
      raw: M2.raw || M2.print_to_string()
    };
  });
  def_to_moz(AST_Atom, function To_Moz_Atom(M2) {
    return {
      type: "Identifier",
      name: String(M2.value)
    };
  });
  def_to_moz(AST_BigInt, (M2) => ({
    type: "Literal",
    // value cannot be represented natively
    // see: https://github.com/estree/estree/blob/master/es2020.md#bigintliteral
    value: null,
    // `M.value` is a string that may be a hex number representation.
    // but "bigint" property should have only decimal digits
    bigint: typeof BigInt === "function" ? BigInt(M2.value).toString() : M2.value
  }));
  AST_Boolean.DEFMETHOD("to_mozilla_ast", AST_Constant.prototype.to_mozilla_ast);
  AST_Null.DEFMETHOD("to_mozilla_ast", AST_Constant.prototype.to_mozilla_ast);
  AST_Hole.DEFMETHOD("to_mozilla_ast", function To_Moz_ArrayHole() {
    return null;
  });
  AST_Block.DEFMETHOD("to_mozilla_ast", AST_BlockStatement.prototype.to_mozilla_ast);
  AST_Lambda.DEFMETHOD("to_mozilla_ast", AST_Function.prototype.to_mozilla_ast);
  function my_start_token(moznode) {
    var loc = moznode.loc, start3 = loc && loc.start;
    var range4 = moznode.range;
    return new AST_Token(
      "",
      "",
      start3 && start3.line || 0,
      start3 && start3.column || 0,
      range4 ? range4[0] : moznode.start,
      false,
      [],
      [],
      loc && loc.source
    );
  }
  function my_end_token(moznode) {
    var loc = moznode.loc, end6 = loc && loc.end;
    var range4 = moznode.range;
    return new AST_Token(
      "",
      "",
      end6 && end6.line || 0,
      end6 && end6.column || 0,
      range4 ? range4[0] : moznode.end,
      false,
      [],
      [],
      loc && loc.source
    );
  }
  var FROM_MOZ_STACK = null;
  function from_moz(node) {
    FROM_MOZ_STACK.push(node);
    var ret = node != null ? MOZ_TO_ME[node.type](node) : null;
    FROM_MOZ_STACK.pop();
    return ret;
  }
  AST_Node.from_mozilla_ast = function(node) {
    var save_stack = FROM_MOZ_STACK;
    FROM_MOZ_STACK = [];
    var ast = from_moz(node);
    FROM_MOZ_STACK = save_stack;
    return ast;
  };
  function set_moz_loc(mynode, moznode) {
    var start3 = mynode.start;
    var end6 = mynode.end;
    if (!(start3 && end6)) {
      return moznode;
    }
    if (start3.pos != null && end6.endpos != null) {
      moznode.range = [start3.pos, end6.endpos];
    }
    if (start3.line) {
      moznode.loc = {
        start: { line: start3.line, column: start3.col },
        end: end6.endline ? { line: end6.endline, column: end6.endcol } : null
      };
      if (start3.file) {
        moznode.loc.source = start3.file;
      }
    }
    return moznode;
  }
  function def_to_moz(mytype, handler) {
    mytype.DEFMETHOD("to_mozilla_ast", function(parent) {
      return set_moz_loc(this, handler(this, parent));
    });
  }
  var TO_MOZ_STACK = null;
  function to_moz(node) {
    if (TO_MOZ_STACK === null) {
      TO_MOZ_STACK = [];
    }
    TO_MOZ_STACK.push(node);
    var ast = node != null ? node.to_mozilla_ast(TO_MOZ_STACK[TO_MOZ_STACK.length - 2]) : null;
    TO_MOZ_STACK.pop();
    if (TO_MOZ_STACK.length === 0) {
      TO_MOZ_STACK = null;
    }
    return ast;
  }
  function to_moz_in_destructuring() {
    var i = TO_MOZ_STACK.length;
    while (i--) {
      if (TO_MOZ_STACK[i] instanceof AST_Destructuring) {
        return true;
      }
    }
    return false;
  }
  function to_moz_block(node) {
    return {
      type: "BlockStatement",
      body: node.body.map(to_moz)
    };
  }
  function to_moz_scope(type, node) {
    var body = node.body.map(to_moz);
    if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {
      body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));
    }
    return {
      type,
      body
    };
  }
})();

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/utils/first_in_statement.js
function first_in_statement(stack) {
  let node = stack.parent(-1);
  for (let i = 0, p3; p3 = stack.parent(i); i++) {
    if (p3 instanceof AST_Statement && p3.body === node)
      return true;
    if (p3 instanceof AST_Sequence && p3.expressions[0] === node || p3.TYPE === "Call" && p3.expression === node || p3 instanceof AST_PrefixedTemplateString && p3.prefix === node || p3 instanceof AST_Dot && p3.expression === node || p3 instanceof AST_Sub && p3.expression === node || p3 instanceof AST_Chain && p3.expression === node || p3 instanceof AST_Conditional && p3.condition === node || p3 instanceof AST_Binary && p3.left === node || p3 instanceof AST_UnaryPostfix && p3.expression === node) {
      node = p3;
    } else {
      return false;
    }
  }
}
function left_is_object(node) {
  if (node instanceof AST_Object) return true;
  if (node instanceof AST_Sequence) return left_is_object(node.expressions[0]);
  if (node.TYPE === "Call") return left_is_object(node.expression);
  if (node instanceof AST_PrefixedTemplateString) return left_is_object(node.prefix);
  if (node instanceof AST_Dot || node instanceof AST_Sub) return left_is_object(node.expression);
  if (node instanceof AST_Chain) return left_is_object(node.expression);
  if (node instanceof AST_Conditional) return left_is_object(node.condition);
  if (node instanceof AST_Binary) return left_is_object(node.left);
  if (node instanceof AST_UnaryPostfix) return left_is_object(node.expression);
  return false;
}

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/output.js
var CODE_LINE_BREAK = 10;
var CODE_SPACE = 32;
var r_annotation = /[@#]__(PURE|INLINE|NOINLINE)__/;
function is_some_comments(comment) {
  return (comment.type === "comment2" || comment.type === "comment1") && /@preserve|@copyright|@lic|@cc_on|^\**!/i.test(comment.value);
}
var ROPE_COMMIT_WHEN = 8 * 1e3;
var Rope = class {
  constructor() {
    this.committed = "";
    this.current = "";
  }
  append(str) {
    if (this.current.length > ROPE_COMMIT_WHEN) {
      this.committed += this.current + str;
      this.current = "";
    } else {
      this.current += str;
    }
  }
  insertAt(char, index) {
    const { committed, current: current2 } = this;
    if (index < committed.length) {
      this.committed = committed.slice(0, index) + char + committed.slice(index);
    } else if (index === committed.length) {
      this.committed += char;
    } else {
      index -= committed.length;
      this.committed += current2.slice(0, index) + char;
      this.current = current2.slice(index);
    }
  }
  charAt(index) {
    const { committed } = this;
    if (index < committed.length) return committed[index];
    return this.current[index - committed.length];
  }
  charCodeAt(index) {
    const { committed } = this;
    if (index < committed.length) return committed.charCodeAt(index);
    return this.current.charCodeAt(index - committed.length);
  }
  length() {
    return this.committed.length + this.current.length;
  }
  expectDirective() {
    let ch, n2 = this.length();
    if (n2 <= 0) return true;
    while ((ch = this.charCodeAt(--n2)) && (ch == CODE_SPACE || ch == CODE_LINE_BREAK)) ;
    return !ch || ch === 59 || ch === 123;
  }
  hasNLB() {
    let n2 = this.length() - 1;
    while (n2 >= 0) {
      const code = this.charCodeAt(n2--);
      if (code === CODE_LINE_BREAK) return true;
      if (code !== CODE_SPACE) return false;
    }
    return true;
  }
  toString() {
    return this.committed + this.current;
  }
};
function OutputStream(options) {
  var readonly = !options;
  options = defaults2(options, {
    ascii_only: false,
    beautify: false,
    braces: false,
    comments: "some",
    ecma: 5,
    ie8: false,
    indent_level: 4,
    indent_start: 0,
    inline_script: true,
    keep_numbers: false,
    keep_quoted_props: false,
    max_line_len: false,
    preamble: null,
    preserve_annotations: false,
    quote_keys: false,
    quote_style: 0,
    safari10: false,
    semicolons: true,
    shebang: true,
    shorthand: void 0,
    source_map: null,
    webkit: false,
    width: 80,
    wrap_iife: false,
    wrap_func_args: true,
    _destroy_ast: false
  }, true);
  if (options.shorthand === void 0)
    options.shorthand = options.ecma > 5;
  var comment_filter = return_false;
  if (options.comments) {
    let comments = options.comments;
    if (typeof options.comments === "string" && /^\/.*\/[a-zA-Z]*$/.test(options.comments)) {
      var regex_pos = options.comments.lastIndexOf("/");
      comments = new RegExp(
        options.comments.substr(1, regex_pos - 1),
        options.comments.substr(regex_pos + 1)
      );
    }
    if (comments instanceof RegExp) {
      comment_filter = function(comment) {
        return comment.type != "comment5" && comments.test(comment.value);
      };
    } else if (typeof comments === "function") {
      comment_filter = function(comment) {
        return comment.type != "comment5" && comments(this, comment);
      };
    } else if (comments === "some") {
      comment_filter = is_some_comments;
    } else {
      comment_filter = return_true;
    }
  }
  if (options.preserve_annotations) {
    let prev_comment_filter = comment_filter;
    comment_filter = function(comment) {
      return r_annotation.test(comment.value) || prev_comment_filter.apply(this, arguments);
    };
  }
  var indentation = 0;
  var current_col = 0;
  var current_line = 1;
  var current_pos = 0;
  var OUTPUT = new Rope();
  let printed_comments = /* @__PURE__ */ new Set();
  var to_utf8 = options.ascii_only ? function(str, identifier4 = false, regexp = false) {
    if (options.ecma >= 2015 && !options.safari10 && !regexp) {
      str = str.replace(/[\ud800-\udbff][\udc00-\udfff]/g, function(ch) {
        var code = get_full_char_code(ch, 0).toString(16);
        return "\\u{" + code + "}";
      });
    }
    return str.replace(/[\u0000-\u001f\u007f-\uffff]/g, function(ch) {
      var code = ch.charCodeAt(0).toString(16);
      if (code.length <= 2 && !identifier4) {
        while (code.length < 2) code = "0" + code;
        return "\\x" + code;
      } else {
        while (code.length < 4) code = "0" + code;
        return "\\u" + code;
      }
    });
  } : function(str) {
    return str.replace(/[\ud800-\udbff][\udc00-\udfff]|([\ud800-\udbff]|[\udc00-\udfff])/g, function(match18, lone) {
      if (lone) {
        return "\\u" + lone.charCodeAt(0).toString(16);
      }
      return match18;
    });
  };
  function make_string(str, quote) {
    var dq = 0, sq = 0;
    str = str.replace(
      /[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/g,
      function(s2, i) {
        switch (s2) {
          case '"':
            ++dq;
            return '"';
          case "'":
            ++sq;
            return "'";
          case "\\":
            return "\\\\";
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "	":
            return "\\t";
          case "\b":
            return "\\b";
          case "\f":
            return "\\f";
          case "\v":
            return options.ie8 ? "\\x0B" : "\\v";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          case "\uFEFF":
            return "\\ufeff";
          case "\0":
            return /[0-9]/.test(get_full_char(str, i + 1)) ? "\\x00" : "\\0";
        }
        return s2;
      }
    );
    function quote_single() {
      return "'" + str.replace(/\x27/g, "\\'") + "'";
    }
    function quote_double() {
      return '"' + str.replace(/\x22/g, '\\"') + '"';
    }
    function quote_template() {
      return "`" + str.replace(/`/g, "\\`") + "`";
    }
    str = to_utf8(str);
    if (quote === "`") return quote_template();
    switch (options.quote_style) {
      case 1:
        return quote_single();
      case 2:
        return quote_double();
      case 3:
        return quote == "'" ? quote_single() : quote_double();
      default:
        return dq > sq ? quote_single() : quote_double();
    }
  }
  function encode_string(str, quote) {
    var ret = make_string(str, quote);
    if (options.inline_script) {
      ret = ret.replace(/<\x2f(script)([>\/\t\n\f\r ])/gi, "<\\/$1$2");
      ret = ret.replace(/\x3c!--/g, "\\x3c!--");
      ret = ret.replace(/--\x3e/g, "--\\x3e");
    }
    return ret;
  }
  function make_name(name) {
    name = name.toString();
    name = to_utf8(name, true);
    return name;
  }
  function make_indent(back) {
    return " ".repeat(options.indent_start + indentation - back * options.indent_level);
  }
  var has_parens = false;
  var might_need_space = false;
  var might_need_semicolon = false;
  var might_add_newline = 0;
  var need_newline_indented = false;
  var need_space = false;
  var newline_insert = -1;
  var last6 = "";
  var mapping_token, mapping_name, mappings = options.source_map && [];
  var do_add_mapping = mappings ? function() {
    mappings.forEach(function(mapping) {
      try {
        let { name, token } = mapping;
        if (name !== false) {
          if (token.type == "name" || token.type === "privatename") {
            name = token.value;
          } else if (name instanceof AST_Symbol) {
            name = token.type === "string" ? token.value : name.name;
          }
        }
        options.source_map.add(
          mapping.token.file,
          mapping.line,
          mapping.col,
          mapping.token.line,
          mapping.token.col,
          is_basic_identifier_string(name) ? name : void 0
        );
      } catch (ex) {
      }
    });
    mappings = [];
  } : noop;
  var ensure_line_len = options.max_line_len ? function() {
    if (current_col > options.max_line_len) {
      if (might_add_newline) {
        OUTPUT.insertAt("\n", might_add_newline);
        const len_after_newline = OUTPUT.length() - might_add_newline - 1;
        if (mappings) {
          var delta = len_after_newline - current_col;
          mappings.forEach(function(mapping) {
            mapping.line++;
            mapping.col += delta;
          });
        }
        current_line++;
        current_pos++;
        current_col = len_after_newline;
      }
    }
    if (might_add_newline) {
      might_add_newline = 0;
      do_add_mapping();
    }
  } : noop;
  var requireSemicolonChars = makePredicate("( [ + * / - , . `");
  function print(str) {
    str = String(str);
    var ch = get_full_char(str, 0);
    if (need_newline_indented && ch) {
      need_newline_indented = false;
      if (ch !== "\n") {
        print("\n");
        indent();
      }
    }
    if (need_space && ch) {
      need_space = false;
      if (!/[\s;})]/.test(ch)) {
        space();
      }
    }
    newline_insert = -1;
    var prev = last6.charAt(last6.length - 1);
    if (might_need_semicolon) {
      might_need_semicolon = false;
      if (prev === ":" && ch === "}" || (!ch || !";}".includes(ch)) && prev !== ";") {
        if (options.semicolons || requireSemicolonChars.has(ch)) {
          OUTPUT.append(";");
          current_col++;
          current_pos++;
        } else {
          ensure_line_len();
          if (current_col > 0) {
            OUTPUT.append("\n");
            current_pos++;
            current_line++;
            current_col = 0;
          }
          if (/^\s+$/.test(str)) {
            might_need_semicolon = true;
          }
        }
        if (!options.beautify)
          might_need_space = false;
      }
    }
    if (might_need_space) {
      if (is_identifier_char(prev) && (is_identifier_char(ch) || ch == "\\") || ch == "/" && ch == prev || (ch == "+" || ch == "-") && ch == last6) {
        OUTPUT.append(" ");
        current_col++;
        current_pos++;
      }
      might_need_space = false;
    }
    if (mapping_token) {
      mappings.push({
        token: mapping_token,
        name: mapping_name,
        line: current_line,
        col: current_col
      });
      mapping_token = false;
      if (!might_add_newline) do_add_mapping();
    }
    OUTPUT.append(str);
    has_parens = str[str.length - 1] == "(";
    current_pos += str.length;
    var a2 = str.split(/\r?\n/), n2 = a2.length - 1;
    current_line += n2;
    current_col += a2[0].length;
    if (n2 > 0) {
      ensure_line_len();
      current_col = a2[n2].length;
    }
    last6 = str;
  }
  var star = function() {
    print("*");
  };
  var space = options.beautify ? function() {
    print(" ");
  } : function() {
    might_need_space = true;
  };
  var indent = options.beautify ? function(half) {
    if (options.beautify) {
      print(make_indent(half ? 0.5 : 0));
    }
  } : noop;
  var with_indent = options.beautify ? function(col, cont) {
    if (col === true) col = next_indent();
    var save_indentation = indentation;
    indentation = col;
    var ret = cont();
    indentation = save_indentation;
    return ret;
  } : function(col, cont) {
    return cont();
  };
  var newline = options.beautify ? function() {
    if (newline_insert < 0) return print("\n");
    if (OUTPUT.charAt(newline_insert) != "\n") {
      OUTPUT.insertAt("\n", newline_insert);
      current_pos++;
      current_line++;
    }
    newline_insert++;
  } : options.max_line_len ? function() {
    ensure_line_len();
    might_add_newline = OUTPUT.length();
  } : noop;
  var semicolon3 = options.beautify ? function() {
    print(";");
  } : function() {
    might_need_semicolon = true;
  };
  function force_semicolon() {
    might_need_semicolon = false;
    print(";");
  }
  function next_indent() {
    return indentation + options.indent_level;
  }
  function with_block(cont) {
    var ret;
    print("{");
    newline();
    with_indent(next_indent(), function() {
      ret = cont();
    });
    indent();
    print("}");
    return ret;
  }
  function with_parens(cont) {
    print("(");
    var ret = cont();
    print(")");
    return ret;
  }
  function with_square(cont) {
    print("[");
    var ret = cont();
    print("]");
    return ret;
  }
  function comma3() {
    print(",");
    space();
  }
  function colon() {
    print(":");
    space();
  }
  var add_mapping = mappings ? function(token, name) {
    mapping_token = token;
    mapping_name = name;
  } : noop;
  function get18() {
    if (might_add_newline) {
      ensure_line_len();
    }
    return OUTPUT.toString();
  }
  function filter_comment(comment) {
    if (!options.preserve_annotations) {
      comment = comment.replace(r_annotation, " ");
    }
    if (/^\s*$/.test(comment)) {
      return "";
    }
    return comment.replace(/(<\s*\/\s*)(script)/i, "<\\/$2");
  }
  function prepend_comments(node) {
    var self2 = this;
    var start3 = node.start;
    if (!start3) return;
    var printed_comments2 = self2.printed_comments;
    const keyword_with_value = node instanceof AST_Exit && node.value || (node instanceof AST_Await || node instanceof AST_Yield) && node.expression;
    if (start3.comments_before && printed_comments2.has(start3.comments_before)) {
      if (keyword_with_value) {
        start3.comments_before = [];
      } else {
        return;
      }
    }
    var comments = start3.comments_before;
    if (!comments) {
      comments = start3.comments_before = [];
    }
    printed_comments2.add(comments);
    if (keyword_with_value) {
      var tw = new TreeWalker(function(node2) {
        var parent = tw.parent();
        if (parent instanceof AST_Exit || parent instanceof AST_Await || parent instanceof AST_Yield || parent instanceof AST_Binary && parent.left === node2 || parent.TYPE == "Call" && parent.expression === node2 || parent instanceof AST_Conditional && parent.condition === node2 || parent instanceof AST_Dot && parent.expression === node2 || parent instanceof AST_Sequence && parent.expressions[0] === node2 || parent instanceof AST_Sub && parent.expression === node2 || parent instanceof AST_UnaryPostfix) {
          if (!node2.start) return;
          var text = node2.start.comments_before;
          if (text && !printed_comments2.has(text)) {
            printed_comments2.add(text);
            comments = comments.concat(text);
          }
        } else {
          return true;
        }
      });
      tw.push(node);
      keyword_with_value.walk(tw);
    }
    if (current_pos == 0) {
      if (comments.length > 0 && options.shebang && comments[0].type === "comment5" && !printed_comments2.has(comments[0])) {
        print("#!" + comments.shift().value + "\n");
        indent();
      }
      var preamble = options.preamble;
      if (preamble) {
        print(preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n"));
      }
    }
    comments = comments.filter(comment_filter, node).filter((c) => !printed_comments2.has(c));
    if (comments.length == 0) return;
    var last_nlb = OUTPUT.hasNLB();
    comments.forEach(function(c, i) {
      printed_comments2.add(c);
      if (!last_nlb) {
        if (c.nlb) {
          print("\n");
          indent();
          last_nlb = true;
        } else if (i > 0) {
          space();
        }
      }
      if (/comment[134]/.test(c.type)) {
        var value = filter_comment(c.value);
        if (value) {
          print("//" + value + "\n");
          indent();
        }
        last_nlb = true;
      } else if (c.type == "comment2") {
        var value = filter_comment(c.value);
        if (value) {
          print("/*" + value + "*/");
        }
        last_nlb = false;
      }
    });
    if (!last_nlb) {
      if (start3.nlb) {
        print("\n");
        indent();
      } else {
        space();
      }
    }
  }
  function append_comments(node, tail) {
    var self2 = this;
    var token = node.end;
    if (!token) return;
    var printed_comments2 = self2.printed_comments;
    var comments = token[tail ? "comments_before" : "comments_after"];
    if (!comments || printed_comments2.has(comments)) return;
    if (!(node instanceof AST_Statement || comments.every(
      (c) => !/comment[134]/.test(c.type)
    ))) return;
    printed_comments2.add(comments);
    var insert5 = OUTPUT.length();
    comments.filter(comment_filter, node).forEach(function(c, i) {
      if (printed_comments2.has(c)) return;
      printed_comments2.add(c);
      need_space = false;
      if (need_newline_indented) {
        print("\n");
        indent();
        need_newline_indented = false;
      } else if (c.nlb && (i > 0 || !OUTPUT.hasNLB())) {
        print("\n");
        indent();
      } else if (i > 0 || !tail) {
        space();
      }
      if (/comment[134]/.test(c.type)) {
        const value = filter_comment(c.value);
        if (value) {
          print("//" + value);
        }
        need_newline_indented = true;
      } else if (c.type == "comment2") {
        const value = filter_comment(c.value);
        if (value) {
          print("/*" + value + "*/");
        }
        need_space = true;
      }
    });
    if (OUTPUT.length() > insert5) newline_insert = insert5;
  }
  const gc_scope = options["_destroy_ast"] ? function gc_scope2(scope5) {
    scope5.body.length = 0;
    scope5.argnames.length = 0;
  } : noop;
  var stack = [];
  return {
    get: get18,
    toString: get18,
    indent,
    in_directive: false,
    use_asm: null,
    active_scope: null,
    indentation: function() {
      return indentation;
    },
    current_width: function() {
      return current_col - indentation;
    },
    should_break: function() {
      return options.width && this.current_width() >= options.width;
    },
    has_parens: function() {
      return has_parens;
    },
    newline,
    print,
    star,
    space,
    comma: comma3,
    colon,
    last: function() {
      return last6;
    },
    semicolon: semicolon3,
    force_semicolon,
    to_utf8,
    print_name: function(name) {
      print(make_name(name));
    },
    print_string: function(str, quote, escape_directive) {
      var encoded = encode_string(str, quote);
      if (escape_directive === true && !encoded.includes("\\")) {
        if (!OUTPUT.expectDirective()) {
          force_semicolon();
        }
        force_semicolon();
      }
      print(encoded);
    },
    print_template_string_chars: function(str) {
      var encoded = encode_string(str, "`").replace(/\${/g, "\\${");
      return print(encoded.substr(1, encoded.length - 2));
    },
    encode_string,
    next_indent,
    with_indent,
    with_block,
    with_parens,
    with_square,
    add_mapping,
    option: function(opt) {
      return options[opt];
    },
    gc_scope,
    printed_comments,
    prepend_comments: readonly ? noop : prepend_comments,
    append_comments: readonly || comment_filter === return_false ? noop : append_comments,
    line: function() {
      return current_line;
    },
    col: function() {
      return current_col;
    },
    pos: function() {
      return current_pos;
    },
    push_node: function(node) {
      stack.push(node);
    },
    pop_node: function() {
      return stack.pop();
    },
    parent: function(n2) {
      return stack[stack.length - 2 - (n2 || 0)];
    }
  };
}
(function() {
  function DEFPRINT(nodetype, generator) {
    nodetype.DEFMETHOD("_codegen", generator);
  }
  AST_Node.DEFMETHOD("print", function(output, force_parens) {
    var self2 = this, generator = self2._codegen;
    if (self2 instanceof AST_Scope) {
      output.active_scope = self2;
    } else if (!output.use_asm && self2 instanceof AST_Directive && self2.value == "use asm") {
      output.use_asm = output.active_scope;
    }
    function doit() {
      output.prepend_comments(self2);
      self2.add_source_map(output);
      generator(self2, output);
      output.append_comments(self2);
    }
    output.push_node(self2);
    if (force_parens || self2.needs_parens(output)) {
      output.with_parens(doit);
    } else {
      doit();
    }
    output.pop_node();
    if (self2 === output.use_asm) {
      output.use_asm = null;
    }
  });
  AST_Node.DEFMETHOD("_print", AST_Node.prototype.print);
  AST_Node.DEFMETHOD("print_to_string", function(options) {
    var output = OutputStream(options);
    this.print(output);
    return output.get();
  });
  function PARENS(nodetype, func) {
    if (Array.isArray(nodetype)) {
      nodetype.forEach(function(nodetype2) {
        PARENS(nodetype2, func);
      });
    } else {
      nodetype.DEFMETHOD("needs_parens", func);
    }
  }
  PARENS(AST_Node, return_false);
  PARENS(AST_Function, function(output) {
    if (!output.has_parens() && first_in_statement(output)) {
      return true;
    }
    if (output.option("webkit")) {
      var p3 = output.parent();
      if (p3 instanceof AST_PropAccess && p3.expression === this) {
        return true;
      }
    }
    if (output.option("wrap_iife")) {
      var p3 = output.parent();
      if (p3 instanceof AST_Call && p3.expression === this) {
        return true;
      }
    }
    if (output.option("wrap_func_args")) {
      var p3 = output.parent();
      if (p3 instanceof AST_Call && p3.args.includes(this)) {
        return true;
      }
    }
    return false;
  });
  PARENS(AST_Arrow, function(output) {
    var p3 = output.parent();
    if (output.option("wrap_func_args") && p3 instanceof AST_Call && p3.args.includes(this)) {
      return true;
    }
    return p3 instanceof AST_PropAccess && p3.expression === this || p3 instanceof AST_Conditional && p3.condition === this;
  });
  PARENS(AST_Object, function(output) {
    return !output.has_parens() && first_in_statement(output);
  });
  PARENS(AST_ClassExpression, first_in_statement);
  PARENS(AST_Unary, function(output) {
    var p3 = output.parent();
    return p3 instanceof AST_PropAccess && p3.expression === this || p3 instanceof AST_Call && p3.expression === this || p3 instanceof AST_Binary && p3.operator === "**" && this instanceof AST_UnaryPrefix && p3.left === this && this.operator !== "++" && this.operator !== "--";
  });
  PARENS(AST_Await, function(output) {
    var p3 = output.parent();
    return p3 instanceof AST_PropAccess && p3.expression === this || p3 instanceof AST_Call && p3.expression === this || p3 instanceof AST_Binary && p3.operator === "**" && p3.left === this || output.option("safari10") && p3 instanceof AST_UnaryPrefix;
  });
  PARENS(AST_Sequence, function(output) {
    var p3 = output.parent();
    return p3 instanceof AST_Call || p3 instanceof AST_Unary || p3 instanceof AST_Binary || p3 instanceof AST_VarDef || p3 instanceof AST_PropAccess || p3 instanceof AST_Array || p3 instanceof AST_ObjectProperty || p3 instanceof AST_Conditional || p3 instanceof AST_Arrow || p3 instanceof AST_DefaultAssign || p3 instanceof AST_Expansion || p3 instanceof AST_ForOf && this === p3.object || p3 instanceof AST_Yield || p3 instanceof AST_Export;
  });
  PARENS(AST_Binary, function(output) {
    var p3 = output.parent();
    if (p3 instanceof AST_Call && p3.expression === this)
      return true;
    if (p3 instanceof AST_Unary)
      return true;
    if (p3 instanceof AST_PropAccess && p3.expression === this)
      return true;
    if (p3 instanceof AST_Binary) {
      const parent_op = p3.operator;
      const op = this.operator;
      if (op === "??" && (parent_op === "||" || parent_op === "&&")) {
        return true;
      }
      if (parent_op === "??" && (op === "||" || op === "&&")) {
        return true;
      }
      const pp = PRECEDENCE[parent_op];
      const sp = PRECEDENCE[op];
      if (pp > sp || pp == sp && (this === p3.right || parent_op == "**")) {
        return true;
      }
    }
    if (p3 instanceof AST_PrivateIn) {
      const op = this.operator;
      const pp = PRECEDENCE["in"];
      const sp = PRECEDENCE[op];
      if (pp > sp || pp == sp && this === p3.value) {
        return true;
      }
    }
  });
  PARENS(AST_PrivateIn, function(output) {
    var p3 = output.parent();
    if (p3 instanceof AST_Call && p3.expression === this) {
      return true;
    }
    if (p3 instanceof AST_Unary) {
      return true;
    }
    if (p3 instanceof AST_PropAccess && p3.expression === this) {
      return true;
    }
    if (p3 instanceof AST_Binary) {
      const parent_op = p3.operator;
      const pp = PRECEDENCE[parent_op];
      const sp = PRECEDENCE["in"];
      if (pp > sp || pp == sp && (this === p3.right || parent_op == "**")) {
        return true;
      }
    }
    if (p3 instanceof AST_PrivateIn && this === p3.value) {
      return true;
    }
  });
  PARENS(AST_Yield, function(output) {
    var p3 = output.parent();
    if (p3 instanceof AST_Binary && p3.operator !== "=")
      return true;
    if (p3 instanceof AST_Call && p3.expression === this)
      return true;
    if (p3 instanceof AST_Conditional && p3.condition === this)
      return true;
    if (p3 instanceof AST_Unary)
      return true;
    if (p3 instanceof AST_PropAccess && p3.expression === this)
      return true;
  });
  PARENS(AST_Chain, function(output) {
    var p3 = output.parent();
    if (!(p3 instanceof AST_Call || p3 instanceof AST_PropAccess)) return false;
    return p3.expression === this;
  });
  PARENS(AST_PropAccess, function(output) {
    var p3 = output.parent();
    if (p3 instanceof AST_New && p3.expression === this) {
      return walk2(this, (node) => {
        if (node instanceof AST_Scope) return true;
        if (node instanceof AST_Call) {
          return walk_abort;
        }
      });
    }
  });
  PARENS(AST_Call, function(output) {
    var p3 = output.parent(), p1;
    if (p3 instanceof AST_New && p3.expression === this || p3 instanceof AST_Export && p3.is_default && this.expression instanceof AST_Function)
      return true;
    return this.expression instanceof AST_Function && p3 instanceof AST_PropAccess && p3.expression === this && (p1 = output.parent(1)) instanceof AST_Assign && p1.left === p3;
  });
  PARENS(AST_New, function(output) {
    var p3 = output.parent();
    if (this.args.length === 0 && (p3 instanceof AST_PropAccess || p3 instanceof AST_Call && p3.expression === this || p3 instanceof AST_PrefixedTemplateString && p3.prefix === this))
      return true;
  });
  PARENS(AST_Number, function(output) {
    var p3 = output.parent();
    if (p3 instanceof AST_PropAccess && p3.expression === this) {
      var value = this.getValue();
      if (value < 0 || /^0/.test(make_num(value))) {
        return true;
      }
    }
  });
  PARENS(AST_BigInt, function(output) {
    var p3 = output.parent();
    if (p3 instanceof AST_PropAccess && p3.expression === this) {
      var value = this.getValue();
      if (value.startsWith("-")) {
        return true;
      }
    }
  });
  PARENS([AST_Assign, AST_Conditional], function(output) {
    var p3 = output.parent();
    if (p3 instanceof AST_Unary)
      return true;
    if (p3 instanceof AST_Binary && !(p3 instanceof AST_Assign))
      return true;
    if (p3 instanceof AST_Call && p3.expression === this)
      return true;
    if (p3 instanceof AST_Conditional && p3.condition === this)
      return true;
    if (p3 instanceof AST_PropAccess && p3.expression === this)
      return true;
    if (this instanceof AST_Assign && this.left instanceof AST_Destructuring && this.left.is_array === false)
      return true;
  });
  DEFPRINT(AST_Directive, function(self2, output) {
    output.print_string(self2.value, self2.quote);
    output.semicolon();
  });
  DEFPRINT(AST_Expansion, function(self2, output) {
    output.print("...");
    self2.expression.print(output);
  });
  DEFPRINT(AST_Destructuring, function(self2, output) {
    output.print(self2.is_array ? "[" : "{");
    var len = self2.names.length;
    self2.names.forEach(function(name, i) {
      if (i > 0) output.comma();
      name.print(output);
      if (i == len - 1 && name instanceof AST_Hole) output.comma();
    });
    output.print(self2.is_array ? "]" : "}");
  });
  DEFPRINT(AST_Debugger, function(self2, output) {
    output.print("debugger");
    output.semicolon();
  });
  function display_body(body, is_toplevel, output, allow_directives) {
    var last6 = body.length - 1;
    output.in_directive = allow_directives;
    body.forEach(function(stmt, i) {
      if (output.in_directive === true && !(stmt instanceof AST_Directive || stmt instanceof AST_EmptyStatement || stmt instanceof AST_SimpleStatement && stmt.body instanceof AST_String)) {
        output.in_directive = false;
      }
      if (!(stmt instanceof AST_EmptyStatement)) {
        output.indent();
        stmt.print(output);
        if (!(i == last6 && is_toplevel)) {
          output.newline();
          if (is_toplevel) output.newline();
        }
      }
      if (output.in_directive === true && stmt instanceof AST_SimpleStatement && stmt.body instanceof AST_String) {
        output.in_directive = false;
      }
    });
    output.in_directive = false;
  }
  AST_StatementWithBody.DEFMETHOD("_do_print_body", function(output) {
    print_maybe_braced_body(this.body, output);
  });
  DEFPRINT(AST_Statement, function(self2, output) {
    self2.body.print(output);
    output.semicolon();
  });
  DEFPRINT(AST_Toplevel, function(self2, output) {
    display_body(self2.body, true, output, true);
    output.print("");
  });
  DEFPRINT(AST_LabeledStatement, function(self2, output) {
    self2.label.print(output);
    output.colon();
    self2.body.print(output);
  });
  DEFPRINT(AST_SimpleStatement, function(self2, output) {
    self2.body.print(output);
    output.semicolon();
  });
  function print_braced_empty(self2, output) {
    output.print("{");
    output.with_indent(output.next_indent(), function() {
      output.append_comments(self2, true);
    });
    output.add_mapping(self2.end);
    output.print("}");
  }
  function print_braced(self2, output, allow_directives) {
    if (self2.body.length > 0) {
      output.with_block(function() {
        display_body(self2.body, false, output, allow_directives);
        output.add_mapping(self2.end);
      });
    } else print_braced_empty(self2, output);
  }
  DEFPRINT(AST_BlockStatement, function(self2, output) {
    print_braced(self2, output);
  });
  DEFPRINT(AST_EmptyStatement, function(self2, output) {
    output.semicolon();
  });
  DEFPRINT(AST_Do, function(self2, output) {
    output.print("do");
    output.space();
    make_block(self2.body, output);
    output.space();
    output.print("while");
    output.space();
    output.with_parens(function() {
      self2.condition.print(output);
    });
    output.semicolon();
  });
  DEFPRINT(AST_While, function(self2, output) {
    output.print("while");
    output.space();
    output.with_parens(function() {
      self2.condition.print(output);
    });
    output.space();
    self2._do_print_body(output);
  });
  DEFPRINT(AST_For, function(self2, output) {
    output.print("for");
    output.space();
    output.with_parens(function() {
      if (self2.init) {
        if (self2.init instanceof AST_Definitions) {
          self2.init.print(output);
        } else {
          parenthesize_for_noin(self2.init, output, true);
        }
        output.print(";");
        output.space();
      } else {
        output.print(";");
      }
      if (self2.condition) {
        self2.condition.print(output);
        output.print(";");
        output.space();
      } else {
        output.print(";");
      }
      if (self2.step) {
        self2.step.print(output);
      }
    });
    output.space();
    self2._do_print_body(output);
  });
  DEFPRINT(AST_ForIn, function(self2, output) {
    output.print("for");
    if (self2.await) {
      output.space();
      output.print("await");
    }
    output.space();
    output.with_parens(function() {
      self2.init.print(output);
      output.space();
      output.print(self2 instanceof AST_ForOf ? "of" : "in");
      output.space();
      self2.object.print(output);
    });
    output.space();
    self2._do_print_body(output);
  });
  DEFPRINT(AST_With, function(self2, output) {
    output.print("with");
    output.space();
    output.with_parens(function() {
      self2.expression.print(output);
    });
    output.space();
    self2._do_print_body(output);
  });
  AST_Lambda.DEFMETHOD("_do_print", function(output, nokeyword) {
    var self2 = this;
    if (!nokeyword) {
      if (self2.async) {
        output.print("async");
        output.space();
      }
      output.print("function");
      if (self2.is_generator) {
        output.star();
      }
      if (self2.name) {
        output.space();
      }
    }
    if (self2.name instanceof AST_Symbol) {
      self2.name.print(output);
    } else if (nokeyword && self2.name instanceof AST_Node) {
      output.with_square(function() {
        self2.name.print(output);
      });
    }
    output.with_parens(function() {
      self2.argnames.forEach(function(arg, i) {
        if (i) output.comma();
        arg.print(output);
      });
    });
    output.space();
    print_braced(self2, output, true);
  });
  DEFPRINT(AST_Lambda, function(self2, output) {
    self2._do_print(output);
    output.gc_scope(self2);
  });
  DEFPRINT(AST_PrefixedTemplateString, function(self2, output) {
    var tag = self2.prefix;
    var parenthesize_tag = tag instanceof AST_Lambda || tag instanceof AST_Binary || tag instanceof AST_Conditional || tag instanceof AST_Sequence || tag instanceof AST_Unary || tag instanceof AST_Dot && tag.expression instanceof AST_Object;
    if (parenthesize_tag) output.print("(");
    self2.prefix.print(output);
    if (parenthesize_tag) output.print(")");
    self2.template_string.print(output);
  });
  DEFPRINT(AST_TemplateString, function(self2, output) {
    var is_tagged = output.parent() instanceof AST_PrefixedTemplateString;
    output.print("`");
    for (var i = 0; i < self2.segments.length; i++) {
      if (!(self2.segments[i] instanceof AST_TemplateSegment)) {
        output.print("${");
        self2.segments[i].print(output);
        output.print("}");
      } else if (is_tagged) {
        output.print(self2.segments[i].raw);
      } else {
        output.print_template_string_chars(self2.segments[i].value);
      }
    }
    output.print("`");
  });
  DEFPRINT(AST_TemplateSegment, function(self2, output) {
    output.print_template_string_chars(self2.value);
  });
  AST_Arrow.DEFMETHOD("_do_print", function(output) {
    var self2 = this;
    var parent = output.parent();
    var needs_parens = parent instanceof AST_Binary && !(parent instanceof AST_Assign) && !(parent instanceof AST_DefaultAssign) || parent instanceof AST_Unary || parent instanceof AST_Call && self2 === parent.expression;
    if (needs_parens) {
      output.print("(");
    }
    if (self2.async) {
      output.print("async");
      output.space();
    }
    if (self2.argnames.length === 1 && self2.argnames[0] instanceof AST_Symbol) {
      self2.argnames[0].print(output);
    } else {
      output.with_parens(function() {
        self2.argnames.forEach(function(arg, i) {
          if (i) output.comma();
          arg.print(output);
        });
      });
    }
    output.space();
    output.print("=>");
    output.space();
    const first_statement = self2.body[0];
    if (self2.body.length === 1 && first_statement instanceof AST_Return) {
      const returned = first_statement.value;
      if (!returned) {
        output.print("{}");
      } else if (left_is_object(returned)) {
        output.print("(");
        returned.print(output);
        output.print(")");
      } else {
        returned.print(output);
      }
    } else {
      print_braced(self2, output);
    }
    if (needs_parens) {
      output.print(")");
    }
    output.gc_scope(self2);
  });
  AST_Exit.DEFMETHOD("_do_print", function(output, kind) {
    output.print(kind);
    if (this.value) {
      output.space();
      const comments = this.value.start.comments_before;
      if (comments && comments.length && !output.printed_comments.has(comments)) {
        output.print("(");
        this.value.print(output);
        output.print(")");
      } else {
        this.value.print(output);
      }
    }
    output.semicolon();
  });
  DEFPRINT(AST_Return, function(self2, output) {
    self2._do_print(output, "return");
  });
  DEFPRINT(AST_Throw, function(self2, output) {
    self2._do_print(output, "throw");
  });
  DEFPRINT(AST_Yield, function(self2, output) {
    var star = self2.is_star ? "*" : "";
    output.print("yield" + star);
    if (self2.expression) {
      output.space();
      self2.expression.print(output);
    }
  });
  DEFPRINT(AST_Await, function(self2, output) {
    output.print("await");
    output.space();
    var e = self2.expression;
    var parens = !(e instanceof AST_Call || e instanceof AST_SymbolRef || e instanceof AST_PropAccess || e instanceof AST_Unary || e instanceof AST_Constant || e instanceof AST_Await || e instanceof AST_Object);
    if (parens) output.print("(");
    self2.expression.print(output);
    if (parens) output.print(")");
  });
  AST_LoopControl.DEFMETHOD("_do_print", function(output, kind) {
    output.print(kind);
    if (this.label) {
      output.space();
      this.label.print(output);
    }
    output.semicolon();
  });
  DEFPRINT(AST_Break, function(self2, output) {
    self2._do_print(output, "break");
  });
  DEFPRINT(AST_Continue, function(self2, output) {
    self2._do_print(output, "continue");
  });
  function make_then(self2, output) {
    var b = self2.body;
    if (output.option("braces") || output.option("ie8") && b instanceof AST_Do)
      return make_block(b, output);
    if (!b) return output.force_semicolon();
    while (true) {
      if (b instanceof AST_If) {
        if (!b.alternative) {
          make_block(self2.body, output);
          return;
        }
        b = b.alternative;
      } else if (b instanceof AST_StatementWithBody) {
        b = b.body;
      } else break;
    }
    print_maybe_braced_body(self2.body, output);
  }
  DEFPRINT(AST_If, function(self2, output) {
    output.print("if");
    output.space();
    output.with_parens(function() {
      self2.condition.print(output);
    });
    output.space();
    if (self2.alternative) {
      make_then(self2, output);
      output.space();
      output.print("else");
      output.space();
      if (self2.alternative instanceof AST_If)
        self2.alternative.print(output);
      else
        print_maybe_braced_body(self2.alternative, output);
    } else {
      self2._do_print_body(output);
    }
  });
  DEFPRINT(AST_Switch, function(self2, output) {
    output.print("switch");
    output.space();
    output.with_parens(function() {
      self2.expression.print(output);
    });
    output.space();
    var last6 = self2.body.length - 1;
    if (last6 < 0) print_braced_empty(self2, output);
    else output.with_block(function() {
      self2.body.forEach(function(branch, i) {
        output.indent(true);
        branch.print(output);
        if (i < last6 && branch.body.length > 0)
          output.newline();
      });
    });
  });
  AST_SwitchBranch.DEFMETHOD("_do_print_body", function(output) {
    output.newline();
    this.body.forEach(function(stmt) {
      output.indent();
      stmt.print(output);
      output.newline();
    });
  });
  DEFPRINT(AST_Default, function(self2, output) {
    output.print("default:");
    self2._do_print_body(output);
  });
  DEFPRINT(AST_Case, function(self2, output) {
    output.print("case");
    output.space();
    self2.expression.print(output);
    output.print(":");
    self2._do_print_body(output);
  });
  DEFPRINT(AST_Try, function(self2, output) {
    output.print("try");
    output.space();
    self2.body.print(output);
    if (self2.bcatch) {
      output.space();
      self2.bcatch.print(output);
    }
    if (self2.bfinally) {
      output.space();
      self2.bfinally.print(output);
    }
  });
  DEFPRINT(AST_TryBlock, function(self2, output) {
    print_braced(self2, output);
  });
  DEFPRINT(AST_Catch, function(self2, output) {
    output.print("catch");
    if (self2.argname) {
      output.space();
      output.with_parens(function() {
        self2.argname.print(output);
      });
    }
    output.space();
    print_braced(self2, output);
  });
  DEFPRINT(AST_Finally, function(self2, output) {
    output.print("finally");
    output.space();
    print_braced(self2, output);
  });
  AST_Definitions.DEFMETHOD("_do_print", function(output, kind) {
    output.print(kind);
    output.space();
    this.definitions.forEach(function(def, i) {
      if (i) output.comma();
      def.print(output);
    });
    var p3 = output.parent();
    var in_for = p3 instanceof AST_For || p3 instanceof AST_ForIn;
    var output_semicolon = !in_for || p3 && p3.init !== this;
    if (output_semicolon)
      output.semicolon();
  });
  DEFPRINT(AST_Let, function(self2, output) {
    self2._do_print(output, "let");
  });
  DEFPRINT(AST_Var, function(self2, output) {
    self2._do_print(output, "var");
  });
  DEFPRINT(AST_Const, function(self2, output) {
    self2._do_print(output, "const");
  });
  DEFPRINT(AST_Import, function(self2, output) {
    output.print("import");
    output.space();
    if (self2.imported_name) {
      self2.imported_name.print(output);
    }
    if (self2.imported_name && self2.imported_names) {
      output.print(",");
      output.space();
    }
    if (self2.imported_names) {
      if (self2.imported_names.length === 1 && self2.imported_names[0].foreign_name.name === "*" && !self2.imported_names[0].foreign_name.quote) {
        self2.imported_names[0].print(output);
      } else {
        output.print("{");
        self2.imported_names.forEach(function(name_import, i) {
          output.space();
          name_import.print(output);
          if (i < self2.imported_names.length - 1) {
            output.print(",");
          }
        });
        output.space();
        output.print("}");
      }
    }
    if (self2.imported_name || self2.imported_names) {
      output.space();
      output.print("from");
      output.space();
    }
    self2.module_name.print(output);
    if (self2.attributes) {
      output.print("with");
      self2.attributes.print(output);
    }
    output.semicolon();
  });
  DEFPRINT(AST_ImportMeta, function(self2, output) {
    output.print("import.meta");
  });
  DEFPRINT(AST_NameMapping, function(self2, output) {
    var is_import = output.parent() instanceof AST_Import;
    var definition = self2.name.definition();
    var foreign_name = self2.foreign_name;
    var names_are_different = (definition && definition.mangled_name || self2.name.name) !== foreign_name.name;
    if (!names_are_different && foreign_name.name === "*" && foreign_name.quote != self2.name.quote) {
      names_are_different = true;
    }
    var foreign_name_is_name = foreign_name.quote == null;
    if (names_are_different) {
      if (is_import) {
        if (foreign_name_is_name) {
          output.print(foreign_name.name);
        } else {
          output.print_string(foreign_name.name, foreign_name.quote);
        }
      } else {
        if (self2.name.quote == null) {
          self2.name.print(output);
        } else {
          output.print_string(self2.name.name, self2.name.quote);
        }
      }
      output.space();
      output.print("as");
      output.space();
      if (is_import) {
        self2.name.print(output);
      } else {
        if (foreign_name_is_name) {
          output.print(foreign_name.name);
        } else {
          output.print_string(foreign_name.name, foreign_name.quote);
        }
      }
    } else {
      if (self2.name.quote == null) {
        self2.name.print(output);
      } else {
        output.print_string(self2.name.name, self2.name.quote);
      }
    }
  });
  DEFPRINT(AST_Export, function(self2, output) {
    output.print("export");
    output.space();
    if (self2.is_default) {
      output.print("default");
      output.space();
    }
    if (self2.exported_names) {
      if (self2.exported_names.length === 1 && self2.exported_names[0].name.name === "*" && !self2.exported_names[0].name.quote) {
        self2.exported_names[0].print(output);
      } else {
        output.print("{");
        self2.exported_names.forEach(function(name_export, i) {
          output.space();
          name_export.print(output);
          if (i < self2.exported_names.length - 1) {
            output.print(",");
          }
        });
        output.space();
        output.print("}");
      }
    } else if (self2.exported_value) {
      self2.exported_value.print(output);
    } else if (self2.exported_definition) {
      self2.exported_definition.print(output);
      if (self2.exported_definition instanceof AST_Definitions) return;
    }
    if (self2.module_name) {
      output.space();
      output.print("from");
      output.space();
      self2.module_name.print(output);
    }
    if (self2.attributes) {
      output.print("with");
      self2.attributes.print(output);
    }
    if (self2.exported_value && !(self2.exported_value instanceof AST_Defun || self2.exported_value instanceof AST_Function || self2.exported_value instanceof AST_Class) || self2.module_name || self2.exported_names) {
      output.semicolon();
    }
  });
  function parenthesize_for_noin(node, output, noin) {
    var parens = false;
    if (noin) {
      parens = walk2(node, (node2) => {
        if (node2 instanceof AST_Scope && !(node2 instanceof AST_Arrow)) {
          return true;
        }
        if (node2 instanceof AST_Binary && node2.operator == "in" || node2 instanceof AST_PrivateIn) {
          return walk_abort;
        }
      });
    }
    node.print(output, parens);
  }
  DEFPRINT(AST_VarDef, function(self2, output) {
    self2.name.print(output);
    if (self2.value) {
      output.space();
      output.print("=");
      output.space();
      var p3 = output.parent(1);
      var noin = p3 instanceof AST_For || p3 instanceof AST_ForIn;
      parenthesize_for_noin(self2.value, output, noin);
    }
  });
  DEFPRINT(AST_Call, function(self2, output) {
    self2.expression.print(output);
    if (self2 instanceof AST_New && self2.args.length === 0)
      return;
    if (self2.expression instanceof AST_Call || self2.expression instanceof AST_Lambda) {
      output.add_mapping(self2.start);
    }
    if (self2.optional) output.print("?.");
    output.with_parens(function() {
      self2.args.forEach(function(expr, i) {
        if (i) output.comma();
        expr.print(output);
      });
    });
  });
  DEFPRINT(AST_New, function(self2, output) {
    output.print("new");
    output.space();
    AST_Call.prototype._codegen(self2, output);
  });
  AST_Sequence.DEFMETHOD("_do_print", function(output) {
    this.expressions.forEach(function(node, index) {
      if (index > 0) {
        output.comma();
        if (output.should_break()) {
          output.newline();
          output.indent();
        }
      }
      node.print(output);
    });
  });
  DEFPRINT(AST_Sequence, function(self2, output) {
    self2._do_print(output);
  });
  DEFPRINT(AST_Dot, function(self2, output) {
    var expr = self2.expression;
    expr.print(output);
    var prop = self2.property;
    var print_computed = ALL_RESERVED_WORDS.has(prop) ? output.option("ie8") : !is_identifier_string(
      prop,
      output.option("ecma") >= 2015 && !output.option("safari10")
    );
    if (self2.optional) output.print("?.");
    if (print_computed) {
      output.print("[");
      output.add_mapping(self2.end);
      output.print_string(prop);
      output.print("]");
    } else {
      if (expr instanceof AST_Number && expr.getValue() >= 0) {
        if (!/[xa-f.)]/i.test(output.last())) {
          output.print(".");
        }
      }
      if (!self2.optional) output.print(".");
      output.add_mapping(self2.end);
      output.print_name(prop);
    }
  });
  DEFPRINT(AST_DotHash, function(self2, output) {
    var expr = self2.expression;
    expr.print(output);
    var prop = self2.property;
    if (self2.optional) output.print("?");
    output.print(".#");
    output.add_mapping(self2.end);
    output.print_name(prop);
  });
  DEFPRINT(AST_Sub, function(self2, output) {
    self2.expression.print(output);
    if (self2.optional) output.print("?.");
    output.print("[");
    self2.property.print(output);
    output.print("]");
  });
  DEFPRINT(AST_Chain, function(self2, output) {
    self2.expression.print(output);
  });
  DEFPRINT(AST_UnaryPrefix, function(self2, output) {
    var op = self2.operator;
    if (op === "--" && output.last().endsWith("!")) {
      output.print(" ");
    }
    output.print(op);
    if (/^[a-z]/i.test(op) || /[+-]$/.test(op) && self2.expression instanceof AST_UnaryPrefix && /^[+-]/.test(self2.expression.operator)) {
      output.space();
    }
    self2.expression.print(output);
  });
  DEFPRINT(AST_UnaryPostfix, function(self2, output) {
    self2.expression.print(output);
    output.print(self2.operator);
  });
  DEFPRINT(AST_Binary, function(self2, output) {
    var op = self2.operator;
    self2.left.print(output);
    if (op[0] == ">" && output.last().endsWith("--")) {
      output.print(" ");
    } else {
      output.space();
    }
    output.print(op);
    output.space();
    self2.right.print(output);
  });
  DEFPRINT(AST_Conditional, function(self2, output) {
    self2.condition.print(output);
    output.space();
    output.print("?");
    output.space();
    self2.consequent.print(output);
    output.space();
    output.colon();
    self2.alternative.print(output);
  });
  DEFPRINT(AST_Array, function(self2, output) {
    output.with_square(function() {
      var a2 = self2.elements, len = a2.length;
      if (len > 0) output.space();
      a2.forEach(function(exp, i) {
        if (i) output.comma();
        exp.print(output);
        if (i === len - 1 && exp instanceof AST_Hole)
          output.comma();
      });
      if (len > 0) output.space();
    });
  });
  DEFPRINT(AST_Object, function(self2, output) {
    if (self2.properties.length > 0) output.with_block(function() {
      self2.properties.forEach(function(prop, i) {
        if (i) {
          output.print(",");
          output.newline();
        }
        output.indent();
        prop.print(output);
      });
      output.newline();
    });
    else print_braced_empty(self2, output);
  });
  DEFPRINT(AST_Class, function(self2, output) {
    output.print("class");
    output.space();
    if (self2.name) {
      self2.name.print(output);
      output.space();
    }
    if (self2.extends) {
      var parens = !(self2.extends instanceof AST_SymbolRef) && !(self2.extends instanceof AST_PropAccess) && !(self2.extends instanceof AST_ClassExpression) && !(self2.extends instanceof AST_Function);
      output.print("extends");
      if (parens) {
        output.print("(");
      } else {
        output.space();
      }
      self2.extends.print(output);
      if (parens) {
        output.print(")");
      } else {
        output.space();
      }
    }
    if (self2.properties.length > 0) output.with_block(function() {
      self2.properties.forEach(function(prop, i) {
        if (i) {
          output.newline();
        }
        output.indent();
        prop.print(output);
      });
      output.newline();
    });
    else output.print("{}");
  });
  DEFPRINT(AST_NewTarget, function(self2, output) {
    output.print("new.target");
  });
  function print_property_name(key, quote, output) {
    if (output.option("quote_keys")) {
      output.print_string(key);
      return false;
    }
    if ("" + +key == key && key >= 0) {
      if (output.option("keep_numbers")) {
        output.print(key);
        return false;
      }
      output.print(make_num(key));
      return false;
    }
    var print_string = ALL_RESERVED_WORDS.has(key) ? output.option("ie8") : output.option("ecma") < 2015 || output.option("safari10") ? !is_basic_identifier_string(key) : !is_identifier_string(key, true);
    if (print_string || quote && output.option("keep_quoted_props")) {
      output.print_string(key, quote);
      return false;
    }
    output.print_name(key);
    return true;
  }
  DEFPRINT(AST_ObjectKeyVal, function(self2, output) {
    function get_name(self3) {
      var def = self3.definition();
      return def ? def.mangled_name || def.name : self3.name;
    }
    const try_shorthand = output.option("shorthand") && !(self2.key instanceof AST_Node);
    if (try_shorthand && self2.value instanceof AST_Symbol && get_name(self2.value) === self2.key && !ALL_RESERVED_WORDS.has(self2.key)) {
      const was_shorthand = print_property_name(self2.key, self2.quote, output);
      if (!was_shorthand) {
        output.colon();
        self2.value.print(output);
      }
    } else if (try_shorthand && self2.value instanceof AST_DefaultAssign && self2.value.left instanceof AST_Symbol && get_name(self2.value.left) === self2.key) {
      const was_shorthand = print_property_name(self2.key, self2.quote, output);
      if (!was_shorthand) {
        output.colon();
        self2.value.left.print(output);
      }
      output.space();
      output.print("=");
      output.space();
      self2.value.right.print(output);
    } else {
      if (!(self2.key instanceof AST_Node)) {
        print_property_name(self2.key, self2.quote, output);
      } else {
        output.with_square(function() {
          self2.key.print(output);
        });
      }
      output.colon();
      self2.value.print(output);
    }
  });
  DEFPRINT(AST_ClassPrivateProperty, (self2, output) => {
    if (self2.static) {
      output.print("static");
      output.space();
    }
    output.print("#");
    print_property_name(self2.key.name, self2.quote, output);
    if (self2.value) {
      output.print("=");
      self2.value.print(output);
    }
    output.semicolon();
  });
  DEFPRINT(AST_ClassProperty, (self2, output) => {
    if (self2.static) {
      output.print("static");
      output.space();
    }
    if (self2.key instanceof AST_SymbolClassProperty) {
      print_property_name(self2.key.name, self2.quote, output);
    } else {
      output.print("[");
      self2.key.print(output);
      output.print("]");
    }
    if (self2.value) {
      output.print("=");
      self2.value.print(output);
    }
    output.semicolon();
  });
  AST_ObjectProperty.DEFMETHOD("_print_getter_setter", function(type, is_private, output) {
    var self2 = this;
    if (self2.static) {
      output.print("static");
      output.space();
    }
    if (type) {
      output.print(type);
      output.space();
    }
    if (self2.key instanceof AST_SymbolMethod) {
      if (is_private) output.print("#");
      print_property_name(self2.key.name, self2.quote, output);
      self2.key.add_source_map(output);
    } else {
      output.with_square(function() {
        self2.key.print(output);
      });
    }
    self2.value._do_print(output, true);
  });
  DEFPRINT(AST_ObjectSetter, function(self2, output) {
    self2._print_getter_setter("set", false, output);
  });
  DEFPRINT(AST_ObjectGetter, function(self2, output) {
    self2._print_getter_setter("get", false, output);
  });
  DEFPRINT(AST_PrivateSetter, function(self2, output) {
    self2._print_getter_setter("set", true, output);
  });
  DEFPRINT(AST_PrivateGetter, function(self2, output) {
    self2._print_getter_setter("get", true, output);
  });
  DEFPRINT(AST_ConciseMethod, function(self2, output) {
    var type;
    if (self2.is_generator && self2.async) {
      type = "async*";
    } else if (self2.is_generator) {
      type = "*";
    } else if (self2.async) {
      type = "async";
    }
    self2._print_getter_setter(type, false, output);
  });
  DEFPRINT(AST_PrivateMethod, function(self2, output) {
    var type;
    if (self2.is_generator && self2.async) {
      type = "async*";
    } else if (self2.is_generator) {
      type = "*";
    } else if (self2.async) {
      type = "async";
    }
    self2._print_getter_setter(type, true, output);
  });
  DEFPRINT(AST_PrivateIn, function(self2, output) {
    self2.key.print(output);
    output.space();
    output.print("in");
    output.space();
    self2.value.print(output);
  });
  DEFPRINT(AST_SymbolPrivateProperty, function(self2, output) {
    output.print("#" + self2.name);
  });
  DEFPRINT(AST_ClassStaticBlock, function(self2, output) {
    output.print("static");
    output.space();
    print_braced(self2, output);
  });
  AST_Symbol.DEFMETHOD("_do_print", function(output) {
    var def = this.definition();
    output.print_name(def ? def.mangled_name || def.name : this.name);
  });
  DEFPRINT(AST_Symbol, function(self2, output) {
    self2._do_print(output);
  });
  DEFPRINT(AST_Hole, noop);
  DEFPRINT(AST_This, function(self2, output) {
    output.print("this");
  });
  DEFPRINT(AST_Super, function(self2, output) {
    output.print("super");
  });
  DEFPRINT(AST_Constant, function(self2, output) {
    output.print(self2.getValue());
  });
  DEFPRINT(AST_String, function(self2, output) {
    output.print_string(self2.getValue(), self2.quote, output.in_directive);
  });
  DEFPRINT(AST_Number, function(self2, output) {
    if ((output.option("keep_numbers") || output.use_asm) && self2.raw) {
      output.print(self2.raw);
    } else {
      output.print(make_num(self2.getValue()));
    }
  });
  DEFPRINT(AST_BigInt, function(self2, output) {
    output.print(self2.getValue() + "n");
  });
  const r_slash_script = /(<\s*\/\s*script)/i;
  const r_starts_with_script = /^\s*script/i;
  const slash_script_replace = (_2, $1) => $1.replace("/", "\\/");
  DEFPRINT(AST_RegExp, function(self2, output) {
    let { source, flags } = self2.getValue();
    source = regexp_source_fix(source);
    flags = flags ? sort_regexp_flags(flags) : "";
    source = source.replace(r_slash_script, slash_script_replace);
    if (r_starts_with_script.test(source) && output.last().endsWith("<")) {
      output.print(" ");
    }
    output.print(output.to_utf8(`/${source}/${flags}`, false, true));
    const parent = output.parent();
    if (parent instanceof AST_Binary && /^\w/.test(parent.operator) && parent.left === self2) {
      output.print(" ");
    }
  });
  function print_maybe_braced_body(stat2, output) {
    if (output.option("braces")) {
      make_block(stat2, output);
    } else {
      if (!stat2 || stat2 instanceof AST_EmptyStatement)
        output.force_semicolon();
      else if (stat2 instanceof AST_Let || stat2 instanceof AST_Const || stat2 instanceof AST_Class)
        make_block(stat2, output);
      else
        stat2.print(output);
    }
  }
  function best_of2(a2) {
    var best = a2[0], len = best.length;
    for (var i = 1; i < a2.length; ++i) {
      if (a2[i].length < len) {
        best = a2[i];
        len = best.length;
      }
    }
    return best;
  }
  function make_num(num) {
    var str = num.toString(10).replace(/^0\./, ".").replace("e+", "e");
    var candidates = [str];
    if (Math.floor(num) === num) {
      if (num < 0) {
        candidates.push("-0x" + (-num).toString(16).toLowerCase());
      } else {
        candidates.push("0x" + num.toString(16).toLowerCase());
      }
    }
    var match18, len, digits;
    if (match18 = /^\.0+/.exec(str)) {
      len = match18[0].length;
      digits = str.slice(len);
      candidates.push(digits + "e-" + (digits.length + len - 1));
    } else if (match18 = /0+$/.exec(str)) {
      len = match18[0].length;
      candidates.push(str.slice(0, -len) + "e" + len);
    } else if (match18 = /^(\d)\.(\d+)e(-?\d+)$/.exec(str)) {
      candidates.push(match18[1] + match18[2] + "e" + (match18[3] - match18[2].length));
    }
    return best_of2(candidates);
  }
  function make_block(stmt, output) {
    if (!stmt || stmt instanceof AST_EmptyStatement)
      output.print("{}");
    else if (stmt instanceof AST_BlockStatement)
      stmt.print(output);
    else output.with_block(function() {
      output.indent();
      stmt.print(output);
      output.newline();
    });
  }
  function DEFMAP(nodetype, generator) {
    nodetype.forEach(function(nodetype2) {
      nodetype2.DEFMETHOD("add_source_map", generator);
    });
  }
  DEFMAP([
    // We could easily add info for ALL nodes, but it seems to me that
    // would be quite wasteful, hence this noop in the base class.
    AST_Node,
    // since the label symbol will mark it
    AST_LabeledStatement,
    AST_Toplevel
  ], noop);
  DEFMAP([
    AST_Array,
    AST_BlockStatement,
    AST_Catch,
    AST_Class,
    AST_Constant,
    AST_Debugger,
    AST_Definitions,
    AST_Directive,
    AST_Finally,
    AST_Jump,
    AST_Lambda,
    AST_New,
    AST_Object,
    AST_StatementWithBody,
    AST_Symbol,
    AST_Switch,
    AST_SwitchBranch,
    AST_TemplateString,
    AST_TemplateSegment,
    AST_Try
  ], function(output) {
    output.add_mapping(this.start);
  });
  DEFMAP([
    AST_ObjectGetter,
    AST_ObjectSetter,
    AST_PrivateGetter,
    AST_PrivateSetter,
    AST_ConciseMethod,
    AST_PrivateMethod
  ], function(output) {
    output.add_mapping(
      this.start,
      false
      /*name handled below*/
    );
  });
  DEFMAP([
    AST_SymbolMethod,
    AST_SymbolPrivateProperty
  ], function(output) {
    const tok_type = this.end && this.end.type;
    if (tok_type === "name" || tok_type === "privatename") {
      output.add_mapping(this.end, this.name);
    } else {
      output.add_mapping(this.end);
    }
  });
  DEFMAP([AST_ObjectProperty], function(output) {
    output.add_mapping(this.start, this.key);
  });
})();

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/equivalent-to.js
var shallow_cmp = (node1, node2) => {
  return node1 === null && node2 === null || node1.TYPE === node2.TYPE && node1.shallow_cmp(node2);
};
var equivalent_to = (tree1, tree2) => {
  if (!shallow_cmp(tree1, tree2)) return false;
  const walk_1_state = [tree1];
  const walk_2_state = [tree2];
  const walk_1_push = walk_1_state.push.bind(walk_1_state);
  const walk_2_push = walk_2_state.push.bind(walk_2_state);
  while (walk_1_state.length && walk_2_state.length) {
    const node_1 = walk_1_state.pop();
    const node_2 = walk_2_state.pop();
    if (!shallow_cmp(node_1, node_2)) return false;
    node_1._children_backwards(walk_1_push);
    node_2._children_backwards(walk_2_push);
    if (walk_1_state.length !== walk_2_state.length) {
      return false;
    }
  }
  return walk_1_state.length == 0 && walk_2_state.length == 0;
};
var pass_through = () => true;
AST_Node.prototype.shallow_cmp = function() {
  throw new Error("did not find a shallow_cmp function for " + this.constructor.name);
};
AST_Debugger.prototype.shallow_cmp = pass_through;
AST_Directive.prototype.shallow_cmp = function(other) {
  return this.value === other.value;
};
AST_SimpleStatement.prototype.shallow_cmp = pass_through;
AST_Block.prototype.shallow_cmp = pass_through;
AST_EmptyStatement.prototype.shallow_cmp = pass_through;
AST_LabeledStatement.prototype.shallow_cmp = function(other) {
  return this.label.name === other.label.name;
};
AST_Do.prototype.shallow_cmp = pass_through;
AST_While.prototype.shallow_cmp = pass_through;
AST_For.prototype.shallow_cmp = function(other) {
  return (this.init == null ? other.init == null : this.init === other.init) && (this.condition == null ? other.condition == null : this.condition === other.condition) && (this.step == null ? other.step == null : this.step === other.step);
};
AST_ForIn.prototype.shallow_cmp = pass_through;
AST_ForOf.prototype.shallow_cmp = pass_through;
AST_With.prototype.shallow_cmp = pass_through;
AST_Toplevel.prototype.shallow_cmp = pass_through;
AST_Expansion.prototype.shallow_cmp = pass_through;
AST_Lambda.prototype.shallow_cmp = function(other) {
  return this.is_generator === other.is_generator && this.async === other.async;
};
AST_Destructuring.prototype.shallow_cmp = function(other) {
  return this.is_array === other.is_array;
};
AST_PrefixedTemplateString.prototype.shallow_cmp = pass_through;
AST_TemplateString.prototype.shallow_cmp = pass_through;
AST_TemplateSegment.prototype.shallow_cmp = function(other) {
  return this.value === other.value;
};
AST_Jump.prototype.shallow_cmp = pass_through;
AST_LoopControl.prototype.shallow_cmp = pass_through;
AST_Await.prototype.shallow_cmp = pass_through;
AST_Yield.prototype.shallow_cmp = function(other) {
  return this.is_star === other.is_star;
};
AST_If.prototype.shallow_cmp = function(other) {
  return this.alternative == null ? other.alternative == null : this.alternative === other.alternative;
};
AST_Switch.prototype.shallow_cmp = pass_through;
AST_SwitchBranch.prototype.shallow_cmp = pass_through;
AST_Try.prototype.shallow_cmp = function(other) {
  return this.body === other.body && (this.bcatch == null ? other.bcatch == null : this.bcatch === other.bcatch) && (this.bfinally == null ? other.bfinally == null : this.bfinally === other.bfinally);
};
AST_Catch.prototype.shallow_cmp = function(other) {
  return this.argname == null ? other.argname == null : this.argname === other.argname;
};
AST_Finally.prototype.shallow_cmp = pass_through;
AST_Definitions.prototype.shallow_cmp = pass_through;
AST_VarDef.prototype.shallow_cmp = function(other) {
  return this.value == null ? other.value == null : this.value === other.value;
};
AST_NameMapping.prototype.shallow_cmp = pass_through;
AST_Import.prototype.shallow_cmp = function(other) {
  return (this.imported_name == null ? other.imported_name == null : this.imported_name === other.imported_name) && (this.imported_names == null ? other.imported_names == null : this.imported_names === other.imported_names);
};
AST_ImportMeta.prototype.shallow_cmp = pass_through;
AST_Export.prototype.shallow_cmp = function(other) {
  return (this.exported_definition == null ? other.exported_definition == null : this.exported_definition === other.exported_definition) && (this.exported_value == null ? other.exported_value == null : this.exported_value === other.exported_value) && (this.exported_names == null ? other.exported_names == null : this.exported_names === other.exported_names) && this.module_name === other.module_name && this.is_default === other.is_default;
};
AST_Call.prototype.shallow_cmp = pass_through;
AST_Sequence.prototype.shallow_cmp = pass_through;
AST_PropAccess.prototype.shallow_cmp = pass_through;
AST_Chain.prototype.shallow_cmp = pass_through;
AST_Dot.prototype.shallow_cmp = function(other) {
  return this.property === other.property;
};
AST_DotHash.prototype.shallow_cmp = function(other) {
  return this.property === other.property;
};
AST_Unary.prototype.shallow_cmp = function(other) {
  return this.operator === other.operator;
};
AST_Binary.prototype.shallow_cmp = function(other) {
  return this.operator === other.operator;
};
AST_Conditional.prototype.shallow_cmp = pass_through;
AST_Array.prototype.shallow_cmp = pass_through;
AST_Object.prototype.shallow_cmp = pass_through;
AST_ObjectProperty.prototype.shallow_cmp = pass_through;
AST_ObjectKeyVal.prototype.shallow_cmp = function(other) {
  return this.key === other.key;
};
AST_ObjectSetter.prototype.shallow_cmp = function(other) {
  return this.static === other.static;
};
AST_ObjectGetter.prototype.shallow_cmp = function(other) {
  return this.static === other.static;
};
AST_ConciseMethod.prototype.shallow_cmp = function(other) {
  return this.static === other.static && this.is_generator === other.is_generator && this.async === other.async;
};
AST_PrivateMethod.prototype.shallow_cmp = function(other) {
  return this.static === other.static && this.is_generator === other.is_generator && this.async === other.async;
};
AST_Class.prototype.shallow_cmp = function(other) {
  return (this.name == null ? other.name == null : this.name === other.name) && (this.extends == null ? other.extends == null : this.extends === other.extends);
};
AST_ClassProperty.prototype.shallow_cmp = function(other) {
  return this.static === other.static && (typeof this.key === "string" ? this.key === other.key : true);
};
AST_ClassPrivateProperty.prototype.shallow_cmp = function(other) {
  return this.static === other.static;
};
AST_Symbol.prototype.shallow_cmp = function(other) {
  return this.name === other.name;
};
AST_NewTarget.prototype.shallow_cmp = pass_through;
AST_This.prototype.shallow_cmp = pass_through;
AST_Super.prototype.shallow_cmp = pass_through;
AST_String.prototype.shallow_cmp = function(other) {
  return this.value === other.value;
};
AST_Number.prototype.shallow_cmp = function(other) {
  return this.value === other.value;
};
AST_BigInt.prototype.shallow_cmp = function(other) {
  return this.value === other.value;
};
AST_RegExp.prototype.shallow_cmp = function(other) {
  return this.value.flags === other.value.flags && this.value.source === other.value.source;
};
AST_Atom.prototype.shallow_cmp = pass_through;

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/scope.js
var MASK_EXPORT_DONT_MANGLE = 1 << 0;
var MASK_EXPORT_WANT_MANGLE = 1 << 1;
var function_defs = null;
var unmangleable_names = null;
var scopes_with_block_defuns = null;
var SymbolDef = class _SymbolDef {
  constructor(scope5, orig, init2) {
    this.name = orig.name;
    this.orig = [orig];
    this.init = init2;
    this.eliminated = 0;
    this.assignments = 0;
    this.scope = scope5;
    this.replaced = 0;
    this.global = false;
    this.export = 0;
    this.mangled_name = null;
    this.undeclared = false;
    this.id = _SymbolDef.next_id++;
    this.chained = false;
    this.direct_access = false;
    this.escaped = 0;
    this.recursive_refs = 0;
    this.references = [];
    this.should_replace = void 0;
    this.single_use = false;
    this.fixed = false;
    Object.seal(this);
  }
  fixed_value() {
    if (!this.fixed || this.fixed instanceof AST_Node) return this.fixed;
    return this.fixed();
  }
  unmangleable(options) {
    if (!options) options = {};
    if (function_defs && function_defs.has(this.id) && keep_name(options.keep_fnames, this.orig[0].name)) return true;
    return this.global && !options.toplevel || this.export & MASK_EXPORT_DONT_MANGLE || this.undeclared || !options.eval && this.scope.pinned() || (this.orig[0] instanceof AST_SymbolLambda || this.orig[0] instanceof AST_SymbolDefun) && keep_name(options.keep_fnames, this.orig[0].name) || this.orig[0] instanceof AST_SymbolMethod || (this.orig[0] instanceof AST_SymbolClass || this.orig[0] instanceof AST_SymbolDefClass) && keep_name(options.keep_classnames, this.orig[0].name);
  }
  mangle(options) {
    const cache3 = options.cache && options.cache.props;
    if (this.global && cache3 && cache3.has(this.name)) {
      this.mangled_name = cache3.get(this.name);
    } else if (!this.mangled_name && !this.unmangleable(options)) {
      var s2 = this.scope;
      var sym = this.orig[0];
      if (options.ie8 && sym instanceof AST_SymbolLambda)
        s2 = s2.parent_scope;
      const redefinition = redefined_catch_def(this);
      this.mangled_name = redefinition ? redefinition.mangled_name || redefinition.name : s2.next_mangled(options, this);
      if (this.global && cache3) {
        cache3.set(this.name, this.mangled_name);
      }
    }
  }
};
SymbolDef.next_id = 1;
function redefined_catch_def(def) {
  if (def.orig[0] instanceof AST_SymbolCatch && def.scope.is_block_scope()) {
    return def.scope.get_defun_scope().variables.get(def.name);
  }
}
AST_Scope.DEFMETHOD("figure_out_scope", function(options, { parent_scope = void 0, toplevel = this } = {}) {
  options = defaults2(options, {
    cache: null,
    ie8: false,
    safari10: false,
    module: false
  });
  if (!(toplevel instanceof AST_Toplevel)) {
    throw new Error("Invalid toplevel scope");
  }
  var scope5 = this.parent_scope = parent_scope;
  var labels = /* @__PURE__ */ new Map();
  var defun = null;
  var in_destructuring = null;
  var for_scopes = [];
  var tw = new TreeWalker((node, descend) => {
    if (node.is_block_scope()) {
      const save_scope2 = scope5;
      node.block_scope = scope5 = new AST_Scope(node);
      scope5._block_scope = true;
      scope5.init_scope_vars(save_scope2);
      scope5.uses_with = save_scope2.uses_with;
      scope5.uses_eval = save_scope2.uses_eval;
      if (options.safari10) {
        if (node instanceof AST_For || node instanceof AST_ForIn || node instanceof AST_ForOf) {
          for_scopes.push(scope5);
        }
      }
      if (node instanceof AST_Switch) {
        const the_block_scope = scope5;
        scope5 = save_scope2;
        node.expression.walk(tw);
        scope5 = the_block_scope;
        for (let i = 0; i < node.body.length; i++) {
          node.body[i].walk(tw);
        }
      } else {
        descend();
      }
      scope5 = save_scope2;
      return true;
    }
    if (node instanceof AST_Destructuring) {
      const save_destructuring = in_destructuring;
      in_destructuring = node;
      descend();
      in_destructuring = save_destructuring;
      return true;
    }
    if (node instanceof AST_Scope) {
      node.init_scope_vars(scope5);
      var save_scope = scope5;
      var save_defun = defun;
      var save_labels = labels;
      defun = scope5 = node;
      labels = /* @__PURE__ */ new Map();
      descend();
      scope5 = save_scope;
      defun = save_defun;
      labels = save_labels;
      return true;
    }
    if (node instanceof AST_LabeledStatement) {
      var l = node.label;
      if (labels.has(l.name)) {
        throw new Error(string_template("Label {name} defined twice", l));
      }
      labels.set(l.name, l);
      descend();
      labels.delete(l.name);
      return true;
    }
    if (node instanceof AST_With) {
      for (var s2 = scope5; s2; s2 = s2.parent_scope)
        s2.uses_with = true;
      return;
    }
    if (node instanceof AST_Symbol) {
      node.scope = scope5;
    }
    if (node instanceof AST_Label) {
      node.thedef = node;
      node.references = [];
    }
    if (node instanceof AST_SymbolLambda) {
      defun.def_function(node, node.name == "arguments" ? void 0 : defun);
    } else if (node instanceof AST_SymbolDefun) {
      const closest_scope = defun.parent_scope;
      node.scope = tw.directives["use strict"] ? closest_scope : closest_scope.get_defun_scope();
      mark_export(node.scope.def_function(node, defun), 1);
    } else if (node instanceof AST_SymbolClass) {
      mark_export(defun.def_variable(node, defun), 1);
    } else if (node instanceof AST_SymbolImport) {
      scope5.def_variable(node);
    } else if (node instanceof AST_SymbolDefClass) {
      mark_export((node.scope = defun.parent_scope).def_function(node, defun), 1);
    } else if (node instanceof AST_SymbolVar || node instanceof AST_SymbolLet || node instanceof AST_SymbolConst || node instanceof AST_SymbolCatch) {
      var def;
      if (node instanceof AST_SymbolBlockDeclaration) {
        def = scope5.def_variable(node, null);
      } else {
        def = defun.def_variable(node, node.TYPE == "SymbolVar" ? null : void 0);
      }
      if (!def.orig.every((sym2) => {
        if (sym2 === node) return true;
        if (node instanceof AST_SymbolBlockDeclaration) {
          return sym2 instanceof AST_SymbolLambda;
        }
        return !(sym2 instanceof AST_SymbolLet || sym2 instanceof AST_SymbolConst);
      })) {
        js_error(
          `"${node.name}" is redeclared`,
          node.start.file,
          node.start.line,
          node.start.col,
          node.start.pos
        );
      }
      if (!(node instanceof AST_SymbolFunarg)) mark_export(def, 2);
      if (defun !== scope5) {
        node.mark_enclosed();
        var def = scope5.find_variable(node);
        if (node.thedef !== def) {
          node.thedef = def;
          node.reference();
        }
      }
    } else if (node instanceof AST_LabelRef) {
      var sym = labels.get(node.name);
      if (!sym) throw new Error(string_template("Undefined label {name} [{line},{col}]", {
        name: node.name,
        line: node.start.line,
        col: node.start.col
      }));
      node.thedef = sym;
    }
    if (!(scope5 instanceof AST_Toplevel) && (node instanceof AST_Export || node instanceof AST_Import)) {
      js_error(
        `"${node.TYPE}" statement may only appear at the top level`,
        node.start.file,
        node.start.line,
        node.start.col,
        node.start.pos
      );
    }
  });
  if (options.module) {
    tw.directives["use strict"] = true;
  }
  this.walk(tw);
  function mark_export(def, level) {
    if (in_destructuring) {
      var i = 0;
      do {
        level++;
      } while (tw.parent(i++) !== in_destructuring);
    }
    var node = tw.parent(level);
    if (def.export = node instanceof AST_Export ? MASK_EXPORT_DONT_MANGLE : 0) {
      var exported = node.exported_definition;
      if ((exported instanceof AST_Defun || exported instanceof AST_DefClass) && node.is_default) {
        def.export = MASK_EXPORT_WANT_MANGLE;
      }
    }
  }
  const is_toplevel = this instanceof AST_Toplevel;
  if (is_toplevel) {
    this.globals = /* @__PURE__ */ new Map();
  }
  var tw = new TreeWalker((node) => {
    if (node instanceof AST_LoopControl && node.label) {
      node.label.thedef.references.push(node);
      return true;
    }
    if (node instanceof AST_SymbolRef) {
      var name = node.name;
      if (name == "eval" && tw.parent() instanceof AST_Call) {
        for (var s2 = node.scope; s2 && !s2.uses_eval; s2 = s2.parent_scope) {
          s2.uses_eval = true;
        }
      }
      var sym;
      if (tw.parent() instanceof AST_NameMapping && tw.parent(1).module_name || !(sym = node.scope.find_variable(name))) {
        sym = toplevel.def_global(node);
        if (node instanceof AST_SymbolExport) sym.export = MASK_EXPORT_DONT_MANGLE;
      } else if (sym.scope instanceof AST_Lambda && name == "arguments") {
        sym.scope.get_defun_scope().uses_arguments = true;
      }
      node.thedef = sym;
      node.reference();
      if (node.scope.is_block_scope() && !(sym.orig[0] instanceof AST_SymbolBlockDeclaration)) {
        node.scope = node.scope.get_defun_scope();
      }
      return true;
    }
    var def;
    if (node instanceof AST_SymbolCatch && (def = redefined_catch_def(node.definition()))) {
      var s2 = node.scope;
      while (s2) {
        push_uniq(s2.enclosed, def);
        if (s2 === def.scope) break;
        s2 = s2.parent_scope;
      }
    }
  });
  this.walk(tw);
  if (options.ie8 || options.safari10) {
    walk2(this, (node) => {
      if (node instanceof AST_SymbolCatch) {
        var name = node.name;
        var refs = node.thedef.references;
        var scope6 = node.scope.get_defun_scope();
        var def = scope6.find_variable(name) || toplevel.globals.get(name) || scope6.def_variable(node);
        refs.forEach(function(ref) {
          ref.thedef = def;
          ref.reference();
        });
        node.thedef = def;
        node.reference();
        return true;
      }
    });
  }
  if (options.safari10) {
    for (const scope6 of for_scopes) {
      scope6.parent_scope.variables.forEach(function(def) {
        push_uniq(scope6.enclosed, def);
      });
    }
  }
});
AST_Toplevel.DEFMETHOD("def_global", function(node) {
  var globals = this.globals, name = node.name;
  if (globals.has(name)) {
    return globals.get(name);
  } else {
    var g = new SymbolDef(this, node);
    g.undeclared = true;
    g.global = true;
    globals.set(name, g);
    return g;
  }
});
AST_Scope.DEFMETHOD("init_scope_vars", function(parent_scope) {
  this.variables = /* @__PURE__ */ new Map();
  this.uses_with = false;
  this.uses_eval = false;
  this.parent_scope = parent_scope;
  this.enclosed = [];
  this.cname = -1;
});
AST_Scope.DEFMETHOD("conflicting_def", function(name) {
  return this.enclosed.find((def) => def.name === name) || this.variables.has(name) || this.parent_scope && this.parent_scope.conflicting_def(name);
});
AST_Scope.DEFMETHOD("conflicting_def_shallow", function(name) {
  return this.enclosed.find((def) => def.name === name) || this.variables.has(name);
});
AST_Scope.DEFMETHOD("add_child_scope", function(scope5) {
  if (scope5.parent_scope === this) return;
  scope5.parent_scope = this;
  if (scope5 instanceof AST_Arrow && (this instanceof AST_Lambda && !this.uses_arguments)) {
    this.uses_arguments = walk2(scope5, (node) => {
      if (node instanceof AST_SymbolRef && node.scope instanceof AST_Lambda && node.name === "arguments") {
        return walk_abort;
      }
      if (node instanceof AST_Lambda && !(node instanceof AST_Arrow)) {
        return true;
      }
    });
  }
  this.uses_with = this.uses_with || scope5.uses_with;
  this.uses_eval = this.uses_eval || scope5.uses_eval;
  const scope_ancestry = (() => {
    const ancestry = [];
    let cur = this;
    do {
      ancestry.push(cur);
    } while (cur = cur.parent_scope);
    ancestry.reverse();
    return ancestry;
  })();
  const new_scope_enclosed_set = new Set(scope5.enclosed);
  const to_enclose = [];
  for (const scope_topdown of scope_ancestry) {
    to_enclose.forEach((e) => push_uniq(scope_topdown.enclosed, e));
    for (const def of scope_topdown.variables.values()) {
      if (new_scope_enclosed_set.has(def)) {
        push_uniq(to_enclose, def);
        push_uniq(scope_topdown.enclosed, def);
      }
    }
  }
});
function find_scopes_visible_from(scopes) {
  const found_scopes = /* @__PURE__ */ new Set();
  for (const scope5 of new Set(scopes)) {
    (function bubble_up(scope6) {
      if (scope6 == null || found_scopes.has(scope6)) return;
      found_scopes.add(scope6);
      bubble_up(scope6.parent_scope);
    })(scope5);
  }
  return [...found_scopes];
}
AST_Scope.DEFMETHOD("create_symbol", function(SymClass, {
  source,
  tentative_name,
  scope: scope5,
  conflict_scopes = [scope5],
  init: init2 = null
} = {}) {
  let symbol_name;
  conflict_scopes = find_scopes_visible_from(conflict_scopes);
  if (tentative_name) {
    tentative_name = symbol_name = tentative_name.replace(/(?:^[^a-z_$]|[^a-z0-9_$])/ig, "_");
    let i = 0;
    while (conflict_scopes.find((s2) => s2.conflicting_def_shallow(symbol_name))) {
      symbol_name = tentative_name + "$" + i++;
    }
  }
  if (!symbol_name) {
    throw new Error("No symbol name could be generated in create_symbol()");
  }
  const symbol3 = make_node(SymClass, source, {
    name: symbol_name,
    scope: scope5
  });
  this.def_variable(symbol3, init2 || null);
  symbol3.mark_enclosed();
  return symbol3;
});
AST_Node.DEFMETHOD("is_block_scope", return_false);
AST_Class.DEFMETHOD("is_block_scope", return_false);
AST_Lambda.DEFMETHOD("is_block_scope", return_false);
AST_Toplevel.DEFMETHOD("is_block_scope", return_false);
AST_SwitchBranch.DEFMETHOD("is_block_scope", return_false);
AST_Block.DEFMETHOD("is_block_scope", return_true);
AST_Scope.DEFMETHOD("is_block_scope", function() {
  return this._block_scope || false;
});
AST_IterationStatement.DEFMETHOD("is_block_scope", return_true);
AST_Lambda.DEFMETHOD("init_scope_vars", function() {
  AST_Scope.prototype.init_scope_vars.apply(this, arguments);
  this.uses_arguments = false;
  this.def_variable(new AST_SymbolFunarg({
    name: "arguments",
    start: this.start,
    end: this.end
  }));
});
AST_Arrow.DEFMETHOD("init_scope_vars", function() {
  AST_Scope.prototype.init_scope_vars.apply(this, arguments);
  this.uses_arguments = false;
});
AST_Symbol.DEFMETHOD("mark_enclosed", function() {
  var def = this.definition();
  var s2 = this.scope;
  while (s2) {
    push_uniq(s2.enclosed, def);
    if (s2 === def.scope) break;
    s2 = s2.parent_scope;
  }
});
AST_Symbol.DEFMETHOD("reference", function() {
  this.definition().references.push(this);
  this.mark_enclosed();
});
AST_Scope.DEFMETHOD("find_variable", function(name) {
  if (name instanceof AST_Symbol) name = name.name;
  return this.variables.get(name) || this.parent_scope && this.parent_scope.find_variable(name);
});
AST_Scope.DEFMETHOD("def_function", function(symbol3, init2) {
  var def = this.def_variable(symbol3, init2);
  if (!def.init || def.init instanceof AST_Defun) def.init = init2;
  return def;
});
AST_Scope.DEFMETHOD("def_variable", function(symbol3, init2) {
  var def = this.variables.get(symbol3.name);
  if (def) {
    def.orig.push(symbol3);
    if (def.init && (def.scope !== symbol3.scope || def.init instanceof AST_Function)) {
      def.init = init2;
    }
  } else {
    def = new SymbolDef(this, symbol3, init2);
    this.variables.set(symbol3.name, def);
    def.global = !this.parent_scope;
  }
  return symbol3.thedef = def;
});
function next_mangled(scope5, options) {
  let defun_scope;
  if (scopes_with_block_defuns && (defun_scope = scope5.get_defun_scope()) && scopes_with_block_defuns.has(defun_scope)) {
    scope5 = defun_scope;
  }
  var ext = scope5.enclosed;
  var nth_identifier = options.nth_identifier;
  out: while (true) {
    var m2 = nth_identifier.get(++scope5.cname);
    if (ALL_RESERVED_WORDS.has(m2)) continue;
    if (options.reserved.has(m2)) continue;
    if (unmangleable_names && unmangleable_names.has(m2)) continue out;
    for (let i = ext.length; --i >= 0; ) {
      const def = ext[i];
      const name = def.mangled_name || def.unmangleable(options) && def.name;
      if (m2 == name) continue out;
    }
    return m2;
  }
}
AST_Scope.DEFMETHOD("next_mangled", function(options) {
  return next_mangled(this, options);
});
AST_Toplevel.DEFMETHOD("next_mangled", function(options) {
  let name;
  const mangled_names = this.mangled_names;
  do {
    name = next_mangled(this, options);
  } while (mangled_names.has(name));
  return name;
});
AST_Function.DEFMETHOD("next_mangled", function(options, def) {
  var tricky_def = def.orig[0] instanceof AST_SymbolFunarg && this.name && this.name.definition();
  var tricky_name = tricky_def ? tricky_def.mangled_name || tricky_def.name : null;
  while (true) {
    var name = next_mangled(this, options);
    if (!tricky_name || tricky_name != name)
      return name;
  }
});
AST_Symbol.DEFMETHOD("unmangleable", function(options) {
  var def = this.definition();
  return !def || def.unmangleable(options);
});
AST_Label.DEFMETHOD("unmangleable", return_false);
AST_Symbol.DEFMETHOD("unreferenced", function() {
  return !this.definition().references.length && !this.scope.pinned();
});
AST_Symbol.DEFMETHOD("definition", function() {
  return this.thedef;
});
AST_Symbol.DEFMETHOD("global", function() {
  return this.thedef.global;
});
function format_mangler_options(options) {
  options = defaults2(options, {
    eval: false,
    nth_identifier: base54,
    ie8: false,
    keep_classnames: false,
    keep_fnames: false,
    module: false,
    reserved: [],
    toplevel: false
  });
  if (options.module) options.toplevel = true;
  if (!Array.isArray(options.reserved) && !(options.reserved instanceof Set)) {
    options.reserved = [];
  }
  options.reserved = new Set(options.reserved);
  options.reserved.add("arguments");
  return options;
}
AST_Toplevel.DEFMETHOD("mangle_names", function(options) {
  options = format_mangler_options(options);
  var nth_identifier = options.nth_identifier;
  var lname = -1;
  var to_mangle = [];
  if (options.keep_fnames) {
    function_defs = /* @__PURE__ */ new Set();
  }
  const mangled_names = this.mangled_names = /* @__PURE__ */ new Set();
  unmangleable_names = /* @__PURE__ */ new Set();
  if (options.cache) {
    this.globals.forEach(collect2);
    if (options.cache.props) {
      options.cache.props.forEach(function(mangled_name) {
        mangled_names.add(mangled_name);
      });
    }
  }
  var tw = new TreeWalker(function(node, descend) {
    if (node instanceof AST_LabeledStatement) {
      var save_nesting = lname;
      descend();
      lname = save_nesting;
      return true;
    }
    if (node instanceof AST_Defun && !(tw.parent() instanceof AST_Scope)) {
      scopes_with_block_defuns = scopes_with_block_defuns || /* @__PURE__ */ new Set();
      scopes_with_block_defuns.add(node.parent_scope.get_defun_scope());
    }
    if (node instanceof AST_Scope) {
      node.variables.forEach(collect2);
      return;
    }
    if (node.is_block_scope()) {
      node.block_scope.variables.forEach(collect2);
      return;
    }
    if (function_defs && node instanceof AST_VarDef && node.value instanceof AST_Lambda && !node.value.name && keep_name(options.keep_fnames, node.name.name)) {
      function_defs.add(node.name.definition().id);
      return;
    }
    if (node instanceof AST_Label) {
      let name;
      do {
        name = nth_identifier.get(++lname);
      } while (ALL_RESERVED_WORDS.has(name));
      node.mangled_name = name;
      return true;
    }
    if (!(options.ie8 || options.safari10) && node instanceof AST_SymbolCatch) {
      to_mangle.push(node.definition());
      return;
    }
  });
  this.walk(tw);
  if (options.keep_fnames || options.keep_classnames) {
    to_mangle.forEach((def) => {
      if (def.name.length < 6 && def.unmangleable(options)) {
        unmangleable_names.add(def.name);
      }
    });
  }
  to_mangle.forEach((def) => {
    def.mangle(options);
  });
  function_defs = null;
  unmangleable_names = null;
  scopes_with_block_defuns = null;
  function collect2(symbol3) {
    if (symbol3.export & MASK_EXPORT_DONT_MANGLE) {
      unmangleable_names.add(symbol3.name);
    } else if (!options.reserved.has(symbol3.name)) {
      to_mangle.push(symbol3);
    }
  }
});
AST_Toplevel.DEFMETHOD("find_colliding_names", function(options) {
  const cache3 = options.cache && options.cache.props;
  const avoid = /* @__PURE__ */ new Set();
  options.reserved.forEach(to_avoid);
  this.globals.forEach(add_def);
  this.walk(new TreeWalker(function(node) {
    if (node instanceof AST_Scope) node.variables.forEach(add_def);
    if (node instanceof AST_SymbolCatch) add_def(node.definition());
  }));
  return avoid;
  function to_avoid(name) {
    avoid.add(name);
  }
  function add_def(def) {
    var name = def.name;
    if (def.global && cache3 && cache3.has(name)) name = cache3.get(name);
    else if (!def.unmangleable(options)) return;
    to_avoid(name);
  }
});
AST_Toplevel.DEFMETHOD("expand_names", function(options) {
  options = format_mangler_options(options);
  var nth_identifier = options.nth_identifier;
  if (nth_identifier.reset && nth_identifier.sort) {
    nth_identifier.reset();
    nth_identifier.sort();
  }
  var avoid = this.find_colliding_names(options);
  var cname = 0;
  this.globals.forEach(rename);
  this.walk(new TreeWalker(function(node) {
    if (node instanceof AST_Scope) node.variables.forEach(rename);
    if (node instanceof AST_SymbolCatch) rename(node.definition());
  }));
  function next_name() {
    var name;
    do {
      name = nth_identifier.get(cname++);
    } while (avoid.has(name) || ALL_RESERVED_WORDS.has(name));
    return name;
  }
  function rename(def) {
    if (def.global && options.cache) return;
    if (def.unmangleable(options)) return;
    if (options.reserved.has(def.name)) return;
    const redefinition = redefined_catch_def(def);
    const name = def.name = redefinition ? redefinition.name : next_name();
    def.orig.forEach(function(sym) {
      sym.name = name;
    });
    def.references.forEach(function(sym) {
      sym.name = name;
    });
  }
});
AST_Node.DEFMETHOD("tail_node", return_this);
AST_Sequence.DEFMETHOD("tail_node", function() {
  return this.expressions[this.expressions.length - 1];
});
AST_Toplevel.DEFMETHOD("compute_char_frequency", function(options) {
  options = format_mangler_options(options);
  var nth_identifier = options.nth_identifier;
  if (!nth_identifier.reset || !nth_identifier.consider || !nth_identifier.sort) {
    return;
  }
  nth_identifier.reset();
  try {
    AST_Node.prototype.print = function(stream, force_parens) {
      this._print(stream, force_parens);
      if (this instanceof AST_Symbol && !this.unmangleable(options)) {
        nth_identifier.consider(this.name, -1);
      } else if (options.properties) {
        if (this instanceof AST_DotHash) {
          nth_identifier.consider("#" + this.property, -1);
        } else if (this instanceof AST_Dot) {
          nth_identifier.consider(this.property, -1);
        } else if (this instanceof AST_Sub) {
          skip_string(this.property);
        }
      }
    };
    nth_identifier.consider(this.print_to_string(), 1);
  } finally {
    AST_Node.prototype.print = AST_Node.prototype._print;
  }
  nth_identifier.sort();
  function skip_string(node) {
    if (node instanceof AST_String) {
      nth_identifier.consider(node.value, -1);
    } else if (node instanceof AST_Conditional) {
      skip_string(node.consequent);
      skip_string(node.alternative);
    } else if (node instanceof AST_Sequence) {
      skip_string(node.tail_node());
    }
  }
});
var base54 = (() => {
  const leading = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_".split("");
  const digits = "0123456789".split("");
  let chars3;
  let frequency5;
  function reset() {
    frequency5 = /* @__PURE__ */ new Map();
    leading.forEach(function(ch) {
      frequency5.set(ch, 0);
    });
    digits.forEach(function(ch) {
      frequency5.set(ch, 0);
    });
  }
  function consider(str, delta) {
    for (var i = str.length; --i >= 0; ) {
      frequency5.set(str[i], frequency5.get(str[i]) + delta);
    }
  }
  function compare(a2, b) {
    return frequency5.get(b) - frequency5.get(a2);
  }
  function sort4() {
    chars3 = mergeSort(leading, compare).concat(mergeSort(digits, compare));
  }
  reset();
  sort4();
  function base542(num) {
    var ret = "", base2 = 54;
    num++;
    do {
      num--;
      ret += chars3[num % base2];
      num = Math.floor(num / base2);
      base2 = 64;
    } while (num > 0);
    return ret;
  }
  return {
    get: base542,
    consider,
    reset,
    sort: sort4
  };
})();

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/size.js
var mangle_options = void 0;
AST_Node.prototype.size = function(compressor, stack) {
  mangle_options = compressor && compressor._mangle_options;
  let size16 = 0;
  walk_parent(this, (node, info3) => {
    size16 += node._size(info3);
    if (node instanceof AST_Arrow && node.is_braceless()) {
      size16 += node.body[0].value._size(info3);
      return true;
    }
  }, stack || compressor && compressor.stack);
  mangle_options = void 0;
  return size16;
};
AST_Node.prototype._size = () => 0;
AST_Debugger.prototype._size = () => 8;
AST_Directive.prototype._size = function() {
  return 2 + this.value.length;
};
var list_overhead = (array6) => array6.length && array6.length - 1;
AST_Block.prototype._size = function() {
  return 2 + list_overhead(this.body);
};
AST_Toplevel.prototype._size = function() {
  return list_overhead(this.body);
};
AST_EmptyStatement.prototype._size = () => 1;
AST_LabeledStatement.prototype._size = () => 2;
AST_Do.prototype._size = () => 9;
AST_While.prototype._size = () => 7;
AST_For.prototype._size = () => 8;
AST_ForIn.prototype._size = () => 8;
AST_With.prototype._size = () => 6;
AST_Expansion.prototype._size = () => 3;
var lambda_modifiers = (func) => (func.is_generator ? 1 : 0) + (func.async ? 6 : 0);
AST_Accessor.prototype._size = function() {
  return lambda_modifiers(this) + 4 + list_overhead(this.argnames) + list_overhead(this.body);
};
AST_Function.prototype._size = function(info3) {
  const first3 = !!first_in_statement(info3);
  return first3 * 2 + lambda_modifiers(this) + 12 + list_overhead(this.argnames) + list_overhead(this.body);
};
AST_Defun.prototype._size = function() {
  return lambda_modifiers(this) + 13 + list_overhead(this.argnames) + list_overhead(this.body);
};
AST_Arrow.prototype._size = function() {
  let args_and_arrow = 2 + list_overhead(this.argnames);
  if (!(this.argnames.length === 1 && this.argnames[0] instanceof AST_Symbol)) {
    args_and_arrow += 2;
  }
  const body_overhead = this.is_braceless() ? 0 : list_overhead(this.body) + 2;
  return lambda_modifiers(this) + args_and_arrow + body_overhead;
};
AST_Destructuring.prototype._size = () => 2;
AST_TemplateString.prototype._size = function() {
  return 2 + Math.floor(this.segments.length / 2) * 3;
};
AST_TemplateSegment.prototype._size = function() {
  return this.value.length;
};
AST_Return.prototype._size = function() {
  return this.value ? 7 : 6;
};
AST_Throw.prototype._size = () => 6;
AST_Break.prototype._size = function() {
  return this.label ? 6 : 5;
};
AST_Continue.prototype._size = function() {
  return this.label ? 9 : 8;
};
AST_If.prototype._size = () => 4;
AST_Switch.prototype._size = function() {
  return 8 + list_overhead(this.body);
};
AST_Case.prototype._size = function() {
  return 5 + list_overhead(this.body);
};
AST_Default.prototype._size = function() {
  return 8 + list_overhead(this.body);
};
AST_Try.prototype._size = () => 3;
AST_Catch.prototype._size = function() {
  let size16 = 7 + list_overhead(this.body);
  if (this.argname) {
    size16 += 2;
  }
  return size16;
};
AST_Finally.prototype._size = function() {
  return 7 + list_overhead(this.body);
};
AST_Var.prototype._size = function() {
  return 4 + list_overhead(this.definitions);
};
AST_Let.prototype._size = function() {
  return 4 + list_overhead(this.definitions);
};
AST_Const.prototype._size = function() {
  return 6 + list_overhead(this.definitions);
};
AST_VarDef.prototype._size = function() {
  return this.value ? 1 : 0;
};
AST_NameMapping.prototype._size = function() {
  return this.name ? 4 : 0;
};
AST_Import.prototype._size = function() {
  let size16 = 6;
  if (this.imported_name) size16 += 1;
  if (this.imported_name || this.imported_names) size16 += 5;
  if (this.imported_names) {
    size16 += 2 + list_overhead(this.imported_names);
  }
  return size16;
};
AST_ImportMeta.prototype._size = () => 11;
AST_Export.prototype._size = function() {
  let size16 = 7 + (this.is_default ? 8 : 0);
  if (this.exported_value) {
    size16 += this.exported_value._size();
  }
  if (this.exported_names) {
    size16 += 2 + list_overhead(this.exported_names);
  }
  if (this.module_name) {
    size16 += 5;
  }
  return size16;
};
AST_Call.prototype._size = function() {
  if (this.optional) {
    return 4 + list_overhead(this.args);
  }
  return 2 + list_overhead(this.args);
};
AST_New.prototype._size = function() {
  return 6 + list_overhead(this.args);
};
AST_Sequence.prototype._size = function() {
  return list_overhead(this.expressions);
};
AST_Dot.prototype._size = function() {
  if (this.optional) {
    return this.property.length + 2;
  }
  return this.property.length + 1;
};
AST_DotHash.prototype._size = function() {
  if (this.optional) {
    return this.property.length + 3;
  }
  return this.property.length + 2;
};
AST_Sub.prototype._size = function() {
  return this.optional ? 4 : 2;
};
AST_Unary.prototype._size = function() {
  if (this.operator === "typeof") return 7;
  if (this.operator === "void") return 5;
  return this.operator.length;
};
AST_Binary.prototype._size = function(info3) {
  if (this.operator === "in") return 4;
  let size16 = this.operator.length;
  if ((this.operator === "+" || this.operator === "-") && this.right instanceof AST_Unary && this.right.operator === this.operator) {
    size16 += 1;
  }
  if (this.needs_parens(info3)) {
    size16 += 2;
  }
  return size16;
};
AST_Conditional.prototype._size = () => 3;
AST_Array.prototype._size = function() {
  return 2 + list_overhead(this.elements);
};
AST_Object.prototype._size = function(info3) {
  let base2 = 2;
  if (first_in_statement(info3)) {
    base2 += 2;
  }
  return base2 + list_overhead(this.properties);
};
var key_size = (key) => typeof key === "string" ? key.length : 0;
AST_ObjectKeyVal.prototype._size = function() {
  return key_size(this.key) + 1;
};
var static_size = (is_static) => is_static ? 7 : 0;
AST_ObjectGetter.prototype._size = function() {
  return 5 + static_size(this.static) + key_size(this.key);
};
AST_ObjectSetter.prototype._size = function() {
  return 5 + static_size(this.static) + key_size(this.key);
};
AST_ConciseMethod.prototype._size = function() {
  return static_size(this.static) + key_size(this.key) + lambda_modifiers(this);
};
AST_PrivateMethod.prototype._size = function() {
  return AST_ConciseMethod.prototype._size.call(this) + 1;
};
AST_PrivateGetter.prototype._size = function() {
  return AST_ConciseMethod.prototype._size.call(this) + 4;
};
AST_PrivateSetter.prototype._size = function() {
  return AST_ConciseMethod.prototype._size.call(this) + 4;
};
AST_PrivateIn.prototype._size = function() {
  return 5;
};
AST_Class.prototype._size = function() {
  return (this.name ? 8 : 7) + (this.extends ? 8 : 0);
};
AST_ClassStaticBlock.prototype._size = function() {
  return 8 + list_overhead(this.body);
};
AST_ClassProperty.prototype._size = function() {
  return static_size(this.static) + (typeof this.key === "string" ? this.key.length + 2 : 0) + (this.value ? 1 : 0);
};
AST_ClassPrivateProperty.prototype._size = function() {
  return AST_ClassProperty.prototype._size.call(this) + 1;
};
AST_Symbol.prototype._size = function() {
  if (!(mangle_options && this.thedef && !this.thedef.unmangleable(mangle_options))) {
    return this.name.length;
  } else {
    return 1;
  }
};
AST_SymbolClassProperty.prototype._size = function() {
  return this.name.length;
};
AST_SymbolRef.prototype._size = AST_SymbolDeclaration.prototype._size = function() {
  if (this.name === "arguments") return 9;
  return AST_Symbol.prototype._size.call(this);
};
AST_NewTarget.prototype._size = () => 10;
AST_SymbolImportForeign.prototype._size = function() {
  return this.name.length;
};
AST_SymbolExportForeign.prototype._size = function() {
  return this.name.length;
};
AST_This.prototype._size = () => 4;
AST_Super.prototype._size = () => 5;
AST_String.prototype._size = function() {
  return this.value.length + 2;
};
AST_Number.prototype._size = function() {
  const { value } = this;
  if (value === 0) return 1;
  if (value > 0 && Math.floor(value) === value) {
    return Math.floor(Math.log10(value) + 1);
  }
  return value.toString().length;
};
AST_BigInt.prototype._size = function() {
  return this.value.length;
};
AST_RegExp.prototype._size = function() {
  return this.value.toString().length;
};
AST_Null.prototype._size = () => 4;
AST_NaN.prototype._size = () => 3;
AST_Undefined.prototype._size = () => 6;
AST_Hole.prototype._size = () => 0;
AST_Infinity.prototype._size = () => 8;
AST_True.prototype._size = () => 4;
AST_False.prototype._size = () => 5;
AST_Await.prototype._size = () => 6;
AST_Yield.prototype._size = () => 6;

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/compress/compressor-flags.js
var UNUSED = 1;
var TRUTHY = 2;
var FALSY = 4;
var UNDEFINED = 8;
var INLINED = 16;
var WRITE_ONLY = 32;
var SQUEEZED = 256;
var OPTIMIZED = 512;
var TOP = 1024;
var CLEAR_BETWEEN_PASSES = SQUEEZED | OPTIMIZED | TOP;
var has_flag = (node, flag) => node.flags & flag;
var set_flag = (node, flag) => {
  node.flags |= flag;
};
var clear_flag = (node, flag) => {
  node.flags &= ~flag;
};

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/compress/common.js
function merge_sequence(array6, node) {
  if (node instanceof AST_Sequence) {
    array6.push(...node.expressions);
  } else {
    array6.push(node);
  }
  return array6;
}
function make_sequence(orig, expressions) {
  if (expressions.length == 1) return expressions[0];
  if (expressions.length == 0) throw new Error("trying to create a sequence with length zero!");
  return make_node(AST_Sequence, orig, {
    expressions: expressions.reduce(merge_sequence, [])
  });
}
function make_empty_function(self2) {
  return make_node(AST_Function, self2, {
    uses_arguments: false,
    argnames: [],
    body: [],
    is_generator: false,
    async: false,
    variables: /* @__PURE__ */ new Map(),
    uses_with: false,
    uses_eval: false,
    parent_scope: null,
    enclosed: [],
    cname: 0,
    block_scope: void 0
  });
}
function make_node_from_constant(val, orig) {
  switch (typeof val) {
    case "string":
      return make_node(AST_String, orig, {
        value: val
      });
    case "number":
      if (isNaN(val)) return make_node(AST_NaN, orig);
      if (isFinite(val)) {
        return 1 / val < 0 ? make_node(AST_UnaryPrefix, orig, {
          operator: "-",
          expression: make_node(AST_Number, orig, { value: -val })
        }) : make_node(AST_Number, orig, { value: val });
      }
      return val < 0 ? make_node(AST_UnaryPrefix, orig, {
        operator: "-",
        expression: make_node(AST_Infinity, orig)
      }) : make_node(AST_Infinity, orig);
    case "bigint":
      return make_node(AST_BigInt, orig, { value: val.toString() });
    case "boolean":
      return make_node(val ? AST_True : AST_False, orig);
    case "undefined":
      return make_node(AST_Undefined, orig);
    default:
      if (val === null) {
        return make_node(AST_Null, orig, { value: null });
      }
      if (val instanceof RegExp) {
        return make_node(AST_RegExp, orig, {
          value: {
            source: regexp_source_fix(val.source),
            flags: val.flags
          }
        });
      }
      throw new Error(string_template("Can't handle constant of type: {type}", {
        type: typeof val
      }));
  }
}
function best_of_expression(ast1, ast2) {
  return ast1.size() > ast2.size() ? ast2 : ast1;
}
function best_of_statement(ast1, ast2) {
  return best_of_expression(
    make_node(AST_SimpleStatement, ast1, {
      body: ast1
    }),
    make_node(AST_SimpleStatement, ast2, {
      body: ast2
    })
  ).body;
}
function best_of(compressor, ast1, ast2) {
  if (first_in_statement(compressor)) {
    return best_of_statement(ast1, ast2);
  } else {
    return best_of_expression(ast1, ast2);
  }
}
function get_simple_key(key) {
  if (key instanceof AST_Constant) {
    return key.getValue();
  }
  if (key instanceof AST_UnaryPrefix && key.operator == "void" && key.expression instanceof AST_Constant) {
    return;
  }
  return key;
}
function read_property(obj, key) {
  key = get_simple_key(key);
  if (key instanceof AST_Node) return;
  var value;
  if (obj instanceof AST_Array) {
    var elements = obj.elements;
    if (key == "length") return make_node_from_constant(elements.length, obj);
    if (typeof key == "number" && key in elements) value = elements[key];
  } else if (obj instanceof AST_Object) {
    key = "" + key;
    var props = obj.properties;
    for (var i = props.length; --i >= 0; ) {
      var prop = props[i];
      if (!(prop instanceof AST_ObjectKeyVal)) return;
      if (!value && props[i].key === key) value = props[i].value;
    }
  }
  return value instanceof AST_SymbolRef && value.fixed_value() || value;
}
function has_break_or_continue(loop3, parent) {
  var found2 = false;
  var tw = new TreeWalker(function(node) {
    if (found2 || node instanceof AST_Scope) return true;
    if (node instanceof AST_LoopControl && tw.loopcontrol_target(node) === loop3) {
      return found2 = true;
    }
  });
  if (parent instanceof AST_LabeledStatement) tw.push(parent);
  tw.push(loop3);
  loop3.body.walk(tw);
  return found2;
}
function maintain_this_binding(parent, orig, val) {
  if (requires_sequence_to_maintain_binding(parent, orig, val)) {
    const zero2 = make_node(AST_Number, orig, { value: 0 });
    return make_sequence(orig, [zero2, val]);
  } else {
    return val;
  }
}
function requires_sequence_to_maintain_binding(parent, orig, val) {
  return parent instanceof AST_UnaryPrefix && parent.operator == "delete" || parent instanceof AST_Call && parent.expression === orig && (val instanceof AST_Chain || val instanceof AST_PropAccess || val instanceof AST_SymbolRef && val.name == "eval");
}
function is_func_expr(node) {
  return node instanceof AST_Arrow || node instanceof AST_Function;
}
function is_iife_call(node) {
  if (node.TYPE != "Call") return false;
  return node.expression instanceof AST_Function || is_iife_call(node.expression);
}
function is_empty(thing) {
  if (thing === null) return true;
  if (thing instanceof AST_EmptyStatement) return true;
  if (thing instanceof AST_BlockStatement) return thing.body.length == 0;
  return false;
}
var identifier_atom = makePredicate("Infinity NaN undefined");
function is_identifier_atom(node) {
  return node instanceof AST_Infinity || node instanceof AST_NaN || node instanceof AST_Undefined;
}
function is_ref_of(ref, type) {
  if (!(ref instanceof AST_SymbolRef)) return false;
  var orig = ref.definition().orig;
  for (var i = orig.length; --i >= 0; ) {
    if (orig[i] instanceof type) return true;
  }
}
function can_be_evicted_from_block(node) {
  return !(node instanceof AST_DefClass || node instanceof AST_Defun || node instanceof AST_Let || node instanceof AST_Const || node instanceof AST_Export || node instanceof AST_Import);
}
function as_statement_array(thing) {
  if (thing === null) return [];
  if (thing instanceof AST_BlockStatement) return thing.body;
  if (thing instanceof AST_EmptyStatement) return [];
  if (thing instanceof AST_Statement) return [thing];
  throw new Error("Can't convert thing to statement array");
}
function is_reachable(scope_node, defs) {
  const find_ref = (node) => {
    if (node instanceof AST_SymbolRef && defs.includes(node.definition())) {
      return walk_abort;
    }
  };
  return walk_parent(scope_node, (node, info3) => {
    if (node instanceof AST_Scope && node !== scope_node) {
      var parent = info3.parent();
      if (parent instanceof AST_Call && parent.expression === node && !(node.async || node.is_generator)) {
        return;
      }
      if (walk2(node, find_ref)) return walk_abort;
      return true;
    }
  });
}
function is_recursive_ref(tw, def) {
  var node;
  for (var i = 0; node = tw.parent(i); i++) {
    if (node instanceof AST_Lambda || node instanceof AST_Class) {
      var name = node.name;
      if (name && name.definition() === def) {
        return true;
      }
    }
  }
  return false;
}
function retain_top_func(fn2, compressor) {
  return compressor.top_retain && fn2 instanceof AST_Defun && has_flag(fn2, TOP) && fn2.name && compressor.top_retain(fn2.name.definition());
}

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/compress/native-objects.js
function make_nested_lookup(obj) {
  const out = /* @__PURE__ */ new Map();
  for (var key of Object.keys(obj)) {
    out.set(key, makePredicate(obj[key]));
  }
  const does_have = (global_name, fname) => {
    const inner_map = out.get(global_name);
    return inner_map != null && inner_map.has(fname);
  };
  return does_have;
}
var pure_prop_access_globals = /* @__PURE__ */ new Set([
  "Number",
  "String",
  "Array",
  "Object",
  "Function",
  "Promise"
]);
var object_methods = [
  "constructor",
  "toString",
  "valueOf"
];
var is_pure_native_method = make_nested_lookup({
  Array: [
    "at",
    "flat",
    "includes",
    "indexOf",
    "join",
    "lastIndexOf",
    "slice",
    ...object_methods
  ],
  Boolean: object_methods,
  Function: object_methods,
  Number: [
    "toExponential",
    "toFixed",
    "toPrecision",
    ...object_methods
  ],
  Object: object_methods,
  RegExp: [
    "test",
    ...object_methods
  ],
  String: [
    "at",
    "charAt",
    "charCodeAt",
    "charPointAt",
    "concat",
    "endsWith",
    "fromCharCode",
    "fromCodePoint",
    "includes",
    "indexOf",
    "italics",
    "lastIndexOf",
    "localeCompare",
    "match",
    "matchAll",
    "normalize",
    "padStart",
    "padEnd",
    "repeat",
    "replace",
    "replaceAll",
    "search",
    "slice",
    "split",
    "startsWith",
    "substr",
    "substring",
    "repeat",
    "toLocaleLowerCase",
    "toLocaleUpperCase",
    "toLowerCase",
    "toUpperCase",
    "trim",
    "trimEnd",
    "trimStart",
    ...object_methods
  ]
});
var is_pure_native_fn = make_nested_lookup({
  Array: [
    "isArray"
  ],
  Math: [
    "abs",
    "acos",
    "asin",
    "atan",
    "ceil",
    "cos",
    "exp",
    "floor",
    "log",
    "round",
    "sin",
    "sqrt",
    "tan",
    "atan2",
    "pow",
    "max",
    "min"
  ],
  Number: [
    "isFinite",
    "isNaN"
  ],
  Object: [
    "create",
    "getOwnPropertyDescriptor",
    "getOwnPropertyNames",
    "getPrototypeOf",
    "isExtensible",
    "isFrozen",
    "isSealed",
    "hasOwn",
    "keys"
  ],
  String: [
    "fromCharCode"
  ]
});
var is_pure_native_value = make_nested_lookup({
  Math: [
    "E",
    "LN10",
    "LN2",
    "LOG2E",
    "LOG10E",
    "PI",
    "SQRT1_2",
    "SQRT2"
  ],
  Number: [
    "MAX_VALUE",
    "MIN_VALUE",
    "NaN",
    "NEGATIVE_INFINITY",
    "POSITIVE_INFINITY"
  ]
});

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/compress/inference.js
var is_undeclared_ref = (node) => node instanceof AST_SymbolRef && node.definition().undeclared;
var bitwise_binop = makePredicate("<<< >> << & | ^ ~");
var lazy_op = makePredicate("&& || ??");
var unary_side_effects = makePredicate("delete ++ --");
(function(def_is_boolean) {
  const unary_bool = makePredicate("! delete");
  const binary_bool = makePredicate("in instanceof == != === !== < <= >= >");
  def_is_boolean(AST_Node, return_false);
  def_is_boolean(AST_UnaryPrefix, function() {
    return unary_bool.has(this.operator);
  });
  def_is_boolean(AST_Binary, function() {
    return binary_bool.has(this.operator) || lazy_op.has(this.operator) && this.left.is_boolean() && this.right.is_boolean();
  });
  def_is_boolean(AST_Conditional, function() {
    return this.consequent.is_boolean() && this.alternative.is_boolean();
  });
  def_is_boolean(AST_Assign, function() {
    return this.operator == "=" && this.right.is_boolean();
  });
  def_is_boolean(AST_Sequence, function() {
    return this.tail_node().is_boolean();
  });
  def_is_boolean(AST_True, return_true);
  def_is_boolean(AST_False, return_true);
})(function(node, func) {
  node.DEFMETHOD("is_boolean", func);
});
(function(def_is_number) {
  def_is_number(AST_Node, return_false);
  def_is_number(AST_Number, return_true);
  const unary = makePredicate("+ - ~ ++ --");
  def_is_number(AST_Unary, function() {
    return unary.has(this.operator) && !(this.expression instanceof AST_BigInt);
  });
  const numeric_ops = makePredicate("- * / % & | ^ << >> >>>");
  def_is_number(AST_Binary, function(compressor) {
    return numeric_ops.has(this.operator) || this.operator == "+" && this.left.is_number(compressor) && this.right.is_number(compressor);
  });
  def_is_number(AST_Assign, function(compressor) {
    return numeric_ops.has(this.operator.slice(0, -1)) || this.operator == "=" && this.right.is_number(compressor);
  });
  def_is_number(AST_Sequence, function(compressor) {
    return this.tail_node().is_number(compressor);
  });
  def_is_number(AST_Conditional, function(compressor) {
    return this.consequent.is_number(compressor) && this.alternative.is_number(compressor);
  });
})(function(node, func) {
  node.DEFMETHOD("is_number", func);
});
(function(def_is_32_bit_integer) {
  def_is_32_bit_integer(AST_Node, return_false);
  def_is_32_bit_integer(AST_Number, function() {
    return this.value === (this.value | 0);
  });
  def_is_32_bit_integer(AST_UnaryPrefix, function() {
    return this.operator == "~" ? this.expression.is_number() : this.operator === "+" ? this.expression.is_32_bit_integer() : false;
  });
  def_is_32_bit_integer(AST_Binary, function() {
    return bitwise_binop.has(this.operator);
  });
})(function(node, func) {
  node.DEFMETHOD("is_32_bit_integer", func);
});
(function(def_is_string) {
  def_is_string(AST_Node, return_false);
  def_is_string(AST_String, return_true);
  def_is_string(AST_TemplateString, return_true);
  def_is_string(AST_UnaryPrefix, function() {
    return this.operator == "typeof";
  });
  def_is_string(AST_Binary, function(compressor) {
    return this.operator == "+" && (this.left.is_string(compressor) || this.right.is_string(compressor));
  });
  def_is_string(AST_Assign, function(compressor) {
    return (this.operator == "=" || this.operator == "+=") && this.right.is_string(compressor);
  });
  def_is_string(AST_Sequence, function(compressor) {
    return this.tail_node().is_string(compressor);
  });
  def_is_string(AST_Conditional, function(compressor) {
    return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);
  });
})(function(node, func) {
  node.DEFMETHOD("is_string", func);
});
function is_undefined(node, compressor) {
  return has_flag(node, UNDEFINED) || node instanceof AST_Undefined || node instanceof AST_UnaryPrefix && node.operator == "void" && !node.expression.has_side_effects(compressor);
}
function is_null_or_undefined(node, compressor) {
  let fixed2;
  return node instanceof AST_Null || is_undefined(node, compressor) || node instanceof AST_SymbolRef && (fixed2 = node.definition().fixed) instanceof AST_Node && is_nullish(fixed2, compressor);
}
function is_nullish_shortcircuited(node, compressor) {
  if (node instanceof AST_PropAccess || node instanceof AST_Call) {
    return node.optional && is_null_or_undefined(node.expression, compressor) || is_nullish_shortcircuited(node.expression, compressor);
  }
  if (node instanceof AST_Chain) return is_nullish_shortcircuited(node.expression, compressor);
  return false;
}
function is_nullish(node, compressor) {
  if (is_null_or_undefined(node, compressor)) return true;
  return is_nullish_shortcircuited(node, compressor);
}
(function(def_has_side_effects) {
  def_has_side_effects(AST_Node, return_true);
  def_has_side_effects(AST_EmptyStatement, return_false);
  def_has_side_effects(AST_Constant, return_false);
  def_has_side_effects(AST_This, return_false);
  function any(list, compressor) {
    for (var i = list.length; --i >= 0; )
      if (list[i].has_side_effects(compressor))
        return true;
    return false;
  }
  def_has_side_effects(AST_Block, function(compressor) {
    return any(this.body, compressor);
  });
  def_has_side_effects(AST_Call, function(compressor) {
    if (!this.is_callee_pure(compressor) && (!this.expression.is_call_pure(compressor) || this.expression.has_side_effects(compressor))) {
      return true;
    }
    return any(this.args, compressor);
  });
  def_has_side_effects(AST_Switch, function(compressor) {
    return this.expression.has_side_effects(compressor) || any(this.body, compressor);
  });
  def_has_side_effects(AST_Case, function(compressor) {
    return this.expression.has_side_effects(compressor) || any(this.body, compressor);
  });
  def_has_side_effects(AST_Try, function(compressor) {
    return this.body.has_side_effects(compressor) || this.bcatch && this.bcatch.has_side_effects(compressor) || this.bfinally && this.bfinally.has_side_effects(compressor);
  });
  def_has_side_effects(AST_If, function(compressor) {
    return this.condition.has_side_effects(compressor) || this.body && this.body.has_side_effects(compressor) || this.alternative && this.alternative.has_side_effects(compressor);
  });
  def_has_side_effects(AST_ImportMeta, return_false);
  def_has_side_effects(AST_LabeledStatement, function(compressor) {
    return this.body.has_side_effects(compressor);
  });
  def_has_side_effects(AST_SimpleStatement, function(compressor) {
    return this.body.has_side_effects(compressor);
  });
  def_has_side_effects(AST_Lambda, return_false);
  def_has_side_effects(AST_Class, function(compressor) {
    if (this.extends && this.extends.has_side_effects(compressor)) {
      return true;
    }
    return any(this.properties, compressor);
  });
  def_has_side_effects(AST_ClassStaticBlock, function(compressor) {
    return any(this.body, compressor);
  });
  def_has_side_effects(AST_Binary, function(compressor) {
    return this.left.has_side_effects(compressor) || this.right.has_side_effects(compressor);
  });
  def_has_side_effects(AST_Assign, return_true);
  def_has_side_effects(AST_Conditional, function(compressor) {
    return this.condition.has_side_effects(compressor) || this.consequent.has_side_effects(compressor) || this.alternative.has_side_effects(compressor);
  });
  def_has_side_effects(AST_Unary, function(compressor) {
    return unary_side_effects.has(this.operator) || this.expression.has_side_effects(compressor);
  });
  def_has_side_effects(AST_SymbolRef, function(compressor) {
    return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);
  });
  def_has_side_effects(AST_SymbolClassProperty, return_false);
  def_has_side_effects(AST_SymbolDeclaration, return_false);
  def_has_side_effects(AST_Object, function(compressor) {
    return any(this.properties, compressor);
  });
  def_has_side_effects(AST_ObjectKeyVal, function(compressor) {
    return this.computed_key() && this.key.has_side_effects(compressor) || this.value && this.value.has_side_effects(compressor);
  });
  def_has_side_effects([
    AST_ClassProperty,
    AST_ClassPrivateProperty
  ], function(compressor) {
    return this.computed_key() && this.key.has_side_effects(compressor) || this.static && this.value && this.value.has_side_effects(compressor);
  });
  def_has_side_effects([
    AST_PrivateMethod,
    AST_PrivateGetter,
    AST_PrivateSetter,
    AST_ConciseMethod,
    AST_ObjectGetter,
    AST_ObjectSetter
  ], function(compressor) {
    return this.computed_key() && this.key.has_side_effects(compressor);
  });
  def_has_side_effects(AST_Array, function(compressor) {
    return any(this.elements, compressor);
  });
  def_has_side_effects(AST_Dot, function(compressor) {
    if (is_nullish(this, compressor)) {
      return this.expression.has_side_effects(compressor);
    }
    if (!this.optional && this.expression.may_throw_on_access(compressor)) {
      return true;
    }
    return this.expression.has_side_effects(compressor);
  });
  def_has_side_effects(AST_Sub, function(compressor) {
    if (is_nullish(this, compressor)) {
      return this.expression.has_side_effects(compressor);
    }
    if (!this.optional && this.expression.may_throw_on_access(compressor)) {
      return true;
    }
    var property3 = this.property.has_side_effects(compressor);
    if (property3 && this.optional) return true;
    return property3 || this.expression.has_side_effects(compressor);
  });
  def_has_side_effects(AST_Chain, function(compressor) {
    return this.expression.has_side_effects(compressor);
  });
  def_has_side_effects(AST_Sequence, function(compressor) {
    return any(this.expressions, compressor);
  });
  def_has_side_effects(AST_Definitions, function(compressor) {
    return any(this.definitions, compressor);
  });
  def_has_side_effects(AST_VarDef, function() {
    return this.value != null;
  });
  def_has_side_effects(AST_TemplateSegment, return_false);
  def_has_side_effects(AST_TemplateString, function(compressor) {
    return any(this.segments, compressor);
  });
})(function(node_or_nodes, func) {
  for (const node of [].concat(node_or_nodes)) {
    node.DEFMETHOD("has_side_effects", func);
  }
});
(function(def_may_throw) {
  def_may_throw(AST_Node, return_true);
  def_may_throw(AST_Constant, return_false);
  def_may_throw(AST_EmptyStatement, return_false);
  def_may_throw(AST_Lambda, return_false);
  def_may_throw(AST_SymbolDeclaration, return_false);
  def_may_throw(AST_This, return_false);
  def_may_throw(AST_ImportMeta, return_false);
  function any(list, compressor) {
    for (var i = list.length; --i >= 0; )
      if (list[i].may_throw(compressor))
        return true;
    return false;
  }
  def_may_throw(AST_Class, function(compressor) {
    if (this.extends && this.extends.may_throw(compressor)) return true;
    return any(this.properties, compressor);
  });
  def_may_throw(AST_ClassStaticBlock, function(compressor) {
    return any(this.body, compressor);
  });
  def_may_throw(AST_Array, function(compressor) {
    return any(this.elements, compressor);
  });
  def_may_throw(AST_Assign, function(compressor) {
    if (this.right.may_throw(compressor)) return true;
    if (!compressor.has_directive("use strict") && this.operator == "=" && this.left instanceof AST_SymbolRef) {
      return false;
    }
    return this.left.may_throw(compressor);
  });
  def_may_throw(AST_Binary, function(compressor) {
    return this.left.may_throw(compressor) || this.right.may_throw(compressor);
  });
  def_may_throw(AST_Block, function(compressor) {
    return any(this.body, compressor);
  });
  def_may_throw(AST_Call, function(compressor) {
    if (is_nullish(this, compressor)) return false;
    if (any(this.args, compressor)) return true;
    if (this.is_callee_pure(compressor)) return false;
    if (this.expression.may_throw(compressor)) return true;
    return !(this.expression instanceof AST_Lambda) || any(this.expression.body, compressor);
  });
  def_may_throw(AST_Case, function(compressor) {
    return this.expression.may_throw(compressor) || any(this.body, compressor);
  });
  def_may_throw(AST_Conditional, function(compressor) {
    return this.condition.may_throw(compressor) || this.consequent.may_throw(compressor) || this.alternative.may_throw(compressor);
  });
  def_may_throw(AST_Definitions, function(compressor) {
    return any(this.definitions, compressor);
  });
  def_may_throw(AST_If, function(compressor) {
    return this.condition.may_throw(compressor) || this.body && this.body.may_throw(compressor) || this.alternative && this.alternative.may_throw(compressor);
  });
  def_may_throw(AST_LabeledStatement, function(compressor) {
    return this.body.may_throw(compressor);
  });
  def_may_throw(AST_Object, function(compressor) {
    return any(this.properties, compressor);
  });
  def_may_throw(AST_ObjectKeyVal, function(compressor) {
    return this.computed_key() && this.key.may_throw(compressor) || this.value ? this.value.may_throw(compressor) : false;
  });
  def_may_throw([
    AST_ClassProperty,
    AST_ClassPrivateProperty
  ], function(compressor) {
    return this.computed_key() && this.key.may_throw(compressor) || this.static && this.value && this.value.may_throw(compressor);
  });
  def_may_throw([
    AST_ConciseMethod,
    AST_ObjectGetter,
    AST_ObjectSetter
  ], function(compressor) {
    return this.computed_key() && this.key.may_throw(compressor);
  });
  def_may_throw([
    AST_PrivateMethod,
    AST_PrivateGetter,
    AST_PrivateSetter
  ], return_false);
  def_may_throw(AST_Return, function(compressor) {
    return this.value && this.value.may_throw(compressor);
  });
  def_may_throw(AST_Sequence, function(compressor) {
    return any(this.expressions, compressor);
  });
  def_may_throw(AST_SimpleStatement, function(compressor) {
    return this.body.may_throw(compressor);
  });
  def_may_throw(AST_Dot, function(compressor) {
    if (is_nullish(this, compressor)) return false;
    return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.may_throw(compressor);
  });
  def_may_throw(AST_Sub, function(compressor) {
    if (is_nullish(this, compressor)) return false;
    return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.may_throw(compressor) || this.property.may_throw(compressor);
  });
  def_may_throw(AST_Chain, function(compressor) {
    return this.expression.may_throw(compressor);
  });
  def_may_throw(AST_Switch, function(compressor) {
    return this.expression.may_throw(compressor) || any(this.body, compressor);
  });
  def_may_throw(AST_SymbolRef, function(compressor) {
    return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);
  });
  def_may_throw(AST_SymbolClassProperty, return_false);
  def_may_throw(AST_Try, function(compressor) {
    return this.bcatch ? this.bcatch.may_throw(compressor) : this.body.may_throw(compressor) || this.bfinally && this.bfinally.may_throw(compressor);
  });
  def_may_throw(AST_Unary, function(compressor) {
    if (this.operator == "typeof" && this.expression instanceof AST_SymbolRef)
      return false;
    return this.expression.may_throw(compressor);
  });
  def_may_throw(AST_VarDef, function(compressor) {
    if (!this.value) return false;
    return this.value.may_throw(compressor);
  });
})(function(node_or_nodes, func) {
  for (const node of [].concat(node_or_nodes)) {
    node.DEFMETHOD("may_throw", func);
  }
});
(function(def_is_constant_expression) {
  function all_refs_local(scope5) {
    let result = true;
    walk2(this, (node) => {
      if (node instanceof AST_SymbolRef) {
        if (has_flag(this, INLINED)) {
          result = false;
          return walk_abort;
        }
        var def = node.definition();
        if (member(def, this.enclosed) && !this.variables.has(def.name)) {
          if (scope5) {
            var scope_def = scope5.find_variable(node);
            if (def.undeclared ? !scope_def : scope_def === def) {
              result = "f";
              return true;
            }
          }
          result = false;
          return walk_abort;
        }
        return true;
      }
      if (node instanceof AST_This && this instanceof AST_Arrow) {
        result = false;
        return walk_abort;
      }
    });
    return result;
  }
  def_is_constant_expression(AST_Node, return_false);
  def_is_constant_expression(AST_Constant, return_true);
  def_is_constant_expression(AST_Class, function(scope5) {
    if (this.extends && !this.extends.is_constant_expression(scope5)) {
      return false;
    }
    for (const prop of this.properties) {
      if (prop.computed_key() && !prop.key.is_constant_expression(scope5)) {
        return false;
      }
      if (prop.static && prop.value && !prop.value.is_constant_expression(scope5)) {
        return false;
      }
      if (prop instanceof AST_ClassStaticBlock) {
        return false;
      }
    }
    return all_refs_local.call(this, scope5);
  });
  def_is_constant_expression(AST_Lambda, all_refs_local);
  def_is_constant_expression(AST_Unary, function() {
    return this.expression.is_constant_expression();
  });
  def_is_constant_expression(AST_Binary, function() {
    return this.left.is_constant_expression() && this.right.is_constant_expression();
  });
  def_is_constant_expression(AST_Array, function() {
    return this.elements.every((l) => l.is_constant_expression());
  });
  def_is_constant_expression(AST_Object, function() {
    return this.properties.every((l) => l.is_constant_expression());
  });
  def_is_constant_expression(AST_ObjectProperty, function() {
    return !!(!(this.key instanceof AST_Node) && this.value && this.value.is_constant_expression());
  });
})(function(node, func) {
  node.DEFMETHOD("is_constant_expression", func);
});
(function(def_may_throw_on_access) {
  AST_Node.DEFMETHOD("may_throw_on_access", function(compressor) {
    return !compressor.option("pure_getters") || this._dot_throw(compressor);
  });
  function is_strict(compressor) {
    return /strict/.test(compressor.option("pure_getters"));
  }
  def_may_throw_on_access(AST_Node, is_strict);
  def_may_throw_on_access(AST_Null, return_true);
  def_may_throw_on_access(AST_Undefined, return_true);
  def_may_throw_on_access(AST_Constant, return_false);
  def_may_throw_on_access(AST_Array, return_false);
  def_may_throw_on_access(AST_Object, function(compressor) {
    if (!is_strict(compressor)) return false;
    for (var i = this.properties.length; --i >= 0; )
      if (this.properties[i]._dot_throw(compressor)) return true;
    return false;
  });
  def_may_throw_on_access(AST_Class, return_false);
  def_may_throw_on_access(AST_ObjectProperty, return_false);
  def_may_throw_on_access(AST_ObjectGetter, return_true);
  def_may_throw_on_access(AST_Expansion, function(compressor) {
    return this.expression._dot_throw(compressor);
  });
  def_may_throw_on_access(AST_Function, return_false);
  def_may_throw_on_access(AST_Arrow, return_false);
  def_may_throw_on_access(AST_UnaryPostfix, return_false);
  def_may_throw_on_access(AST_UnaryPrefix, function() {
    return this.operator == "void";
  });
  def_may_throw_on_access(AST_Binary, function(compressor) {
    return (this.operator == "&&" || this.operator == "||" || this.operator == "??") && (this.left._dot_throw(compressor) || this.right._dot_throw(compressor));
  });
  def_may_throw_on_access(AST_Assign, function(compressor) {
    if (this.logical) return true;
    return this.operator == "=" && this.right._dot_throw(compressor);
  });
  def_may_throw_on_access(AST_Conditional, function(compressor) {
    return this.consequent._dot_throw(compressor) || this.alternative._dot_throw(compressor);
  });
  def_may_throw_on_access(AST_Dot, function(compressor) {
    if (!is_strict(compressor)) return false;
    if (this.property == "prototype") {
      return !(this.expression instanceof AST_Function || this.expression instanceof AST_Class);
    }
    return true;
  });
  def_may_throw_on_access(AST_Chain, function(compressor) {
    return this.expression._dot_throw(compressor);
  });
  def_may_throw_on_access(AST_Sequence, function(compressor) {
    return this.tail_node()._dot_throw(compressor);
  });
  def_may_throw_on_access(AST_SymbolRef, function(compressor) {
    if (this.name === "arguments" && this.scope instanceof AST_Lambda) return false;
    if (has_flag(this, UNDEFINED)) return true;
    if (!is_strict(compressor)) return false;
    if (is_undeclared_ref(this) && this.is_declared(compressor)) return false;
    if (this.is_immutable()) return false;
    var fixed2 = this.fixed_value();
    return !fixed2 || fixed2._dot_throw(compressor);
  });
})(function(node, func) {
  node.DEFMETHOD("_dot_throw", func);
});
function is_lhs(node, parent) {
  if (parent instanceof AST_Unary && unary_side_effects.has(parent.operator)) return parent.expression;
  if (parent instanceof AST_Assign && parent.left === node) return node;
  if (parent instanceof AST_ForIn && parent.init === node) return node;
}
(function(def_negate) {
  function basic_negation(exp) {
    return make_node(AST_UnaryPrefix, exp, {
      operator: "!",
      expression: exp
    });
  }
  function best(orig, alt, first_in_statement2) {
    var negated = basic_negation(orig);
    if (first_in_statement2) {
      var stat2 = make_node(AST_SimpleStatement, alt, {
        body: alt
      });
      return best_of_expression(negated, stat2) === stat2 ? alt : negated;
    }
    return best_of_expression(negated, alt);
  }
  def_negate(AST_Node, function() {
    return basic_negation(this);
  });
  def_negate(AST_Statement, function() {
    throw new Error("Cannot negate a statement");
  });
  def_negate(AST_Function, function() {
    return basic_negation(this);
  });
  def_negate(AST_Class, function() {
    return basic_negation(this);
  });
  def_negate(AST_Arrow, function() {
    return basic_negation(this);
  });
  def_negate(AST_UnaryPrefix, function() {
    if (this.operator == "!")
      return this.expression;
    return basic_negation(this);
  });
  def_negate(AST_Sequence, function(compressor) {
    var expressions = this.expressions.slice();
    expressions.push(expressions.pop().negate(compressor));
    return make_sequence(this, expressions);
  });
  def_negate(AST_Conditional, function(compressor, first_in_statement2) {
    var self2 = this.clone();
    self2.consequent = self2.consequent.negate(compressor);
    self2.alternative = self2.alternative.negate(compressor);
    return best(this, self2, first_in_statement2);
  });
  def_negate(AST_Binary, function(compressor, first_in_statement2) {
    var self2 = this.clone(), op = this.operator;
    if (compressor.option("unsafe_comps")) {
      switch (op) {
        case "<=":
          self2.operator = ">";
          return self2;
        case "<":
          self2.operator = ">=";
          return self2;
        case ">=":
          self2.operator = "<";
          return self2;
        case ">":
          self2.operator = "<=";
          return self2;
      }
    }
    switch (op) {
      case "==":
        self2.operator = "!=";
        return self2;
      case "!=":
        self2.operator = "==";
        return self2;
      case "===":
        self2.operator = "!==";
        return self2;
      case "!==":
        self2.operator = "===";
        return self2;
      case "&&":
        self2.operator = "||";
        self2.left = self2.left.negate(compressor, first_in_statement2);
        self2.right = self2.right.negate(compressor);
        return best(this, self2, first_in_statement2);
      case "||":
        self2.operator = "&&";
        self2.left = self2.left.negate(compressor, first_in_statement2);
        self2.right = self2.right.negate(compressor);
        return best(this, self2, first_in_statement2);
    }
    return basic_negation(this);
  });
})(function(node, func) {
  node.DEFMETHOD("negate", function(compressor, first_in_statement2) {
    return func.call(this, compressor, first_in_statement2);
  });
});
(function(def_bitwise_negate) {
  function basic_negation(exp) {
    return make_node(AST_UnaryPrefix, exp, {
      operator: "~",
      expression: exp
    });
  }
  def_bitwise_negate(AST_Node, function() {
    return basic_negation(this);
  });
  def_bitwise_negate(AST_Number, function() {
    const neg = ~this.value;
    if (neg.toString().length > this.value.toString().length) {
      return basic_negation(this);
    }
    return make_node(AST_Number, this, { value: neg });
  });
  def_bitwise_negate(AST_UnaryPrefix, function(in_32_bit_context) {
    if (this.operator == "~" && (in_32_bit_context || this.expression.is_32_bit_integer())) {
      return this.expression;
    } else {
      return basic_negation(this);
    }
  });
})(function(node, func) {
  node.DEFMETHOD("bitwise_negate", func);
});
var global_pure_fns = makePredicate("Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError");
AST_Call.DEFMETHOD("is_callee_pure", function(compressor) {
  if (compressor.option("unsafe")) {
    var expr = this.expression;
    var first_arg = this.args && this.args[0] && this.args[0].evaluate(compressor);
    if (expr.expression && expr.expression.name === "hasOwnProperty" && (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared)) {
      return false;
    }
    if (is_undeclared_ref(expr) && global_pure_fns.has(expr.name)) return true;
    if (expr instanceof AST_Dot && is_undeclared_ref(expr.expression) && is_pure_native_fn(expr.expression.name, expr.property)) {
      return true;
    }
  }
  if (this instanceof AST_New && compressor.option("pure_new")) {
    return true;
  }
  if (compressor.option("side_effects") && has_annotation(this, _PURE)) {
    return true;
  }
  return !compressor.pure_funcs(this);
});
AST_Node.DEFMETHOD("is_call_pure", return_false);
AST_Dot.DEFMETHOD("is_call_pure", function(compressor) {
  if (!compressor.option("unsafe")) return;
  const expr = this.expression;
  let native_obj;
  if (expr instanceof AST_Array) {
    native_obj = "Array";
  } else if (expr.is_boolean()) {
    native_obj = "Boolean";
  } else if (expr.is_number(compressor)) {
    native_obj = "Number";
  } else if (expr instanceof AST_RegExp) {
    native_obj = "RegExp";
  } else if (expr.is_string(compressor)) {
    native_obj = "String";
  } else if (!this.may_throw_on_access(compressor)) {
    native_obj = "Object";
  }
  return native_obj != null && is_pure_native_method(native_obj, this.property);
});
var aborts = (thing) => thing && thing.aborts();
(function(def_aborts) {
  def_aborts(AST_Statement, return_null);
  def_aborts(AST_Jump, return_this);
  function block_aborts() {
    for (var i = 0; i < this.body.length; i++) {
      if (aborts(this.body[i])) {
        return this.body[i];
      }
    }
    return null;
  }
  def_aborts(AST_Import, return_null);
  def_aborts(AST_BlockStatement, block_aborts);
  def_aborts(AST_SwitchBranch, block_aborts);
  def_aborts(AST_DefClass, function() {
    for (const prop of this.properties) {
      if (prop instanceof AST_ClassStaticBlock) {
        if (prop.aborts()) return prop;
      }
    }
    return null;
  });
  def_aborts(AST_ClassStaticBlock, block_aborts);
  def_aborts(AST_If, function() {
    return this.alternative && aborts(this.body) && aborts(this.alternative) && this;
  });
})(function(node, func) {
  node.DEFMETHOD("aborts", func);
});
AST_Node.DEFMETHOD("contains_this", function() {
  return walk2(this, (node) => {
    if (node instanceof AST_This) return walk_abort;
    if (node !== this && node instanceof AST_Scope && !(node instanceof AST_Arrow)) {
      return true;
    }
  });
});
function is_modified(compressor, tw, node, value, level, immutable) {
  var parent = tw.parent(level);
  var lhs = is_lhs(node, parent);
  if (lhs) return lhs;
  if (!immutable && parent instanceof AST_Call && parent.expression === node && !(value instanceof AST_Arrow) && !(value instanceof AST_Class) && !parent.is_callee_pure(compressor) && (!(value instanceof AST_Function) || !(parent instanceof AST_New) && value.contains_this())) {
    return true;
  }
  if (parent instanceof AST_Array) {
    return is_modified(compressor, tw, parent, parent, level + 1);
  }
  if (parent instanceof AST_ObjectKeyVal && node === parent.value) {
    var obj = tw.parent(level + 1);
    return is_modified(compressor, tw, obj, obj, level + 2);
  }
  if (parent instanceof AST_PropAccess && parent.expression === node) {
    var prop = read_property(value, parent.property);
    return !immutable && is_modified(compressor, tw, parent, prop, level + 1);
  }
}
function is_used_in_expression(tw) {
  for (let p3 = -1, node, parent; node = tw.parent(p3), parent = tw.parent(p3 + 1); p3++) {
    if (parent instanceof AST_Sequence) {
      const nth_expression = parent.expressions.indexOf(node);
      if (nth_expression !== parent.expressions.length - 1) {
        const grandparent = tw.parent(p3 + 2);
        if (parent.expressions.length > 2 || parent.expressions.length === 1 || !requires_sequence_to_maintain_binding(grandparent, parent, parent.expressions[1])) {
          return false;
        }
        return true;
      } else {
        continue;
      }
    }
    if (parent instanceof AST_Unary) {
      const op = parent.operator;
      if (op === "void") {
        return false;
      }
      if (op === "typeof" || op === "+" || op === "-" || op === "!" || op === "~") {
        continue;
      }
    }
    if (parent instanceof AST_SimpleStatement || parent instanceof AST_LabeledStatement) {
      return false;
    }
    if (parent instanceof AST_Scope) {
      return false;
    }
    return true;
  }
  return true;
}

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/compress/evaluate.js
function def_eval(node, func) {
  node.DEFMETHOD("_eval", func);
}
var nullish = Symbol("This AST_Chain is nullish");
AST_Node.DEFMETHOD("evaluate", function(compressor) {
  if (!compressor.option("evaluate"))
    return this;
  var val = this._eval(compressor, 1);
  if (!val || val instanceof RegExp)
    return val;
  if (typeof val == "function" || typeof val == "object" || val == nullish)
    return this;
  if (typeof val === "string") {
    const unevaluated_size = this.size(compressor);
    if (val.length + 2 > unevaluated_size) return this;
  }
  return val;
});
var unaryPrefix = makePredicate("! ~ - + void");
AST_Node.DEFMETHOD("is_constant", function() {
  if (this instanceof AST_Constant) {
    return !(this instanceof AST_RegExp);
  } else {
    return this instanceof AST_UnaryPrefix && unaryPrefix.has(this.operator) && // `this.expression` may be an `AST_RegExp`,
    // so not only `.is_constant()`.
    (this.expression instanceof AST_Constant || this.expression.is_constant());
  }
});
def_eval(AST_Statement, function() {
  throw new Error(string_template("Cannot evaluate a statement [{file}:{line},{col}]", this.start));
});
def_eval(AST_Lambda, return_this);
def_eval(AST_Class, return_this);
def_eval(AST_Node, return_this);
def_eval(AST_Constant, function() {
  return this.getValue();
});
var supports_bigint = typeof BigInt === "function";
def_eval(AST_BigInt, function() {
  if (supports_bigint) {
    return BigInt(this.value);
  } else {
    return this;
  }
});
def_eval(AST_RegExp, function(compressor) {
  let evaluated = compressor.evaluated_regexps.get(this.value);
  if (evaluated === void 0 && regexp_is_safe(this.value.source)) {
    try {
      const { source, flags } = this.value;
      evaluated = new RegExp(source, flags);
    } catch (e) {
      evaluated = null;
    }
    compressor.evaluated_regexps.set(this.value, evaluated);
  }
  return evaluated || this;
});
def_eval(AST_TemplateString, function() {
  if (this.segments.length !== 1) return this;
  return this.segments[0].value;
});
def_eval(AST_Function, function(compressor) {
  if (compressor.option("unsafe")) {
    var fn2 = function() {
    };
    fn2.node = this;
    fn2.toString = () => this.print_to_string();
    return fn2;
  }
  return this;
});
def_eval(AST_Array, function(compressor, depth) {
  if (compressor.option("unsafe")) {
    var elements = [];
    for (var i = 0, len = this.elements.length; i < len; i++) {
      var element = this.elements[i];
      var value = element._eval(compressor, depth);
      if (element === value)
        return this;
      elements.push(value);
    }
    return elements;
  }
  return this;
});
def_eval(AST_Object, function(compressor, depth) {
  if (compressor.option("unsafe")) {
    var val = {};
    for (var i = 0, len = this.properties.length; i < len; i++) {
      var prop = this.properties[i];
      if (prop instanceof AST_Expansion)
        return this;
      var key = prop.key;
      if (key instanceof AST_Symbol) {
        key = key.name;
      } else if (key instanceof AST_Node) {
        key = key._eval(compressor, depth);
        if (key === prop.key)
          return this;
      }
      if (typeof Object.prototype[key] === "function") {
        return this;
      }
      if (prop.value instanceof AST_Function)
        continue;
      val[key] = prop.value._eval(compressor, depth);
      if (val[key] === prop.value)
        return this;
    }
    return val;
  }
  return this;
});
var non_converting_unary = makePredicate("! typeof void");
def_eval(AST_UnaryPrefix, function(compressor, depth) {
  var e = this.expression;
  if (compressor.option("typeofs") && this.operator == "typeof") {
    if (e instanceof AST_Lambda || e instanceof AST_SymbolRef && e.fixed_value() instanceof AST_Lambda) {
      return "function";
    }
    if ((e instanceof AST_Object || e instanceof AST_Array || e instanceof AST_SymbolRef && (e.fixed_value() instanceof AST_Object || e.fixed_value() instanceof AST_Array)) && !e.has_side_effects(compressor)) {
      return typeof {};
    }
  }
  if (!non_converting_unary.has(this.operator))
    depth++;
  e = e._eval(compressor, depth);
  if (e === this.expression)
    return this;
  switch (this.operator) {
    case "!":
      return !e;
    case "typeof":
      if (e instanceof RegExp)
        return this;
      return typeof e;
    case "void":
      return void 0;
    case "~":
      return ~e;
    case "-":
      return -e;
    case "+":
      return +e;
  }
  return this;
});
var non_converting_binary = makePredicate("&& || ?? === !==");
var identity_comparison = makePredicate("== != === !==");
var has_identity = (value) => typeof value === "object" || typeof value === "function" || typeof value === "symbol";
def_eval(AST_Binary, function(compressor, depth) {
  if (!non_converting_binary.has(this.operator))
    depth++;
  var left3 = this.left._eval(compressor, depth);
  if (left3 === this.left)
    return this;
  var right3 = this.right._eval(compressor, depth);
  if (right3 === this.right)
    return this;
  if (left3 != null && right3 != null && identity_comparison.has(this.operator) && has_identity(left3) && has_identity(right3) && typeof left3 === typeof right3) {
    return this;
  }
  if (typeof left3 === "bigint" !== (typeof right3 === "bigint") || typeof left3 === "bigint" && (this.operator === ">>>" || this.operator === "/" && Number(right3) === 0)) {
    return this;
  }
  var result;
  switch (this.operator) {
    case "&&":
      result = left3 && right3;
      break;
    case "||":
      result = left3 || right3;
      break;
    case "??":
      result = left3 != null ? left3 : right3;
      break;
    case "|":
      result = left3 | right3;
      break;
    case "&":
      result = left3 & right3;
      break;
    case "^":
      result = left3 ^ right3;
      break;
    case "+":
      result = left3 + right3;
      break;
    case "*":
      result = left3 * right3;
      break;
    case "**":
      result = left3 ** right3;
      break;
    case "/":
      result = left3 / right3;
      break;
    case "%":
      result = left3 % right3;
      break;
    case "-":
      result = left3 - right3;
      break;
    case "<<":
      result = left3 << right3;
      break;
    case ">>":
      result = left3 >> right3;
      break;
    case ">>>":
      result = left3 >>> right3;
      break;
    case "==":
      result = left3 == right3;
      break;
    case "===":
      result = left3 === right3;
      break;
    case "!=":
      result = left3 != right3;
      break;
    case "!==":
      result = left3 !== right3;
      break;
    case "<":
      result = left3 < right3;
      break;
    case "<=":
      result = left3 <= right3;
      break;
    case ">":
      result = left3 > right3;
      break;
    case ">=":
      result = left3 >= right3;
      break;
    default:
      return this;
  }
  if (typeof result === "number" && isNaN(result) && compressor.find_parent(AST_With)) {
    return this;
  }
  return result;
});
def_eval(AST_Conditional, function(compressor, depth) {
  var condition = this.condition._eval(compressor, depth);
  if (condition === this.condition)
    return this;
  var node = condition ? this.consequent : this.alternative;
  var value = node._eval(compressor, depth);
  return value === node ? this : value;
});
var reentrant_ref_eval = /* @__PURE__ */ new Set();
def_eval(AST_SymbolRef, function(compressor, depth) {
  if (reentrant_ref_eval.has(this))
    return this;
  var fixed2 = this.fixed_value();
  if (!fixed2)
    return this;
  reentrant_ref_eval.add(this);
  const value = fixed2._eval(compressor, depth);
  reentrant_ref_eval.delete(this);
  if (value === fixed2)
    return this;
  if (value && typeof value == "object") {
    var escaped = this.definition().escaped;
    if (escaped && depth > escaped)
      return this;
  }
  return value;
});
var global_objs = { Array, Math, Number, Object, String };
var regexp_flags = /* @__PURE__ */ new Set([
  "dotAll",
  "global",
  "ignoreCase",
  "multiline",
  "sticky",
  "unicode"
]);
def_eval(AST_PropAccess, function(compressor, depth) {
  let obj = this.expression._eval(compressor, depth + 1);
  if (obj === nullish || this.optional && obj == null) return nullish;
  if (this.property === "length") {
    if (typeof obj === "string") {
      return obj.length;
    }
    const is_spreadless_array = obj instanceof AST_Array && obj.elements.every((el) => !(el instanceof AST_Expansion));
    if (is_spreadless_array && obj.elements.every((el) => !el.has_side_effects(compressor))) {
      return obj.elements.length;
    }
  }
  if (compressor.option("unsafe")) {
    var key = this.property;
    if (key instanceof AST_Node) {
      key = key._eval(compressor, depth);
      if (key === this.property)
        return this;
    }
    var exp = this.expression;
    if (is_undeclared_ref(exp)) {
      var aa;
      var first_arg = exp.name === "hasOwnProperty" && key === "call" && (aa = compressor.parent() && compressor.parent().args) && (aa && aa[0] && aa[0].evaluate(compressor));
      first_arg = first_arg instanceof AST_Dot ? first_arg.expression : first_arg;
      if (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared) {
        return this.clone();
      }
      if (!is_pure_native_value(exp.name, key))
        return this;
      obj = global_objs[exp.name];
    } else {
      if (obj instanceof RegExp) {
        if (key == "source") {
          return regexp_source_fix(obj.source);
        } else if (key == "flags" || regexp_flags.has(key)) {
          return obj[key];
        }
      }
      if (!obj || obj === exp || !HOP(obj, key))
        return this;
      if (typeof obj == "function")
        switch (key) {
          case "name":
            return obj.node.name ? obj.node.name.name : "";
          case "length":
            return obj.node.length_property();
          default:
            return this;
        }
    }
    return obj[key];
  }
  return this;
});
def_eval(AST_Chain, function(compressor, depth) {
  const evaluated = this.expression._eval(compressor, depth);
  return evaluated === nullish ? void 0 : evaluated === this.expression ? this : evaluated;
});
def_eval(AST_Call, function(compressor, depth) {
  var exp = this.expression;
  const callee = exp._eval(compressor, depth);
  if (callee === nullish || this.optional && callee == null) return nullish;
  if (compressor.option("unsafe") && exp instanceof AST_PropAccess) {
    var key = exp.property;
    if (key instanceof AST_Node) {
      key = key._eval(compressor, depth);
      if (key === exp.property)
        return this;
    }
    var val;
    var e = exp.expression;
    if (is_undeclared_ref(e)) {
      var first_arg = e.name === "hasOwnProperty" && key === "call" && (this.args[0] && this.args[0].evaluate(compressor));
      first_arg = first_arg instanceof AST_Dot ? first_arg.expression : first_arg;
      if (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared) {
        return this.clone();
      }
      if (!is_pure_native_fn(e.name, key)) return this;
      val = global_objs[e.name];
    } else {
      val = e._eval(compressor, depth + 1);
      if (val === e || !val)
        return this;
      if (!is_pure_native_method(val.constructor.name, key))
        return this;
    }
    var args2 = [];
    for (var i = 0, len = this.args.length; i < len; i++) {
      var arg = this.args[i];
      var value = arg._eval(compressor, depth);
      if (arg === value)
        return this;
      if (arg instanceof AST_Lambda)
        return this;
      args2.push(value);
    }
    try {
      return val[key].apply(val, args2);
    } catch (ex) {
    }
  }
  return this;
});
def_eval(AST_New, return_this);

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/compress/drop-side-effect-free.js
function def_drop_side_effect_free(node_or_nodes, func) {
  for (const node of [].concat(node_or_nodes)) {
    node.DEFMETHOD("drop_side_effect_free", func);
  }
}
function trim(nodes, compressor, first_in_statement2) {
  var len = nodes.length;
  if (!len) return null;
  var ret = [], changed = false;
  for (var i = 0; i < len; i++) {
    var node = nodes[i].drop_side_effect_free(compressor, first_in_statement2);
    changed |= node !== nodes[i];
    if (node) {
      ret.push(node);
      first_in_statement2 = false;
    }
  }
  return changed ? ret.length ? ret : null : nodes;
}
def_drop_side_effect_free(AST_Node, return_this);
def_drop_side_effect_free(AST_Constant, return_null);
def_drop_side_effect_free(AST_This, return_null);
def_drop_side_effect_free(AST_Call, function(compressor, first_in_statement2) {
  if (is_nullish_shortcircuited(this, compressor)) {
    return this.expression.drop_side_effect_free(compressor, first_in_statement2);
  }
  if (!this.is_callee_pure(compressor)) {
    if (this.expression.is_call_pure(compressor)) {
      var exprs = this.args.slice();
      exprs.unshift(this.expression.expression);
      exprs = trim(exprs, compressor, first_in_statement2);
      return exprs && make_sequence(this, exprs);
    }
    if (is_func_expr(this.expression) && (!this.expression.name || !this.expression.name.definition().references.length)) {
      var node = this.clone();
      node.expression.process_expression(false, compressor);
      return node;
    }
    return this;
  }
  var args2 = trim(this.args, compressor, first_in_statement2);
  return args2 && make_sequence(this, args2);
});
def_drop_side_effect_free(AST_Accessor, return_null);
def_drop_side_effect_free(AST_Function, return_null);
def_drop_side_effect_free(AST_Arrow, return_null);
def_drop_side_effect_free(AST_Class, function(compressor) {
  const with_effects = [];
  if (this.is_self_referential() && this.has_side_effects(compressor)) {
    return this;
  }
  const trimmed_extends = this.extends && this.extends.drop_side_effect_free(compressor);
  if (trimmed_extends) with_effects.push(trimmed_extends);
  for (const prop of this.properties) {
    if (prop instanceof AST_ClassStaticBlock) {
      if (prop.has_side_effects(compressor)) {
        return this;
      }
    } else {
      const trimmed_prop = prop.drop_side_effect_free(compressor);
      if (trimmed_prop) with_effects.push(trimmed_prop);
    }
  }
  if (!with_effects.length)
    return null;
  const exprs = make_sequence(this, with_effects);
  if (this instanceof AST_DefClass) {
    return make_node(AST_SimpleStatement, this, { body: exprs });
  } else {
    return exprs;
  }
});
def_drop_side_effect_free([
  AST_ClassProperty,
  AST_ClassPrivateProperty
], function(compressor) {
  const key = this.computed_key() && this.key.drop_side_effect_free(compressor);
  const value = this.static && this.value && this.value.drop_side_effect_free(compressor);
  if (key && value)
    return make_sequence(this, [key, value]);
  return key || value || null;
});
def_drop_side_effect_free(AST_Binary, function(compressor, first_in_statement2) {
  var right3 = this.right.drop_side_effect_free(compressor);
  if (!right3)
    return this.left.drop_side_effect_free(compressor, first_in_statement2);
  if (lazy_op.has(this.operator)) {
    if (right3 === this.right)
      return this;
    var node = this.clone();
    node.right = right3;
    return node;
  } else {
    var left3 = this.left.drop_side_effect_free(compressor, first_in_statement2);
    if (!left3)
      return this.right.drop_side_effect_free(compressor, first_in_statement2);
    return make_sequence(this, [left3, right3]);
  }
});
def_drop_side_effect_free(AST_Assign, function(compressor) {
  if (this.logical)
    return this;
  var left3 = this.left;
  if (left3.has_side_effects(compressor) || compressor.has_directive("use strict") && left3 instanceof AST_PropAccess && left3.expression.is_constant()) {
    return this;
  }
  set_flag(this, WRITE_ONLY);
  while (left3 instanceof AST_PropAccess) {
    left3 = left3.expression;
  }
  if (left3.is_constant_expression(compressor.find_parent(AST_Scope))) {
    return this.right.drop_side_effect_free(compressor);
  }
  return this;
});
def_drop_side_effect_free(AST_Conditional, function(compressor) {
  var consequent = this.consequent.drop_side_effect_free(compressor);
  var alternative = this.alternative.drop_side_effect_free(compressor);
  if (consequent === this.consequent && alternative === this.alternative)
    return this;
  if (!consequent)
    return alternative ? make_node(AST_Binary, this, {
      operator: "||",
      left: this.condition,
      right: alternative
    }) : this.condition.drop_side_effect_free(compressor);
  if (!alternative)
    return make_node(AST_Binary, this, {
      operator: "&&",
      left: this.condition,
      right: consequent
    });
  var node = this.clone();
  node.consequent = consequent;
  node.alternative = alternative;
  return node;
});
def_drop_side_effect_free(AST_Unary, function(compressor, first_in_statement2) {
  if (unary_side_effects.has(this.operator)) {
    if (!this.expression.has_side_effects(compressor)) {
      set_flag(this, WRITE_ONLY);
    } else {
      clear_flag(this, WRITE_ONLY);
    }
    return this;
  }
  if (this.operator == "typeof" && this.expression instanceof AST_SymbolRef)
    return null;
  var expression = this.expression.drop_side_effect_free(compressor, first_in_statement2);
  if (first_in_statement2 && expression && is_iife_call(expression)) {
    if (expression === this.expression && this.operator == "!")
      return this;
    return expression.negate(compressor, first_in_statement2);
  }
  return expression;
});
def_drop_side_effect_free(AST_SymbolRef, function(compressor) {
  const safe_access = this.is_declared(compressor) || pure_prop_access_globals.has(this.name);
  return safe_access ? null : this;
});
def_drop_side_effect_free(AST_Object, function(compressor, first_in_statement2) {
  var values3 = trim(this.properties, compressor, first_in_statement2);
  return values3 && make_sequence(this, values3);
});
def_drop_side_effect_free(AST_ObjectKeyVal, function(compressor, first_in_statement2) {
  const computed_key = this.key instanceof AST_Node;
  const key = computed_key && this.key.drop_side_effect_free(compressor, first_in_statement2);
  const value = this.value.drop_side_effect_free(compressor, first_in_statement2);
  if (key && value) {
    return make_sequence(this, [key, value]);
  }
  return key || value;
});
def_drop_side_effect_free([
  AST_ConciseMethod,
  AST_ObjectGetter,
  AST_ObjectSetter
], function() {
  return this.computed_key() ? this.key : null;
});
def_drop_side_effect_free([
  AST_PrivateMethod,
  AST_PrivateGetter,
  AST_PrivateSetter
], function() {
  return null;
});
def_drop_side_effect_free(AST_Array, function(compressor, first_in_statement2) {
  var values3 = trim(this.elements, compressor, first_in_statement2);
  return values3 && make_sequence(this, values3);
});
def_drop_side_effect_free(AST_Dot, function(compressor, first_in_statement2) {
  if (is_nullish_shortcircuited(this, compressor)) {
    return this.expression.drop_side_effect_free(compressor, first_in_statement2);
  }
  if (!this.optional && this.expression.may_throw_on_access(compressor)) {
    return this;
  }
  return this.expression.drop_side_effect_free(compressor, first_in_statement2);
});
def_drop_side_effect_free(AST_Sub, function(compressor, first_in_statement2) {
  if (is_nullish_shortcircuited(this, compressor)) {
    return this.expression.drop_side_effect_free(compressor, first_in_statement2);
  }
  if (!this.optional && this.expression.may_throw_on_access(compressor)) {
    return this;
  }
  var property3 = this.property.drop_side_effect_free(compressor);
  if (property3 && this.optional) return this;
  var expression = this.expression.drop_side_effect_free(compressor, first_in_statement2);
  if (expression && property3) return make_sequence(this, [expression, property3]);
  return expression || property3;
});
def_drop_side_effect_free(AST_Chain, function(compressor, first_in_statement2) {
  return this.expression.drop_side_effect_free(compressor, first_in_statement2);
});
def_drop_side_effect_free(AST_Sequence, function(compressor) {
  var last6 = this.tail_node();
  var expr = last6.drop_side_effect_free(compressor);
  if (expr === last6)
    return this;
  var expressions = this.expressions.slice(0, -1);
  if (expr)
    expressions.push(expr);
  if (!expressions.length) {
    return make_node(AST_Number, this, { value: 0 });
  }
  return make_sequence(this, expressions);
});
def_drop_side_effect_free(AST_Expansion, function(compressor, first_in_statement2) {
  return this.expression.drop_side_effect_free(compressor, first_in_statement2);
});
def_drop_side_effect_free(AST_TemplateSegment, return_null);
def_drop_side_effect_free(AST_TemplateString, function(compressor) {
  var values3 = trim(this.segments, compressor, first_in_statement);
  return values3 && make_sequence(this, values3);
});

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/compress/drop-unused.js
var r_keep_assign = /keep_assign/;
AST_Scope.DEFMETHOD("drop_unused", function(compressor) {
  if (!compressor.option("unused")) return;
  if (compressor.has_directive("use asm")) return;
  if (!this.variables) return;
  var self2 = this;
  if (self2.pinned()) return;
  var drop_funcs = !(self2 instanceof AST_Toplevel) || compressor.toplevel.funcs;
  var drop_vars = !(self2 instanceof AST_Toplevel) || compressor.toplevel.vars;
  const assign_as_unused = r_keep_assign.test(compressor.option("unused")) ? return_false : function(node) {
    if (node instanceof AST_Assign && !node.logical && (has_flag(node, WRITE_ONLY) || node.operator == "=")) {
      return node.left;
    }
    if (node instanceof AST_Unary && has_flag(node, WRITE_ONLY)) {
      return node.expression;
    }
  };
  var in_use_ids = /* @__PURE__ */ new Map();
  var fixed_ids = /* @__PURE__ */ new Map();
  if (self2 instanceof AST_Toplevel && compressor.top_retain) {
    self2.variables.forEach(function(def) {
      if (compressor.top_retain(def)) {
        in_use_ids.set(def.id, def);
      }
    });
  }
  var var_defs_by_id = /* @__PURE__ */ new Map();
  var initializations = /* @__PURE__ */ new Map();
  var scope5 = this;
  var tw = new TreeWalker(function(node, descend) {
    if (node instanceof AST_Lambda && node.uses_arguments && !tw.has_directive("use strict")) {
      node.argnames.forEach(function(argname) {
        if (!(argname instanceof AST_SymbolDeclaration)) return;
        var def = argname.definition();
        in_use_ids.set(def.id, def);
      });
    }
    if (node === self2) return;
    if (node instanceof AST_Class && node.has_side_effects(compressor)) {
      if (node.is_self_referential()) {
        descend();
      } else {
        node.visit_nondeferred_class_parts(tw);
      }
    }
    if (node instanceof AST_Defun || node instanceof AST_DefClass) {
      var node_def = node.name.definition();
      const in_export = tw.parent() instanceof AST_Export;
      if (in_export || !drop_funcs && scope5 === self2) {
        if (node_def.global) {
          in_use_ids.set(node_def.id, node_def);
        }
      }
      map_add(initializations, node_def.id, node);
      return true;
    }
    const in_root_scope = scope5 === self2;
    if (node instanceof AST_SymbolFunarg && in_root_scope) {
      map_add(var_defs_by_id, node.definition().id, node);
    }
    if (node instanceof AST_Definitions && in_root_scope) {
      const in_export = tw.parent() instanceof AST_Export;
      node.definitions.forEach(function(def) {
        if (def.name instanceof AST_SymbolVar) {
          map_add(var_defs_by_id, def.name.definition().id, def);
        }
        if (in_export || !drop_vars) {
          walk2(def.name, (node2) => {
            if (node2 instanceof AST_SymbolDeclaration) {
              const def2 = node2.definition();
              if (def2.global) {
                in_use_ids.set(def2.id, def2);
              }
            }
          });
        }
        if (def.name instanceof AST_Destructuring) {
          def.walk(tw);
        }
        if (def.name instanceof AST_SymbolDeclaration && def.value) {
          var node_def2 = def.name.definition();
          map_add(initializations, node_def2.id, def.value);
          if (!node_def2.chained && def.name.fixed_value() === def.value) {
            fixed_ids.set(node_def2.id, def);
          }
          if (def.value.has_side_effects(compressor)) {
            def.value.walk(tw);
          }
        }
      });
      return true;
    }
    return scan_ref_scoped(node, descend);
  });
  self2.walk(tw);
  tw = new TreeWalker(scan_ref_scoped);
  in_use_ids.forEach(function(def) {
    var init2 = initializations.get(def.id);
    if (init2) init2.forEach(function(init3) {
      init3.walk(tw);
    });
  });
  var tt = new TreeTransformer(
    function before2(node, descend, in_list) {
      var parent = tt.parent();
      if (drop_vars) {
        const sym2 = assign_as_unused(node);
        if (sym2 instanceof AST_SymbolRef) {
          var def = sym2.definition();
          var in_use = in_use_ids.has(def.id);
          if (node instanceof AST_Assign) {
            if (!in_use || fixed_ids.has(def.id) && fixed_ids.get(def.id) !== node) {
              const assignee = node.right.transform(tt);
              if (!in_use && !assignee.has_side_effects(compressor) && !is_used_in_expression(tt)) {
                return in_list ? MAP.skip : make_node(AST_Number, node, { value: 0 });
              }
              return maintain_this_binding(parent, node, assignee);
            }
          } else if (!in_use) {
            return in_list ? MAP.skip : make_node(AST_Number, node, { value: 0 });
          }
        }
      }
      if (scope5 !== self2) return;
      var def;
      if (node.name && (node instanceof AST_ClassExpression && !keep_name(compressor.option("keep_classnames"), (def = node.name.definition()).name) || node instanceof AST_Function && !keep_name(compressor.option("keep_fnames"), (def = node.name.definition()).name))) {
        if (!in_use_ids.has(def.id) || def.orig.length > 1) node.name = null;
      }
      if (node instanceof AST_Lambda && !(node instanceof AST_Accessor)) {
        var trim2 = !compressor.option("keep_fargs") || parent instanceof AST_Call && parent.expression === node && !node.pinned() && (!node.name || node.name.unreferenced());
        for (var a2 = node.argnames, i = a2.length; --i >= 0; ) {
          var sym = a2[i];
          if (sym instanceof AST_Expansion) {
            sym = sym.expression;
          }
          if (sym instanceof AST_DefaultAssign) {
            sym = sym.left;
          }
          if (!(sym instanceof AST_Destructuring) && !in_use_ids.has(sym.definition().id)) {
            set_flag(sym, UNUSED);
            if (trim2) {
              a2.pop();
            }
          } else {
            trim2 = false;
          }
        }
      }
      if (node instanceof AST_DefClass && node !== self2) {
        const def2 = node.name.definition();
        descend(node, this);
        const keep_class = def2.global && !drop_funcs || in_use_ids.has(def2.id);
        if (!keep_class) {
          const kept = node.drop_side_effect_free(compressor);
          if (kept == null) {
            def2.eliminated++;
            return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
          }
          return kept;
        }
        return node;
      }
      if (node instanceof AST_Defun && node !== self2) {
        const def2 = node.name.definition();
        const keep = def2.global && !drop_funcs || in_use_ids.has(def2.id);
        if (!keep) {
          def2.eliminated++;
          return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
        }
      }
      if (node instanceof AST_Definitions && !(parent instanceof AST_ForIn && parent.init === node)) {
        var drop_block = !(parent instanceof AST_Toplevel) && !(node instanceof AST_Var);
        var body = [], head6 = [], tail = [];
        var side_effects = [];
        node.definitions.forEach(function(def2) {
          if (def2.value) def2.value = def2.value.transform(tt);
          var is_destructure = def2.name instanceof AST_Destructuring;
          var sym2 = is_destructure ? new SymbolDef(null, { name: "<destructure>" }) : def2.name.definition();
          if (drop_block && sym2.global) return tail.push(def2);
          if (!(drop_vars || drop_block) || is_destructure && (def2.name.names.length || def2.name.is_array || compressor.option("pure_getters") != true) || in_use_ids.has(sym2.id)) {
            if (def2.value && fixed_ids.has(sym2.id) && fixed_ids.get(sym2.id) !== def2) {
              def2.value = def2.value.drop_side_effect_free(compressor);
            }
            if (def2.name instanceof AST_SymbolVar) {
              var var_defs = var_defs_by_id.get(sym2.id);
              if (var_defs.length > 1 && (!def2.value || sym2.orig.indexOf(def2.name) > sym2.eliminated)) {
                if (def2.value) {
                  var ref = make_node(AST_SymbolRef, def2.name, def2.name);
                  sym2.references.push(ref);
                  var assign = make_node(AST_Assign, def2, {
                    operator: "=",
                    logical: false,
                    left: ref,
                    right: def2.value
                  });
                  if (fixed_ids.get(sym2.id) === def2) {
                    fixed_ids.set(sym2.id, assign);
                  }
                  side_effects.push(assign.transform(tt));
                }
                remove9(var_defs, def2);
                sym2.eliminated++;
                return;
              }
            }
            if (def2.value) {
              if (side_effects.length > 0) {
                if (tail.length > 0) {
                  side_effects.push(def2.value);
                  def2.value = make_sequence(def2.value, side_effects);
                } else {
                  body.push(make_node(AST_SimpleStatement, node, {
                    body: make_sequence(node, side_effects)
                  }));
                }
                side_effects = [];
              }
              tail.push(def2);
            } else {
              head6.push(def2);
            }
          } else if (sym2.orig[0] instanceof AST_SymbolCatch) {
            var value = def2.value && def2.value.drop_side_effect_free(compressor);
            if (value) side_effects.push(value);
            def2.value = null;
            head6.push(def2);
          } else {
            var value = def2.value && def2.value.drop_side_effect_free(compressor);
            if (value) {
              side_effects.push(value);
            }
            sym2.eliminated++;
          }
        });
        if (head6.length > 0 || tail.length > 0) {
          node.definitions = head6.concat(tail);
          body.push(node);
        }
        if (side_effects.length > 0) {
          body.push(make_node(AST_SimpleStatement, node, {
            body: make_sequence(node, side_effects)
          }));
        }
        switch (body.length) {
          case 0:
            return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
          case 1:
            return body[0];
          default:
            return in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, { body });
        }
      }
      if (node instanceof AST_For) {
        descend(node, this);
        var block;
        if (node.init instanceof AST_BlockStatement) {
          block = node.init;
          node.init = block.body.pop();
          block.body.push(node);
        }
        if (node.init instanceof AST_SimpleStatement) {
          node.init = node.init.body;
        } else if (is_empty(node.init)) {
          node.init = null;
        }
        return !block ? node : in_list ? MAP.splice(block.body) : block;
      }
      if (node instanceof AST_LabeledStatement && node.body instanceof AST_For) {
        descend(node, this);
        if (node.body instanceof AST_BlockStatement) {
          var block = node.body;
          node.body = block.body.pop();
          block.body.push(node);
          return in_list ? MAP.splice(block.body) : block;
        }
        return node;
      }
      if (node instanceof AST_BlockStatement) {
        descend(node, this);
        if (in_list && node.body.every(can_be_evicted_from_block)) {
          return MAP.splice(node.body);
        }
        return node;
      }
      if (node instanceof AST_Scope && !(node instanceof AST_ClassStaticBlock)) {
        const save_scope = scope5;
        scope5 = node;
        descend(node, this);
        scope5 = save_scope;
        return node;
      }
    },
    function after3(node, in_list) {
      if (node instanceof AST_Sequence) {
        switch (node.expressions.length) {
          case 0:
            return in_list ? MAP.skip : make_node(AST_Number, node, { value: 0 });
          case 1:
            return node.expressions[0];
        }
      }
    }
  );
  self2.transform(tt);
  function scan_ref_scoped(node, descend) {
    var node_def;
    const sym = assign_as_unused(node);
    if (sym instanceof AST_SymbolRef && !is_ref_of(node.left, AST_SymbolBlockDeclaration) && self2.variables.get(sym.name) === (node_def = sym.definition())) {
      if (node instanceof AST_Assign) {
        node.right.walk(tw);
        if (!node_def.chained && node.left.fixed_value() === node.right) {
          fixed_ids.set(node_def.id, node);
        }
      }
      return true;
    }
    if (node instanceof AST_SymbolRef) {
      node_def = node.definition();
      if (!in_use_ids.has(node_def.id)) {
        in_use_ids.set(node_def.id, node_def);
        if (node_def.orig[0] instanceof AST_SymbolCatch) {
          const redef = node_def.scope.is_block_scope() && node_def.scope.get_defun_scope().variables.get(node_def.name);
          if (redef) in_use_ids.set(redef.id, redef);
        }
      }
      return true;
    }
    if (node instanceof AST_Class) {
      descend();
      return true;
    }
    if (node instanceof AST_Scope && !(node instanceof AST_ClassStaticBlock)) {
      var save_scope = scope5;
      scope5 = node;
      descend();
      scope5 = save_scope;
      return true;
    }
  }
});

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/compress/reduce-vars.js
function def_reduce_vars(node, func) {
  node.DEFMETHOD("reduce_vars", func);
}
def_reduce_vars(AST_Node, noop);
function reset_def(compressor, def) {
  def.assignments = 0;
  def.chained = false;
  def.direct_access = false;
  def.escaped = 0;
  def.recursive_refs = 0;
  def.references = [];
  def.single_use = void 0;
  if (def.scope.pinned() || def.orig[0] instanceof AST_SymbolFunarg && def.scope.uses_arguments) {
    def.fixed = false;
  } else if (def.orig[0] instanceof AST_SymbolConst || !compressor.exposed(def)) {
    def.fixed = def.init;
  } else {
    def.fixed = false;
  }
}
function reset_variables(tw, compressor, node) {
  node.variables.forEach(function(def) {
    reset_def(compressor, def);
    if (def.fixed === null) {
      tw.defs_to_safe_ids.set(def.id, tw.safe_ids);
      mark(tw, def, true);
    } else if (def.fixed) {
      tw.loop_ids.set(def.id, tw.in_loop);
      mark(tw, def, true);
    }
  });
}
function reset_block_variables(compressor, node) {
  if (node.block_scope) node.block_scope.variables.forEach((def) => {
    reset_def(compressor, def);
  });
}
function push(tw) {
  tw.safe_ids = Object.create(tw.safe_ids);
}
function pop(tw) {
  tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);
}
function mark(tw, def, safe) {
  tw.safe_ids[def.id] = safe;
}
function safe_to_read(tw, def) {
  if (def.single_use == "m") return false;
  if (tw.safe_ids[def.id]) {
    if (def.fixed == null) {
      var orig = def.orig[0];
      if (orig instanceof AST_SymbolFunarg || orig.name == "arguments") return false;
      def.fixed = make_node(AST_Undefined, orig);
    }
    return true;
  }
  return def.fixed instanceof AST_Defun;
}
function safe_to_assign(tw, def, scope5, value) {
  if (def.fixed === void 0) return true;
  let def_safe_ids;
  if (def.fixed === null && (def_safe_ids = tw.defs_to_safe_ids.get(def.id))) {
    def_safe_ids[def.id] = false;
    tw.defs_to_safe_ids.delete(def.id);
    return true;
  }
  if (!HOP(tw.safe_ids, def.id)) return false;
  if (!safe_to_read(tw, def)) return false;
  if (def.fixed === false) return false;
  if (def.fixed != null && (!value || def.references.length > def.assignments)) return false;
  if (def.fixed instanceof AST_Defun) {
    return value instanceof AST_Node && def.fixed.parent_scope === scope5;
  }
  return def.orig.every((sym) => {
    return !(sym instanceof AST_SymbolConst || sym instanceof AST_SymbolDefun || sym instanceof AST_SymbolLambda);
  });
}
function ref_once(tw, compressor, def) {
  return compressor.option("unused") && !def.scope.pinned() && def.references.length - def.recursive_refs == 1 && tw.loop_ids.get(def.id) === tw.in_loop;
}
function is_immutable(value) {
  if (!value) return false;
  return value.is_constant() || value instanceof AST_Lambda || value instanceof AST_This;
}
function mark_escaped(tw, d2, scope5, node, value, level = 0, depth = 1) {
  var parent = tw.parent(level);
  if (value) {
    if (value.is_constant()) return;
    if (value instanceof AST_ClassExpression) return;
  }
  if (parent instanceof AST_Assign && (parent.operator === "=" || parent.logical) && node === parent.right || parent instanceof AST_Call && (node !== parent.expression || parent instanceof AST_New) || parent instanceof AST_Exit && node === parent.value && node.scope !== d2.scope || parent instanceof AST_VarDef && node === parent.value || parent instanceof AST_Yield && node === parent.value && node.scope !== d2.scope) {
    if (depth > 1 && !(value && value.is_constant_expression(scope5))) depth = 1;
    if (!d2.escaped || d2.escaped > depth) d2.escaped = depth;
    return;
  } else if (parent instanceof AST_Array || parent instanceof AST_Await || parent instanceof AST_Binary && lazy_op.has(parent.operator) || parent instanceof AST_Conditional && node !== parent.condition || parent instanceof AST_Expansion || parent instanceof AST_Sequence && node === parent.tail_node()) {
    mark_escaped(tw, d2, scope5, parent, parent, level + 1, depth);
  } else if (parent instanceof AST_ObjectKeyVal && node === parent.value) {
    var obj = tw.parent(level + 1);
    mark_escaped(tw, d2, scope5, obj, obj, level + 2, depth);
  } else if (parent instanceof AST_PropAccess && node === parent.expression) {
    value = read_property(value, parent.property);
    mark_escaped(tw, d2, scope5, parent, value, level + 1, depth + 1);
    if (value) return;
  }
  if (level > 0) return;
  if (parent instanceof AST_Sequence && node !== parent.tail_node()) return;
  if (parent instanceof AST_SimpleStatement) return;
  d2.direct_access = true;
}
var suppress = (node) => walk2(node, (node2) => {
  if (!(node2 instanceof AST_Symbol)) return;
  var d2 = node2.definition();
  if (!d2) return;
  if (node2 instanceof AST_SymbolRef) d2.references.push(node2);
  d2.fixed = false;
});
def_reduce_vars(AST_Accessor, function(tw, descend, compressor) {
  push(tw);
  reset_variables(tw, compressor, this);
  descend();
  pop(tw);
  return true;
});
def_reduce_vars(AST_Assign, function(tw, descend, compressor) {
  var node = this;
  if (node.left instanceof AST_Destructuring) {
    suppress(node.left);
    return;
  }
  const finish_walk = () => {
    if (node.logical) {
      node.left.walk(tw);
      push(tw);
      node.right.walk(tw);
      pop(tw);
      return true;
    }
  };
  var sym = node.left;
  if (!(sym instanceof AST_SymbolRef)) return finish_walk();
  var def = sym.definition();
  var safe = safe_to_assign(tw, def, sym.scope, node.right);
  def.assignments++;
  if (!safe) return finish_walk();
  var fixed2 = def.fixed;
  if (!fixed2 && node.operator != "=" && !node.logical) return finish_walk();
  var eq = node.operator == "=";
  var value = eq ? node.right : node;
  if (is_modified(compressor, tw, node, value, 0)) return finish_walk();
  def.references.push(sym);
  if (!node.logical) {
    if (!eq) def.chained = true;
    def.fixed = eq ? function() {
      return node.right;
    } : function() {
      return make_node(AST_Binary, node, {
        operator: node.operator.slice(0, -1),
        left: fixed2 instanceof AST_Node ? fixed2 : fixed2(),
        right: node.right
      });
    };
  }
  if (node.logical) {
    mark(tw, def, false);
    push(tw);
    node.right.walk(tw);
    pop(tw);
    return true;
  }
  mark(tw, def, false);
  node.right.walk(tw);
  mark(tw, def, true);
  mark_escaped(tw, def, sym.scope, node, value, 0, 1);
  return true;
});
def_reduce_vars(AST_Binary, function(tw) {
  if (!lazy_op.has(this.operator)) return;
  this.left.walk(tw);
  push(tw);
  this.right.walk(tw);
  pop(tw);
  return true;
});
def_reduce_vars(AST_Block, function(tw, descend, compressor) {
  reset_block_variables(compressor, this);
});
def_reduce_vars(AST_Case, function(tw) {
  push(tw);
  this.expression.walk(tw);
  pop(tw);
  push(tw);
  walk_body(this, tw);
  pop(tw);
  return true;
});
def_reduce_vars(AST_Class, function(tw, descend) {
  clear_flag(this, INLINED);
  push(tw);
  descend();
  pop(tw);
  return true;
});
def_reduce_vars(AST_ClassStaticBlock, function(tw, descend, compressor) {
  reset_block_variables(compressor, this);
});
def_reduce_vars(AST_Conditional, function(tw) {
  this.condition.walk(tw);
  push(tw);
  this.consequent.walk(tw);
  pop(tw);
  push(tw);
  this.alternative.walk(tw);
  pop(tw);
  return true;
});
def_reduce_vars(AST_Chain, function(tw, descend) {
  const safe_ids = tw.safe_ids;
  descend();
  tw.safe_ids = safe_ids;
  return true;
});
def_reduce_vars(AST_Call, function(tw) {
  this.expression.walk(tw);
  if (this.optional) {
    push(tw);
  }
  for (const arg of this.args) arg.walk(tw);
  return true;
});
def_reduce_vars(AST_PropAccess, function(tw) {
  if (!this.optional) return;
  this.expression.walk(tw);
  push(tw);
  if (this.property instanceof AST_Node) this.property.walk(tw);
  return true;
});
def_reduce_vars(AST_Default, function(tw, descend) {
  push(tw);
  descend();
  pop(tw);
  return true;
});
function mark_lambda(tw, descend, compressor) {
  clear_flag(this, INLINED);
  push(tw);
  reset_variables(tw, compressor, this);
  var iife2;
  if (!this.name && !this.uses_arguments && !this.pinned() && (iife2 = tw.parent()) instanceof AST_Call && iife2.expression === this && !iife2.args.some((arg) => arg instanceof AST_Expansion) && this.argnames.every((arg_name) => arg_name instanceof AST_Symbol)) {
    this.argnames.forEach((arg, i) => {
      if (!arg.definition) return;
      var d2 = arg.definition();
      if (d2.orig.length > 1) return;
      if (d2.fixed === void 0 && (!this.uses_arguments || tw.has_directive("use strict"))) {
        d2.fixed = function() {
          return iife2.args[i] || make_node(AST_Undefined, iife2);
        };
        tw.loop_ids.set(d2.id, tw.in_loop);
        mark(tw, d2, true);
      } else {
        d2.fixed = false;
      }
    });
  }
  descend();
  pop(tw);
  handle_defined_after_hoist(this);
  return true;
}
function handle_defined_after_hoist(parent) {
  const defuns = [];
  walk2(parent, (node) => {
    if (node === parent) return;
    if (node instanceof AST_Defun) {
      defuns.push(node);
      return true;
    }
    if (node instanceof AST_Scope || node instanceof AST_SimpleStatement) return true;
  });
  const defun_dependencies_map = /* @__PURE__ */ new Map();
  const dependencies_map = /* @__PURE__ */ new Map();
  const symbols_of_interest = /* @__PURE__ */ new Set();
  const defuns_of_interest = /* @__PURE__ */ new Set();
  for (const defun of defuns) {
    const fname_def = defun.name.definition();
    const enclosing_defs = [];
    for (const def of defun.enclosed) {
      if (def.fixed === false || def === fname_def || def.scope.get_defun_scope() !== parent) {
        continue;
      }
      symbols_of_interest.add(def.id);
      if (def.assignments === 0 && def.orig.length === 1 && def.orig[0] instanceof AST_SymbolDefun) {
        defuns_of_interest.add(def.id);
        symbols_of_interest.add(def.id);
        defuns_of_interest.add(fname_def.id);
        symbols_of_interest.add(fname_def.id);
        if (!defun_dependencies_map.has(fname_def.id)) {
          defun_dependencies_map.set(fname_def.id, []);
        }
        defun_dependencies_map.get(fname_def.id).push(def.id);
        continue;
      }
      enclosing_defs.push(def);
    }
    if (enclosing_defs.length) {
      dependencies_map.set(fname_def.id, enclosing_defs);
      defuns_of_interest.add(fname_def.id);
      symbols_of_interest.add(fname_def.id);
    }
  }
  if (!dependencies_map.size) {
    return;
  }
  let symbol_index = 1;
  const defun_first_read_map = /* @__PURE__ */ new Map();
  const symbol_last_write_map = /* @__PURE__ */ new Map();
  walk_parent(parent, (node, walk_info) => {
    if (node instanceof AST_Symbol && node.thedef) {
      const id2 = node.definition().id;
      symbol_index++;
      if (symbols_of_interest.has(id2)) {
        if (node instanceof AST_SymbolDeclaration || is_lhs(node, walk_info.parent())) {
          symbol_last_write_map.set(id2, symbol_index);
        }
      }
      if (defuns_of_interest.has(id2)) {
        if (!defun_first_read_map.has(id2) && !is_recursive_ref(walk_info, id2)) {
          defun_first_read_map.set(id2, symbol_index);
        }
      }
    }
  });
  for (const [defun, defun_first_read] of defun_first_read_map) {
    const queue = new Set(defun_dependencies_map.get(defun));
    for (const enclosed_defun of queue) {
      let enclosed_defun_first_read = defun_first_read_map.get(enclosed_defun);
      if (enclosed_defun_first_read != null && enclosed_defun_first_read < defun_first_read) {
        continue;
      }
      defun_first_read_map.set(enclosed_defun, defun_first_read);
      for (const enclosed_enclosed_defun of defun_dependencies_map.get(enclosed_defun) || []) {
        queue.add(enclosed_enclosed_defun);
      }
    }
  }
  for (const [defun, defs] of dependencies_map) {
    const defun_first_read = defun_first_read_map.get(defun);
    if (defun_first_read === void 0) {
      continue;
    }
    for (const def of defs) {
      if (def.fixed === false) {
        continue;
      }
      let def_last_write = symbol_last_write_map.get(def.id) || 0;
      if (defun_first_read < def_last_write) {
        def.fixed = false;
      }
    }
  }
}
def_reduce_vars(AST_Lambda, mark_lambda);
def_reduce_vars(AST_Do, function(tw, descend, compressor) {
  reset_block_variables(compressor, this);
  const saved_loop = tw.in_loop;
  tw.in_loop = this;
  push(tw);
  this.body.walk(tw);
  if (has_break_or_continue(this)) {
    pop(tw);
    push(tw);
  }
  this.condition.walk(tw);
  pop(tw);
  tw.in_loop = saved_loop;
  return true;
});
def_reduce_vars(AST_For, function(tw, descend, compressor) {
  reset_block_variables(compressor, this);
  if (this.init) this.init.walk(tw);
  const saved_loop = tw.in_loop;
  tw.in_loop = this;
  push(tw);
  if (this.condition) this.condition.walk(tw);
  this.body.walk(tw);
  if (this.step) {
    if (has_break_or_continue(this)) {
      pop(tw);
      push(tw);
    }
    this.step.walk(tw);
  }
  pop(tw);
  tw.in_loop = saved_loop;
  return true;
});
def_reduce_vars(AST_ForIn, function(tw, descend, compressor) {
  reset_block_variables(compressor, this);
  suppress(this.init);
  this.object.walk(tw);
  const saved_loop = tw.in_loop;
  tw.in_loop = this;
  push(tw);
  this.body.walk(tw);
  pop(tw);
  tw.in_loop = saved_loop;
  return true;
});
def_reduce_vars(AST_If, function(tw) {
  this.condition.walk(tw);
  push(tw);
  this.body.walk(tw);
  pop(tw);
  if (this.alternative) {
    push(tw);
    this.alternative.walk(tw);
    pop(tw);
  }
  return true;
});
def_reduce_vars(AST_LabeledStatement, function(tw) {
  push(tw);
  this.body.walk(tw);
  pop(tw);
  return true;
});
def_reduce_vars(AST_SymbolCatch, function() {
  this.definition().fixed = false;
});
def_reduce_vars(AST_SymbolRef, function(tw, descend, compressor) {
  var d2 = this.definition();
  d2.references.push(this);
  if (d2.references.length == 1 && !d2.fixed && d2.orig[0] instanceof AST_SymbolDefun) {
    tw.loop_ids.set(d2.id, tw.in_loop);
  }
  var fixed_value;
  if (d2.fixed === void 0 || !safe_to_read(tw, d2)) {
    d2.fixed = false;
  } else if (d2.fixed) {
    fixed_value = this.fixed_value();
    if (fixed_value instanceof AST_Lambda && is_recursive_ref(tw, d2)) {
      d2.recursive_refs++;
    } else if (fixed_value && !compressor.exposed(d2) && ref_once(tw, compressor, d2)) {
      d2.single_use = fixed_value instanceof AST_Lambda && !fixed_value.pinned() || fixed_value instanceof AST_Class || d2.scope === this.scope && fixed_value.is_constant_expression();
    } else {
      d2.single_use = false;
    }
    if (is_modified(compressor, tw, this, fixed_value, 0, is_immutable(fixed_value))) {
      if (d2.single_use) {
        d2.single_use = "m";
      } else {
        d2.fixed = false;
      }
    }
  }
  mark_escaped(tw, d2, this.scope, this, fixed_value, 0, 1);
});
def_reduce_vars(AST_Toplevel, function(tw, descend, compressor) {
  this.globals.forEach(function(def) {
    reset_def(compressor, def);
  });
  reset_variables(tw, compressor, this);
  descend();
  handle_defined_after_hoist(this);
  return true;
});
def_reduce_vars(AST_Try, function(tw, descend, compressor) {
  reset_block_variables(compressor, this);
  push(tw);
  this.body.walk(tw);
  pop(tw);
  if (this.bcatch) {
    push(tw);
    this.bcatch.walk(tw);
    pop(tw);
  }
  if (this.bfinally) this.bfinally.walk(tw);
  return true;
});
def_reduce_vars(AST_Unary, function(tw) {
  var node = this;
  if (node.operator !== "++" && node.operator !== "--") return;
  var exp = node.expression;
  if (!(exp instanceof AST_SymbolRef)) return;
  var def = exp.definition();
  var safe = safe_to_assign(tw, def, exp.scope, true);
  def.assignments++;
  if (!safe) return;
  var fixed2 = def.fixed;
  if (!fixed2) return;
  def.references.push(exp);
  def.chained = true;
  def.fixed = function() {
    return make_node(AST_Binary, node, {
      operator: node.operator.slice(0, -1),
      left: make_node(AST_UnaryPrefix, node, {
        operator: "+",
        expression: fixed2 instanceof AST_Node ? fixed2 : fixed2()
      }),
      right: make_node(AST_Number, node, {
        value: 1
      })
    });
  };
  mark(tw, def, true);
  return true;
});
def_reduce_vars(AST_VarDef, function(tw, descend) {
  var node = this;
  if (node.name instanceof AST_Destructuring) {
    suppress(node.name);
    return;
  }
  var d2 = node.name.definition();
  if (node.value) {
    if (safe_to_assign(tw, d2, node.name.scope, node.value)) {
      d2.fixed = function() {
        return node.value;
      };
      tw.loop_ids.set(d2.id, tw.in_loop);
      mark(tw, d2, false);
      descend();
      mark(tw, d2, true);
      return true;
    } else {
      d2.fixed = false;
    }
  }
});
def_reduce_vars(AST_While, function(tw, descend, compressor) {
  reset_block_variables(compressor, this);
  const saved_loop = tw.in_loop;
  tw.in_loop = this;
  push(tw);
  descend();
  pop(tw);
  tw.in_loop = saved_loop;
  return true;
});

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/compress/tighten-body.js
function loop_body(x2) {
  if (x2 instanceof AST_IterationStatement) {
    return x2.body instanceof AST_BlockStatement ? x2.body : x2;
  }
  return x2;
}
function is_lhs_read_only(lhs) {
  if (lhs instanceof AST_This) return true;
  if (lhs instanceof AST_SymbolRef) return lhs.definition().orig[0] instanceof AST_SymbolLambda;
  if (lhs instanceof AST_PropAccess) {
    lhs = lhs.expression;
    if (lhs instanceof AST_SymbolRef) {
      if (lhs.is_immutable()) return false;
      lhs = lhs.fixed_value();
    }
    if (!lhs) return true;
    if (lhs instanceof AST_RegExp) return false;
    if (lhs instanceof AST_Constant) return true;
    return is_lhs_read_only(lhs);
  }
  return false;
}
function remove_initializers(var_statement) {
  var decls = [];
  var_statement.definitions.forEach(function(def) {
    if (def.name instanceof AST_SymbolDeclaration) {
      def.value = null;
      decls.push(def);
    } else {
      def.declarations_as_names().forEach((name) => {
        decls.push(make_node(AST_VarDef, def, {
          name,
          value: null
        }));
      });
    }
  });
  return decls.length ? make_node(AST_Var, var_statement, { definitions: decls }) : null;
}
function trim_unreachable_code(compressor, stat2, target) {
  walk2(stat2, (node) => {
    if (node instanceof AST_Var) {
      const no_initializers = remove_initializers(node);
      if (no_initializers) target.push(no_initializers);
      return true;
    }
    if (node instanceof AST_Defun && (node === stat2 || !compressor.has_directive("use strict"))) {
      target.push(node === stat2 ? node : make_node(AST_Var, node, {
        definitions: [
          make_node(AST_VarDef, node, {
            name: make_node(AST_SymbolVar, node.name, node.name),
            value: null
          })
        ]
      }));
      return true;
    }
    if (node instanceof AST_Export || node instanceof AST_Import) {
      target.push(node);
      return true;
    }
    if (node instanceof AST_Scope) {
      return true;
    }
  });
}
function tighten_body(statements, compressor) {
  const nearest_scope = compressor.find_scope();
  const defun_scope = nearest_scope.get_defun_scope();
  const { in_loop, in_try } = find_loop_scope_try();
  var CHANGED, max_iter = 10;
  do {
    CHANGED = false;
    eliminate_spurious_blocks(statements);
    if (compressor.option("dead_code")) {
      eliminate_dead_code(statements, compressor);
    }
    if (compressor.option("if_return")) {
      handle_if_return(statements, compressor);
    }
    if (compressor.sequences_limit > 0) {
      sequencesize(statements, compressor);
      sequencesize_2(statements, compressor);
    }
    if (compressor.option("join_vars")) {
      join_consecutive_vars(statements);
    }
    if (compressor.option("collapse_vars")) {
      collapse(statements, compressor);
    }
  } while (CHANGED && max_iter-- > 0);
  function find_loop_scope_try() {
    var node = compressor.self(), level = 0, in_loop2 = false, in_try2 = false;
    do {
      if (node instanceof AST_IterationStatement) {
        in_loop2 = true;
      } else if (node instanceof AST_Scope) {
        break;
      } else if (node instanceof AST_TryBlock) {
        in_try2 = true;
      }
    } while (node = compressor.parent(level++));
    return { in_loop: in_loop2, in_try: in_try2 };
  }
  function collapse(statements2, compressor2) {
    if (nearest_scope.pinned() || defun_scope.pinned())
      return statements2;
    var args2;
    var candidates = [];
    var stat_index = statements2.length;
    var scanner = new TreeTransformer(function(node) {
      if (abort)
        return node;
      if (!hit) {
        if (node !== hit_stack[hit_index])
          return node;
        hit_index++;
        if (hit_index < hit_stack.length)
          return handle_custom_scan_order(node);
        hit = true;
        stop_after = find_stop(node, 0);
        if (stop_after === node)
          abort = true;
        return node;
      }
      var parent = scanner.parent();
      if (node instanceof AST_Assign && (node.logical || node.operator != "=" && lhs.equivalent_to(node.left)) || node instanceof AST_Await || node instanceof AST_Call && lhs instanceof AST_PropAccess && lhs.equivalent_to(node.expression) || (node instanceof AST_Call || node instanceof AST_PropAccess) && node.optional || node instanceof AST_Debugger || node instanceof AST_Destructuring || node instanceof AST_Expansion && node.expression instanceof AST_Symbol && (node.expression instanceof AST_This || node.expression.definition().references.length > 1) || node instanceof AST_IterationStatement && !(node instanceof AST_For) || node instanceof AST_LoopControl || node instanceof AST_Try || node instanceof AST_With || node instanceof AST_Yield || node instanceof AST_Export || node instanceof AST_Class || parent instanceof AST_For && node !== parent.init || !replace_all && (node instanceof AST_SymbolRef && !node.is_declared(compressor2) && !pure_prop_access_globals.has(node)) || node instanceof AST_SymbolRef && parent instanceof AST_Call && has_annotation(parent, _NOINLINE) || node instanceof AST_ObjectProperty && node.key instanceof AST_Node) {
        abort = true;
        return node;
      }
      if (!stop_if_hit && (!lhs_local || !replace_all) && (parent instanceof AST_Binary && lazy_op.has(parent.operator) && parent.left !== node || parent instanceof AST_Conditional && parent.condition !== node || parent instanceof AST_If && parent.condition !== node)) {
        stop_if_hit = parent;
      }
      if (can_replace && !(node instanceof AST_SymbolDeclaration) && lhs.equivalent_to(node) && !shadows(scanner.find_scope() || nearest_scope, lvalues)) {
        if (stop_if_hit) {
          abort = true;
          return node;
        }
        if (is_lhs(node, parent)) {
          if (value_def)
            replaced++;
          return node;
        } else {
          replaced++;
          if (value_def && candidate instanceof AST_VarDef)
            return node;
        }
        CHANGED = abort = true;
        if (candidate instanceof AST_UnaryPostfix) {
          return make_node(AST_UnaryPrefix, candidate, candidate);
        }
        if (candidate instanceof AST_VarDef) {
          var def2 = candidate.name.definition();
          var value = candidate.value;
          if (def2.references.length - def2.replaced == 1 && !compressor2.exposed(def2)) {
            def2.replaced++;
            if (funarg && is_identifier_atom(value)) {
              return value.transform(compressor2);
            } else {
              return maintain_this_binding(parent, node, value);
            }
          }
          return make_node(AST_Assign, candidate, {
            operator: "=",
            logical: false,
            left: make_node(AST_SymbolRef, candidate.name, candidate.name),
            right: value
          });
        }
        clear_flag(candidate, WRITE_ONLY);
        return candidate;
      }
      var sym;
      if (node instanceof AST_Call || node instanceof AST_Exit && (side_effects || lhs instanceof AST_PropAccess || may_modify(lhs)) || node instanceof AST_PropAccess && (side_effects || node.expression.may_throw_on_access(compressor2)) || node instanceof AST_SymbolRef && (lvalues.has(node.name) && lvalues.get(node.name).modified || side_effects && may_modify(node)) || node instanceof AST_VarDef && node.value && (lvalues.has(node.name.name) || side_effects && may_modify(node.name)) || (sym = is_lhs(node.left, node)) && (sym instanceof AST_PropAccess || lvalues.has(sym.name)) || may_throw && (in_try ? node.has_side_effects(compressor2) : side_effects_external(node))) {
        stop_after = node;
        if (node instanceof AST_Scope)
          abort = true;
      }
      return handle_custom_scan_order(node);
    }, function(node) {
      if (abort)
        return;
      if (stop_after === node)
        abort = true;
      if (stop_if_hit === node)
        stop_if_hit = null;
    });
    var multi_replacer = new TreeTransformer(function(node) {
      if (abort)
        return node;
      if (!hit) {
        if (node !== hit_stack[hit_index])
          return node;
        hit_index++;
        if (hit_index < hit_stack.length)
          return;
        hit = true;
        return node;
      }
      if (node instanceof AST_SymbolRef && node.name == def.name) {
        if (!--replaced)
          abort = true;
        if (is_lhs(node, multi_replacer.parent()))
          return node;
        def.replaced++;
        value_def.replaced--;
        return candidate.value;
      }
      if (node instanceof AST_Default || node instanceof AST_Scope)
        return node;
    });
    while (--stat_index >= 0) {
      if (stat_index == 0 && compressor2.option("unused"))
        extract_args();
      var hit_stack = [];
      extract_candidates(statements2[stat_index]);
      while (candidates.length > 0) {
        hit_stack = candidates.pop();
        var hit_index = 0;
        var candidate = hit_stack[hit_stack.length - 1];
        var value_def = null;
        var stop_after = null;
        var stop_if_hit = null;
        var lhs = get_lhs(candidate);
        if (!lhs || is_lhs_read_only(lhs) || lhs.has_side_effects(compressor2))
          continue;
        var lvalues = get_lvalues(candidate);
        var lhs_local = is_lhs_local(lhs);
        if (lhs instanceof AST_SymbolRef) {
          lvalues.set(lhs.name, { def: lhs.definition(), modified: false });
        }
        var side_effects = value_has_side_effects(candidate);
        var replace_all = replace_all_symbols();
        var may_throw = candidate.may_throw(compressor2);
        var funarg = candidate.name instanceof AST_SymbolFunarg;
        var hit = funarg;
        var abort = false, replaced = 0, can_replace = !args2 || !hit;
        if (!can_replace) {
          for (let j = compressor2.self().argnames.lastIndexOf(candidate.name) + 1; !abort && j < args2.length; j++) {
            args2[j].transform(scanner);
          }
          can_replace = true;
        }
        for (var i = stat_index; !abort && i < statements2.length; i++) {
          statements2[i].transform(scanner);
        }
        if (value_def) {
          var def = candidate.name.definition();
          if (abort && def.references.length - def.replaced > replaced)
            replaced = false;
          else {
            abort = false;
            hit_index = 0;
            hit = funarg;
            for (var i = stat_index; !abort && i < statements2.length; i++) {
              statements2[i].transform(multi_replacer);
            }
            value_def.single_use = false;
          }
        }
        if (replaced && !remove_candidate(candidate))
          statements2.splice(stat_index, 1);
      }
    }
    function handle_custom_scan_order(node) {
      if (node instanceof AST_Scope)
        return node;
      if (node instanceof AST_Switch) {
        node.expression = node.expression.transform(scanner);
        for (var i2 = 0, len = node.body.length; !abort && i2 < len; i2++) {
          var branch = node.body[i2];
          if (branch instanceof AST_Case) {
            if (!hit) {
              if (branch !== hit_stack[hit_index])
                continue;
              hit_index++;
            }
            branch.expression = branch.expression.transform(scanner);
            if (!replace_all)
              break;
          }
        }
        abort = true;
        return node;
      }
    }
    function redefined_within_scope(def2, scope5) {
      if (def2.global)
        return false;
      let cur_scope = def2.scope;
      while (cur_scope && cur_scope !== scope5) {
        if (cur_scope.variables.has(def2.name)) {
          return true;
        }
        cur_scope = cur_scope.parent_scope;
      }
      return false;
    }
    function has_overlapping_symbol(fn2, arg, fn_strict) {
      var found2 = false, scan_this = !(fn2 instanceof AST_Arrow);
      arg.walk(new TreeWalker(function(node, descend) {
        if (found2)
          return true;
        if (node instanceof AST_SymbolRef && (fn2.variables.has(node.name) || redefined_within_scope(node.definition(), fn2))) {
          var s2 = node.definition().scope;
          if (s2 !== defun_scope)
            while (s2 = s2.parent_scope) {
              if (s2 === defun_scope)
                return true;
            }
          return found2 = true;
        }
        if ((fn_strict || scan_this) && node instanceof AST_This) {
          return found2 = true;
        }
        if (node instanceof AST_Scope && !(node instanceof AST_Arrow)) {
          var prev = scan_this;
          scan_this = false;
          descend();
          scan_this = prev;
          return true;
        }
      }));
      return found2;
    }
    function arg_is_injectable(arg) {
      if (arg instanceof AST_Expansion) return false;
      const contains_await = walk2(arg, (node) => {
        if (node instanceof AST_Await) return walk_abort;
      });
      if (contains_await) return false;
      return true;
    }
    function extract_args() {
      var iife2, fn2 = compressor2.self();
      if (is_func_expr(fn2) && !fn2.name && !fn2.uses_arguments && !fn2.pinned() && (iife2 = compressor2.parent()) instanceof AST_Call && iife2.expression === fn2 && iife2.args.every(arg_is_injectable)) {
        var fn_strict = compressor2.has_directive("use strict");
        if (fn_strict && !member(fn_strict, fn2.body))
          fn_strict = false;
        var len = fn2.argnames.length;
        args2 = iife2.args.slice(len);
        var names = /* @__PURE__ */ new Set();
        for (var i2 = len; --i2 >= 0; ) {
          var sym = fn2.argnames[i2];
          var arg = iife2.args[i2];
          const def2 = sym.definition && sym.definition();
          const is_reassigned = def2 && def2.orig.length > 1;
          if (is_reassigned)
            continue;
          args2.unshift(make_node(AST_VarDef, sym, {
            name: sym,
            value: arg
          }));
          if (names.has(sym.name))
            continue;
          names.add(sym.name);
          if (sym instanceof AST_Expansion) {
            var elements = iife2.args.slice(i2);
            if (elements.every(
              (arg2) => !has_overlapping_symbol(fn2, arg2, fn_strict)
            )) {
              candidates.unshift([make_node(AST_VarDef, sym, {
                name: sym.expression,
                value: make_node(AST_Array, iife2, {
                  elements
                })
              })]);
            }
          } else {
            if (!arg) {
              arg = make_node(AST_Undefined, sym).transform(compressor2);
            } else if (arg instanceof AST_Lambda && arg.pinned() || has_overlapping_symbol(fn2, arg, fn_strict)) {
              arg = null;
            }
            if (arg)
              candidates.unshift([make_node(AST_VarDef, sym, {
                name: sym,
                value: arg
              })]);
          }
        }
      }
    }
    function extract_candidates(expr) {
      hit_stack.push(expr);
      if (expr instanceof AST_Assign) {
        if (!expr.left.has_side_effects(compressor2) && !(expr.right instanceof AST_Chain)) {
          candidates.push(hit_stack.slice());
        }
        extract_candidates(expr.right);
      } else if (expr instanceof AST_Binary) {
        extract_candidates(expr.left);
        extract_candidates(expr.right);
      } else if (expr instanceof AST_Call && !has_annotation(expr, _NOINLINE)) {
        extract_candidates(expr.expression);
        expr.args.forEach(extract_candidates);
      } else if (expr instanceof AST_Case) {
        extract_candidates(expr.expression);
      } else if (expr instanceof AST_Conditional) {
        extract_candidates(expr.condition);
        extract_candidates(expr.consequent);
        extract_candidates(expr.alternative);
      } else if (expr instanceof AST_Definitions) {
        var len = expr.definitions.length;
        var i2 = len - 200;
        if (i2 < 0)
          i2 = 0;
        for (; i2 < len; i2++) {
          extract_candidates(expr.definitions[i2]);
        }
      } else if (expr instanceof AST_DWLoop) {
        extract_candidates(expr.condition);
        if (!(expr.body instanceof AST_Block)) {
          extract_candidates(expr.body);
        }
      } else if (expr instanceof AST_Exit) {
        if (expr.value)
          extract_candidates(expr.value);
      } else if (expr instanceof AST_For) {
        if (expr.init)
          extract_candidates(expr.init);
        if (expr.condition)
          extract_candidates(expr.condition);
        if (expr.step)
          extract_candidates(expr.step);
        if (!(expr.body instanceof AST_Block)) {
          extract_candidates(expr.body);
        }
      } else if (expr instanceof AST_ForIn) {
        extract_candidates(expr.object);
        if (!(expr.body instanceof AST_Block)) {
          extract_candidates(expr.body);
        }
      } else if (expr instanceof AST_If) {
        extract_candidates(expr.condition);
        if (!(expr.body instanceof AST_Block)) {
          extract_candidates(expr.body);
        }
        if (expr.alternative && !(expr.alternative instanceof AST_Block)) {
          extract_candidates(expr.alternative);
        }
      } else if (expr instanceof AST_Sequence) {
        expr.expressions.forEach(extract_candidates);
      } else if (expr instanceof AST_SimpleStatement) {
        extract_candidates(expr.body);
      } else if (expr instanceof AST_Switch) {
        extract_candidates(expr.expression);
        expr.body.forEach(extract_candidates);
      } else if (expr instanceof AST_Unary) {
        if (expr.operator == "++" || expr.operator == "--") {
          candidates.push(hit_stack.slice());
        }
      } else if (expr instanceof AST_VarDef) {
        if (expr.value && !(expr.value instanceof AST_Chain)) {
          candidates.push(hit_stack.slice());
          extract_candidates(expr.value);
        }
      }
      hit_stack.pop();
    }
    function find_stop(node, level, write_only) {
      var parent = scanner.parent(level);
      if (parent instanceof AST_Assign) {
        if (write_only && !parent.logical && !(parent.left instanceof AST_PropAccess || lvalues.has(parent.left.name))) {
          return find_stop(parent, level + 1, write_only);
        }
        return node;
      }
      if (parent instanceof AST_Binary) {
        if (write_only && (!lazy_op.has(parent.operator) || parent.left === node)) {
          return find_stop(parent, level + 1, write_only);
        }
        return node;
      }
      if (parent instanceof AST_Call)
        return node;
      if (parent instanceof AST_Case)
        return node;
      if (parent instanceof AST_Conditional) {
        if (write_only && parent.condition === node) {
          return find_stop(parent, level + 1, write_only);
        }
        return node;
      }
      if (parent instanceof AST_Definitions) {
        return find_stop(parent, level + 1, true);
      }
      if (parent instanceof AST_Exit) {
        return write_only ? find_stop(parent, level + 1, write_only) : node;
      }
      if (parent instanceof AST_If) {
        if (write_only && parent.condition === node) {
          return find_stop(parent, level + 1, write_only);
        }
        return node;
      }
      if (parent instanceof AST_IterationStatement)
        return node;
      if (parent instanceof AST_Sequence) {
        return find_stop(parent, level + 1, parent.tail_node() !== node);
      }
      if (parent instanceof AST_SimpleStatement) {
        return find_stop(parent, level + 1, true);
      }
      if (parent instanceof AST_Switch)
        return node;
      if (parent instanceof AST_VarDef)
        return node;
      return null;
    }
    function mangleable_var(var_def) {
      var value = var_def.value;
      if (!(value instanceof AST_SymbolRef))
        return;
      if (value.name == "arguments")
        return;
      var def2 = value.definition();
      if (def2.undeclared)
        return;
      return value_def = def2;
    }
    function get_lhs(expr) {
      if (expr instanceof AST_Assign && expr.logical) {
        return false;
      } else if (expr instanceof AST_VarDef && expr.name instanceof AST_SymbolDeclaration) {
        var def2 = expr.name.definition();
        if (!member(expr.name, def2.orig))
          return;
        var referenced = def2.references.length - def2.replaced;
        if (!referenced)
          return;
        var declared = def2.orig.length - def2.eliminated;
        if (declared > 1 && !(expr.name instanceof AST_SymbolFunarg) || (referenced > 1 ? mangleable_var(expr) : !compressor2.exposed(def2))) {
          return make_node(AST_SymbolRef, expr.name, expr.name);
        }
      } else {
        const lhs2 = expr instanceof AST_Assign ? expr.left : expr.expression;
        return !is_ref_of(lhs2, AST_SymbolConst) && !is_ref_of(lhs2, AST_SymbolLet) && lhs2;
      }
    }
    function get_rvalue(expr) {
      if (expr instanceof AST_Assign) {
        return expr.right;
      } else {
        return expr.value;
      }
    }
    function get_lvalues(expr) {
      var lvalues2 = /* @__PURE__ */ new Map();
      if (expr instanceof AST_Unary)
        return lvalues2;
      var tw = new TreeWalker(function(node) {
        var sym = node;
        while (sym instanceof AST_PropAccess)
          sym = sym.expression;
        if (sym instanceof AST_SymbolRef) {
          const prev = lvalues2.get(sym.name);
          if (!prev || !prev.modified) {
            lvalues2.set(sym.name, {
              def: sym.definition(),
              modified: is_modified(compressor2, tw, node, node, 0)
            });
          }
        }
      });
      get_rvalue(expr).walk(tw);
      return lvalues2;
    }
    function remove_candidate(expr) {
      if (expr.name instanceof AST_SymbolFunarg) {
        var iife2 = compressor2.parent(), argnames = compressor2.self().argnames;
        var index = argnames.indexOf(expr.name);
        if (index < 0) {
          iife2.args.length = Math.min(iife2.args.length, argnames.length - 1);
        } else {
          var args3 = iife2.args;
          if (args3[index])
            args3[index] = make_node(AST_Number, args3[index], {
              value: 0
            });
        }
        return true;
      }
      var found2 = false;
      return statements2[stat_index].transform(new TreeTransformer(function(node, descend, in_list) {
        if (found2)
          return node;
        if (node === expr || node.body === expr) {
          found2 = true;
          if (node instanceof AST_VarDef) {
            node.value = node.name instanceof AST_SymbolConst ? make_node(AST_Undefined, node.value) : null;
            return node;
          }
          return in_list ? MAP.skip : null;
        }
      }, function(node) {
        if (node instanceof AST_Sequence)
          switch (node.expressions.length) {
            case 0:
              return null;
            case 1:
              return node.expressions[0];
          }
      }));
    }
    function is_lhs_local(lhs2) {
      while (lhs2 instanceof AST_PropAccess)
        lhs2 = lhs2.expression;
      return lhs2 instanceof AST_SymbolRef && lhs2.definition().scope.get_defun_scope() === defun_scope && !(in_loop && (lvalues.has(lhs2.name) || candidate instanceof AST_Unary || candidate instanceof AST_Assign && !candidate.logical && candidate.operator != "="));
    }
    function value_has_side_effects(expr) {
      if (expr instanceof AST_Unary)
        return unary_side_effects.has(expr.operator);
      return get_rvalue(expr).has_side_effects(compressor2);
    }
    function replace_all_symbols() {
      if (side_effects)
        return false;
      if (value_def)
        return true;
      if (lhs instanceof AST_SymbolRef) {
        var def2 = lhs.definition();
        if (def2.references.length - def2.replaced == (candidate instanceof AST_VarDef ? 1 : 2)) {
          return true;
        }
      }
      return false;
    }
    function may_modify(sym) {
      if (!sym.definition)
        return true;
      var def2 = sym.definition();
      if (def2.orig.length == 1 && def2.orig[0] instanceof AST_SymbolDefun)
        return false;
      if (def2.scope.get_defun_scope() !== defun_scope)
        return true;
      return def2.references.some(
        (ref) => ref.scope.get_defun_scope() !== defun_scope
      );
    }
    function side_effects_external(node, lhs2) {
      if (node instanceof AST_Assign)
        return side_effects_external(node.left, true);
      if (node instanceof AST_Unary)
        return side_effects_external(node.expression, true);
      if (node instanceof AST_VarDef)
        return node.value && side_effects_external(node.value);
      if (lhs2) {
        if (node instanceof AST_Dot)
          return side_effects_external(node.expression, true);
        if (node instanceof AST_Sub)
          return side_effects_external(node.expression, true);
        if (node instanceof AST_SymbolRef)
          return node.definition().scope.get_defun_scope() !== defun_scope;
      }
      return false;
    }
    function shadows(my_scope, lvalues2) {
      for (const { def: def2 } of lvalues2.values()) {
        const looked_up = my_scope.find_variable(def2.name);
        if (looked_up) {
          if (looked_up === def2) continue;
          return true;
        }
      }
      return false;
    }
  }
  function eliminate_spurious_blocks(statements2) {
    var seen_dirs = [];
    for (var i = 0; i < statements2.length; ) {
      var stat2 = statements2[i];
      if (stat2 instanceof AST_BlockStatement && stat2.body.every(can_be_evicted_from_block)) {
        CHANGED = true;
        eliminate_spurious_blocks(stat2.body);
        statements2.splice(i, 1, ...stat2.body);
        i += stat2.body.length;
      } else if (stat2 instanceof AST_EmptyStatement) {
        CHANGED = true;
        statements2.splice(i, 1);
      } else if (stat2 instanceof AST_Directive) {
        if (seen_dirs.indexOf(stat2.value) < 0) {
          i++;
          seen_dirs.push(stat2.value);
        } else {
          CHANGED = true;
          statements2.splice(i, 1);
        }
      } else
        i++;
    }
  }
  function handle_if_return(statements2, compressor2) {
    var self2 = compressor2.self();
    var multiple_if_returns = has_multiple_if_returns(statements2);
    var in_lambda = self2 instanceof AST_Lambda;
    const iteration_start = Math.min(statements2.length, 500);
    for (var i = iteration_start; --i >= 0; ) {
      var stat2 = statements2[i];
      var j = next_index(i);
      var next = statements2[j];
      if (in_lambda && !next && stat2 instanceof AST_Return) {
        if (!stat2.value) {
          CHANGED = true;
          statements2.splice(i, 1);
          continue;
        }
        if (stat2.value instanceof AST_UnaryPrefix && stat2.value.operator == "void") {
          CHANGED = true;
          statements2[i] = make_node(AST_SimpleStatement, stat2, {
            body: stat2.value.expression
          });
          continue;
        }
      }
      if (stat2 instanceof AST_If) {
        let ab, new_else;
        ab = aborts(stat2.body);
        if (can_merge_flow(ab) && (new_else = as_statement_array_with_return(stat2.body, ab))) {
          if (ab.label) {
            remove9(ab.label.thedef.references, ab);
          }
          CHANGED = true;
          stat2 = stat2.clone();
          stat2.condition = stat2.condition.negate(compressor2);
          stat2.body = make_node(AST_BlockStatement, stat2, {
            body: as_statement_array(stat2.alternative).concat(extract_functions())
          });
          stat2.alternative = make_node(AST_BlockStatement, stat2, {
            body: new_else
          });
          statements2[i] = stat2.transform(compressor2);
          continue;
        }
        ab = aborts(stat2.alternative);
        if (can_merge_flow(ab) && (new_else = as_statement_array_with_return(stat2.alternative, ab))) {
          if (ab.label) {
            remove9(ab.label.thedef.references, ab);
          }
          CHANGED = true;
          stat2 = stat2.clone();
          stat2.body = make_node(AST_BlockStatement, stat2.body, {
            body: as_statement_array(stat2.body).concat(extract_functions())
          });
          stat2.alternative = make_node(AST_BlockStatement, stat2.alternative, {
            body: new_else
          });
          statements2[i] = stat2.transform(compressor2);
          continue;
        }
      }
      if (stat2 instanceof AST_If && stat2.body instanceof AST_Return) {
        var value = stat2.body.value;
        if (!value && !stat2.alternative && (in_lambda && !next || next instanceof AST_Return && !next.value)) {
          CHANGED = true;
          statements2[i] = make_node(AST_SimpleStatement, stat2.condition, {
            body: stat2.condition
          });
          continue;
        }
        if (value && !stat2.alternative && next instanceof AST_Return && next.value) {
          CHANGED = true;
          stat2 = stat2.clone();
          stat2.alternative = next;
          statements2[i] = stat2.transform(compressor2);
          statements2.splice(j, 1);
          continue;
        }
        if (value && !stat2.alternative && (!next && in_lambda && multiple_if_returns || next instanceof AST_Return)) {
          CHANGED = true;
          stat2 = stat2.clone();
          stat2.alternative = next || make_node(AST_Return, stat2, {
            value: null
          });
          statements2[i] = stat2.transform(compressor2);
          if (next)
            statements2.splice(j, 1);
          continue;
        }
        var prev = statements2[prev_index(i)];
        if (compressor2.option("sequences") && in_lambda && !stat2.alternative && prev instanceof AST_If && prev.body instanceof AST_Return && next_index(j) == statements2.length && next instanceof AST_SimpleStatement) {
          CHANGED = true;
          stat2 = stat2.clone();
          stat2.alternative = make_node(AST_BlockStatement, next, {
            body: [
              next,
              make_node(AST_Return, next, {
                value: null
              })
            ]
          });
          statements2[i] = stat2.transform(compressor2);
          statements2.splice(j, 1);
          continue;
        }
      }
    }
    function has_multiple_if_returns(statements3) {
      var n2 = 0;
      for (var i2 = statements3.length; --i2 >= 0; ) {
        var stat3 = statements3[i2];
        if (stat3 instanceof AST_If && stat3.body instanceof AST_Return) {
          if (++n2 > 1)
            return true;
        }
      }
      return false;
    }
    function is_return_void(value2) {
      return !value2 || value2 instanceof AST_UnaryPrefix && value2.operator == "void";
    }
    function can_merge_flow(ab) {
      if (!ab)
        return false;
      for (var j2 = i + 1, len = statements2.length; j2 < len; j2++) {
        var stat3 = statements2[j2];
        if (stat3 instanceof AST_Const || stat3 instanceof AST_Let)
          return false;
      }
      var lct = ab instanceof AST_LoopControl ? compressor2.loopcontrol_target(ab) : null;
      return ab instanceof AST_Return && in_lambda && is_return_void(ab.value) || ab instanceof AST_Continue && self2 === loop_body(lct) || ab instanceof AST_Break && lct instanceof AST_BlockStatement && self2 === lct;
    }
    function extract_functions() {
      var tail = statements2.slice(i + 1);
      statements2.length = i + 1;
      return tail.filter(function(stat3) {
        if (stat3 instanceof AST_Defun) {
          statements2.push(stat3);
          return false;
        }
        return true;
      });
    }
    function as_statement_array_with_return(node, ab) {
      var body = as_statement_array(node);
      if (ab !== body[body.length - 1]) {
        return void 0;
      }
      body = body.slice(0, -1);
      if (ab.value) {
        body.push(make_node(AST_SimpleStatement, ab.value, {
          body: ab.value.expression
        }));
      }
      return body;
    }
    function next_index(i2) {
      for (var j2 = i2 + 1, len = statements2.length; j2 < len; j2++) {
        var stat3 = statements2[j2];
        if (!(stat3 instanceof AST_Var && declarations_only(stat3))) {
          break;
        }
      }
      return j2;
    }
    function prev_index(i2) {
      for (var j2 = i2; --j2 >= 0; ) {
        var stat3 = statements2[j2];
        if (!(stat3 instanceof AST_Var && declarations_only(stat3))) {
          break;
        }
      }
      return j2;
    }
  }
  function eliminate_dead_code(statements2, compressor2) {
    var has_quit;
    var self2 = compressor2.self();
    for (var i = 0, n2 = 0, len = statements2.length; i < len; i++) {
      var stat2 = statements2[i];
      if (stat2 instanceof AST_LoopControl) {
        var lct = compressor2.loopcontrol_target(stat2);
        if (stat2 instanceof AST_Break && !(lct instanceof AST_IterationStatement) && loop_body(lct) === self2 || stat2 instanceof AST_Continue && loop_body(lct) === self2) {
          if (stat2.label) {
            remove9(stat2.label.thedef.references, stat2);
          }
        } else {
          statements2[n2++] = stat2;
        }
      } else {
        statements2[n2++] = stat2;
      }
      if (aborts(stat2)) {
        has_quit = statements2.slice(i + 1);
        break;
      }
    }
    statements2.length = n2;
    CHANGED = n2 != len;
    if (has_quit)
      has_quit.forEach(function(stat3) {
        trim_unreachable_code(compressor2, stat3, statements2);
      });
  }
  function declarations_only(node) {
    return node.definitions.every((var_def) => !var_def.value);
  }
  function sequencesize(statements2, compressor2) {
    if (statements2.length < 2)
      return;
    var seq2 = [], n2 = 0;
    function push_seq() {
      if (!seq2.length)
        return;
      var body2 = make_sequence(seq2[0], seq2);
      statements2[n2++] = make_node(AST_SimpleStatement, body2, { body: body2 });
      seq2 = [];
    }
    for (var i = 0, len = statements2.length; i < len; i++) {
      var stat2 = statements2[i];
      if (stat2 instanceof AST_SimpleStatement) {
        if (seq2.length >= compressor2.sequences_limit)
          push_seq();
        var body = stat2.body;
        if (seq2.length > 0)
          body = body.drop_side_effect_free(compressor2);
        if (body)
          merge_sequence(seq2, body);
      } else if (stat2 instanceof AST_Definitions && declarations_only(stat2) || stat2 instanceof AST_Defun) {
        statements2[n2++] = stat2;
      } else {
        push_seq();
        statements2[n2++] = stat2;
      }
    }
    push_seq();
    statements2.length = n2;
    if (n2 != len)
      CHANGED = true;
  }
  function to_simple_statement(block, decls) {
    if (!(block instanceof AST_BlockStatement))
      return block;
    var stat2 = null;
    for (var i = 0, len = block.body.length; i < len; i++) {
      var line = block.body[i];
      if (line instanceof AST_Var && declarations_only(line)) {
        decls.push(line);
      } else if (stat2 || line instanceof AST_Const || line instanceof AST_Let) {
        return false;
      } else {
        stat2 = line;
      }
    }
    return stat2;
  }
  function sequencesize_2(statements2, compressor2) {
    function cons_seq(right3) {
      n2--;
      CHANGED = true;
      var left3 = prev.body;
      return make_sequence(left3, [left3, right3]).transform(compressor2);
    }
    var n2 = 0, prev;
    for (var i = 0; i < statements2.length; i++) {
      var stat2 = statements2[i];
      if (prev) {
        if (stat2 instanceof AST_Exit) {
          stat2.value = cons_seq(stat2.value || make_node(AST_Undefined, stat2).transform(compressor2));
        } else if (stat2 instanceof AST_For) {
          if (!(stat2.init instanceof AST_Definitions)) {
            const abort = walk2(prev.body, (node) => {
              if (node instanceof AST_Scope)
                return true;
              if (node instanceof AST_Binary && node.operator === "in") {
                return walk_abort;
              }
            });
            if (!abort) {
              if (stat2.init)
                stat2.init = cons_seq(stat2.init);
              else {
                stat2.init = prev.body;
                n2--;
                CHANGED = true;
              }
            }
          }
        } else if (stat2 instanceof AST_ForIn) {
          if (!(stat2.init instanceof AST_Const) && !(stat2.init instanceof AST_Let)) {
            stat2.object = cons_seq(stat2.object);
          }
        } else if (stat2 instanceof AST_If) {
          stat2.condition = cons_seq(stat2.condition);
        } else if (stat2 instanceof AST_Switch) {
          stat2.expression = cons_seq(stat2.expression);
        } else if (stat2 instanceof AST_With) {
          stat2.expression = cons_seq(stat2.expression);
        }
      }
      if (compressor2.option("conditionals") && stat2 instanceof AST_If) {
        var decls = [];
        var body = to_simple_statement(stat2.body, decls);
        var alt = to_simple_statement(stat2.alternative, decls);
        if (body !== false && alt !== false && decls.length > 0) {
          var len = decls.length;
          decls.push(make_node(AST_If, stat2, {
            condition: stat2.condition,
            body: body || make_node(AST_EmptyStatement, stat2.body),
            alternative: alt
          }));
          decls.unshift(n2, 1);
          [].splice.apply(statements2, decls);
          i += len;
          n2 += len + 1;
          prev = null;
          CHANGED = true;
          continue;
        }
      }
      statements2[n2++] = stat2;
      prev = stat2 instanceof AST_SimpleStatement ? stat2 : null;
    }
    statements2.length = n2;
  }
  function join_object_assignments(defn, body) {
    if (!(defn instanceof AST_Definitions))
      return;
    var def = defn.definitions[defn.definitions.length - 1];
    if (!(def.value instanceof AST_Object))
      return;
    var exprs;
    if (body instanceof AST_Assign && !body.logical) {
      exprs = [body];
    } else if (body instanceof AST_Sequence) {
      exprs = body.expressions.slice();
    }
    if (!exprs)
      return;
    var trimmed2 = false;
    do {
      var node = exprs[0];
      if (!(node instanceof AST_Assign))
        break;
      if (node.operator != "=")
        break;
      if (!(node.left instanceof AST_PropAccess))
        break;
      var sym = node.left.expression;
      if (!(sym instanceof AST_SymbolRef))
        break;
      if (def.name.name != sym.name)
        break;
      if (!node.right.is_constant_expression(nearest_scope))
        break;
      var prop = node.left.property;
      if (prop instanceof AST_Node) {
        prop = prop.evaluate(compressor);
      }
      if (prop instanceof AST_Node)
        break;
      prop = "" + prop;
      var diff8 = compressor.option("ecma") < 2015 && compressor.has_directive("use strict") ? function(node2) {
        return node2.key != prop && (node2.key && node2.key.name != prop);
      } : function(node2) {
        return node2.key && node2.key.name != prop;
      };
      if (!def.value.properties.every(diff8))
        break;
      var p3 = def.value.properties.filter(function(p4) {
        return p4.key === prop;
      })[0];
      if (!p3) {
        def.value.properties.push(make_node(AST_ObjectKeyVal, node, {
          key: prop,
          value: node.right
        }));
      } else {
        p3.value = new AST_Sequence({
          start: p3.start,
          expressions: [p3.value.clone(), node.right.clone()],
          end: p3.end
        });
      }
      exprs.shift();
      trimmed2 = true;
    } while (exprs.length);
    return trimmed2 && exprs;
  }
  function join_consecutive_vars(statements2) {
    var defs;
    for (var i = 0, j = -1, len = statements2.length; i < len; i++) {
      var stat2 = statements2[i];
      var prev = statements2[j];
      if (stat2 instanceof AST_Definitions) {
        if (prev && prev.TYPE == stat2.TYPE) {
          prev.definitions = prev.definitions.concat(stat2.definitions);
          CHANGED = true;
        } else if (defs && defs.TYPE == stat2.TYPE && declarations_only(stat2)) {
          defs.definitions = defs.definitions.concat(stat2.definitions);
          CHANGED = true;
        } else {
          statements2[++j] = stat2;
          defs = stat2;
        }
      } else if (stat2 instanceof AST_Exit) {
        stat2.value = extract_object_assignments(stat2.value);
      } else if (stat2 instanceof AST_For) {
        var exprs = join_object_assignments(prev, stat2.init);
        if (exprs) {
          CHANGED = true;
          stat2.init = exprs.length ? make_sequence(stat2.init, exprs) : null;
          statements2[++j] = stat2;
        } else if (prev instanceof AST_Var && (!stat2.init || stat2.init.TYPE == prev.TYPE)) {
          if (stat2.init) {
            prev.definitions = prev.definitions.concat(stat2.init.definitions);
          }
          stat2.init = prev;
          statements2[j] = stat2;
          CHANGED = true;
        } else if (defs instanceof AST_Var && stat2.init instanceof AST_Var && declarations_only(stat2.init)) {
          defs.definitions = defs.definitions.concat(stat2.init.definitions);
          stat2.init = null;
          statements2[++j] = stat2;
          CHANGED = true;
        } else {
          statements2[++j] = stat2;
        }
      } else if (stat2 instanceof AST_ForIn) {
        stat2.object = extract_object_assignments(stat2.object);
      } else if (stat2 instanceof AST_If) {
        stat2.condition = extract_object_assignments(stat2.condition);
      } else if (stat2 instanceof AST_SimpleStatement) {
        var exprs = join_object_assignments(prev, stat2.body);
        if (exprs) {
          CHANGED = true;
          if (!exprs.length)
            continue;
          stat2.body = make_sequence(stat2.body, exprs);
        }
        statements2[++j] = stat2;
      } else if (stat2 instanceof AST_Switch) {
        stat2.expression = extract_object_assignments(stat2.expression);
      } else if (stat2 instanceof AST_With) {
        stat2.expression = extract_object_assignments(stat2.expression);
      } else {
        statements2[++j] = stat2;
      }
    }
    statements2.length = j + 1;
    function extract_object_assignments(value) {
      statements2[++j] = stat2;
      var exprs2 = join_object_assignments(prev, value);
      if (exprs2) {
        CHANGED = true;
        if (exprs2.length) {
          return make_sequence(value, exprs2);
        } else if (value instanceof AST_Sequence) {
          return value.tail_node().left;
        } else {
          return value.left;
        }
      }
      return value;
    }
  }
}

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/compress/inline.js
function within_array_or_object_literal(compressor) {
  var node, level = 0;
  while (node = compressor.parent(level++)) {
    if (node instanceof AST_Statement) return false;
    if (node instanceof AST_Array || node instanceof AST_ObjectKeyVal || node instanceof AST_Object) {
      return true;
    }
  }
  return false;
}
function scope_encloses_variables_in_this_scope(scope5, pulled_scope) {
  for (const enclosed of pulled_scope.enclosed) {
    if (pulled_scope.variables.has(enclosed.name)) {
      continue;
    }
    const looked_up = scope5.find_variable(enclosed.name);
    if (looked_up) {
      if (looked_up === enclosed) continue;
      return true;
    }
  }
  return false;
}
function is_const_symbol_short_than_init_value(def, fixed_value) {
  if (def.orig.length === 1 && fixed_value) {
    const init_value_length = fixed_value.size();
    const identifer_length = def.name.length;
    return init_value_length > identifer_length;
  }
  return true;
}
function inline_into_symbolref(self2, compressor) {
  if (compressor.in_computed_key()) return self2;
  const parent = compressor.parent();
  const def = self2.definition();
  const nearest_scope = compressor.find_scope();
  let fixed2 = self2.fixed_value();
  if (compressor.top_retain && def.global && compressor.top_retain(def) && // when identifier is in top_retain option dose not mean we can always inline it.
  // if identifier name is longer then init value, we can replace it.
  is_const_symbol_short_than_init_value(def, fixed2)) {
    def.fixed = false;
    def.single_use = false;
    return self2;
  }
  let single_use = def.single_use && !(parent instanceof AST_Call && parent.is_callee_pure(compressor) || has_annotation(parent, _NOINLINE)) && !(parent instanceof AST_Export && fixed2 instanceof AST_Lambda && fixed2.name);
  if (single_use && fixed2 instanceof AST_Node) {
    single_use = !fixed2.has_side_effects(compressor) && !fixed2.may_throw(compressor);
  }
  if (fixed2 instanceof AST_Class && def.scope !== self2.scope) {
    return self2;
  }
  if (single_use && (fixed2 instanceof AST_Lambda || fixed2 instanceof AST_Class)) {
    if (retain_top_func(fixed2, compressor)) {
      single_use = false;
    } else if (def.scope !== self2.scope && (def.escaped == 1 || has_flag(fixed2, INLINED) || within_array_or_object_literal(compressor) || !compressor.option("reduce_funcs"))) {
      single_use = false;
    } else if (is_recursive_ref(compressor, def)) {
      single_use = false;
    } else if (def.scope !== self2.scope || def.orig[0] instanceof AST_SymbolFunarg) {
      single_use = fixed2.is_constant_expression(self2.scope);
      if (single_use == "f") {
        var scope5 = self2.scope;
        do {
          if (scope5 instanceof AST_Defun || is_func_expr(scope5)) {
            set_flag(scope5, INLINED);
          }
        } while (scope5 = scope5.parent_scope);
      }
    }
  }
  if (single_use && (fixed2 instanceof AST_Lambda || fixed2 instanceof AST_Class)) {
    single_use = def.scope === self2.scope && !scope_encloses_variables_in_this_scope(nearest_scope, fixed2) || parent instanceof AST_Call && parent.expression === self2 && !scope_encloses_variables_in_this_scope(nearest_scope, fixed2) && !(fixed2.name && fixed2.name.definition().recursive_refs > 0);
  }
  if (single_use && fixed2) {
    if (fixed2 instanceof AST_DefClass) {
      set_flag(fixed2, SQUEEZED);
      fixed2 = make_node(AST_ClassExpression, fixed2, fixed2);
    }
    if (fixed2 instanceof AST_Defun) {
      set_flag(fixed2, SQUEEZED);
      fixed2 = make_node(AST_Function, fixed2, fixed2);
    }
    if (def.recursive_refs > 0 && fixed2.name instanceof AST_SymbolDefun) {
      const defun_def = fixed2.name.definition();
      let lambda_def = fixed2.variables.get(fixed2.name.name);
      let name = lambda_def && lambda_def.orig[0];
      if (!(name instanceof AST_SymbolLambda)) {
        name = make_node(AST_SymbolLambda, fixed2.name, fixed2.name);
        name.scope = fixed2;
        fixed2.name = name;
        lambda_def = fixed2.def_function(name);
      }
      walk2(fixed2, (node) => {
        if (node instanceof AST_SymbolRef && node.definition() === defun_def) {
          node.thedef = lambda_def;
          lambda_def.references.push(node);
        }
      });
    }
    if ((fixed2 instanceof AST_Lambda || fixed2 instanceof AST_Class) && fixed2.parent_scope !== nearest_scope) {
      fixed2 = fixed2.clone(true, compressor.get_toplevel());
      nearest_scope.add_child_scope(fixed2);
    }
    return fixed2.optimize(compressor);
  }
  if (fixed2) {
    let replace2;
    if (fixed2 instanceof AST_This) {
      if (!(def.orig[0] instanceof AST_SymbolFunarg) && def.references.every(
        (ref) => def.scope === ref.scope
      )) {
        replace2 = fixed2;
      }
    } else {
      var ev = fixed2.evaluate(compressor);
      if (ev !== fixed2 && (compressor.option("unsafe_regexp") || !(ev instanceof RegExp))) {
        replace2 = make_node_from_constant(ev, fixed2);
      }
    }
    if (replace2) {
      const name_length = self2.size(compressor);
      const replace_size = replace2.size(compressor);
      let overhead = 0;
      if (compressor.option("unused") && !compressor.exposed(def)) {
        overhead = (name_length + 2 + fixed2.size(compressor)) / (def.references.length - def.assignments);
      }
      if (replace_size <= name_length + overhead) {
        return replace2;
      }
    }
  }
  return self2;
}
function inline_into_call(self2, compressor) {
  if (compressor.in_computed_key()) return self2;
  var exp = self2.expression;
  var fn2 = exp;
  var simple_args = self2.args.every((arg) => !(arg instanceof AST_Expansion));
  if (compressor.option("reduce_vars") && fn2 instanceof AST_SymbolRef && !has_annotation(self2, _NOINLINE)) {
    const fixed2 = fn2.fixed_value();
    if (retain_top_func(fixed2, compressor) || !compressor.toplevel.funcs && exp.definition().global) {
      return self2;
    }
    fn2 = fixed2;
  }
  var is_func = fn2 instanceof AST_Lambda;
  var stat2 = is_func && fn2.body[0];
  var is_regular_func = is_func && !fn2.is_generator && !fn2.async;
  var can_inline = is_regular_func && compressor.option("inline") && !self2.is_callee_pure(compressor);
  if (can_inline && stat2 instanceof AST_Return) {
    let returned = stat2.value;
    if (!returned || returned.is_constant_expression()) {
      if (returned) {
        returned = returned.clone(true);
      } else {
        returned = make_node(AST_Undefined, self2);
      }
      const args3 = self2.args.concat(returned);
      return make_sequence(self2, args3).optimize(compressor);
    }
    if (fn2.argnames.length === 1 && fn2.argnames[0] instanceof AST_SymbolFunarg && self2.args.length < 2 && !(self2.args[0] instanceof AST_Expansion) && returned instanceof AST_SymbolRef && returned.name === fn2.argnames[0].name) {
      const replacement = (self2.args[0] || make_node(AST_Undefined)).optimize(compressor);
      let parent;
      if (replacement instanceof AST_PropAccess && (parent = compressor.parent()) instanceof AST_Call && parent.expression === self2) {
        return make_sequence(self2, [
          make_node(AST_Number, self2, { value: 0 }),
          replacement
        ]);
      }
      return replacement;
    }
  }
  if (can_inline) {
    var scope5, in_loop, level = -1;
    let def;
    let returned_value;
    let nearest_scope;
    if (simple_args && !fn2.uses_arguments && !(compressor.parent() instanceof AST_Class) && !(fn2.name && fn2 instanceof AST_Function) && (returned_value = can_flatten_body(stat2)) && (exp === fn2 || has_annotation(self2, _INLINE) || compressor.option("unused") && (def = exp.definition()).references.length == 1 && !is_recursive_ref(compressor, def) && fn2.is_constant_expression(exp.scope)) && !has_annotation(self2, _PURE | _NOINLINE) && !fn2.contains_this() && can_inject_symbols() && (nearest_scope = compressor.find_scope()) && !scope_encloses_variables_in_this_scope(nearest_scope, fn2) && !function in_default_assign() {
      let i = 0;
      let p3;
      while (p3 = compressor.parent(i++)) {
        if (p3 instanceof AST_DefaultAssign) return true;
        if (p3 instanceof AST_Block) break;
      }
      return false;
    }() && !(scope5 instanceof AST_Class)) {
      set_flag(fn2, SQUEEZED);
      nearest_scope.add_child_scope(fn2);
      return make_sequence(self2, flatten_fn(returned_value)).optimize(compressor);
    }
  }
  if (can_inline && has_annotation(self2, _INLINE)) {
    set_flag(fn2, SQUEEZED);
    fn2 = make_node(fn2.CTOR === AST_Defun ? AST_Function : fn2.CTOR, fn2, fn2);
    fn2 = fn2.clone(true);
    fn2.figure_out_scope({}, {
      parent_scope: compressor.find_scope(),
      toplevel: compressor.get_toplevel()
    });
    return make_node(AST_Call, self2, {
      expression: fn2,
      args: self2.args
    }).optimize(compressor);
  }
  const can_drop_this_call = is_regular_func && compressor.option("side_effects") && fn2.body.every(is_empty);
  if (can_drop_this_call) {
    var args2 = self2.args.concat(make_node(AST_Undefined, self2));
    return make_sequence(self2, args2).optimize(compressor);
  }
  if (compressor.option("negate_iife") && compressor.parent() instanceof AST_SimpleStatement && is_iife_call(self2)) {
    return self2.negate(compressor, true);
  }
  var ev = self2.evaluate(compressor);
  if (ev !== self2) {
    ev = make_node_from_constant(ev, self2).optimize(compressor);
    return best_of(compressor, ev, self2);
  }
  return self2;
  function return_value(stat3) {
    if (!stat3) return make_node(AST_Undefined, self2);
    if (stat3 instanceof AST_Return) {
      if (!stat3.value) return make_node(AST_Undefined, self2);
      return stat3.value.clone(true);
    }
    if (stat3 instanceof AST_SimpleStatement) {
      return make_node(AST_UnaryPrefix, stat3, {
        operator: "void",
        expression: stat3.body.clone(true)
      });
    }
  }
  function can_flatten_body(stat3) {
    var body = fn2.body;
    var len = body.length;
    if (compressor.option("inline") < 3) {
      return len == 1 && return_value(stat3);
    }
    stat3 = null;
    for (var i = 0; i < len; i++) {
      var line = body[i];
      if (line instanceof AST_Var) {
        if (stat3 && !line.definitions.every(
          (var_def) => !var_def.value
        )) {
          return false;
        }
      } else if (stat3) {
        return false;
      } else if (!(line instanceof AST_EmptyStatement)) {
        stat3 = line;
      }
    }
    return return_value(stat3);
  }
  function can_inject_args(block_scoped, safe_to_inject) {
    for (var i = 0, len = fn2.argnames.length; i < len; i++) {
      var arg = fn2.argnames[i];
      if (arg instanceof AST_DefaultAssign) {
        if (has_flag(arg.left, UNUSED)) continue;
        return false;
      }
      if (arg instanceof AST_Destructuring) return false;
      if (arg instanceof AST_Expansion) {
        if (has_flag(arg.expression, UNUSED)) continue;
        return false;
      }
      if (has_flag(arg, UNUSED)) continue;
      if (!safe_to_inject || block_scoped.has(arg.name) || identifier_atom.has(arg.name) || scope5.conflicting_def(arg.name)) {
        return false;
      }
      if (in_loop) in_loop.push(arg.definition());
    }
    return true;
  }
  function can_inject_vars(block_scoped, safe_to_inject) {
    var len = fn2.body.length;
    for (var i = 0; i < len; i++) {
      var stat3 = fn2.body[i];
      if (!(stat3 instanceof AST_Var)) continue;
      if (!safe_to_inject) return false;
      for (var j = stat3.definitions.length; --j >= 0; ) {
        var name = stat3.definitions[j].name;
        if (name instanceof AST_Destructuring || block_scoped.has(name.name) || identifier_atom.has(name.name) || scope5.conflicting_def(name.name)) {
          return false;
        }
        if (in_loop) in_loop.push(name.definition());
      }
    }
    return true;
  }
  function can_inject_symbols() {
    var block_scoped = /* @__PURE__ */ new Set();
    do {
      scope5 = compressor.parent(++level);
      if (scope5.is_block_scope() && scope5.block_scope) {
        scope5.block_scope.variables.forEach(function(variable) {
          block_scoped.add(variable.name);
        });
      }
      if (scope5 instanceof AST_Catch) {
        if (scope5.argname) {
          block_scoped.add(scope5.argname.name);
        }
      } else if (scope5 instanceof AST_IterationStatement) {
        in_loop = [];
      } else if (scope5 instanceof AST_SymbolRef) {
        if (scope5.fixed_value() instanceof AST_Scope) return false;
      }
    } while (!(scope5 instanceof AST_Scope));
    var safe_to_inject = !(scope5 instanceof AST_Toplevel) || compressor.toplevel.vars;
    var inline = compressor.option("inline");
    if (!can_inject_vars(block_scoped, inline >= 3 && safe_to_inject)) return false;
    if (!can_inject_args(block_scoped, inline >= 2 && safe_to_inject)) return false;
    return !in_loop || in_loop.length == 0 || !is_reachable(fn2, in_loop);
  }
  function append_var(decls, expressions, name, value) {
    var def = name.definition();
    const already_appended = scope5.variables.has(name.name);
    if (!already_appended) {
      scope5.variables.set(name.name, def);
      scope5.enclosed.push(def);
      decls.push(make_node(AST_VarDef, name, {
        name,
        value: null
      }));
    }
    var sym = make_node(AST_SymbolRef, name, name);
    def.references.push(sym);
    if (value) expressions.push(make_node(AST_Assign, self2, {
      operator: "=",
      logical: false,
      left: sym,
      right: value.clone()
    }));
  }
  function flatten_args(decls, expressions) {
    var len = fn2.argnames.length;
    for (var i = self2.args.length; --i >= len; ) {
      expressions.push(self2.args[i]);
    }
    for (i = len; --i >= 0; ) {
      var name = fn2.argnames[i];
      var value = self2.args[i];
      if (has_flag(name, UNUSED) || !name.name || scope5.conflicting_def(name.name)) {
        if (value) expressions.push(value);
      } else {
        var symbol3 = make_node(AST_SymbolVar, name, name);
        name.definition().orig.push(symbol3);
        if (!value && in_loop) value = make_node(AST_Undefined, self2);
        append_var(decls, expressions, symbol3, value);
      }
    }
    decls.reverse();
    expressions.reverse();
  }
  function flatten_vars(decls, expressions) {
    var pos = expressions.length;
    for (var i = 0, lines = fn2.body.length; i < lines; i++) {
      var stat3 = fn2.body[i];
      if (!(stat3 instanceof AST_Var)) continue;
      for (var j = 0, defs = stat3.definitions.length; j < defs; j++) {
        var var_def = stat3.definitions[j];
        var name = var_def.name;
        append_var(decls, expressions, name, var_def.value);
        if (in_loop && fn2.argnames.every(
          (argname) => argname.name != name.name
        )) {
          var def = fn2.variables.get(name.name);
          var sym = make_node(AST_SymbolRef, name, name);
          def.references.push(sym);
          expressions.splice(pos++, 0, make_node(AST_Assign, var_def, {
            operator: "=",
            logical: false,
            left: sym,
            right: make_node(AST_Undefined, name)
          }));
        }
      }
    }
  }
  function flatten_fn(returned_value) {
    var decls = [];
    var expressions = [];
    flatten_args(decls, expressions);
    flatten_vars(decls, expressions);
    expressions.push(returned_value);
    if (decls.length) {
      const i = scope5.body.indexOf(compressor.parent(level - 1)) + 1;
      scope5.body.splice(i, 0, make_node(AST_Var, fn2, {
        definitions: decls
      }));
    }
    return expressions.map((exp2) => exp2.clone(true));
  }
}

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/compress/global-defs.js
(function(def_find_defs) {
  function to_node(value, orig) {
    if (value instanceof AST_Node) {
      if (!(value instanceof AST_Constant)) {
        value = value.clone(true);
      }
      return make_node(value.CTOR, orig, value);
    }
    if (Array.isArray(value)) return make_node(AST_Array, orig, {
      elements: value.map(function(value2) {
        return to_node(value2, orig);
      })
    });
    if (value && typeof value == "object") {
      var props = [];
      for (var key in value) if (HOP(value, key)) {
        props.push(make_node(AST_ObjectKeyVal, orig, {
          key,
          value: to_node(value[key], orig)
        }));
      }
      return make_node(AST_Object, orig, {
        properties: props
      });
    }
    return make_node_from_constant(value, orig);
  }
  AST_Toplevel.DEFMETHOD("resolve_defines", function(compressor) {
    if (!compressor.option("global_defs")) return this;
    this.figure_out_scope({ ie8: compressor.option("ie8") });
    return this.transform(new TreeTransformer(function(node) {
      var def = node._find_defs(compressor, "");
      if (!def) return;
      var level = 0, child = node, parent;
      while (parent = this.parent(level++)) {
        if (!(parent instanceof AST_PropAccess)) break;
        if (parent.expression !== child) break;
        child = parent;
      }
      if (is_lhs(child, parent)) {
        return;
      }
      return def;
    }));
  });
  def_find_defs(AST_Node, noop);
  def_find_defs(AST_Chain, function(compressor, suffix) {
    return this.expression._find_defs(compressor, suffix);
  });
  def_find_defs(AST_Dot, function(compressor, suffix) {
    return this.expression._find_defs(compressor, "." + this.property + suffix);
  });
  def_find_defs(AST_SymbolDeclaration, function() {
    if (!this.global()) return;
  });
  def_find_defs(AST_SymbolRef, function(compressor, suffix) {
    if (!this.global()) return;
    var defines = compressor.option("global_defs");
    var name = this.name + suffix;
    if (HOP(defines, name)) return to_node(defines[name], this);
  });
  def_find_defs(AST_ImportMeta, function(compressor, suffix) {
    var defines = compressor.option("global_defs");
    var name = "import.meta" + suffix;
    if (HOP(defines, name)) return to_node(defines[name], this);
  });
})(function(node, func) {
  node.DEFMETHOD("_find_defs", func);
});

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/compress/index.js
var Compressor = class extends TreeWalker {
  constructor(options, { false_by_default = false, mangle_options: mangle_options2 = false }) {
    super();
    if (options.defaults !== void 0 && !options.defaults) false_by_default = true;
    this.options = defaults2(options, {
      arguments: false,
      arrows: !false_by_default,
      booleans: !false_by_default,
      booleans_as_integers: false,
      collapse_vars: !false_by_default,
      comparisons: !false_by_default,
      computed_props: !false_by_default,
      conditionals: !false_by_default,
      dead_code: !false_by_default,
      defaults: true,
      directives: !false_by_default,
      drop_console: false,
      drop_debugger: !false_by_default,
      ecma: 5,
      evaluate: !false_by_default,
      expression: false,
      global_defs: false,
      hoist_funs: false,
      hoist_props: !false_by_default,
      hoist_vars: false,
      ie8: false,
      if_return: !false_by_default,
      inline: !false_by_default,
      join_vars: !false_by_default,
      keep_classnames: false,
      keep_fargs: true,
      keep_fnames: false,
      keep_infinity: false,
      lhs_constants: !false_by_default,
      loops: !false_by_default,
      module: false,
      negate_iife: !false_by_default,
      passes: 1,
      properties: !false_by_default,
      pure_getters: !false_by_default && "strict",
      pure_funcs: null,
      pure_new: false,
      reduce_funcs: !false_by_default,
      reduce_vars: !false_by_default,
      sequences: !false_by_default,
      side_effects: !false_by_default,
      switches: !false_by_default,
      top_retain: null,
      toplevel: !!(options && options["top_retain"]),
      typeofs: !false_by_default,
      unsafe: false,
      unsafe_arrows: false,
      unsafe_comps: false,
      unsafe_Function: false,
      unsafe_math: false,
      unsafe_symbols: false,
      unsafe_methods: false,
      unsafe_proto: false,
      unsafe_regexp: false,
      unsafe_undefined: false,
      unused: !false_by_default,
      warnings: false
      // legacy
    }, true);
    var global_defs = this.options["global_defs"];
    if (typeof global_defs == "object") for (var key in global_defs) {
      if (key[0] === "@" && HOP(global_defs, key)) {
        global_defs[key.slice(1)] = parse(global_defs[key], {
          expression: true
        });
      }
    }
    if (this.options["inline"] === true) this.options["inline"] = 3;
    var pure_funcs = this.options["pure_funcs"];
    if (typeof pure_funcs == "function") {
      this.pure_funcs = pure_funcs;
    } else {
      this.pure_funcs = pure_funcs ? function(node) {
        return !pure_funcs.includes(node.expression.print_to_string());
      } : return_true;
    }
    var top_retain = this.options["top_retain"];
    if (top_retain instanceof RegExp) {
      this.top_retain = function(def) {
        return top_retain.test(def.name);
      };
    } else if (typeof top_retain == "function") {
      this.top_retain = top_retain;
    } else if (top_retain) {
      if (typeof top_retain == "string") {
        top_retain = top_retain.split(/,/);
      }
      this.top_retain = function(def) {
        return top_retain.includes(def.name);
      };
    }
    if (this.options["module"]) {
      this.directives["use strict"] = true;
      this.options["toplevel"] = true;
    }
    var toplevel = this.options["toplevel"];
    this.toplevel = typeof toplevel == "string" ? {
      funcs: /funcs/.test(toplevel),
      vars: /vars/.test(toplevel)
    } : {
      funcs: toplevel,
      vars: toplevel
    };
    var sequences = this.options["sequences"];
    this.sequences_limit = sequences == 1 ? 800 : sequences | 0;
    this.evaluated_regexps = /* @__PURE__ */ new Map();
    this._toplevel = void 0;
    this._mangle_options = mangle_options2 ? format_mangler_options(mangle_options2) : mangle_options2;
  }
  mangle_options() {
    var nth_identifier = this._mangle_options && this._mangle_options.nth_identifier || base54;
    var module = this._mangle_options && this._mangle_options.module || this.option("module");
    return { ie8: this.option("ie8"), nth_identifier, module };
  }
  option(key) {
    return this.options[key];
  }
  exposed(def) {
    if (def.export) return true;
    if (def.global) {
      for (var i = 0, len = def.orig.length; i < len; i++)
        if (!this.toplevel[def.orig[i] instanceof AST_SymbolDefun ? "funcs" : "vars"])
          return true;
    }
    return false;
  }
  in_boolean_context() {
    if (!this.option("booleans")) return false;
    var self2 = this.self();
    for (var i = 0, p3; p3 = this.parent(i); i++) {
      if (p3 instanceof AST_SimpleStatement || p3 instanceof AST_Conditional && p3.condition === self2 || p3 instanceof AST_DWLoop && p3.condition === self2 || p3 instanceof AST_For && p3.condition === self2 || p3 instanceof AST_If && p3.condition === self2 || p3 instanceof AST_UnaryPrefix && p3.operator == "!" && p3.expression === self2) {
        return true;
      }
      if (p3 instanceof AST_Binary && (p3.operator == "&&" || p3.operator == "||" || p3.operator == "??") || p3 instanceof AST_Conditional || p3.tail_node() === self2) {
        self2 = p3;
      } else {
        return false;
      }
    }
  }
  in_32_bit_context() {
    if (!this.option("evaluate")) return false;
    var self2 = this.self();
    for (var i = 0, p3; p3 = this.parent(i); i++) {
      if (p3 instanceof AST_Binary && bitwise_binop.has(p3.operator)) {
        return true;
      }
      if (p3 instanceof AST_UnaryPrefix) {
        return p3.operator === "~";
      }
      if (p3 instanceof AST_Binary && (p3.operator == "&&" || p3.operator == "||" || p3.operator == "??") || p3 instanceof AST_Conditional && p3.condition !== self2 || p3.tail_node() === self2) {
        self2 = p3;
      } else {
        return false;
      }
    }
  }
  in_computed_key() {
    if (!this.option("evaluate")) return false;
    var self2 = this.self();
    for (var i = 0, p3; p3 = this.parent(i); i++) {
      if (p3 instanceof AST_ObjectProperty && p3.key === self2) {
        return true;
      }
    }
    return false;
  }
  get_toplevel() {
    return this._toplevel;
  }
  compress(toplevel) {
    toplevel = toplevel.resolve_defines(this);
    this._toplevel = toplevel;
    if (this.option("expression")) {
      this._toplevel.process_expression(true);
    }
    var passes = +this.options.passes || 1;
    var min_count = 1 / 0;
    var stopping = false;
    var mangle = this.mangle_options();
    for (var pass = 0; pass < passes; pass++) {
      this._toplevel.figure_out_scope(mangle);
      if (pass === 0 && this.option("drop_console")) {
        this._toplevel = this._toplevel.drop_console(this.option("drop_console"));
      }
      if (pass > 0 || this.option("reduce_vars")) {
        this._toplevel.reset_opt_flags(this);
      }
      this._toplevel = this._toplevel.transform(this);
      if (passes > 1) {
        let count5 = 0;
        walk2(this._toplevel, () => {
          count5++;
        });
        if (count5 < min_count) {
          min_count = count5;
          stopping = false;
        } else if (stopping) {
          break;
        } else {
          stopping = true;
        }
      }
    }
    if (this.option("expression")) {
      this._toplevel.process_expression(false);
    }
    toplevel = this._toplevel;
    this._toplevel = void 0;
    return toplevel;
  }
  before(node, descend) {
    if (has_flag(node, SQUEEZED)) return node;
    var was_scope = false;
    if (node instanceof AST_Scope) {
      node = node.hoist_properties(this);
      node = node.hoist_declarations(this);
      was_scope = true;
    }
    descend(node, this);
    descend(node, this);
    var opt = node.optimize(this);
    if (was_scope && opt instanceof AST_Scope) {
      opt.drop_unused(this);
      descend(opt, this);
    }
    if (opt === node) set_flag(opt, SQUEEZED);
    return opt;
  }
  /** Alternative to plain is_lhs() which doesn't work within .optimize() */
  is_lhs() {
    const self2 = this.stack[this.stack.length - 1];
    const parent = this.stack[this.stack.length - 2];
    return is_lhs(self2, parent);
  }
};
function def_optimize(node, optimizer) {
  node.DEFMETHOD("optimize", function(compressor) {
    var self2 = this;
    if (has_flag(self2, OPTIMIZED)) return self2;
    if (compressor.has_directive("use asm")) return self2;
    var opt = optimizer(self2, compressor);
    set_flag(opt, OPTIMIZED);
    return opt;
  });
}
def_optimize(AST_Node, function(self2) {
  return self2;
});
AST_Toplevel.DEFMETHOD("drop_console", function(options) {
  const isArray4 = Array.isArray(options);
  const tt = new TreeTransformer(function(self2) {
    if (self2.TYPE !== "Call") {
      return;
    }
    var exp = self2.expression;
    if (!(exp instanceof AST_PropAccess)) {
      return;
    }
    var name = exp.expression;
    var property3 = exp.property;
    var depth = 2;
    while (name.expression) {
      property3 = name.property;
      name = name.expression;
      depth++;
    }
    if (isArray4 && !options.includes(property3)) {
      return;
    }
    if (is_undeclared_ref(name) && name.name == "console") {
      if (depth === 3 && !["call", "apply"].includes(exp.property) && is_used_in_expression(tt)) {
        exp.expression = make_empty_function(self2);
        set_flag(exp.expression, SQUEEZED);
        self2.args = [];
      } else {
        return make_node(AST_Undefined, self2);
      }
    }
  });
  return this.transform(tt);
});
AST_Node.DEFMETHOD("equivalent_to", function(node) {
  return equivalent_to(this, node);
});
AST_Scope.DEFMETHOD("process_expression", function(insert5, compressor) {
  var self2 = this;
  var tt = new TreeTransformer(function(node) {
    if (insert5 && node instanceof AST_SimpleStatement) {
      return make_node(AST_Return, node, {
        value: node.body
      });
    }
    if (!insert5 && node instanceof AST_Return) {
      if (compressor) {
        var value = node.value && node.value.drop_side_effect_free(compressor, true);
        return value ? make_node(AST_SimpleStatement, node, { body: value }) : make_node(AST_EmptyStatement, node);
      }
      return make_node(AST_SimpleStatement, node, {
        body: node.value || make_node(AST_UnaryPrefix, node, {
          operator: "void",
          expression: make_node(AST_Number, node, {
            value: 0
          })
        })
      });
    }
    if (node instanceof AST_Class || node instanceof AST_Lambda && node !== self2) {
      return node;
    }
    if (node instanceof AST_Block) {
      var index = node.body.length - 1;
      if (index >= 0) {
        node.body[index] = node.body[index].transform(tt);
      }
    } else if (node instanceof AST_If) {
      node.body = node.body.transform(tt);
      if (node.alternative) {
        node.alternative = node.alternative.transform(tt);
      }
    } else if (node instanceof AST_With) {
      node.body = node.body.transform(tt);
    }
    return node;
  });
  self2.transform(tt);
});
AST_Toplevel.DEFMETHOD("reset_opt_flags", function(compressor) {
  const self2 = this;
  const reduce_vars = compressor.option("reduce_vars");
  const preparation = new TreeWalker(function(node, descend) {
    clear_flag(node, CLEAR_BETWEEN_PASSES);
    if (reduce_vars) {
      if (compressor.top_retain && node instanceof AST_Defun && preparation.parent() === self2) {
        set_flag(node, TOP);
      }
      return node.reduce_vars(preparation, descend, compressor);
    }
  });
  preparation.safe_ids = /* @__PURE__ */ Object.create(null);
  preparation.in_loop = null;
  preparation.loop_ids = /* @__PURE__ */ new Map();
  preparation.defs_to_safe_ids = /* @__PURE__ */ new Map();
  self2.walk(preparation);
});
AST_Symbol.DEFMETHOD("fixed_value", function() {
  var fixed2 = this.thedef.fixed;
  if (!fixed2 || fixed2 instanceof AST_Node) return fixed2;
  return fixed2();
});
AST_SymbolRef.DEFMETHOD("is_immutable", function() {
  var orig = this.definition().orig;
  return orig.length == 1 && orig[0] instanceof AST_SymbolLambda;
});
function find_variable(compressor, name) {
  var scope5, i = 0;
  while (scope5 = compressor.parent(i++)) {
    if (scope5 instanceof AST_Scope) break;
    if (scope5 instanceof AST_Catch && scope5.argname) {
      scope5 = scope5.argname.definition().scope;
      break;
    }
  }
  return scope5.find_variable(name);
}
var global_names = makePredicate("Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Math Number parseFloat parseInt RangeError ReferenceError RegExp Object setInterval setTimeout String SyntaxError TypeError unescape URIError");
AST_SymbolRef.DEFMETHOD("is_declared", function(compressor) {
  return !this.definition().undeclared || compressor.option("unsafe") && global_names.has(this.name);
});
var directives = /* @__PURE__ */ new Set(["use asm", "use strict"]);
def_optimize(AST_Directive, function(self2, compressor) {
  if (compressor.option("directives") && (!directives.has(self2.value) || compressor.has_directive(self2.value) !== self2)) {
    return make_node(AST_EmptyStatement, self2);
  }
  return self2;
});
def_optimize(AST_Debugger, function(self2, compressor) {
  if (compressor.option("drop_debugger"))
    return make_node(AST_EmptyStatement, self2);
  return self2;
});
def_optimize(AST_LabeledStatement, function(self2, compressor) {
  if (self2.body instanceof AST_Break && compressor.loopcontrol_target(self2.body) === self2.body) {
    return make_node(AST_EmptyStatement, self2);
  }
  return self2.label.references.length == 0 ? self2.body : self2;
});
def_optimize(AST_Block, function(self2, compressor) {
  tighten_body(self2.body, compressor);
  return self2;
});
function can_be_extracted_from_if_block(node) {
  return !(node instanceof AST_Const || node instanceof AST_Let || node instanceof AST_Class);
}
def_optimize(AST_BlockStatement, function(self2, compressor) {
  tighten_body(self2.body, compressor);
  switch (self2.body.length) {
    case 1:
      if (!compressor.has_directive("use strict") && compressor.parent() instanceof AST_If && can_be_extracted_from_if_block(self2.body[0]) || can_be_evicted_from_block(self2.body[0])) {
        return self2.body[0];
      }
      break;
    case 0:
      return make_node(AST_EmptyStatement, self2);
  }
  return self2;
});
function opt_AST_Lambda(self2, compressor) {
  tighten_body(self2.body, compressor);
  if (compressor.option("side_effects") && self2.body.length == 1 && self2.body[0] === compressor.has_directive("use strict")) {
    self2.body.length = 0;
  }
  return self2;
}
def_optimize(AST_Lambda, opt_AST_Lambda);
AST_Scope.DEFMETHOD("hoist_declarations", function(compressor) {
  var self2 = this;
  if (compressor.has_directive("use asm")) return self2;
  var hoist_funs = compressor.option("hoist_funs");
  var hoist_vars = compressor.option("hoist_vars");
  if (hoist_funs || hoist_vars) {
    var dirs = [];
    var hoisted = [];
    var vars = /* @__PURE__ */ new Map(), vars_found = 0, var_decl = 0;
    walk2(self2, (node) => {
      if (node instanceof AST_Scope && node !== self2)
        return true;
      if (node instanceof AST_Var) {
        ++var_decl;
        return true;
      }
    });
    hoist_vars = hoist_vars && var_decl > 1;
    var tt = new TreeTransformer(
      function before2(node) {
        if (node !== self2) {
          if (node instanceof AST_Directive) {
            dirs.push(node);
            return make_node(AST_EmptyStatement, node);
          }
          if (hoist_funs && node instanceof AST_Defun && !(tt.parent() instanceof AST_Export) && tt.parent() === self2) {
            hoisted.push(node);
            return make_node(AST_EmptyStatement, node);
          }
          if (hoist_vars && node instanceof AST_Var && !node.definitions.some((def3) => def3.name instanceof AST_Destructuring)) {
            node.definitions.forEach(function(def3) {
              vars.set(def3.name.name, def3);
              ++vars_found;
            });
            var seq2 = node.to_assignments(compressor);
            var p3 = tt.parent();
            if (p3 instanceof AST_ForIn && p3.init === node) {
              if (seq2 == null) {
                var def2 = node.definitions[0].name;
                return make_node(AST_SymbolRef, def2, def2);
              }
              return seq2;
            }
            if (p3 instanceof AST_For && p3.init === node) {
              return seq2;
            }
            if (!seq2) return make_node(AST_EmptyStatement, node);
            return make_node(AST_SimpleStatement, node, {
              body: seq2
            });
          }
          if (node instanceof AST_Scope)
            return node;
        }
      }
    );
    self2 = self2.transform(tt);
    if (vars_found > 0) {
      var defs = [];
      const is_lambda = self2 instanceof AST_Lambda;
      const args_as_names = is_lambda ? self2.args_as_names() : null;
      vars.forEach((def2, name) => {
        if (is_lambda && args_as_names.some((x2) => x2.name === def2.name.name)) {
          vars.delete(name);
        } else {
          def2 = def2.clone();
          def2.value = null;
          defs.push(def2);
          vars.set(name, def2);
        }
      });
      if (defs.length > 0) {
        for (var i = 0; i < self2.body.length; ) {
          if (self2.body[i] instanceof AST_SimpleStatement) {
            var expr = self2.body[i].body, sym, assign;
            if (expr instanceof AST_Assign && expr.operator == "=" && (sym = expr.left) instanceof AST_Symbol && vars.has(sym.name)) {
              var def = vars.get(sym.name);
              if (def.value) break;
              def.value = expr.right;
              remove9(defs, def);
              defs.push(def);
              self2.body.splice(i, 1);
              continue;
            }
            if (expr instanceof AST_Sequence && (assign = expr.expressions[0]) instanceof AST_Assign && assign.operator == "=" && (sym = assign.left) instanceof AST_Symbol && vars.has(sym.name)) {
              var def = vars.get(sym.name);
              if (def.value) break;
              def.value = assign.right;
              remove9(defs, def);
              defs.push(def);
              self2.body[i].body = make_sequence(expr, expr.expressions.slice(1));
              continue;
            }
          }
          if (self2.body[i] instanceof AST_EmptyStatement) {
            self2.body.splice(i, 1);
            continue;
          }
          if (self2.body[i] instanceof AST_BlockStatement) {
            self2.body.splice(i, 1, ...self2.body[i].body);
            continue;
          }
          break;
        }
        defs = make_node(AST_Var, self2, {
          definitions: defs
        });
        hoisted.push(defs);
      }
    }
    self2.body = dirs.concat(hoisted, self2.body);
  }
  return self2;
});
AST_Scope.DEFMETHOD("hoist_properties", function(compressor) {
  var self2 = this;
  if (!compressor.option("hoist_props") || compressor.has_directive("use asm")) return self2;
  var top_retain = self2 instanceof AST_Toplevel && compressor.top_retain || return_false;
  var defs_by_id = /* @__PURE__ */ new Map();
  var hoister = new TreeTransformer(function(node, descend) {
    if (node instanceof AST_VarDef) {
      const sym = node.name;
      let def;
      let value;
      if (sym.scope === self2 && (def = sym.definition()).escaped != 1 && !def.assignments && !def.direct_access && !def.single_use && !compressor.exposed(def) && !top_retain(def) && (value = sym.fixed_value()) === node.value && value instanceof AST_Object && !value.properties.some(
        (prop) => prop instanceof AST_Expansion || prop.computed_key()
      )) {
        descend(node, this);
        const defs = /* @__PURE__ */ new Map();
        const assignments = [];
        value.properties.forEach(({ key, value: value2 }) => {
          const scope5 = hoister.find_scope();
          const symbol3 = self2.create_symbol(sym.CTOR, {
            source: sym,
            scope: scope5,
            conflict_scopes: /* @__PURE__ */ new Set([
              scope5,
              ...sym.definition().references.map((ref) => ref.scope)
            ]),
            tentative_name: sym.name + "_" + key
          });
          defs.set(String(key), symbol3.definition());
          assignments.push(make_node(AST_VarDef, node, {
            name: symbol3,
            value: value2
          }));
        });
        defs_by_id.set(def.id, defs);
        return MAP.splice(assignments);
      }
    } else if (node instanceof AST_PropAccess && node.expression instanceof AST_SymbolRef) {
      const defs = defs_by_id.get(node.expression.definition().id);
      if (defs) {
        const def = defs.get(String(get_simple_key(node.property)));
        const sym = make_node(AST_SymbolRef, node, {
          name: def.name,
          scope: node.expression.scope,
          thedef: def
        });
        sym.reference({});
        return sym;
      }
    }
  });
  return self2.transform(hoister);
});
def_optimize(AST_SimpleStatement, function(self2, compressor) {
  if (compressor.option("side_effects")) {
    var body = self2.body;
    var node = body.drop_side_effect_free(compressor, true);
    if (!node) {
      return make_node(AST_EmptyStatement, self2);
    }
    if (node !== body) {
      return make_node(AST_SimpleStatement, self2, { body: node });
    }
  }
  return self2;
});
def_optimize(AST_While, function(self2, compressor) {
  return compressor.option("loops") ? make_node(AST_For, self2, self2).optimize(compressor) : self2;
});
def_optimize(AST_Do, function(self2, compressor) {
  if (!compressor.option("loops")) return self2;
  var cond = self2.condition.tail_node().evaluate(compressor);
  if (!(cond instanceof AST_Node)) {
    if (cond) return make_node(AST_For, self2, {
      body: make_node(AST_BlockStatement, self2.body, {
        body: [
          self2.body,
          make_node(AST_SimpleStatement, self2.condition, {
            body: self2.condition
          })
        ]
      })
    }).optimize(compressor);
    if (!has_break_or_continue(self2, compressor.parent())) {
      return make_node(AST_BlockStatement, self2.body, {
        body: [
          self2.body,
          make_node(AST_SimpleStatement, self2.condition, {
            body: self2.condition
          })
        ]
      }).optimize(compressor);
    }
  }
  return self2;
});
function if_break_in_loop(self2, compressor) {
  var first3 = self2.body instanceof AST_BlockStatement ? self2.body.body[0] : self2.body;
  if (compressor.option("dead_code") && is_break(first3)) {
    var body = [];
    if (self2.init instanceof AST_Statement) {
      body.push(self2.init);
    } else if (self2.init) {
      body.push(make_node(AST_SimpleStatement, self2.init, {
        body: self2.init
      }));
    }
    if (self2.condition) {
      body.push(make_node(AST_SimpleStatement, self2.condition, {
        body: self2.condition
      }));
    }
    trim_unreachable_code(compressor, self2.body, body);
    return make_node(AST_BlockStatement, self2, {
      body
    });
  }
  if (first3 instanceof AST_If) {
    if (is_break(first3.body)) {
      if (self2.condition) {
        self2.condition = make_node(AST_Binary, self2.condition, {
          left: self2.condition,
          operator: "&&",
          right: first3.condition.negate(compressor)
        });
      } else {
        self2.condition = first3.condition.negate(compressor);
      }
      drop_it(first3.alternative);
    } else if (is_break(first3.alternative)) {
      if (self2.condition) {
        self2.condition = make_node(AST_Binary, self2.condition, {
          left: self2.condition,
          operator: "&&",
          right: first3.condition
        });
      } else {
        self2.condition = first3.condition;
      }
      drop_it(first3.body);
    }
  }
  return self2;
  function is_break(node) {
    return node instanceof AST_Break && compressor.loopcontrol_target(node) === compressor.self();
  }
  function drop_it(rest) {
    rest = as_statement_array(rest);
    if (self2.body instanceof AST_BlockStatement) {
      self2.body = self2.body.clone();
      self2.body.body = rest.concat(self2.body.body.slice(1));
      self2.body = self2.body.transform(compressor);
    } else {
      self2.body = make_node(AST_BlockStatement, self2.body, {
        body: rest
      }).transform(compressor);
    }
    self2 = if_break_in_loop(self2, compressor);
  }
}
def_optimize(AST_For, function(self2, compressor) {
  if (!compressor.option("loops")) return self2;
  if (compressor.option("side_effects") && self2.init) {
    self2.init = self2.init.drop_side_effect_free(compressor);
  }
  if (self2.condition) {
    var cond = self2.condition.evaluate(compressor);
    if (!(cond instanceof AST_Node)) {
      if (cond) self2.condition = null;
      else if (!compressor.option("dead_code")) {
        var orig = self2.condition;
        self2.condition = make_node_from_constant(cond, self2.condition);
        self2.condition = best_of_expression(self2.condition.transform(compressor), orig);
      }
    }
    if (compressor.option("dead_code")) {
      if (cond instanceof AST_Node) cond = self2.condition.tail_node().evaluate(compressor);
      if (!cond) {
        var body = [];
        trim_unreachable_code(compressor, self2.body, body);
        if (self2.init instanceof AST_Statement) {
          body.push(self2.init);
        } else if (self2.init) {
          body.push(make_node(AST_SimpleStatement, self2.init, {
            body: self2.init
          }));
        }
        body.push(make_node(AST_SimpleStatement, self2.condition, {
          body: self2.condition
        }));
        return make_node(AST_BlockStatement, self2, { body }).optimize(compressor);
      }
    }
  }
  return if_break_in_loop(self2, compressor);
});
def_optimize(AST_If, function(self2, compressor) {
  if (is_empty(self2.alternative)) self2.alternative = null;
  if (!compressor.option("conditionals")) return self2;
  var cond = self2.condition.evaluate(compressor);
  if (!compressor.option("dead_code") && !(cond instanceof AST_Node)) {
    var orig = self2.condition;
    self2.condition = make_node_from_constant(cond, orig);
    self2.condition = best_of_expression(self2.condition.transform(compressor), orig);
  }
  if (compressor.option("dead_code")) {
    if (cond instanceof AST_Node) cond = self2.condition.tail_node().evaluate(compressor);
    if (!cond) {
      var body = [];
      trim_unreachable_code(compressor, self2.body, body);
      body.push(make_node(AST_SimpleStatement, self2.condition, {
        body: self2.condition
      }));
      if (self2.alternative) body.push(self2.alternative);
      return make_node(AST_BlockStatement, self2, { body }).optimize(compressor);
    } else if (!(cond instanceof AST_Node)) {
      var body = [];
      body.push(make_node(AST_SimpleStatement, self2.condition, {
        body: self2.condition
      }));
      body.push(self2.body);
      if (self2.alternative) {
        trim_unreachable_code(compressor, self2.alternative, body);
      }
      return make_node(AST_BlockStatement, self2, { body }).optimize(compressor);
    }
  }
  var negated = self2.condition.negate(compressor);
  var self_condition_length = self2.condition.size();
  var negated_length = negated.size();
  var negated_is_best = negated_length < self_condition_length;
  if (self2.alternative && negated_is_best) {
    negated_is_best = false;
    self2.condition = negated;
    var tmp = self2.body;
    self2.body = self2.alternative || make_node(AST_EmptyStatement, self2);
    self2.alternative = tmp;
  }
  if (is_empty(self2.body) && is_empty(self2.alternative)) {
    return make_node(AST_SimpleStatement, self2.condition, {
      body: self2.condition.clone()
    }).optimize(compressor);
  }
  if (self2.body instanceof AST_SimpleStatement && self2.alternative instanceof AST_SimpleStatement) {
    return make_node(AST_SimpleStatement, self2, {
      body: make_node(AST_Conditional, self2, {
        condition: self2.condition,
        consequent: self2.body.body,
        alternative: self2.alternative.body
      })
    }).optimize(compressor);
  }
  if (is_empty(self2.alternative) && self2.body instanceof AST_SimpleStatement) {
    if (self_condition_length === negated_length && !negated_is_best && self2.condition instanceof AST_Binary && self2.condition.operator == "||") {
      negated_is_best = true;
    }
    if (negated_is_best) return make_node(AST_SimpleStatement, self2, {
      body: make_node(AST_Binary, self2, {
        operator: "||",
        left: negated,
        right: self2.body.body
      })
    }).optimize(compressor);
    return make_node(AST_SimpleStatement, self2, {
      body: make_node(AST_Binary, self2, {
        operator: "&&",
        left: self2.condition,
        right: self2.body.body
      })
    }).optimize(compressor);
  }
  if (self2.body instanceof AST_EmptyStatement && self2.alternative instanceof AST_SimpleStatement) {
    return make_node(AST_SimpleStatement, self2, {
      body: make_node(AST_Binary, self2, {
        operator: "||",
        left: self2.condition,
        right: self2.alternative.body
      })
    }).optimize(compressor);
  }
  if (self2.body instanceof AST_Exit && self2.alternative instanceof AST_Exit && self2.body.TYPE == self2.alternative.TYPE) {
    return make_node(self2.body.CTOR, self2, {
      value: make_node(AST_Conditional, self2, {
        condition: self2.condition,
        consequent: self2.body.value || make_node(AST_Undefined, self2.body),
        alternative: self2.alternative.value || make_node(AST_Undefined, self2.alternative)
      }).transform(compressor)
    }).optimize(compressor);
  }
  if (self2.body instanceof AST_If && !self2.body.alternative && !self2.alternative) {
    self2 = make_node(AST_If, self2, {
      condition: make_node(AST_Binary, self2.condition, {
        operator: "&&",
        left: self2.condition,
        right: self2.body.condition
      }),
      body: self2.body.body,
      alternative: null
    });
  }
  if (aborts(self2.body)) {
    if (self2.alternative) {
      var alt = self2.alternative;
      self2.alternative = null;
      return make_node(AST_BlockStatement, self2, {
        body: [self2, alt]
      }).optimize(compressor);
    }
  }
  if (aborts(self2.alternative)) {
    var body = self2.body;
    self2.body = self2.alternative;
    self2.condition = negated_is_best ? negated : self2.condition.negate(compressor);
    self2.alternative = null;
    return make_node(AST_BlockStatement, self2, {
      body: [self2, body]
    }).optimize(compressor);
  }
  return self2;
});
def_optimize(AST_Switch, function(self2, compressor) {
  if (!compressor.option("switches")) return self2;
  var branch;
  var value = self2.expression.evaluate(compressor);
  if (!(value instanceof AST_Node)) {
    var orig = self2.expression;
    self2.expression = make_node_from_constant(value, orig);
    self2.expression = best_of_expression(self2.expression.transform(compressor), orig);
  }
  if (!compressor.option("dead_code")) return self2;
  if (value instanceof AST_Node) {
    value = self2.expression.tail_node().evaluate(compressor);
  }
  var decl = [];
  var body = [];
  var default_branch;
  var exact_match;
  for (var i = 0, len = self2.body.length; i < len && !exact_match; i++) {
    branch = self2.body[i];
    if (branch instanceof AST_Default) {
      if (!default_branch) {
        default_branch = branch;
      } else {
        eliminate_branch(branch, body[body.length - 1]);
      }
    } else if (!(value instanceof AST_Node)) {
      var exp = branch.expression.evaluate(compressor);
      if (!(exp instanceof AST_Node) && exp !== value) {
        eliminate_branch(branch, body[body.length - 1]);
        continue;
      }
      if (exp instanceof AST_Node && !exp.has_side_effects(compressor)) {
        exp = branch.expression.tail_node().evaluate(compressor);
      }
      if (exp === value) {
        exact_match = branch;
        if (default_branch) {
          var default_index = body.indexOf(default_branch);
          body.splice(default_index, 1);
          eliminate_branch(default_branch, body[default_index - 1]);
          default_branch = null;
        }
      }
    }
    body.push(branch);
  }
  while (i < len) eliminate_branch(self2.body[i++], body[body.length - 1]);
  self2.body = body;
  let default_or_exact = default_branch || exact_match;
  default_branch = null;
  exact_match = null;
  if (body.every((branch2, i2) => (branch2 === default_or_exact || branch2.expression instanceof AST_Constant) && (branch2.body.length === 0 || aborts(branch2) || body.length - 1 === i2))) {
    for (let i2 = 0; i2 < body.length; i2++) {
      const branch2 = body[i2];
      for (let j = i2 + 1; j < body.length; j++) {
        const next = body[j];
        if (next.body.length === 0) continue;
        const last_branch = j === body.length - 1;
        const equivalentBranch = branches_equivalent(next, branch2, false);
        if (equivalentBranch || last_branch && branches_equivalent(next, branch2, true)) {
          if (!equivalentBranch && last_branch) {
            next.body.push(make_node(AST_Break));
          }
          let x2 = j - 1;
          let fallthroughDepth = 0;
          while (x2 > i2) {
            if (is_inert_body(body[x2--])) {
              fallthroughDepth++;
            } else {
              break;
            }
          }
          const plucked = body.splice(j - fallthroughDepth, 1 + fallthroughDepth);
          body.splice(i2 + 1, 0, ...plucked);
          i2 += plucked.length;
        }
      }
    }
  }
  for (let i2 = 0; i2 < body.length; i2++) {
    let branch2 = body[i2];
    if (branch2.body.length === 0) continue;
    if (!aborts(branch2)) continue;
    for (let j = i2 + 1; j < body.length; i2++, j++) {
      let next = body[j];
      if (next.body.length === 0) continue;
      if (branches_equivalent(next, branch2, false) || j === body.length - 1 && branches_equivalent(next, branch2, true)) {
        branch2.body = [];
        branch2 = next;
        continue;
      }
      break;
    }
  }
  {
    let i2 = body.length - 1;
    for (; i2 >= 0; i2--) {
      let bbody = body[i2].body;
      if (is_break(bbody[bbody.length - 1], compressor)) bbody.pop();
      if (!is_inert_body(body[i2])) break;
    }
    i2++;
    if (!default_or_exact || body.indexOf(default_or_exact) >= i2) {
      for (let j = body.length - 1; j >= i2; j--) {
        let branch2 = body[j];
        if (branch2 === default_or_exact) {
          default_or_exact = null;
          body.pop();
        } else if (!branch2.expression.has_side_effects(compressor)) {
          body.pop();
        } else {
          break;
        }
      }
    }
  }
  DEFAULT: if (default_or_exact) {
    let default_index2 = body.indexOf(default_or_exact);
    let default_body_index = default_index2;
    for (; default_body_index < body.length - 1; default_body_index++) {
      if (!is_inert_body(body[default_body_index])) break;
    }
    if (default_body_index < body.length - 1) {
      break DEFAULT;
    }
    let side_effect_index = body.length - 1;
    for (; side_effect_index >= 0; side_effect_index--) {
      let branch2 = body[side_effect_index];
      if (branch2 === default_or_exact) continue;
      if (branch2.expression.has_side_effects(compressor)) break;
    }
    if (default_body_index > side_effect_index) {
      let prev_body_index = default_index2 - 1;
      for (; prev_body_index >= 0; prev_body_index--) {
        if (!is_inert_body(body[prev_body_index])) break;
      }
      let before2 = Math.max(side_effect_index, prev_body_index) + 1;
      let after3 = default_index2;
      if (side_effect_index > default_index2) {
        after3 = side_effect_index;
        body[side_effect_index].body = body[default_body_index].body;
      } else {
        default_or_exact.body = body[default_body_index].body;
      }
      body.splice(after3 + 1, default_body_index - after3);
      body.splice(before2, default_index2 - before2);
    }
  }
  DEFAULT: if (default_or_exact) {
    let i2 = body.findIndex((branch2) => !is_inert_body(branch2));
    let caseBody;
    if (i2 === body.length - 1) {
      let branch2 = body[i2];
      if (has_nested_break(self2)) break DEFAULT;
      caseBody = make_node(AST_BlockStatement, branch2, {
        body: branch2.body
      });
      branch2.body = [];
    } else if (i2 !== -1) {
      break DEFAULT;
    }
    let sideEffect = body.find(
      (branch2) => branch2 !== default_or_exact && branch2.expression.has_side_effects(compressor)
    );
    if (!sideEffect) {
      return make_node(AST_BlockStatement, self2, {
        body: decl.concat(
          statement(self2.expression),
          default_or_exact.expression ? statement(default_or_exact.expression) : [],
          caseBody || []
        )
      }).optimize(compressor);
    }
    const default_index2 = body.indexOf(default_or_exact);
    body.splice(default_index2, 1);
    default_or_exact = null;
    if (caseBody) {
      return make_node(AST_BlockStatement, self2, {
        body: decl.concat(self2, caseBody)
      }).optimize(compressor);
    }
  }
  if (body.length > 0) {
    body[0].body = decl.concat(body[0].body);
  }
  if (body.length == 0) {
    return make_node(AST_BlockStatement, self2, {
      body: decl.concat(statement(self2.expression))
    }).optimize(compressor);
  }
  if (body.length == 1 && !has_nested_break(self2)) {
    let branch2 = body[0];
    return make_node(AST_If, self2, {
      condition: make_node(AST_Binary, self2, {
        operator: "===",
        left: self2.expression,
        right: branch2.expression
      }),
      body: make_node(AST_BlockStatement, branch2, {
        body: branch2.body
      }),
      alternative: null
    }).optimize(compressor);
  }
  if (body.length === 2 && default_or_exact && !has_nested_break(self2)) {
    let branch2 = body[0] === default_or_exact ? body[1] : body[0];
    let exact_exp = default_or_exact.expression && statement(default_or_exact.expression);
    if (aborts(body[0])) {
      let first3 = body[0];
      if (is_break(first3.body[first3.body.length - 1], compressor)) {
        first3.body.pop();
      }
      return make_node(AST_If, self2, {
        condition: make_node(AST_Binary, self2, {
          operator: "===",
          left: self2.expression,
          right: branch2.expression
        }),
        body: make_node(AST_BlockStatement, branch2, {
          body: branch2.body
        }),
        alternative: make_node(AST_BlockStatement, default_or_exact, {
          body: [].concat(
            exact_exp || [],
            default_or_exact.body
          )
        })
      }).optimize(compressor);
    }
    let operator = "===";
    let consequent = make_node(AST_BlockStatement, branch2, {
      body: branch2.body
    });
    let always = make_node(AST_BlockStatement, default_or_exact, {
      body: [].concat(
        exact_exp || [],
        default_or_exact.body
      )
    });
    if (body[0] === default_or_exact) {
      operator = "!==";
      let tmp = always;
      always = consequent;
      consequent = tmp;
    }
    return make_node(AST_BlockStatement, self2, {
      body: [
        make_node(AST_If, self2, {
          condition: make_node(AST_Binary, self2, {
            operator,
            left: self2.expression,
            right: branch2.expression
          }),
          body: consequent,
          alternative: null
        }),
        always
      ]
    }).optimize(compressor);
  }
  return self2;
  function eliminate_branch(branch2, prev) {
    if (prev && !aborts(prev)) {
      prev.body = prev.body.concat(branch2.body);
    } else {
      trim_unreachable_code(compressor, branch2, decl);
    }
  }
  function branches_equivalent(branch2, prev, insertBreak) {
    let bbody = branch2.body;
    let pbody = prev.body;
    if (insertBreak) {
      bbody = bbody.concat(make_node(AST_Break));
    }
    if (bbody.length !== pbody.length) return false;
    let bblock = make_node(AST_BlockStatement, branch2, { body: bbody });
    let pblock = make_node(AST_BlockStatement, prev, { body: pbody });
    return bblock.equivalent_to(pblock);
  }
  function statement(body2) {
    return make_node(AST_SimpleStatement, body2, { body: body2 });
  }
  function has_nested_break(root) {
    let has_break = false;
    let tw = new TreeWalker((node) => {
      if (has_break) return true;
      if (node instanceof AST_Lambda) return true;
      if (node instanceof AST_SimpleStatement) return true;
      if (!is_break(node, tw)) return;
      let parent = tw.parent();
      if (parent instanceof AST_SwitchBranch && parent.body[parent.body.length - 1] === node) {
        return;
      }
      has_break = true;
    });
    root.walk(tw);
    return has_break;
  }
  function is_break(node, stack) {
    return node instanceof AST_Break && stack.loopcontrol_target(node) === self2;
  }
  function is_inert_body(branch2) {
    return !aborts(branch2) && !make_node(AST_BlockStatement, branch2, {
      body: branch2.body
    }).has_side_effects(compressor);
  }
});
def_optimize(AST_Try, function(self2, compressor) {
  if (self2.bcatch && self2.bfinally && self2.bfinally.body.every(is_empty)) self2.bfinally = null;
  if (compressor.option("dead_code") && self2.body.body.every(is_empty)) {
    var body = [];
    if (self2.bcatch) {
      trim_unreachable_code(compressor, self2.bcatch, body);
    }
    if (self2.bfinally) body.push(...self2.bfinally.body);
    return make_node(AST_BlockStatement, self2, {
      body
    }).optimize(compressor);
  }
  return self2;
});
AST_Definitions.DEFMETHOD("to_assignments", function(compressor) {
  var reduce_vars = compressor.option("reduce_vars");
  var assignments = [];
  for (const def of this.definitions) {
    if (def.value) {
      var name = make_node(AST_SymbolRef, def.name, def.name);
      assignments.push(make_node(AST_Assign, def, {
        operator: "=",
        logical: false,
        left: name,
        right: def.value
      }));
      if (reduce_vars) name.definition().fixed = false;
    }
    const thedef = def.name.definition();
    thedef.eliminated++;
    thedef.replaced--;
  }
  if (assignments.length == 0) return null;
  return make_sequence(this, assignments);
});
def_optimize(AST_Definitions, function(self2) {
  if (self2.definitions.length == 0) {
    return make_node(AST_EmptyStatement, self2);
  }
  return self2;
});
def_optimize(AST_VarDef, function(self2, compressor) {
  if (self2.name instanceof AST_SymbolLet && self2.value != null && is_undefined(self2.value, compressor)) {
    self2.value = null;
  }
  return self2;
});
def_optimize(AST_Import, function(self2) {
  return self2;
});
def_optimize(AST_Call, function(self2, compressor) {
  var exp = self2.expression;
  var fn2 = exp;
  inline_array_like_spread(self2.args);
  var simple_args = self2.args.every((arg2) => !(arg2 instanceof AST_Expansion));
  if (compressor.option("reduce_vars") && fn2 instanceof AST_SymbolRef) {
    fn2 = fn2.fixed_value();
  }
  var is_func = fn2 instanceof AST_Lambda;
  if (is_func && fn2.pinned()) return self2;
  if (compressor.option("unused") && simple_args && is_func && !fn2.uses_arguments) {
    var pos = 0, last6 = 0;
    for (var i = 0, len = self2.args.length; i < len; i++) {
      if (fn2.argnames[i] instanceof AST_Expansion) {
        if (has_flag(fn2.argnames[i].expression, UNUSED)) while (i < len) {
          var node = self2.args[i++].drop_side_effect_free(compressor);
          if (node) {
            self2.args[pos++] = node;
          }
        }
        else while (i < len) {
          self2.args[pos++] = self2.args[i++];
        }
        last6 = pos;
        break;
      }
      var trim2 = i >= fn2.argnames.length;
      if (trim2 || has_flag(fn2.argnames[i], UNUSED)) {
        var node = self2.args[i].drop_side_effect_free(compressor);
        if (node) {
          self2.args[pos++] = node;
        } else if (!trim2) {
          self2.args[pos++] = make_node(AST_Number, self2.args[i], {
            value: 0
          });
          continue;
        }
      } else {
        self2.args[pos++] = self2.args[i];
      }
      last6 = pos;
    }
    self2.args.length = last6;
  }
  if (exp instanceof AST_Dot && exp.expression instanceof AST_SymbolRef && exp.expression.name === "console" && exp.expression.definition().undeclared && exp.property === "assert") {
    const condition = self2.args[0];
    if (condition) {
      const value2 = condition.evaluate(compressor);
      if (value2 === 1 || value2 === true) {
        return make_node(AST_Undefined, self2);
      }
    }
  }
  if (compressor.option("unsafe") && !exp.contains_optional()) {
    if (exp instanceof AST_Dot && exp.start.value === "Array" && exp.property === "from" && self2.args.length === 1) {
      const [argument] = self2.args;
      if (argument instanceof AST_Array) {
        return make_node(AST_Array, argument, {
          elements: argument.elements
        }).optimize(compressor);
      }
    }
    if (is_undeclared_ref(exp)) switch (exp.name) {
      case "Array":
        if (self2.args.length != 1) {
          return make_node(AST_Array, self2, {
            elements: self2.args
          }).optimize(compressor);
        } else if (self2.args[0] instanceof AST_Number && self2.args[0].value <= 11) {
          const elements2 = [];
          for (let i2 = 0; i2 < self2.args[0].value; i2++) elements2.push(new AST_Hole());
          return new AST_Array({ elements: elements2 });
        }
        break;
      case "Object":
        if (self2.args.length == 0) {
          return make_node(AST_Object, self2, {
            properties: []
          });
        }
        break;
      case "String":
        if (self2.args.length == 0) return make_node(AST_String, self2, {
          value: ""
        });
        if (self2.args.length <= 1) return make_node(AST_Binary, self2, {
          left: self2.args[0],
          operator: "+",
          right: make_node(AST_String, self2, { value: "" })
        }).optimize(compressor);
        break;
      case "Number":
        if (self2.args.length == 0) return make_node(AST_Number, self2, {
          value: 0
        });
        if (self2.args.length == 1 && compressor.option("unsafe_math")) {
          return make_node(AST_UnaryPrefix, self2, {
            expression: self2.args[0],
            operator: "+"
          }).optimize(compressor);
        }
        break;
      case "Symbol":
        if (self2.args.length == 1 && self2.args[0] instanceof AST_String && compressor.option("unsafe_symbols"))
          self2.args.length = 0;
        break;
      case "Boolean":
        if (self2.args.length == 0) return make_node(AST_False, self2);
        if (self2.args.length == 1) return make_node(AST_UnaryPrefix, self2, {
          expression: make_node(AST_UnaryPrefix, self2, {
            expression: self2.args[0],
            operator: "!"
          }),
          operator: "!"
        }).optimize(compressor);
        break;
      case "RegExp":
        var params = [];
        if (self2.args.length >= 1 && self2.args.length <= 2 && self2.args.every((arg2) => {
          var value2 = arg2.evaluate(compressor);
          params.push(value2);
          return arg2 !== value2;
        }) && regexp_is_safe(params[0])) {
          let [source, flags] = params;
          source = regexp_source_fix(new RegExp(source).source);
          const rx = make_node(AST_RegExp, self2, {
            value: { source, flags }
          });
          if (rx._eval(compressor) !== rx) {
            return rx;
          }
        }
        break;
    }
    else if (exp instanceof AST_Dot) switch (exp.property) {
      case "toString":
        if (self2.args.length == 0 && !exp.expression.may_throw_on_access(compressor)) {
          return make_node(AST_Binary, self2, {
            left: make_node(AST_String, self2, { value: "" }),
            operator: "+",
            right: exp.expression
          }).optimize(compressor);
        }
        break;
      case "join":
        if (exp.expression instanceof AST_Array) EXIT: {
          var separator;
          if (self2.args.length > 0) {
            separator = self2.args[0].evaluate(compressor);
            if (separator === self2.args[0]) break EXIT;
          }
          var elements = [];
          var consts = [];
          for (var i = 0, len = exp.expression.elements.length; i < len; i++) {
            var el = exp.expression.elements[i];
            if (el instanceof AST_Expansion) break EXIT;
            var value = el.evaluate(compressor);
            if (value !== el) {
              consts.push(value);
            } else {
              if (consts.length > 0) {
                elements.push(make_node(AST_String, self2, {
                  value: consts.join(separator)
                }));
                consts.length = 0;
              }
              elements.push(el);
            }
          }
          if (consts.length > 0) {
            elements.push(make_node(AST_String, self2, {
              value: consts.join(separator)
            }));
          }
          if (elements.length == 0) return make_node(AST_String, self2, { value: "" });
          if (elements.length == 1) {
            if (elements[0].is_string(compressor)) {
              return elements[0];
            }
            return make_node(AST_Binary, elements[0], {
              operator: "+",
              left: make_node(AST_String, self2, { value: "" }),
              right: elements[0]
            });
          }
          if (separator == "") {
            var first3;
            if (elements[0].is_string(compressor) || elements[1].is_string(compressor)) {
              first3 = elements.shift();
            } else {
              first3 = make_node(AST_String, self2, { value: "" });
            }
            return elements.reduce(function(prev, el2) {
              return make_node(AST_Binary, el2, {
                operator: "+",
                left: prev,
                right: el2
              });
            }, first3).optimize(compressor);
          }
          var node = self2.clone();
          node.expression = node.expression.clone();
          node.expression.expression = node.expression.expression.clone();
          node.expression.expression.elements = elements;
          return best_of(compressor, self2, node);
        }
        break;
      case "charAt":
        if (exp.expression.is_string(compressor)) {
          var arg = self2.args[0];
          var index = arg ? arg.evaluate(compressor) : 0;
          if (index !== arg) {
            return make_node(AST_Sub, exp, {
              expression: exp.expression,
              property: make_node_from_constant(index | 0, arg || exp)
            }).optimize(compressor);
          }
        }
        break;
      case "apply":
        if (self2.args.length == 2 && self2.args[1] instanceof AST_Array) {
          var args2 = self2.args[1].elements.slice();
          args2.unshift(self2.args[0]);
          return make_node(AST_Call, self2, {
            expression: make_node(AST_Dot, exp, {
              expression: exp.expression,
              optional: false,
              property: "call"
            }),
            args: args2
          }).optimize(compressor);
        }
        break;
      case "call":
        var func = exp.expression;
        if (func instanceof AST_SymbolRef) {
          func = func.fixed_value();
        }
        if (func instanceof AST_Lambda && !func.contains_this()) {
          return (self2.args.length ? make_sequence(this, [
            self2.args[0],
            make_node(AST_Call, self2, {
              expression: exp.expression,
              args: self2.args.slice(1)
            })
          ]) : make_node(AST_Call, self2, {
            expression: exp.expression,
            args: []
          })).optimize(compressor);
        }
        break;
    }
  }
  if (compressor.option("unsafe_Function") && is_undeclared_ref(exp) && exp.name == "Function") {
    if (self2.args.length == 0) return make_empty_function(self2).optimize(compressor);
    if (self2.args.every((x2) => x2 instanceof AST_String)) {
      try {
        var code = "n(function(" + self2.args.slice(0, -1).map(function(arg2) {
          return arg2.value;
        }).join(",") + "){" + self2.args[self2.args.length - 1].value + "})";
        var ast = parse(code);
        var mangle = compressor.mangle_options();
        ast.figure_out_scope(mangle);
        var comp = new Compressor(compressor.options, {
          mangle_options: compressor._mangle_options
        });
        ast = ast.transform(comp);
        ast.figure_out_scope(mangle);
        ast.compute_char_frequency(mangle);
        ast.mangle_names(mangle);
        var fun;
        walk2(ast, (node2) => {
          if (is_func_expr(node2)) {
            fun = node2;
            return walk_abort;
          }
        });
        var code = OutputStream();
        AST_BlockStatement.prototype._codegen.call(fun, fun, code);
        self2.args = [
          make_node(AST_String, self2, {
            value: fun.argnames.map(function(arg2) {
              return arg2.print_to_string();
            }).join(",")
          }),
          make_node(AST_String, self2.args[self2.args.length - 1], {
            value: code.get().replace(/^{|}$/g, "")
          })
        ];
        return self2;
      } catch (ex) {
        if (!(ex instanceof JS_Parse_Error)) {
          throw ex;
        }
      }
    }
  }
  return inline_into_call(self2, compressor);
});
AST_Node.DEFMETHOD("contains_optional", function() {
  if (this instanceof AST_PropAccess || this instanceof AST_Call || this instanceof AST_Chain) {
    if (this.optional) {
      return true;
    } else {
      return this.expression.contains_optional();
    }
  } else {
    return false;
  }
});
def_optimize(AST_New, function(self2, compressor) {
  if (compressor.option("unsafe") && is_undeclared_ref(self2.expression) && ["Object", "RegExp", "Function", "Error", "Array"].includes(self2.expression.name)) return make_node(AST_Call, self2, self2).transform(compressor);
  return self2;
});
def_optimize(AST_Sequence, function(self2, compressor) {
  if (!compressor.option("side_effects")) return self2;
  var expressions = [];
  filter_for_side_effects();
  var end6 = expressions.length - 1;
  trim_right_for_undefined();
  if (end6 == 0) {
    self2 = maintain_this_binding(compressor.parent(), compressor.self(), expressions[0]);
    if (!(self2 instanceof AST_Sequence)) self2 = self2.optimize(compressor);
    return self2;
  }
  self2.expressions = expressions;
  return self2;
  function filter_for_side_effects() {
    var first3 = first_in_statement(compressor);
    var last6 = self2.expressions.length - 1;
    self2.expressions.forEach(function(expr, index) {
      if (index < last6) expr = expr.drop_side_effect_free(compressor, first3);
      if (expr) {
        merge_sequence(expressions, expr);
        first3 = false;
      }
    });
  }
  function trim_right_for_undefined() {
    while (end6 > 0 && is_undefined(expressions[end6], compressor)) end6--;
    if (end6 < expressions.length - 1) {
      expressions[end6] = make_node(AST_UnaryPrefix, self2, {
        operator: "void",
        expression: expressions[end6]
      });
      expressions.length = end6 + 1;
    }
  }
});
AST_Unary.DEFMETHOD("lift_sequences", function(compressor) {
  if (compressor.option("sequences")) {
    if (this.expression instanceof AST_Sequence) {
      var x2 = this.expression.expressions.slice();
      var e = this.clone();
      e.expression = x2.pop();
      x2.push(e);
      return make_sequence(this, x2).optimize(compressor);
    }
  }
  return this;
});
def_optimize(AST_UnaryPostfix, function(self2, compressor) {
  return self2.lift_sequences(compressor);
});
def_optimize(AST_UnaryPrefix, function(self2, compressor) {
  var e = self2.expression;
  if (self2.operator == "delete" && !(e instanceof AST_SymbolRef || e instanceof AST_PropAccess || e instanceof AST_Chain || is_identifier_atom(e))) {
    return make_sequence(self2, [e, make_node(AST_True, self2)]).optimize(compressor);
  }
  var seq2 = self2.lift_sequences(compressor);
  if (seq2 !== self2) {
    return seq2;
  }
  if (compressor.option("side_effects") && self2.operator == "void") {
    e = e.drop_side_effect_free(compressor);
    if (e) {
      self2.expression = e;
      return self2;
    } else {
      return make_node(AST_Undefined, self2).optimize(compressor);
    }
  }
  if (compressor.in_boolean_context()) {
    switch (self2.operator) {
      case "!":
        if (e instanceof AST_UnaryPrefix && e.operator == "!") {
          return e.expression;
        }
        if (e instanceof AST_Binary) {
          self2 = best_of(compressor, self2, e.negate(compressor, first_in_statement(compressor)));
        }
        break;
      case "typeof":
        return (e instanceof AST_SymbolRef ? make_node(AST_True, self2) : make_sequence(self2, [
          e,
          make_node(AST_True, self2)
        ])).optimize(compressor);
    }
  }
  if (self2.operator == "-" && e instanceof AST_Infinity) {
    e = e.transform(compressor);
  }
  if (e instanceof AST_Binary && (self2.operator == "+" || self2.operator == "-") && (e.operator == "*" || e.operator == "/" || e.operator == "%")) {
    return make_node(AST_Binary, self2, {
      operator: e.operator,
      left: make_node(AST_UnaryPrefix, e.left, {
        operator: self2.operator,
        expression: e.left
      }),
      right: e.right
    });
  }
  if (compressor.option("evaluate")) {
    if (self2.operator === "~" && self2.expression instanceof AST_UnaryPrefix && self2.expression.operator === "~" && (compressor.in_32_bit_context() || self2.expression.expression.is_32_bit_integer())) {
      return self2.expression.expression;
    }
    if (self2.operator === "~" && e instanceof AST_Binary && e.operator === "^") {
      if (e.left instanceof AST_UnaryPrefix && e.left.operator === "~") {
        e.left = e.left.bitwise_negate(true);
      } else {
        e.right = e.right.bitwise_negate(true);
      }
      return e;
    }
  }
  if (self2.operator != "-" || !(e instanceof AST_Number || e instanceof AST_Infinity || e instanceof AST_BigInt)) {
    var ev = self2.evaluate(compressor);
    if (ev !== self2) {
      ev = make_node_from_constant(ev, self2).optimize(compressor);
      return best_of(compressor, ev, self2);
    }
  }
  return self2;
});
AST_Binary.DEFMETHOD("lift_sequences", function(compressor) {
  if (compressor.option("sequences")) {
    if (this.left instanceof AST_Sequence) {
      var x2 = this.left.expressions.slice();
      var e = this.clone();
      e.left = x2.pop();
      x2.push(e);
      return make_sequence(this, x2).optimize(compressor);
    }
    if (this.right instanceof AST_Sequence && !this.left.has_side_effects(compressor)) {
      var assign = this.operator == "=" && this.left instanceof AST_SymbolRef;
      var x2 = this.right.expressions;
      var last6 = x2.length - 1;
      for (var i = 0; i < last6; i++) {
        if (!assign && x2[i].has_side_effects(compressor)) break;
      }
      if (i == last6) {
        x2 = x2.slice();
        var e = this.clone();
        e.right = x2.pop();
        x2.push(e);
        return make_sequence(this, x2).optimize(compressor);
      } else if (i > 0) {
        var e = this.clone();
        e.right = make_sequence(this.right, x2.slice(i));
        x2 = x2.slice(0, i);
        x2.push(e);
        return make_sequence(this, x2).optimize(compressor);
      }
    }
  }
  return this;
});
var commutativeOperators = makePredicate("== === != !== * & | ^");
function is_object(node) {
  return node instanceof AST_Array || node instanceof AST_Lambda || node instanceof AST_Object || node instanceof AST_Class;
}
def_optimize(AST_Binary, function(self2, compressor) {
  function reversible() {
    return self2.left.is_constant() || self2.right.is_constant() || !self2.left.has_side_effects(compressor) && !self2.right.has_side_effects(compressor);
  }
  function reverse4(op) {
    if (reversible()) {
      if (op) self2.operator = op;
      var tmp = self2.left;
      self2.left = self2.right;
      self2.right = tmp;
    }
  }
  if (compressor.option("lhs_constants") && commutativeOperators.has(self2.operator)) {
    if (self2.right.is_constant() && !self2.left.is_constant()) {
      if (!(self2.left instanceof AST_Binary && PRECEDENCE[self2.left.operator] >= PRECEDENCE[self2.operator])) {
        reverse4();
      }
    }
  }
  self2 = self2.lift_sequences(compressor);
  if (compressor.option("comparisons")) switch (self2.operator) {
    case "===":
    case "!==":
      var is_strict_comparison = true;
      if (self2.left.is_string(compressor) && self2.right.is_string(compressor) || self2.left.is_number(compressor) && self2.right.is_number(compressor) || self2.left.is_boolean() && self2.right.is_boolean() || self2.left.equivalent_to(self2.right)) {
        self2.operator = self2.operator.substr(0, 2);
      }
    // XXX: intentionally falling down to the next case
    case "==":
    case "!=":
      if (!is_strict_comparison && is_undefined(self2.left, compressor)) {
        self2.left = make_node(AST_Null, self2.left);
      } else if (!is_strict_comparison && is_undefined(self2.right, compressor)) {
        self2.right = make_node(AST_Null, self2.right);
      } else if (compressor.option("typeofs") && self2.left instanceof AST_String && self2.left.value == "undefined" && self2.right instanceof AST_UnaryPrefix && self2.right.operator == "typeof") {
        var expr = self2.right.expression;
        if (expr instanceof AST_SymbolRef ? expr.is_declared(compressor) : !(expr instanceof AST_PropAccess && compressor.option("ie8"))) {
          self2.right = expr;
          self2.left = make_node(AST_Undefined, self2.left).optimize(compressor);
          if (self2.operator.length == 2) self2.operator += "=";
        }
      } else if (compressor.option("typeofs") && self2.left instanceof AST_UnaryPrefix && self2.left.operator == "typeof" && self2.right instanceof AST_String && self2.right.value == "undefined") {
        var expr = self2.left.expression;
        if (expr instanceof AST_SymbolRef ? expr.is_declared(compressor) : !(expr instanceof AST_PropAccess && compressor.option("ie8"))) {
          self2.left = expr;
          self2.right = make_node(AST_Undefined, self2.right).optimize(compressor);
          if (self2.operator.length == 2) self2.operator += "=";
        }
      } else if (self2.left instanceof AST_SymbolRef && self2.right instanceof AST_SymbolRef && self2.left.definition() === self2.right.definition() && is_object(self2.left.fixed_value())) {
        return make_node(self2.operator[0] == "=" ? AST_True : AST_False, self2);
      } else if (self2.left.is_32_bit_integer() && self2.right.is_32_bit_integer()) {
        const not2 = (node) => make_node(AST_UnaryPrefix, node, {
          operator: "!",
          expression: node
        });
        const booleanify = (node, truthy) => {
          if (truthy) {
            return compressor.in_boolean_context() ? node : not2(not2(node));
          } else {
            return not2(node);
          }
        };
        if (self2.left instanceof AST_Number && self2.left.value === 0) {
          return booleanify(self2.right, self2.operator[0] === "!");
        }
        if (self2.right instanceof AST_Number && self2.right.value === 0) {
          return booleanify(self2.left, self2.operator[0] === "!");
        }
        let and_op, x2, mask;
        if ((and_op = self2.left instanceof AST_Binary ? self2.left : self2.right instanceof AST_Binary ? self2.right : null) && (mask = and_op === self2.left ? self2.right : self2.left) && and_op.operator === "&" && mask instanceof AST_Number && mask.is_32_bit_integer() && (x2 = and_op.left.equivalent_to(mask) ? and_op.right : and_op.right.equivalent_to(mask) ? and_op.left : null)) {
          let optimized = booleanify(make_node(AST_Binary, self2, {
            operator: "&",
            left: mask,
            right: make_node(AST_UnaryPrefix, self2, {
              operator: "~",
              expression: x2
            })
          }), self2.operator[0] === "!");
          return best_of(compressor, optimized, self2);
        }
      }
      break;
    case "&&":
    case "||":
      var lhs = self2.left;
      if (lhs.operator == self2.operator) {
        lhs = lhs.right;
      }
      if (lhs instanceof AST_Binary && lhs.operator == (self2.operator == "&&" ? "!==" : "===") && self2.right instanceof AST_Binary && lhs.operator == self2.right.operator && (is_undefined(lhs.left, compressor) && self2.right.left instanceof AST_Null || lhs.left instanceof AST_Null && is_undefined(self2.right.left, compressor)) && !lhs.right.has_side_effects(compressor) && lhs.right.equivalent_to(self2.right.right)) {
        var combined = make_node(AST_Binary, self2, {
          operator: lhs.operator.slice(0, -1),
          left: make_node(AST_Null, self2),
          right: lhs.right
        });
        if (lhs !== self2.left) {
          combined = make_node(AST_Binary, self2, {
            operator: self2.operator,
            left: self2.left.left,
            right: combined
          });
        }
        return combined;
      }
      break;
  }
  if (self2.operator == "+" && compressor.in_boolean_context()) {
    var ll = self2.left.evaluate(compressor);
    var rr = self2.right.evaluate(compressor);
    if (ll && typeof ll == "string") {
      return make_sequence(self2, [
        self2.right,
        make_node(AST_True, self2)
      ]).optimize(compressor);
    }
    if (rr && typeof rr == "string") {
      return make_sequence(self2, [
        self2.left,
        make_node(AST_True, self2)
      ]).optimize(compressor);
    }
  }
  if (compressor.option("comparisons") && self2.is_boolean()) {
    if (!(compressor.parent() instanceof AST_Binary) || compressor.parent() instanceof AST_Assign) {
      var negated = make_node(AST_UnaryPrefix, self2, {
        operator: "!",
        expression: self2.negate(compressor, first_in_statement(compressor))
      });
      self2 = best_of(compressor, self2, negated);
    }
    if (compressor.option("unsafe_comps")) {
      switch (self2.operator) {
        case "<":
          reverse4(">");
          break;
        case "<=":
          reverse4(">=");
          break;
      }
    }
  }
  if (self2.operator == "+") {
    if (self2.right instanceof AST_String && self2.right.getValue() == "" && self2.left.is_string(compressor)) {
      return self2.left;
    }
    if (self2.left instanceof AST_String && self2.left.getValue() == "" && self2.right.is_string(compressor)) {
      return self2.right;
    }
    if (self2.left instanceof AST_Binary && self2.left.operator == "+" && self2.left.left instanceof AST_String && self2.left.left.getValue() == "" && self2.right.is_string(compressor)) {
      self2.left = self2.left.right;
      return self2;
    }
  }
  if (compressor.option("evaluate")) {
    switch (self2.operator) {
      case "&&":
        var ll = has_flag(self2.left, TRUTHY) ? true : has_flag(self2.left, FALSY) ? false : self2.left.evaluate(compressor);
        if (!ll) {
          return maintain_this_binding(compressor.parent(), compressor.self(), self2.left).optimize(compressor);
        } else if (!(ll instanceof AST_Node)) {
          return make_sequence(self2, [self2.left, self2.right]).optimize(compressor);
        }
        var rr = self2.right.evaluate(compressor);
        if (!rr) {
          if (compressor.in_boolean_context()) {
            return make_sequence(self2, [
              self2.left,
              make_node(AST_False, self2)
            ]).optimize(compressor);
          } else {
            set_flag(self2, FALSY);
          }
        } else if (!(rr instanceof AST_Node)) {
          var parent = compressor.parent();
          if (parent.operator == "&&" && parent.left === compressor.self() || compressor.in_boolean_context()) {
            return self2.left.optimize(compressor);
          }
        }
        if (self2.left.operator == "||") {
          var lr = self2.left.right.evaluate(compressor);
          if (!lr) return make_node(AST_Conditional, self2, {
            condition: self2.left.left,
            consequent: self2.right,
            alternative: self2.left.right
          }).optimize(compressor);
        }
        break;
      case "||":
        var ll = has_flag(self2.left, TRUTHY) ? true : has_flag(self2.left, FALSY) ? false : self2.left.evaluate(compressor);
        if (!ll) {
          return make_sequence(self2, [self2.left, self2.right]).optimize(compressor);
        } else if (!(ll instanceof AST_Node)) {
          return maintain_this_binding(compressor.parent(), compressor.self(), self2.left).optimize(compressor);
        }
        var rr = self2.right.evaluate(compressor);
        if (!rr) {
          var parent = compressor.parent();
          if (parent.operator == "||" && parent.left === compressor.self() || compressor.in_boolean_context()) {
            return self2.left.optimize(compressor);
          }
        } else if (!(rr instanceof AST_Node)) {
          if (compressor.in_boolean_context()) {
            return make_sequence(self2, [
              self2.left,
              make_node(AST_True, self2)
            ]).optimize(compressor);
          } else {
            set_flag(self2, TRUTHY);
          }
        }
        if (self2.left.operator == "&&") {
          var lr = self2.left.right.evaluate(compressor);
          if (lr && !(lr instanceof AST_Node)) return make_node(AST_Conditional, self2, {
            condition: self2.left.left,
            consequent: self2.left.right,
            alternative: self2.right
          }).optimize(compressor);
        }
        break;
      case "??":
        if (is_nullish(self2.left, compressor)) {
          return self2.right;
        }
        var ll = self2.left.evaluate(compressor);
        if (!(ll instanceof AST_Node)) {
          return ll == null ? self2.right : self2.left;
        }
        if (compressor.in_boolean_context()) {
          const rr2 = self2.right.evaluate(compressor);
          if (!(rr2 instanceof AST_Node) && !rr2) {
            return self2.left;
          }
        }
    }
    var associative = true;
    switch (self2.operator) {
      case "+":
        if (self2.right instanceof AST_Constant && self2.left instanceof AST_Binary && self2.left.operator == "+" && self2.left.is_string(compressor)) {
          var binary = make_node(AST_Binary, self2, {
            operator: "+",
            left: self2.left.right,
            right: self2.right
          });
          var r = binary.optimize(compressor);
          if (binary !== r) {
            self2 = make_node(AST_Binary, self2, {
              operator: "+",
              left: self2.left.left,
              right: r
            });
          }
        }
        if (self2.left instanceof AST_Binary && self2.left.operator == "+" && self2.left.is_string(compressor) && self2.right instanceof AST_Binary && self2.right.operator == "+" && self2.right.is_string(compressor)) {
          var binary = make_node(AST_Binary, self2, {
            operator: "+",
            left: self2.left.right,
            right: self2.right.left
          });
          var m2 = binary.optimize(compressor);
          if (binary !== m2) {
            self2 = make_node(AST_Binary, self2, {
              operator: "+",
              left: make_node(AST_Binary, self2.left, {
                operator: "+",
                left: self2.left.left,
                right: m2
              }),
              right: self2.right.right
            });
          }
        }
        if (self2.right instanceof AST_UnaryPrefix && self2.right.operator == "-" && self2.left.is_number(compressor)) {
          self2 = make_node(AST_Binary, self2, {
            operator: "-",
            left: self2.left,
            right: self2.right.expression
          });
          break;
        }
        if (self2.left instanceof AST_UnaryPrefix && self2.left.operator == "-" && reversible() && self2.right.is_number(compressor)) {
          self2 = make_node(AST_Binary, self2, {
            operator: "-",
            left: self2.right,
            right: self2.left.expression
          });
          break;
        }
        if (self2.left instanceof AST_TemplateString) {
          var l = self2.left;
          var r = self2.right.evaluate(compressor);
          if (r != self2.right) {
            l.segments[l.segments.length - 1].value += String(r);
            return l;
          }
        }
        if (self2.right instanceof AST_TemplateString) {
          var r = self2.right;
          var l = self2.left.evaluate(compressor);
          if (l != self2.left) {
            r.segments[0].value = String(l) + r.segments[0].value;
            return r;
          }
        }
        if (self2.left instanceof AST_TemplateString && self2.right instanceof AST_TemplateString) {
          var l = self2.left;
          var segments = l.segments;
          var r = self2.right;
          segments[segments.length - 1].value += r.segments[0].value;
          for (var i = 1; i < r.segments.length; i++) {
            segments.push(r.segments[i]);
          }
          return l;
        }
      case "*":
        associative = compressor.option("unsafe_math");
      case "&":
      case "|":
      case "^":
        if (self2.left.is_number(compressor) && self2.right.is_number(compressor) && reversible() && !(self2.left instanceof AST_Binary && self2.left.operator != self2.operator && PRECEDENCE[self2.left.operator] >= PRECEDENCE[self2.operator])) {
          var reversed2 = make_node(AST_Binary, self2, {
            operator: self2.operator,
            left: self2.right,
            right: self2.left
          });
          if (self2.right instanceof AST_Constant && !(self2.left instanceof AST_Constant)) {
            self2 = best_of(compressor, reversed2, self2);
          } else {
            self2 = best_of(compressor, self2, reversed2);
          }
        }
        if (associative && self2.is_number(compressor)) {
          if (self2.right instanceof AST_Binary && self2.right.operator == self2.operator) {
            self2 = make_node(AST_Binary, self2, {
              operator: self2.operator,
              left: make_node(AST_Binary, self2.left, {
                operator: self2.operator,
                left: self2.left,
                right: self2.right.left,
                start: self2.left.start,
                end: self2.right.left.end
              }),
              right: self2.right.right
            });
          }
          if (self2.right instanceof AST_Constant && self2.left instanceof AST_Binary && self2.left.operator == self2.operator) {
            if (self2.left.left instanceof AST_Constant) {
              self2 = make_node(AST_Binary, self2, {
                operator: self2.operator,
                left: make_node(AST_Binary, self2.left, {
                  operator: self2.operator,
                  left: self2.left.left,
                  right: self2.right,
                  start: self2.left.left.start,
                  end: self2.right.end
                }),
                right: self2.left.right
              });
            } else if (self2.left.right instanceof AST_Constant) {
              self2 = make_node(AST_Binary, self2, {
                operator: self2.operator,
                left: make_node(AST_Binary, self2.left, {
                  operator: self2.operator,
                  left: self2.left.right,
                  right: self2.right,
                  start: self2.left.right.start,
                  end: self2.right.end
                }),
                right: self2.left.left
              });
            }
          }
          if (self2.left instanceof AST_Binary && self2.left.operator == self2.operator && self2.left.right instanceof AST_Constant && self2.right instanceof AST_Binary && self2.right.operator == self2.operator && self2.right.left instanceof AST_Constant) {
            self2 = make_node(AST_Binary, self2, {
              operator: self2.operator,
              left: make_node(AST_Binary, self2.left, {
                operator: self2.operator,
                left: make_node(AST_Binary, self2.left.left, {
                  operator: self2.operator,
                  left: self2.left.right,
                  right: self2.right.left,
                  start: self2.left.right.start,
                  end: self2.right.left.end
                }),
                right: self2.left.left
              }),
              right: self2.right.right
            });
          }
        }
    }
    if (bitwise_binop.has(self2.operator)) {
      let y, z2, x_node, y_node, z_node = self2.left;
      if (self2.operator === "&" && self2.right instanceof AST_Binary && self2.right.operator === "|" && typeof (z2 = self2.left.evaluate(compressor)) === "number") {
        if (typeof (y = self2.right.right.evaluate(compressor)) === "number") {
          x_node = self2.right.left;
          y_node = self2.right.right;
        } else if (typeof (y = self2.right.left.evaluate(compressor)) === "number") {
          x_node = self2.right.right;
          y_node = self2.right.left;
        }
        if (x_node && y_node) {
          if ((y & z2) === 0) {
            self2 = make_node(AST_Binary, self2, {
              operator: self2.operator,
              left: z_node,
              right: x_node
            });
          } else {
            const reordered_ops = make_node(AST_Binary, self2, {
              operator: "|",
              left: make_node(AST_Binary, self2, {
                operator: "&",
                left: x_node,
                right: z_node
              }),
              right: make_node_from_constant(y & z2, y_node)
            });
            self2 = best_of(compressor, self2, reordered_ops);
          }
        }
      }
      const same_operands = self2.left.equivalent_to(self2.right) && !self2.left.has_side_effects(compressor);
      if (same_operands) {
        if (self2.operator === "^") {
          return make_node(AST_Number, self2, { value: 0 });
        }
        if (self2.operator === "|" || self2.operator === "&") {
          self2.left = make_node(AST_Number, self2, { value: 0 });
          self2.operator = "|";
        }
      }
      if ((self2.operator === "<<" || self2.operator === ">>") && self2.right instanceof AST_Number && self2.right.value === 0) {
        self2.operator = "|";
      }
      const zero_side = self2.right instanceof AST_Number && self2.right.value === 0 ? self2.right : self2.left instanceof AST_Number && self2.left.value === 0 ? self2.left : null;
      const non_zero_side = zero_side && (zero_side === self2.right ? self2.left : self2.right);
      if (zero_side && (self2.operator === "|" || self2.operator === "^") && (non_zero_side.is_32_bit_integer() || compressor.in_32_bit_context())) {
        return non_zero_side;
      }
      if (zero_side && self2.operator === "&" && !non_zero_side.has_side_effects(compressor)) {
        return zero_side;
      }
      const is_full_mask = (node) => node instanceof AST_Number && node.value === -1 || node instanceof AST_UnaryPrefix && (node.operator === "-" && node.expression instanceof AST_Number && node.expression.value === 1 || node.operator === "~" && node.expression instanceof AST_Number && node.expression.value === 0);
      const full_mask = is_full_mask(self2.right) ? self2.right : is_full_mask(self2.left) ? self2.left : null;
      const non_full_mask_side = full_mask && (full_mask === self2.right ? self2.left : self2.right);
      switch (self2.operator) {
        case "|":
          if (full_mask && !non_full_mask_side.has_side_effects(compressor)) {
            return full_mask;
          }
          break;
        case "&":
          if (full_mask && (non_full_mask_side.is_32_bit_integer() || compressor.in_32_bit_context())) {
            return non_full_mask_side;
          }
          break;
        case "^":
          if (full_mask) {
            return non_full_mask_side.bitwise_negate(compressor.in_32_bit_context());
          }
          if (self2.left instanceof AST_UnaryPrefix && self2.left.operator === "~" && self2.right instanceof AST_UnaryPrefix && self2.right.operator === "~") {
            self2 = make_node(AST_Binary, self2, {
              operator: "^",
              left: self2.left.expression,
              right: self2.right.expression
            });
          }
          break;
      }
    }
  }
  if (self2.right instanceof AST_Binary && self2.right.operator == self2.operator && (lazy_op.has(self2.operator) || self2.operator == "+" && (self2.right.left.is_string(compressor) || self2.left.is_string(compressor) && self2.right.right.is_string(compressor)))) {
    self2.left = make_node(AST_Binary, self2.left, {
      operator: self2.operator,
      left: self2.left.transform(compressor),
      right: self2.right.left.transform(compressor)
    });
    self2.right = self2.right.right.transform(compressor);
    return self2.transform(compressor);
  }
  var ev = self2.evaluate(compressor);
  if (ev !== self2) {
    ev = make_node_from_constant(ev, self2).optimize(compressor);
    return best_of(compressor, ev, self2);
  }
  return self2;
});
def_optimize(AST_SymbolExport, function(self2) {
  return self2;
});
def_optimize(AST_SymbolRef, function(self2, compressor) {
  if (!compressor.option("ie8") && is_undeclared_ref(self2) && !compressor.find_parent(AST_With)) {
    switch (self2.name) {
      case "undefined":
        return make_node(AST_Undefined, self2).optimize(compressor);
      case "NaN":
        return make_node(AST_NaN, self2).optimize(compressor);
      case "Infinity":
        return make_node(AST_Infinity, self2).optimize(compressor);
    }
  }
  if (compressor.option("reduce_vars") && !compressor.is_lhs()) {
    return inline_into_symbolref(self2, compressor);
  } else {
    return self2;
  }
});
function is_atomic(lhs, self2) {
  return lhs instanceof AST_SymbolRef || lhs.TYPE === self2.TYPE;
}
def_optimize(AST_Undefined, function(self2, compressor) {
  if (compressor.option("unsafe_undefined")) {
    var undef = find_variable(compressor, "undefined");
    if (undef) {
      var ref = make_node(AST_SymbolRef, self2, {
        name: "undefined",
        scope: undef.scope,
        thedef: undef
      });
      set_flag(ref, UNDEFINED);
      return ref;
    }
  }
  var lhs = compressor.is_lhs();
  if (lhs && is_atomic(lhs, self2)) return self2;
  return make_node(AST_UnaryPrefix, self2, {
    operator: "void",
    expression: make_node(AST_Number, self2, {
      value: 0
    })
  });
});
def_optimize(AST_Infinity, function(self2, compressor) {
  var lhs = compressor.is_lhs();
  if (lhs && is_atomic(lhs, self2)) return self2;
  if (compressor.option("keep_infinity") && !(lhs && !is_atomic(lhs, self2)) && !find_variable(compressor, "Infinity")) {
    return self2;
  }
  return make_node(AST_Binary, self2, {
    operator: "/",
    left: make_node(AST_Number, self2, {
      value: 1
    }),
    right: make_node(AST_Number, self2, {
      value: 0
    })
  });
});
def_optimize(AST_NaN, function(self2, compressor) {
  var lhs = compressor.is_lhs();
  if (lhs && !is_atomic(lhs, self2) || find_variable(compressor, "NaN")) {
    return make_node(AST_Binary, self2, {
      operator: "/",
      left: make_node(AST_Number, self2, {
        value: 0
      }),
      right: make_node(AST_Number, self2, {
        value: 0
      })
    });
  }
  return self2;
});
var ASSIGN_OPS = makePredicate("+ - / * % >> << >>> | ^ &");
var ASSIGN_OPS_COMMUTATIVE = makePredicate("* | ^ &");
def_optimize(AST_Assign, function(self2, compressor) {
  if (self2.logical) {
    return self2.lift_sequences(compressor);
  }
  var def;
  if (self2.operator === "=" && self2.left instanceof AST_SymbolRef && self2.left.name !== "arguments" && !(def = self2.left.definition()).undeclared && self2.right.equivalent_to(self2.left)) {
    return self2.right;
  }
  if (compressor.option("dead_code") && self2.left instanceof AST_SymbolRef && (def = self2.left.definition()).scope === compressor.find_parent(AST_Lambda)) {
    var level = 0, node, parent = self2;
    do {
      node = parent;
      parent = compressor.parent(level++);
      if (parent instanceof AST_Exit) {
        if (in_try(level, parent)) break;
        if (is_reachable(def.scope, [def])) break;
        if (self2.operator == "=") return self2.right;
        def.fixed = false;
        return make_node(AST_Binary, self2, {
          operator: self2.operator.slice(0, -1),
          left: self2.left,
          right: self2.right
        }).optimize(compressor);
      }
    } while (parent instanceof AST_Binary && parent.right === node || parent instanceof AST_Sequence && parent.tail_node() === node);
  }
  self2 = self2.lift_sequences(compressor);
  if (self2.operator == "=" && self2.left instanceof AST_SymbolRef && self2.right instanceof AST_Binary) {
    if (self2.right.left instanceof AST_SymbolRef && self2.right.left.name == self2.left.name && ASSIGN_OPS.has(self2.right.operator)) {
      self2.operator = self2.right.operator + "=";
      self2.right = self2.right.right;
    } else if (self2.right.right instanceof AST_SymbolRef && self2.right.right.name == self2.left.name && ASSIGN_OPS_COMMUTATIVE.has(self2.right.operator) && !self2.right.left.has_side_effects(compressor)) {
      self2.operator = self2.right.operator + "=";
      self2.right = self2.right.left;
    }
  }
  return self2;
  function in_try(level2, node2) {
    function may_assignment_throw() {
      const right3 = self2.right;
      self2.right = make_node(AST_Null, right3);
      const may_throw = node2.may_throw(compressor);
      self2.right = right3;
      return may_throw;
    }
    var stop_at = self2.left.definition().scope.get_defun_scope();
    var parent2;
    while ((parent2 = compressor.parent(level2++)) !== stop_at) {
      if (parent2 instanceof AST_Try) {
        if (parent2.bfinally) return true;
        if (parent2.bcatch && may_assignment_throw()) return true;
      }
    }
  }
});
def_optimize(AST_DefaultAssign, function(self2, compressor) {
  if (!compressor.option("evaluate")) {
    return self2;
  }
  var evaluateRight = self2.right.evaluate(compressor);
  let lambda, iife2;
  if (evaluateRight === void 0) {
    if ((lambda = compressor.parent()) instanceof AST_Lambda ? compressor.option("keep_fargs") === false || (iife2 = compressor.parent(1)).TYPE === "Call" && iife2.expression === lambda : true) {
      self2 = self2.left;
    }
  } else if (evaluateRight !== self2.right) {
    evaluateRight = make_node_from_constant(evaluateRight, self2.right);
    self2.right = best_of_expression(evaluateRight, self2.right);
  }
  return self2;
});
function is_nullish_check(check2, check_subject, compressor) {
  if (check_subject.may_throw(compressor)) return false;
  let nullish_side;
  if (check2 instanceof AST_Binary && check2.operator === "==" && ((nullish_side = is_nullish(check2.left, compressor) && check2.left) || (nullish_side = is_nullish(check2.right, compressor) && check2.right)) && (nullish_side === check2.left ? check2.right : check2.left).equivalent_to(check_subject)) {
    return true;
  }
  if (check2 instanceof AST_Binary && check2.operator === "||") {
    let null_cmp;
    let undefined_cmp;
    const find_comparison = (cmp) => {
      if (!(cmp instanceof AST_Binary && (cmp.operator === "===" || cmp.operator === "=="))) {
        return false;
      }
      let found2 = 0;
      let defined_side;
      if (cmp.left instanceof AST_Null) {
        found2++;
        null_cmp = cmp;
        defined_side = cmp.right;
      }
      if (cmp.right instanceof AST_Null) {
        found2++;
        null_cmp = cmp;
        defined_side = cmp.left;
      }
      if (is_undefined(cmp.left, compressor)) {
        found2++;
        undefined_cmp = cmp;
        defined_side = cmp.right;
      }
      if (is_undefined(cmp.right, compressor)) {
        found2++;
        undefined_cmp = cmp;
        defined_side = cmp.left;
      }
      if (found2 !== 1) {
        return false;
      }
      if (!defined_side.equivalent_to(check_subject)) {
        return false;
      }
      return true;
    };
    if (!find_comparison(check2.left)) return false;
    if (!find_comparison(check2.right)) return false;
    if (null_cmp && undefined_cmp && null_cmp !== undefined_cmp) {
      return true;
    }
  }
  return false;
}
def_optimize(AST_Conditional, function(self2, compressor) {
  if (!compressor.option("conditionals")) return self2;
  if (self2.condition instanceof AST_Sequence) {
    var expressions = self2.condition.expressions.slice();
    self2.condition = expressions.pop();
    expressions.push(self2);
    return make_sequence(self2, expressions);
  }
  var cond = self2.condition.evaluate(compressor);
  if (cond !== self2.condition) {
    if (cond) {
      return maintain_this_binding(compressor.parent(), compressor.self(), self2.consequent);
    } else {
      return maintain_this_binding(compressor.parent(), compressor.self(), self2.alternative);
    }
  }
  var negated = cond.negate(compressor, first_in_statement(compressor));
  if (best_of(compressor, cond, negated) === negated) {
    self2 = make_node(AST_Conditional, self2, {
      condition: negated,
      consequent: self2.alternative,
      alternative: self2.consequent
    });
  }
  var condition = self2.condition;
  var consequent = self2.consequent;
  var alternative = self2.alternative;
  if (condition instanceof AST_SymbolRef && consequent instanceof AST_SymbolRef && condition.definition() === consequent.definition()) {
    return make_node(AST_Binary, self2, {
      operator: "||",
      left: condition,
      right: alternative
    });
  }
  if (consequent instanceof AST_Assign && alternative instanceof AST_Assign && consequent.operator === alternative.operator && consequent.logical === alternative.logical && consequent.left.equivalent_to(alternative.left) && (!self2.condition.has_side_effects(compressor) || consequent.operator == "=" && !consequent.left.has_side_effects(compressor))) {
    return make_node(AST_Assign, self2, {
      operator: consequent.operator,
      left: consequent.left,
      logical: consequent.logical,
      right: make_node(AST_Conditional, self2, {
        condition: self2.condition,
        consequent: consequent.right,
        alternative: alternative.right
      })
    });
  }
  var arg_index;
  if (consequent instanceof AST_Call && alternative.TYPE === consequent.TYPE && consequent.args.length > 0 && consequent.args.length == alternative.args.length && consequent.expression.equivalent_to(alternative.expression) && !self2.condition.has_side_effects(compressor) && !consequent.expression.has_side_effects(compressor) && typeof (arg_index = single_arg_diff()) == "number") {
    var node = consequent.clone();
    node.args[arg_index] = make_node(AST_Conditional, self2, {
      condition: self2.condition,
      consequent: consequent.args[arg_index],
      alternative: alternative.args[arg_index]
    });
    return node;
  }
  if (alternative instanceof AST_Conditional && consequent.equivalent_to(alternative.consequent)) {
    return make_node(AST_Conditional, self2, {
      condition: make_node(AST_Binary, self2, {
        operator: "||",
        left: condition,
        right: alternative.condition
      }),
      consequent,
      alternative: alternative.alternative
    }).optimize(compressor);
  }
  if (compressor.option("ecma") >= 2020 && is_nullish_check(condition, alternative, compressor)) {
    return make_node(AST_Binary, self2, {
      operator: "??",
      left: alternative,
      right: consequent
    }).optimize(compressor);
  }
  if (alternative instanceof AST_Sequence && consequent.equivalent_to(alternative.expressions[alternative.expressions.length - 1])) {
    return make_sequence(self2, [
      make_node(AST_Binary, self2, {
        operator: "||",
        left: condition,
        right: make_sequence(self2, alternative.expressions.slice(0, -1))
      }),
      consequent
    ]).optimize(compressor);
  }
  if (alternative instanceof AST_Binary && alternative.operator == "&&" && consequent.equivalent_to(alternative.right)) {
    return make_node(AST_Binary, self2, {
      operator: "&&",
      left: make_node(AST_Binary, self2, {
        operator: "||",
        left: condition,
        right: alternative.left
      }),
      right: consequent
    }).optimize(compressor);
  }
  if (consequent instanceof AST_Conditional && consequent.alternative.equivalent_to(alternative)) {
    return make_node(AST_Conditional, self2, {
      condition: make_node(AST_Binary, self2, {
        left: self2.condition,
        operator: "&&",
        right: consequent.condition
      }),
      consequent: consequent.consequent,
      alternative
    });
  }
  if (consequent.equivalent_to(alternative)) {
    return make_sequence(self2, [
      self2.condition,
      consequent
    ]).optimize(compressor);
  }
  if (consequent instanceof AST_Binary && consequent.operator == "||" && consequent.right.equivalent_to(alternative)) {
    return make_node(AST_Binary, self2, {
      operator: "||",
      left: make_node(AST_Binary, self2, {
        operator: "&&",
        left: self2.condition,
        right: consequent.left
      }),
      right: alternative
    }).optimize(compressor);
  }
  const in_bool = compressor.in_boolean_context();
  if (is_true(self2.consequent)) {
    if (is_false(self2.alternative)) {
      return booleanize(self2.condition);
    }
    return make_node(AST_Binary, self2, {
      operator: "||",
      left: booleanize(self2.condition),
      right: self2.alternative
    });
  }
  if (is_false(self2.consequent)) {
    if (is_true(self2.alternative)) {
      return booleanize(self2.condition.negate(compressor));
    }
    return make_node(AST_Binary, self2, {
      operator: "&&",
      left: booleanize(self2.condition.negate(compressor)),
      right: self2.alternative
    });
  }
  if (is_true(self2.alternative)) {
    return make_node(AST_Binary, self2, {
      operator: "||",
      left: booleanize(self2.condition.negate(compressor)),
      right: self2.consequent
    });
  }
  if (is_false(self2.alternative)) {
    return make_node(AST_Binary, self2, {
      operator: "&&",
      left: booleanize(self2.condition),
      right: self2.consequent
    });
  }
  return self2;
  function booleanize(node2) {
    if (node2.is_boolean()) return node2;
    return make_node(AST_UnaryPrefix, node2, {
      operator: "!",
      expression: node2.negate(compressor)
    });
  }
  function is_true(node2) {
    return node2 instanceof AST_True || in_bool && node2 instanceof AST_Constant && node2.getValue() || node2 instanceof AST_UnaryPrefix && node2.operator == "!" && node2.expression instanceof AST_Constant && !node2.expression.getValue();
  }
  function is_false(node2) {
    return node2 instanceof AST_False || in_bool && node2 instanceof AST_Constant && !node2.getValue() || node2 instanceof AST_UnaryPrefix && node2.operator == "!" && node2.expression instanceof AST_Constant && node2.expression.getValue();
  }
  function single_arg_diff() {
    var a2 = consequent.args;
    var b = alternative.args;
    for (var i = 0, len = a2.length; i < len; i++) {
      if (a2[i] instanceof AST_Expansion) return;
      if (!a2[i].equivalent_to(b[i])) {
        if (b[i] instanceof AST_Expansion) return;
        for (var j = i + 1; j < len; j++) {
          if (a2[j] instanceof AST_Expansion) return;
          if (!a2[j].equivalent_to(b[j])) return;
        }
        return i;
      }
    }
  }
});
def_optimize(AST_Boolean, function(self2, compressor) {
  if (compressor.in_boolean_context()) return make_node(AST_Number, self2, {
    value: +self2.value
  });
  var p3 = compressor.parent();
  if (compressor.option("booleans_as_integers")) {
    if (p3 instanceof AST_Binary && (p3.operator == "===" || p3.operator == "!==")) {
      p3.operator = p3.operator.replace(/=$/, "");
    }
    return make_node(AST_Number, self2, {
      value: +self2.value
    });
  }
  if (compressor.option("booleans")) {
    if (p3 instanceof AST_Binary && (p3.operator == "==" || p3.operator == "!=")) {
      return make_node(AST_Number, self2, {
        value: +self2.value
      });
    }
    return make_node(AST_UnaryPrefix, self2, {
      operator: "!",
      expression: make_node(AST_Number, self2, {
        value: 1 - self2.value
      })
    });
  }
  return self2;
});
function safe_to_flatten(value, compressor) {
  if (value instanceof AST_SymbolRef) {
    value = value.fixed_value();
  }
  if (!value) return false;
  if (!(value instanceof AST_Lambda || value instanceof AST_Class)) return true;
  if (!(value instanceof AST_Lambda && value.contains_this())) return true;
  return compressor.parent() instanceof AST_New;
}
AST_PropAccess.DEFMETHOD("flatten_object", function(key, compressor) {
  if (!compressor.option("properties")) return;
  if (key === "__proto__") return;
  if (this instanceof AST_DotHash) return;
  var arrows = compressor.option("unsafe_arrows") && compressor.option("ecma") >= 2015;
  var expr = this.expression;
  if (expr instanceof AST_Object) {
    var props = expr.properties;
    for (var i = props.length; --i >= 0; ) {
      var prop = props[i];
      if ("" + (prop instanceof AST_ConciseMethod ? prop.key.name : prop.key) == key) {
        const all_props_flattenable = props.every(
          (p3) => (p3 instanceof AST_ObjectKeyVal || arrows && p3 instanceof AST_ConciseMethod && !p3.is_generator) && !p3.computed_key()
        );
        if (!all_props_flattenable) return;
        if (!safe_to_flatten(prop.value, compressor)) return;
        return make_node(AST_Sub, this, {
          expression: make_node(AST_Array, expr, {
            elements: props.map(function(prop2) {
              var v2 = prop2.value;
              if (v2 instanceof AST_Accessor) {
                v2 = make_node(AST_Function, v2, v2);
              }
              var k = prop2.key;
              if (k instanceof AST_Node && !(k instanceof AST_SymbolMethod)) {
                return make_sequence(prop2, [k, v2]);
              }
              return v2;
            })
          }),
          property: make_node(AST_Number, this, {
            value: i
          })
        });
      }
    }
  }
});
def_optimize(AST_Sub, function(self2, compressor) {
  var expr = self2.expression;
  var prop = self2.property;
  if (compressor.option("properties")) {
    var key = prop.evaluate(compressor);
    if (key !== prop) {
      if (typeof key == "string") {
        if (key == "undefined") {
          key = void 0;
        } else {
          var value = parseFloat(key);
          if (value.toString() == key) {
            key = value;
          }
        }
      }
      prop = self2.property = best_of_expression(
        prop,
        make_node_from_constant(key, prop).transform(compressor)
      );
      var property3 = "" + key;
      if (is_basic_identifier_string(property3) && property3.length <= prop.size() + 1) {
        return make_node(AST_Dot, self2, {
          expression: expr,
          optional: self2.optional,
          property: property3,
          quote: prop.quote
        }).optimize(compressor);
      }
    }
  }
  var fn2;
  OPT_ARGUMENTS: if (compressor.option("arguments") && expr instanceof AST_SymbolRef && expr.name == "arguments" && expr.definition().orig.length == 1 && (fn2 = expr.scope) instanceof AST_Lambda && fn2.uses_arguments && !(fn2 instanceof AST_Arrow) && prop instanceof AST_Number) {
    var index = prop.getValue();
    var params = /* @__PURE__ */ new Set();
    var argnames = fn2.argnames;
    for (var n2 = 0; n2 < argnames.length; n2++) {
      if (!(argnames[n2] instanceof AST_SymbolFunarg)) {
        break OPT_ARGUMENTS;
      }
      var param = argnames[n2].name;
      if (params.has(param)) {
        break OPT_ARGUMENTS;
      }
      params.add(param);
    }
    var argname = fn2.argnames[index];
    if (argname && compressor.has_directive("use strict")) {
      var def = argname.definition();
      if (!compressor.option("reduce_vars") || def.assignments || def.orig.length > 1) {
        argname = null;
      }
    } else if (!argname && !compressor.option("keep_fargs") && index < fn2.argnames.length + 5) {
      while (index >= fn2.argnames.length) {
        argname = fn2.create_symbol(AST_SymbolFunarg, {
          source: fn2,
          scope: fn2,
          tentative_name: "argument_" + fn2.argnames.length
        });
        fn2.argnames.push(argname);
      }
    }
    if (argname) {
      var sym = make_node(AST_SymbolRef, self2, argname);
      sym.reference({});
      clear_flag(argname, UNUSED);
      return sym;
    }
  }
  if (compressor.is_lhs()) return self2;
  if (key !== prop) {
    var sub = self2.flatten_object(property3, compressor);
    if (sub) {
      expr = self2.expression = sub.expression;
      prop = self2.property = sub.property;
    }
  }
  if (compressor.option("properties") && compressor.option("side_effects") && prop instanceof AST_Number && expr instanceof AST_Array) {
    var index = prop.getValue();
    var elements = expr.elements;
    var retValue = elements[index];
    FLATTEN: if (safe_to_flatten(retValue, compressor)) {
      var flatten14 = true;
      var values3 = [];
      for (var i = elements.length; --i > index; ) {
        var value = elements[i].drop_side_effect_free(compressor);
        if (value) {
          values3.unshift(value);
          if (flatten14 && value.has_side_effects(compressor)) flatten14 = false;
        }
      }
      if (retValue instanceof AST_Expansion) break FLATTEN;
      retValue = retValue instanceof AST_Hole ? make_node(AST_Undefined, retValue) : retValue;
      if (!flatten14) values3.unshift(retValue);
      while (--i >= 0) {
        var value = elements[i];
        if (value instanceof AST_Expansion) break FLATTEN;
        value = value.drop_side_effect_free(compressor);
        if (value) values3.unshift(value);
        else index--;
      }
      if (flatten14) {
        values3.push(retValue);
        return make_sequence(self2, values3).optimize(compressor);
      } else return make_node(AST_Sub, self2, {
        expression: make_node(AST_Array, expr, {
          elements: values3
        }),
        property: make_node(AST_Number, prop, {
          value: index
        })
      });
    }
  }
  var ev = self2.evaluate(compressor);
  if (ev !== self2) {
    ev = make_node_from_constant(ev, self2).optimize(compressor);
    return best_of(compressor, ev, self2);
  }
  return self2;
});
def_optimize(AST_Chain, function(self2, compressor) {
  if (is_nullish(self2.expression, compressor)) {
    let parent = compressor.parent();
    if (parent instanceof AST_UnaryPrefix && parent.operator === "delete") {
      return make_node_from_constant(0, self2);
    }
    return make_node(AST_Undefined, self2);
  }
  if (self2.expression instanceof AST_PropAccess || self2.expression instanceof AST_Call) {
    return self2;
  } else {
    return self2.expression;
  }
});
def_optimize(AST_Dot, function(self2, compressor) {
  const parent = compressor.parent();
  if (compressor.is_lhs()) return self2;
  if (compressor.option("unsafe_proto") && self2.expression instanceof AST_Dot && self2.expression.property == "prototype") {
    var exp = self2.expression.expression;
    if (is_undeclared_ref(exp)) switch (exp.name) {
      case "Array":
        self2.expression = make_node(AST_Array, self2.expression, {
          elements: []
        });
        break;
      case "Function":
        self2.expression = make_empty_function(self2.expression);
        break;
      case "Number":
        self2.expression = make_node(AST_Number, self2.expression, {
          value: 0
        });
        break;
      case "Object":
        self2.expression = make_node(AST_Object, self2.expression, {
          properties: []
        });
        break;
      case "RegExp":
        self2.expression = make_node(AST_RegExp, self2.expression, {
          value: { source: "t", flags: "" }
        });
        break;
      case "String":
        self2.expression = make_node(AST_String, self2.expression, {
          value: ""
        });
        break;
    }
  }
  if (!(parent instanceof AST_Call) || !has_annotation(parent, _NOINLINE)) {
    const sub = self2.flatten_object(self2.property, compressor);
    if (sub) return sub.optimize(compressor);
  }
  if (self2.expression instanceof AST_PropAccess && parent instanceof AST_PropAccess) {
    return self2;
  }
  let ev = self2.evaluate(compressor);
  if (ev !== self2) {
    ev = make_node_from_constant(ev, self2).optimize(compressor);
    return best_of(compressor, ev, self2);
  }
  return self2;
});
function literals_in_boolean_context(self2, compressor) {
  if (compressor.in_boolean_context()) {
    return best_of(compressor, self2, make_sequence(self2, [
      self2,
      make_node(AST_True, self2)
    ]).optimize(compressor));
  }
  return self2;
}
function inline_array_like_spread(elements) {
  for (var i = 0; i < elements.length; i++) {
    var el = elements[i];
    if (el instanceof AST_Expansion) {
      var expr = el.expression;
      if (expr instanceof AST_Array && !expr.elements.some((elm) => elm instanceof AST_Hole)) {
        elements.splice(i, 1, ...expr.elements);
        i--;
      }
    }
  }
}
def_optimize(AST_Array, function(self2, compressor) {
  var optimized = literals_in_boolean_context(self2, compressor);
  if (optimized !== self2) {
    return optimized;
  }
  inline_array_like_spread(self2.elements);
  return self2;
});
function inline_object_prop_spread(props) {
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    if (prop instanceof AST_Expansion) {
      const expr = prop.expression;
      if (expr instanceof AST_Object && expr.properties.every((prop2) => prop2 instanceof AST_ObjectKeyVal)) {
        props.splice(i, 1, ...expr.properties);
        i--;
      } else if (
        // `expr.is_constant()` returns `false` for `AST_RegExp`, so need both.
        (expr instanceof AST_Constant || expr.is_constant()) && !(expr instanceof AST_String)
      ) {
        props.splice(i, 1);
        i--;
      }
    }
  }
}
def_optimize(AST_Object, function(self2, compressor) {
  var optimized = literals_in_boolean_context(self2, compressor);
  if (optimized !== self2) {
    return optimized;
  }
  inline_object_prop_spread(self2.properties);
  return self2;
});
def_optimize(AST_RegExp, literals_in_boolean_context);
def_optimize(AST_Return, function(self2, compressor) {
  if (self2.value && is_undefined(self2.value, compressor)) {
    self2.value = null;
  }
  return self2;
});
def_optimize(AST_Arrow, opt_AST_Lambda);
def_optimize(AST_Function, function(self2, compressor) {
  self2 = opt_AST_Lambda(self2, compressor);
  if (compressor.option("unsafe_arrows") && compressor.option("ecma") >= 2015 && !self2.name && !self2.is_generator && !self2.uses_arguments && !self2.pinned()) {
    const uses_this = walk2(self2, (node) => {
      if (node instanceof AST_This) return walk_abort;
    });
    if (!uses_this) return make_node(AST_Arrow, self2, self2).optimize(compressor);
  }
  return self2;
});
def_optimize(AST_Class, function(self2) {
  for (let i = 0; i < self2.properties.length; i++) {
    const prop = self2.properties[i];
    if (prop instanceof AST_ClassStaticBlock && prop.body.length == 0) {
      self2.properties.splice(i, 1);
      i--;
    }
  }
  return self2;
});
def_optimize(AST_ClassStaticBlock, function(self2, compressor) {
  tighten_body(self2.body, compressor);
  return self2;
});
def_optimize(AST_Yield, function(self2, compressor) {
  if (self2.expression && !self2.is_star && is_undefined(self2.expression, compressor)) {
    self2.expression = null;
  }
  return self2;
});
def_optimize(AST_TemplateString, function(self2, compressor) {
  if (!compressor.option("evaluate") || compressor.parent() instanceof AST_PrefixedTemplateString) {
    return self2;
  }
  var segments = [];
  for (var i = 0; i < self2.segments.length; i++) {
    var segment = self2.segments[i];
    if (segment instanceof AST_Node) {
      var result = segment.evaluate(compressor);
      if (result !== segment && (result + "").length <= segment.size() + "${}".length) {
        segments[segments.length - 1].value = segments[segments.length - 1].value + result + self2.segments[++i].value;
        continue;
      }
      if (segment instanceof AST_TemplateString) {
        var inners = segment.segments;
        segments[segments.length - 1].value += inners[0].value;
        for (var j = 1; j < inners.length; j++) {
          segment = inners[j];
          segments.push(segment);
        }
        continue;
      }
    }
    segments.push(segment);
  }
  self2.segments = segments;
  if (segments.length == 1) {
    return make_node(AST_String, self2, segments[0]);
  }
  if (segments.length === 3 && segments[1] instanceof AST_Node && (segments[1].is_string(compressor) || segments[1].is_number(compressor) || is_nullish(segments[1], compressor) || compressor.option("unsafe"))) {
    if (segments[2].value === "") {
      return make_node(AST_Binary, self2, {
        operator: "+",
        left: make_node(AST_String, self2, {
          value: segments[0].value
        }),
        right: segments[1]
      });
    }
    if (segments[0].value === "") {
      return make_node(AST_Binary, self2, {
        operator: "+",
        left: segments[1],
        right: make_node(AST_String, self2, {
          value: segments[2].value
        })
      });
    }
  }
  return self2;
});
def_optimize(AST_PrefixedTemplateString, function(self2) {
  return self2;
});
function lift_key(self2, compressor) {
  if (!compressor.option("computed_props")) return self2;
  if (!(self2.key instanceof AST_Constant)) return self2;
  if (self2.key instanceof AST_String || self2.key instanceof AST_Number) {
    const key = self2.key.value.toString();
    if (key === "__proto__") return self2;
    if (key == "constructor" && compressor.parent() instanceof AST_Class) return self2;
    if (self2 instanceof AST_ObjectKeyVal) {
      self2.quote = self2.key.quote;
      self2.key = key;
    } else if (self2 instanceof AST_ClassProperty) {
      self2.quote = self2.key.quote;
      self2.key = make_node(AST_SymbolClassProperty, self2.key, {
        name: key
      });
    } else {
      self2.quote = self2.key.quote;
      self2.key = make_node(AST_SymbolMethod, self2.key, {
        name: key
      });
    }
  }
  return self2;
}
def_optimize(AST_ObjectProperty, lift_key);
def_optimize(AST_ConciseMethod, function(self2, compressor) {
  lift_key(self2, compressor);
  if (compressor.option("arrows") && compressor.parent() instanceof AST_Object && !self2.is_generator && !self2.value.uses_arguments && !self2.value.pinned() && self2.value.body.length == 1 && self2.value.body[0] instanceof AST_Return && self2.value.body[0].value && !self2.value.contains_this()) {
    var arrow = make_node(AST_Arrow, self2.value, self2.value);
    arrow.async = self2.async;
    arrow.is_generator = self2.is_generator;
    return make_node(AST_ObjectKeyVal, self2, {
      key: self2.key instanceof AST_SymbolMethod ? self2.key.name : self2.key,
      value: arrow,
      quote: self2.quote
    });
  }
  return self2;
});
def_optimize(AST_ObjectKeyVal, function(self2, compressor) {
  lift_key(self2, compressor);
  var unsafe_methods = compressor.option("unsafe_methods");
  if (unsafe_methods && compressor.option("ecma") >= 2015 && (!(unsafe_methods instanceof RegExp) || unsafe_methods.test(self2.key + ""))) {
    var key = self2.key;
    var value = self2.value;
    var is_arrow_with_block = value instanceof AST_Arrow && Array.isArray(value.body) && !value.contains_this();
    if ((is_arrow_with_block || value instanceof AST_Function) && !value.name) {
      return make_node(AST_ConciseMethod, self2, {
        async: value.async,
        is_generator: value.is_generator,
        key: key instanceof AST_Node ? key : make_node(AST_SymbolMethod, self2, {
          name: key
        }),
        value: make_node(AST_Accessor, value, value),
        quote: self2.quote
      });
    }
  }
  return self2;
});
def_optimize(AST_Destructuring, function(self2, compressor) {
  if (compressor.option("pure_getters") == true && compressor.option("unused") && !self2.is_array && Array.isArray(self2.names) && !is_destructuring_export_decl(compressor) && !(self2.names[self2.names.length - 1] instanceof AST_Expansion)) {
    var keep = [];
    for (var i = 0; i < self2.names.length; i++) {
      var elem = self2.names[i];
      if (!(elem instanceof AST_ObjectKeyVal && typeof elem.key == "string" && elem.value instanceof AST_SymbolDeclaration && !should_retain(compressor, elem.value.definition()))) {
        keep.push(elem);
      }
    }
    if (keep.length != self2.names.length) {
      self2.names = keep;
    }
  }
  return self2;
  function is_destructuring_export_decl(compressor2) {
    var ancestors = [/^VarDef$/, /^(Const|Let|Var)$/, /^Export$/];
    for (var a2 = 0, p3 = 0, len = ancestors.length; a2 < len; p3++) {
      var parent = compressor2.parent(p3);
      if (!parent) return false;
      if (a2 === 0 && parent.TYPE == "Destructuring") continue;
      if (!ancestors[a2].test(parent.TYPE)) {
        return false;
      }
      a2++;
    }
    return true;
  }
  function should_retain(compressor2, def) {
    if (def.references.length) return true;
    if (!def.global) return false;
    if (compressor2.toplevel.vars) {
      if (compressor2.top_retain) {
        return compressor2.top_retain(def);
      }
      return false;
    }
    return true;
  }
});

// node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.0/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
function decodeInteger(reader, relative4) {
  let value = 0;
  let shift2 = 0;
  let integer3 = 0;
  do {
    const c = reader.next();
    integer3 = charToInt[c];
    value |= (integer3 & 31) << shift2;
    shift2 += 5;
  } while (integer3 & 32);
  const shouldNegate = value & 1;
  value >>>= 1;
  if (shouldNegate) {
    value = -2147483648 | -value;
  }
  return relative4 + value;
}
function encodeInteger(builder, num, relative4) {
  let delta = num - relative4;
  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
  do {
    let clamped = delta & 31;
    delta >>>= 5;
    if (delta > 0)
      clamped |= 32;
    builder.write(intToChar[clamped]);
  } while (delta > 0);
  return num;
}
function hasMoreVlq(reader, max5) {
  if (reader.pos >= max5)
    return false;
  return reader.peek() !== comma;
}
var bufLength = 1024 * 16;
var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = "";
    for (let i = 0; i < buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};
var StringWriter = class {
  constructor() {
    this.pos = 0;
    this.out = "";
    this.buffer = new Uint8Array(bufLength);
  }
  write(v2) {
    const { buffer: buffer4 } = this;
    buffer4[this.pos++] = v2;
    if (this.pos === bufLength) {
      this.out += td.decode(buffer4);
      this.pos = 0;
    }
  }
  flush() {
    const { buffer: buffer4, out, pos } = this;
    return pos > 0 ? out + td.decode(buffer4.subarray(0, pos)) : out;
  }
};
var StringReader = class {
  constructor(buffer4) {
    this.pos = 0;
    this.buffer = buffer4;
  }
  next() {
    return this.buffer.charCodeAt(this.pos++);
  }
  peek() {
    return this.buffer.charCodeAt(this.pos);
  }
  indexOf(char) {
    const { buffer: buffer4, pos } = this;
    const idx = buffer4.indexOf(char, pos);
    return idx === -1 ? buffer4.length : idx;
  }
};
function decode2(mappings) {
  const { length: length3 } = mappings;
  const reader = new StringReader(mappings);
  const decoded = [];
  let genColumn = 0;
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  do {
    const semi = reader.indexOf(";");
    const line = [];
    let sorted2 = true;
    let lastCol = 0;
    genColumn = 0;
    while (reader.pos < semi) {
      let seg;
      genColumn = decodeInteger(reader, genColumn);
      if (genColumn < lastCol)
        sorted2 = false;
      lastCol = genColumn;
      if (hasMoreVlq(reader, semi)) {
        sourcesIndex = decodeInteger(reader, sourcesIndex);
        sourceLine = decodeInteger(reader, sourceLine);
        sourceColumn = decodeInteger(reader, sourceColumn);
        if (hasMoreVlq(reader, semi)) {
          namesIndex = decodeInteger(reader, namesIndex);
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
        } else {
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
        }
      } else {
        seg = [genColumn];
      }
      line.push(seg);
      reader.pos++;
    }
    if (!sorted2)
      sort2(line);
    decoded.push(line);
    reader.pos = semi + 1;
  } while (reader.pos <= length3);
  return decoded;
}
function sort2(line) {
  line.sort(sortComparator);
}
function sortComparator(a2, b) {
  return a2[0] - b[0];
}
function encode(decoded) {
  const writer = new StringWriter();
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0)
      writer.write(semicolon);
    if (line.length === 0)
      continue;
    let genColumn = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      if (j > 0)
        writer.write(comma);
      genColumn = encodeInteger(writer, segment[0], genColumn);
      if (segment.length === 1)
        continue;
      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
      sourceLine = encodeInteger(writer, segment[2], sourceLine);
      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
      if (segment.length === 4)
        continue;
      namesIndex = encodeInteger(writer, segment[4], namesIndex);
    }
  }
  return writer.flush();
}

// node_modules/.pnpm/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs
var schemeRegex = /^[\w+.-]+:\/\//;
var urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
var fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
function isAbsoluteUrl(input2) {
  return schemeRegex.test(input2);
}
function isSchemeRelativeUrl(input2) {
  return input2.startsWith("//");
}
function isAbsolutePath(input2) {
  return input2.startsWith("/");
}
function isFileUrl(input2) {
  return input2.startsWith("file:");
}
function isRelative(input2) {
  return /^[.?#]/.test(input2);
}
function parseAbsoluteUrl(input2) {
  const match18 = urlRegex.exec(input2);
  return makeUrl(match18[1], match18[2] || "", match18[3], match18[4] || "", match18[5] || "/", match18[6] || "", match18[7] || "");
}
function parseFileUrl(input2) {
  const match18 = fileRegex.exec(input2);
  const path3 = match18[2];
  return makeUrl("file:", "", match18[1] || "", "", isAbsolutePath(path3) ? path3 : "/" + path3, match18[3] || "", match18[4] || "");
}
function makeUrl(scheme, user, host, port, path3, query, hash2) {
  return {
    scheme,
    user,
    host,
    port,
    path: path3,
    query,
    hash: hash2,
    type: 7
  };
}
function parseUrl(input2) {
  if (isSchemeRelativeUrl(input2)) {
    const url4 = parseAbsoluteUrl("http:" + input2);
    url4.scheme = "";
    url4.type = 6;
    return url4;
  }
  if (isAbsolutePath(input2)) {
    const url4 = parseAbsoluteUrl("http://foo.com" + input2);
    url4.scheme = "";
    url4.host = "";
    url4.type = 5;
    return url4;
  }
  if (isFileUrl(input2))
    return parseFileUrl(input2);
  if (isAbsoluteUrl(input2))
    return parseAbsoluteUrl(input2);
  const url3 = parseAbsoluteUrl("http://foo.com/" + input2);
  url3.scheme = "";
  url3.host = "";
  url3.type = input2 ? input2.startsWith("?") ? 3 : input2.startsWith("#") ? 2 : 4 : 1;
  return url3;
}
function stripPathFilename(path3) {
  if (path3.endsWith("/.."))
    return path3;
  const index = path3.lastIndexOf("/");
  return path3.slice(0, index + 1);
}
function mergePaths(url3, base2) {
  normalizePath3(base2, base2.type);
  if (url3.path === "/") {
    url3.path = base2.path;
  } else {
    url3.path = stripPathFilename(base2.path) + url3.path;
  }
}
function normalizePath3(url3, type) {
  const rel = type <= 4;
  const pieces = url3.path.split("/");
  let pointer = 1;
  let positive = 0;
  let addTrailingSlash = false;
  for (let i = 1; i < pieces.length; i++) {
    const piece = pieces[i];
    if (!piece) {
      addTrailingSlash = true;
      continue;
    }
    addTrailingSlash = false;
    if (piece === ".")
      continue;
    if (piece === "..") {
      if (positive) {
        addTrailingSlash = true;
        positive--;
        pointer--;
      } else if (rel) {
        pieces[pointer++] = piece;
      }
      continue;
    }
    pieces[pointer++] = piece;
    positive++;
  }
  let path3 = "";
  for (let i = 1; i < pointer; i++) {
    path3 += "/" + pieces[i];
  }
  if (!path3 || addTrailingSlash && !path3.endsWith("/..")) {
    path3 += "/";
  }
  url3.path = path3;
}
function resolve3(input2, base2) {
  if (!input2 && !base2)
    return "";
  const url3 = parseUrl(input2);
  let inputType = url3.type;
  if (base2 && inputType !== 7) {
    const baseUrl = parseUrl(base2);
    const baseType = baseUrl.type;
    switch (inputType) {
      case 1:
        url3.hash = baseUrl.hash;
      // fall through
      case 2:
        url3.query = baseUrl.query;
      // fall through
      case 3:
      case 4:
        mergePaths(url3, baseUrl);
      // fall through
      case 5:
        url3.user = baseUrl.user;
        url3.host = baseUrl.host;
        url3.port = baseUrl.port;
      // fall through
      case 6:
        url3.scheme = baseUrl.scheme;
    }
    if (baseType > inputType)
      inputType = baseType;
  }
  normalizePath3(url3, inputType);
  const queryHash = url3.query + url3.hash;
  switch (inputType) {
    // This is impossible, because of the empty checks at the start of the function.
    // case UrlType.Empty:
    case 2:
    case 3:
      return queryHash;
    case 4: {
      const path3 = url3.path.slice(1);
      if (!path3)
        return queryHash || ".";
      if (isRelative(base2 || input2) && !isRelative(path3)) {
        return "./" + path3 + queryHash;
      }
      return path3 + queryHash;
    }
    case 5:
      return url3.path + queryHash;
    default:
      return url3.scheme + "//" + url3.user + url3.host + url3.port + url3.path + queryHash;
  }
}

// node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs
function resolve4(input2, base2) {
  if (base2 && !base2.endsWith("/"))
    base2 += "/";
  return resolve3(input2, base2);
}
function stripFilename(path3) {
  if (!path3)
    return "";
  const index = path3.lastIndexOf("/");
  return path3.slice(0, index + 1);
}
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
var REV_GENERATED_LINE = 1;
var REV_GENERATED_COLUMN = 2;
function maybeSort(mappings, owned) {
  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
  if (unsortedIndex === mappings.length)
    return mappings;
  if (!owned)
    mappings = mappings.slice();
  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
    mappings[i] = sortSegments(mappings[i], owned);
  }
  return mappings;
}
function nextUnsortedSegmentLine(mappings, start3) {
  for (let i = start3; i < mappings.length; i++) {
    if (!isSorted(mappings[i]))
      return i;
  }
  return mappings.length;
}
function isSorted(line) {
  for (let j = 1; j < line.length; j++) {
    if (line[j][COLUMN] < line[j - 1][COLUMN]) {
      return false;
    }
  }
  return true;
}
function sortSegments(line, owned) {
  if (!owned)
    line = line.slice();
  return line.sort(sortComparator2);
}
function sortComparator2(a2, b) {
  return a2[COLUMN] - b[COLUMN];
}
var found = false;
function binarySearch(haystack, needle, low, high) {
  while (low <= high) {
    const mid = low + (high - low >> 1);
    const cmp = haystack[mid][COLUMN] - needle;
    if (cmp === 0) {
      found = true;
      return mid;
    }
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  found = false;
  return low - 1;
}
function upperBound(haystack, needle, index) {
  for (let i = index + 1; i < haystack.length; index = i++) {
    if (haystack[i][COLUMN] !== needle)
      break;
  }
  return index;
}
function lowerBound(haystack, needle, index) {
  for (let i = index - 1; i >= 0; index = i--) {
    if (haystack[i][COLUMN] !== needle)
      break;
  }
  return index;
}
function memoizedState() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
function memoizedBinarySearch(haystack, needle, state, key) {
  const { lastKey, lastNeedle, lastIndex } = state;
  let low = 0;
  let high = haystack.length - 1;
  if (key === lastKey) {
    if (needle === lastNeedle) {
      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
      return lastIndex;
    }
    if (needle >= lastNeedle) {
      low = lastIndex === -1 ? 0 : lastIndex;
    } else {
      high = lastIndex;
    }
  }
  state.lastKey = key;
  state.lastNeedle = needle;
  return state.lastIndex = binarySearch(haystack, needle, low, high);
}
function buildBySources(decoded, memos) {
  const sources = memos.map(buildNullArray);
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    for (let j = 0; j < line.length; j++) {
      const seg = line[j];
      if (seg.length === 1)
        continue;
      const sourceIndex2 = seg[SOURCES_INDEX];
      const sourceLine = seg[SOURCE_LINE];
      const sourceColumn = seg[SOURCE_COLUMN];
      const originalSource = sources[sourceIndex2];
      const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
      const memo = memos[sourceIndex2];
      let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
      memo.lastIndex = ++index;
      insert3(originalLine, index, [sourceColumn, i, seg[COLUMN]]);
    }
  }
  return sources;
}
function insert3(array6, index, value) {
  for (let i = array6.length; i > index; i--) {
    array6[i] = array6[i - 1];
  }
  array6[index] = value;
}
function buildNullArray() {
  return { __proto__: null };
}
var AnyMap = function(map26, mapUrl) {
  const parsed = parse2(map26);
  if (!("sections" in parsed)) {
    return new TraceMap(parsed, mapUrl);
  }
  const mappings = [];
  const sources = [];
  const sourcesContent = [];
  const names = [];
  const ignoreList = [];
  recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);
  const joined = {
    version: 3,
    file: parsed.file,
    names,
    sources,
    sourcesContent,
    mappings,
    ignoreList
  };
  return presortedDecodedMap(joined);
};
function parse2(map26) {
  return typeof map26 === "string" ? JSON.parse(map26) : map26;
}
function recurse(input2, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
  const { sections } = input2;
  for (let i = 0; i < sections.length; i++) {
    const { map: map26, offset } = sections[i];
    let sl = stopLine;
    let sc = stopColumn;
    if (i + 1 < sections.length) {
      const nextOffset = sections[i + 1].offset;
      sl = Math.min(stopLine, lineOffset + nextOffset.line);
      if (sl === stopLine) {
        sc = Math.min(stopColumn, columnOffset + nextOffset.column);
      } else if (sl < stopLine) {
        sc = columnOffset + nextOffset.column;
      }
    }
    addSection(map26, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
  }
}
function addSection(input2, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
  const parsed = parse2(input2);
  if ("sections" in parsed)
    return recurse(...arguments);
  const map26 = new TraceMap(parsed, mapUrl);
  const sourcesOffset = sources.length;
  const namesOffset = names.length;
  const decoded = decodedMappings(map26);
  const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map26;
  append5(sources, resolvedSources);
  append5(names, map26.names);
  if (contents)
    append5(sourcesContent, contents);
  else
    for (let i = 0; i < resolvedSources.length; i++)
      sourcesContent.push(null);
  if (ignores)
    for (let i = 0; i < ignores.length; i++)
      ignoreList.push(ignores[i] + sourcesOffset);
  for (let i = 0; i < decoded.length; i++) {
    const lineI = lineOffset + i;
    if (lineI > stopLine)
      return;
    const out = getLine(mappings, lineI);
    const cOffset = i === 0 ? columnOffset : 0;
    const line = decoded[i];
    for (let j = 0; j < line.length; j++) {
      const seg = line[j];
      const column = cOffset + seg[COLUMN];
      if (lineI === stopLine && column >= stopColumn)
        return;
      if (seg.length === 1) {
        out.push([column]);
        continue;
      }
      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
      const sourceLine = seg[SOURCE_LINE];
      const sourceColumn = seg[SOURCE_COLUMN];
      out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
    }
  }
}
function append5(arr, other) {
  for (let i = 0; i < other.length; i++)
    arr.push(other[i]);
}
function getLine(arr, index) {
  for (let i = arr.length; i <= index; i++)
    arr[i] = [];
  return arr[index];
}
var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;
var TraceMap = class {
  constructor(map26, mapUrl) {
    const isString2 = typeof map26 === "string";
    if (!isString2 && map26._decodedMemo)
      return map26;
    const parsed = isString2 ? JSON.parse(map26) : map26;
    const { version: version3, file, names, sourceRoot, sources, sourcesContent } = parsed;
    this.version = version3;
    this.file = file;
    this.names = names || [];
    this.sourceRoot = sourceRoot;
    this.sources = sources;
    this.sourcesContent = sourcesContent;
    this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
    const from = resolve4(sourceRoot || "", stripFilename(mapUrl));
    this.resolvedSources = sources.map((s2) => resolve4(s2 || "", from));
    const { mappings } = parsed;
    if (typeof mappings === "string") {
      this._encoded = mappings;
      this._decoded = void 0;
    } else {
      this._encoded = void 0;
      this._decoded = maybeSort(mappings, isString2);
    }
    this._decodedMemo = memoizedState();
    this._bySources = void 0;
    this._bySourceMemos = void 0;
  }
};
function cast(map26) {
  return map26;
}
function encodedMappings(map26) {
  var _a2;
  var _b;
  return (_a2 = (_b = cast(map26))._encoded) !== null && _a2 !== void 0 ? _a2 : _b._encoded = encode(cast(map26)._decoded);
}
function decodedMappings(map26) {
  var _a2;
  return (_a2 = cast(map26))._decoded || (_a2._decoded = decode2(cast(map26)._encoded));
}
function originalPositionFor(map26, needle) {
  let { line, column, bias } = needle;
  line--;
  if (line < 0)
    throw new Error(LINE_GTR_ZERO);
  if (column < 0)
    throw new Error(COL_GTR_EQ_ZERO);
  const decoded = decodedMappings(map26);
  if (line >= decoded.length)
    return OMapping(null, null, null, null);
  const segments = decoded[line];
  const index = traceSegmentInternal(segments, cast(map26)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
  if (index === -1)
    return OMapping(null, null, null, null);
  const segment = segments[index];
  if (segment.length === 1)
    return OMapping(null, null, null, null);
  const { names, resolvedSources } = map26;
  return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
}
function generatedPositionFor(map26, needle) {
  const { source, line, column, bias } = needle;
  return generatedPosition(map26, source, line, column, bias || GREATEST_LOWER_BOUND, false);
}
function allGeneratedPositionsFor(map26, needle) {
  const { source, line, column, bias } = needle;
  return generatedPosition(map26, source, line, column, bias || LEAST_UPPER_BOUND, true);
}
function eachMapping(map26, cb) {
  const decoded = decodedMappings(map26);
  const { names, resolvedSources } = map26;
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    for (let j = 0; j < line.length; j++) {
      const seg = line[j];
      const generatedLine = i + 1;
      const generatedColumn = seg[0];
      let source = null;
      let originalLine = null;
      let originalColumn = null;
      let name = null;
      if (seg.length !== 1) {
        source = resolvedSources[seg[1]];
        originalLine = seg[2] + 1;
        originalColumn = seg[3];
      }
      if (seg.length === 5)
        name = names[seg[4]];
      cb({
        generatedLine,
        generatedColumn,
        source,
        originalLine,
        originalColumn,
        name
      });
    }
  }
}
function sourceIndex(map26, source) {
  const { sources, resolvedSources } = map26;
  let index = sources.indexOf(source);
  if (index === -1)
    index = resolvedSources.indexOf(source);
  return index;
}
function sourceContentFor(map26, source) {
  const { sourcesContent } = map26;
  if (sourcesContent == null)
    return null;
  const index = sourceIndex(map26, source);
  return index === -1 ? null : sourcesContent[index];
}
function presortedDecodedMap(map26, mapUrl) {
  const tracer3 = new TraceMap(clone3(map26, []), mapUrl);
  cast(tracer3)._decoded = map26.mappings;
  return tracer3;
}
function clone3(map26, mappings) {
  return {
    version: map26.version,
    file: map26.file,
    names: map26.names,
    sourceRoot: map26.sourceRoot,
    sources: map26.sources,
    sourcesContent: map26.sourcesContent,
    mappings,
    ignoreList: map26.ignoreList || map26.x_google_ignoreList
  };
}
function OMapping(source, line, column, name) {
  return { source, line, column, name };
}
function GMapping(line, column) {
  return { line, column };
}
function traceSegmentInternal(segments, memo, line, column, bias) {
  let index = memoizedBinarySearch(segments, column, memo, line);
  if (found) {
    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
  } else if (bias === LEAST_UPPER_BOUND)
    index++;
  if (index === -1 || index === segments.length)
    return -1;
  return index;
}
function sliceGeneratedPositions(segments, memo, line, column, bias) {
  let min3 = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
  if (!found && bias === LEAST_UPPER_BOUND)
    min3++;
  if (min3 === -1 || min3 === segments.length)
    return [];
  const matchedColumn = found ? column : segments[min3][COLUMN];
  if (!found)
    min3 = lowerBound(segments, matchedColumn, min3);
  const max5 = upperBound(segments, matchedColumn, min3);
  const result = [];
  for (; min3 <= max5; min3++) {
    const segment = segments[min3];
    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
  }
  return result;
}
function generatedPosition(map26, source, line, column, bias, all8) {
  var _a2;
  line--;
  if (line < 0)
    throw new Error(LINE_GTR_ZERO);
  if (column < 0)
    throw new Error(COL_GTR_EQ_ZERO);
  const { sources, resolvedSources } = map26;
  let sourceIndex2 = sources.indexOf(source);
  if (sourceIndex2 === -1)
    sourceIndex2 = resolvedSources.indexOf(source);
  if (sourceIndex2 === -1)
    return all8 ? [] : GMapping(null, null);
  const generated = (_a2 = cast(map26))._bySources || (_a2._bySources = buildBySources(decodedMappings(map26), cast(map26)._bySourceMemos = sources.map(memoizedState)));
  const segments = generated[sourceIndex2][line];
  if (segments == null)
    return all8 ? [] : GMapping(null, null);
  const memo = cast(map26)._bySourceMemos[sourceIndex2];
  if (all8)
    return sliceGeneratedPositions(segments, memo, line, column, bias);
  const index = traceSegmentInternal(segments, memo, line, column, bias);
  if (index === -1)
    return GMapping(null, null);
  const segment = segments[index];
  return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
}

// node_modules/.pnpm/@jridgewell+set-array@1.2.1/node_modules/@jridgewell/set-array/dist/set-array.mjs
var SetArray = class {
  constructor() {
    this._indexes = { __proto__: null };
    this.array = [];
  }
};
function cast2(set8) {
  return set8;
}
function get17(setarr, key) {
  return cast2(setarr)._indexes[key];
}
function put(setarr, key) {
  const index = get17(setarr, key);
  if (index !== void 0)
    return index;
  const { array: array6, _indexes: indexes } = cast2(setarr);
  const length3 = array6.push(key);
  return indexes[key] = length3 - 1;
}

// node_modules/.pnpm/@jridgewell+gen-mapping@0.3.8/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs
var COLUMN2 = 0;
var SOURCES_INDEX2 = 1;
var SOURCE_LINE2 = 2;
var SOURCE_COLUMN2 = 3;
var NAMES_INDEX2 = 4;
var NO_NAME = -1;
var GenMapping = class {
  constructor({ file, sourceRoot } = {}) {
    this._names = new SetArray();
    this._sources = new SetArray();
    this._sourcesContent = [];
    this._mappings = [];
    this.file = file;
    this.sourceRoot = sourceRoot;
    this._ignoreList = new SetArray();
  }
};
function cast3(map26) {
  return map26;
}
var maybeAddMapping = (map26, mapping) => {
  return addMappingInternal(true, map26, mapping);
};
function setSourceContent(map26, source, content) {
  const { _sources: sources, _sourcesContent: sourcesContent } = cast3(map26);
  const index = put(sources, source);
  sourcesContent[index] = content;
}
function toDecodedMap(map26) {
  const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList } = cast3(map26);
  removeEmptyFinalLines(mappings);
  return {
    version: 3,
    file: map26.file || void 0,
    names: names.array,
    sourceRoot: map26.sourceRoot || void 0,
    sources: sources.array,
    sourcesContent,
    mappings,
    ignoreList: ignoreList.array
  };
}
function toEncodedMap(map26) {
  const decoded = toDecodedMap(map26);
  return Object.assign(Object.assign({}, decoded), { mappings: encode(decoded.mappings) });
}
function fromMap3(input2) {
  const map26 = new TraceMap(input2);
  const gen3 = new GenMapping({ file: map26.file, sourceRoot: map26.sourceRoot });
  putAll(cast3(gen3)._names, map26.names);
  putAll(cast3(gen3)._sources, map26.sources);
  cast3(gen3)._sourcesContent = map26.sourcesContent || map26.sources.map(() => null);
  cast3(gen3)._mappings = decodedMappings(map26);
  if (map26.ignoreList)
    putAll(cast3(gen3)._ignoreList, map26.ignoreList);
  return gen3;
}
function addSegmentInternal(skipable, map26, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
  const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = cast3(map26);
  const line = getLine2(mappings, genLine);
  const index = getColumnIndex(line, genColumn);
  if (!source) {
    if (skipSourceless(line, index))
      return;
    return insert4(line, index, [genColumn]);
  }
  const sourcesIndex = put(sources, source);
  const namesIndex = name ? put(names, name) : NO_NAME;
  if (sourcesIndex === sourcesContent.length)
    sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
  if (skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
    return;
  }
  return insert4(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
}
function getLine2(mappings, index) {
  for (let i = mappings.length; i <= index; i++) {
    mappings[i] = [];
  }
  return mappings[index];
}
function getColumnIndex(line, genColumn) {
  let index = line.length;
  for (let i = index - 1; i >= 0; index = i--) {
    const current2 = line[i];
    if (genColumn >= current2[COLUMN2])
      break;
  }
  return index;
}
function insert4(array6, index, value) {
  for (let i = array6.length; i > index; i--) {
    array6[i] = array6[i - 1];
  }
  array6[index] = value;
}
function removeEmptyFinalLines(mappings) {
  const { length: length3 } = mappings;
  let len = length3;
  for (let i = len - 1; i >= 0; len = i, i--) {
    if (mappings[i].length > 0)
      break;
  }
  if (len < length3)
    mappings.length = len;
}
function putAll(setarr, array6) {
  for (let i = 0; i < array6.length; i++)
    put(setarr, array6[i]);
}
function skipSourceless(line, index) {
  if (index === 0)
    return true;
  const prev = line[index - 1];
  return prev.length === 1;
}
function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
  if (index === 0)
    return false;
  const prev = line[index - 1];
  if (prev.length === 1)
    return false;
  return sourcesIndex === prev[SOURCES_INDEX2] && sourceLine === prev[SOURCE_LINE2] && sourceColumn === prev[SOURCE_COLUMN2] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX2] : NO_NAME);
}
function addMappingInternal(skipable, map26, mapping) {
  const { generated, source, original, name, content } = mapping;
  if (!source) {
    return addSegmentInternal(skipable, map26, generated.line - 1, generated.column, null, null, null, null, null);
  }
  return addSegmentInternal(skipable, map26, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);
}

// node_modules/.pnpm/@jridgewell+source-map@0.3.6/node_modules/@jridgewell/source-map/dist/source-map.mjs
var SourceMapConsumer = class _SourceMapConsumer {
  constructor(map26, mapUrl) {
    const trace3 = this._map = new AnyMap(map26, mapUrl);
    this.file = trace3.file;
    this.names = trace3.names;
    this.sourceRoot = trace3.sourceRoot;
    this.sources = trace3.resolvedSources;
    this.sourcesContent = trace3.sourcesContent;
    this.version = trace3.version;
  }
  static fromSourceMap(map26, mapUrl) {
    if (map26.toDecodedMap) {
      return new _SourceMapConsumer(map26.toDecodedMap(), mapUrl);
    }
    return new _SourceMapConsumer(map26.toJSON(), mapUrl);
  }
  get mappings() {
    return encodedMappings(this._map);
  }
  originalPositionFor(needle) {
    return originalPositionFor(this._map, needle);
  }
  generatedPositionFor(originalPosition) {
    return generatedPositionFor(this._map, originalPosition);
  }
  allGeneratedPositionsFor(originalPosition) {
    return allGeneratedPositionsFor(this._map, originalPosition);
  }
  hasContentsOfAllSources() {
    if (!this.sourcesContent || this.sourcesContent.length !== this.sources.length) {
      return false;
    }
    for (const content of this.sourcesContent) {
      if (content == null) {
        return false;
      }
    }
    return true;
  }
  sourceContentFor(source, nullOnMissing) {
    const sourceContent = sourceContentFor(this._map, source);
    if (sourceContent != null) {
      return sourceContent;
    }
    if (nullOnMissing) {
      return null;
    }
    throw new Error(`"${source}" is not in the SourceMap.`);
  }
  eachMapping(callback, context8) {
    eachMapping(this._map, context8 ? callback.bind(context8) : callback);
  }
  destroy() {
  }
};
var SourceMapGenerator = class _SourceMapGenerator {
  constructor(opts) {
    this._map = opts instanceof GenMapping ? opts : new GenMapping(opts);
  }
  static fromSourceMap(consumer) {
    return new _SourceMapGenerator(fromMap3(consumer));
  }
  addMapping(mapping) {
    maybeAddMapping(this._map, mapping);
  }
  setSourceContent(source, content) {
    setSourceContent(this._map, source, content);
  }
  toJSON() {
    return toEncodedMap(this._map);
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toDecodedMap() {
    return toDecodedMap(this._map);
  }
};

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/sourcemap.js
function* SourceMap(options) {
  options = defaults2(options, {
    file: null,
    root: null,
    orig: null,
    files: {}
  });
  var orig_map;
  var generator = new SourceMapGenerator({
    file: options.file,
    sourceRoot: options.root
  });
  let sourcesContent = { __proto__: null };
  let files = options.files;
  for (var name in files) if (HOP(files, name)) {
    sourcesContent[name] = files[name];
  }
  if (options.orig) {
    orig_map = yield new SourceMapConsumer(options.orig);
    if (orig_map.sourcesContent) {
      orig_map.sources.forEach(function(source, i) {
        var content = orig_map.sourcesContent[i];
        if (content) {
          sourcesContent[source] = content;
        }
      });
    }
  }
  function add6(source, gen_line, gen_col, orig_line, orig_col, name2) {
    let generatedPos = { line: gen_line, column: gen_col };
    if (orig_map) {
      var info3 = orig_map.originalPositionFor({
        line: orig_line,
        column: orig_col
      });
      if (info3.source === null) {
        generator.addMapping({
          generated: generatedPos,
          original: null,
          source: null,
          name: null
        });
        return;
      }
      source = info3.source;
      orig_line = info3.line;
      orig_col = info3.column;
      name2 = info3.name || name2;
    }
    generator.addMapping({
      generated: generatedPos,
      original: { line: orig_line, column: orig_col },
      source,
      name: name2
    });
    generator.setSourceContent(source, sourcesContent[source]);
  }
  function clean(map26) {
    const allNull = map26.sourcesContent && map26.sourcesContent.every((c) => c == null);
    if (allNull) delete map26.sourcesContent;
    if (map26.file === void 0) delete map26.file;
    if (map26.sourceRoot === void 0) delete map26.sourceRoot;
    return map26;
  }
  function getDecoded() {
    if (!generator.toDecodedMap) return null;
    return clean(generator.toDecodedMap());
  }
  function getEncoded() {
    return clean(generator.toJSON());
  }
  function destroy() {
    if (orig_map && orig_map.destroy) orig_map.destroy();
  }
  return {
    add: add6,
    getDecoded,
    getEncoded,
    destroy
  };
}

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/tools/domprops.js
var domprops = [
  "$&",
  "$'",
  "$*",
  "$+",
  "$1",
  "$2",
  "$3",
  "$4",
  "$5",
  "$6",
  "$7",
  "$8",
  "$9",
  "$_",
  "$`",
  "$input",
  "-moz-animation",
  "-moz-animation-delay",
  "-moz-animation-direction",
  "-moz-animation-duration",
  "-moz-animation-fill-mode",
  "-moz-animation-iteration-count",
  "-moz-animation-name",
  "-moz-animation-play-state",
  "-moz-animation-timing-function",
  "-moz-appearance",
  "-moz-backface-visibility",
  "-moz-border-end",
  "-moz-border-end-color",
  "-moz-border-end-style",
  "-moz-border-end-width",
  "-moz-border-image",
  "-moz-border-start",
  "-moz-border-start-color",
  "-moz-border-start-style",
  "-moz-border-start-width",
  "-moz-box-align",
  "-moz-box-direction",
  "-moz-box-flex",
  "-moz-box-ordinal-group",
  "-moz-box-orient",
  "-moz-box-pack",
  "-moz-box-sizing",
  "-moz-float-edge",
  "-moz-font-feature-settings",
  "-moz-font-language-override",
  "-moz-force-broken-image-icon",
  "-moz-hyphens",
  "-moz-image-region",
  "-moz-margin-end",
  "-moz-margin-start",
  "-moz-orient",
  "-moz-osx-font-smoothing",
  "-moz-outline-radius",
  "-moz-outline-radius-bottomleft",
  "-moz-outline-radius-bottomright",
  "-moz-outline-radius-topleft",
  "-moz-outline-radius-topright",
  "-moz-padding-end",
  "-moz-padding-start",
  "-moz-perspective",
  "-moz-perspective-origin",
  "-moz-tab-size",
  "-moz-text-size-adjust",
  "-moz-transform",
  "-moz-transform-origin",
  "-moz-transform-style",
  "-moz-transition",
  "-moz-transition-delay",
  "-moz-transition-duration",
  "-moz-transition-property",
  "-moz-transition-timing-function",
  "-moz-user-focus",
  "-moz-user-input",
  "-moz-user-modify",
  "-moz-user-select",
  "-moz-window-dragging",
  "-webkit-align-content",
  "-webkit-align-items",
  "-webkit-align-self",
  "-webkit-animation",
  "-webkit-animation-delay",
  "-webkit-animation-direction",
  "-webkit-animation-duration",
  "-webkit-animation-fill-mode",
  "-webkit-animation-iteration-count",
  "-webkit-animation-name",
  "-webkit-animation-play-state",
  "-webkit-animation-timing-function",
  "-webkit-appearance",
  "-webkit-backface-visibility",
  "-webkit-background-clip",
  "-webkit-background-origin",
  "-webkit-background-size",
  "-webkit-border-bottom-left-radius",
  "-webkit-border-bottom-right-radius",
  "-webkit-border-image",
  "-webkit-border-radius",
  "-webkit-border-top-left-radius",
  "-webkit-border-top-right-radius",
  "-webkit-box-align",
  "-webkit-box-direction",
  "-webkit-box-flex",
  "-webkit-box-ordinal-group",
  "-webkit-box-orient",
  "-webkit-box-pack",
  "-webkit-box-shadow",
  "-webkit-box-sizing",
  "-webkit-clip-path",
  "-webkit-filter",
  "-webkit-flex",
  "-webkit-flex-basis",
  "-webkit-flex-direction",
  "-webkit-flex-flow",
  "-webkit-flex-grow",
  "-webkit-flex-shrink",
  "-webkit-flex-wrap",
  "-webkit-font-feature-settings",
  "-webkit-justify-content",
  "-webkit-line-clamp",
  "-webkit-mask",
  "-webkit-mask-clip",
  "-webkit-mask-composite",
  "-webkit-mask-image",
  "-webkit-mask-origin",
  "-webkit-mask-position",
  "-webkit-mask-position-x",
  "-webkit-mask-position-y",
  "-webkit-mask-repeat",
  "-webkit-mask-size",
  "-webkit-order",
  "-webkit-perspective",
  "-webkit-perspective-origin",
  "-webkit-text-fill-color",
  "-webkit-text-security",
  "-webkit-text-size-adjust",
  "-webkit-text-stroke",
  "-webkit-text-stroke-color",
  "-webkit-text-stroke-width",
  "-webkit-transform",
  "-webkit-transform-origin",
  "-webkit-transform-style",
  "-webkit-transition",
  "-webkit-transition-delay",
  "-webkit-transition-duration",
  "-webkit-transition-property",
  "-webkit-transition-timing-function",
  "-webkit-user-select",
  "@@iterator",
  "ABORT_ERR",
  "ACTIVE",
  "ACTIVE_ATTRIBUTES",
  "ACTIVE_TEXTURE",
  "ACTIVE_UNIFORMS",
  "ACTIVE_UNIFORM_BLOCKS",
  "ADDITION",
  "ALIASED_LINE_WIDTH_RANGE",
  "ALIASED_POINT_SIZE_RANGE",
  "ALL",
  "ALLOW_KEYBOARD_INPUT",
  "ALLPASS",
  "ALPHA",
  "ALPHA_BITS",
  "ALREADY_SIGNALED",
  "ALT_MASK",
  "ALWAYS",
  "ANY_SAMPLES_PASSED",
  "ANY_SAMPLES_PASSED_CONSERVATIVE",
  "ANY_TYPE",
  "ANY_UNORDERED_NODE_TYPE",
  "ARRAY_BUFFER",
  "ARRAY_BUFFER_BINDING",
  "ATTACHED_SHADERS",
  "ATTRIBUTE_NODE",
  "AT_TARGET",
  "AbortController",
  "AbortSignal",
  "AbsoluteOrientationSensor",
  "AbstractRange",
  "Accelerometer",
  "AddSearchProvider",
  "AggregateError",
  "AnalyserNode",
  "Animation",
  "AnimationEffect",
  "AnimationEvent",
  "AnimationPlaybackEvent",
  "AnimationTimeline",
  "AnonXMLHttpRequest",
  "Any",
  "AnyPermissions",
  "ApplicationCache",
  "ApplicationCacheErrorEvent",
  "Array",
  "ArrayBuffer",
  "ArrayType",
  "Atomics",
  "Attr",
  "Audio",
  "AudioBuffer",
  "AudioBufferSourceNode",
  "AudioContext",
  "AudioData",
  "AudioDecoder",
  "AudioDestinationNode",
  "AudioEncoder",
  "AudioListener",
  "AudioNode",
  "AudioParam",
  "AudioParamMap",
  "AudioProcessingEvent",
  "AudioScheduledSourceNode",
  "AudioSinkInfo",
  "AudioStreamTrack",
  "AudioWorklet",
  "AudioWorkletNode",
  "AuthenticatorAssertionResponse",
  "AuthenticatorAttestationResponse",
  "AuthenticatorResponse",
  "AutocompleteErrorEvent",
  "BACK",
  "BAD_BOUNDARYPOINTS_ERR",
  "BAD_REQUEST",
  "BANDPASS",
  "BLEND",
  "BLEND_COLOR",
  "BLEND_DST_ALPHA",
  "BLEND_DST_RGB",
  "BLEND_EQUATION",
  "BLEND_EQUATION_ALPHA",
  "BLEND_EQUATION_RGB",
  "BLEND_SRC_ALPHA",
  "BLEND_SRC_RGB",
  "BLUE",
  "BLUE_BITS",
  "BLUR",
  "BOOL",
  "BOOLEAN_TYPE",
  "BOOL_VEC2",
  "BOOL_VEC3",
  "BOOL_VEC4",
  "BOTH",
  "BROWSER_DEFAULT_WEBGL",
  "BUBBLING_PHASE",
  "BUFFER_SIZE",
  "BUFFER_USAGE",
  "BYTE",
  "BYTES_PER_ELEMENT",
  "BackgroundFetchManager",
  "BackgroundFetchRecord",
  "BackgroundFetchRegistration",
  "BarProp",
  "BarcodeDetector",
  "BaseAudioContext",
  "BaseHref",
  "BatteryManager",
  "BeforeInstallPromptEvent",
  "BeforeLoadEvent",
  "BeforeUnloadEvent",
  "BigInt",
  "BigInt64Array",
  "BigUint64Array",
  "BiquadFilterNode",
  "Blob",
  "BlobEvent",
  "Bluetooth",
  "BluetoothCharacteristicProperties",
  "BluetoothDevice",
  "BluetoothRemoteGATTCharacteristic",
  "BluetoothRemoteGATTDescriptor",
  "BluetoothRemoteGATTServer",
  "BluetoothRemoteGATTService",
  "BluetoothUUID",
  "Boolean",
  "BroadcastChannel",
  "BrowserCaptureMediaStreamTrack",
  "BrowserInfo",
  "ByteLengthQueuingStrategy",
  "CAPTURING_PHASE",
  "CCW",
  "CDATASection",
  "CDATA_SECTION_NODE",
  "CHANGE",
  "CHARSET_RULE",
  "CHECKING",
  "CLAMP_TO_EDGE",
  "CLICK",
  "CLOSED",
  "CLOSING",
  "COLOR",
  "COLOR_ATTACHMENT0",
  "COLOR_ATTACHMENT1",
  "COLOR_ATTACHMENT10",
  "COLOR_ATTACHMENT11",
  "COLOR_ATTACHMENT12",
  "COLOR_ATTACHMENT13",
  "COLOR_ATTACHMENT14",
  "COLOR_ATTACHMENT15",
  "COLOR_ATTACHMENT2",
  "COLOR_ATTACHMENT3",
  "COLOR_ATTACHMENT4",
  "COLOR_ATTACHMENT5",
  "COLOR_ATTACHMENT6",
  "COLOR_ATTACHMENT7",
  "COLOR_ATTACHMENT8",
  "COLOR_ATTACHMENT9",
  "COLOR_BUFFER_BIT",
  "COLOR_CLEAR_VALUE",
  "COLOR_WRITEMASK",
  "COMMENT_NODE",
  "COMPARE_REF_TO_TEXTURE",
  "COMPILE_STATUS",
  "COMPLETION_STATUS_KHR",
  "COMPRESSED_RGBA_S3TC_DXT1_EXT",
  "COMPRESSED_RGBA_S3TC_DXT3_EXT",
  "COMPRESSED_RGBA_S3TC_DXT5_EXT",
  "COMPRESSED_RGB_S3TC_DXT1_EXT",
  "COMPRESSED_TEXTURE_FORMATS",
  "COMPUTE",
  "CONDITION_SATISFIED",
  "CONFIGURATION_UNSUPPORTED",
  "CONNECTING",
  "CONSTANT_ALPHA",
  "CONSTANT_COLOR",
  "CONSTRAINT_ERR",
  "CONTEXT_LOST_WEBGL",
  "CONTROL_MASK",
  "COPY_DST",
  "COPY_READ_BUFFER",
  "COPY_READ_BUFFER_BINDING",
  "COPY_SRC",
  "COPY_WRITE_BUFFER",
  "COPY_WRITE_BUFFER_BINDING",
  "COUNTER_STYLE_RULE",
  "CSS",
  "CSS2Properties",
  "CSSAnimation",
  "CSSCharsetRule",
  "CSSConditionRule",
  "CSSContainerRule",
  "CSSCounterStyleRule",
  "CSSFontFaceRule",
  "CSSFontFeatureValuesRule",
  "CSSFontPaletteValuesRule",
  "CSSGroupingRule",
  "CSSImageValue",
  "CSSImportRule",
  "CSSKeyframeRule",
  "CSSKeyframesRule",
  "CSSKeywordValue",
  "CSSLayerBlockRule",
  "CSSLayerStatementRule",
  "CSSMarginRule",
  "CSSMathClamp",
  "CSSMathInvert",
  "CSSMathMax",
  "CSSMathMin",
  "CSSMathNegate",
  "CSSMathProduct",
  "CSSMathSum",
  "CSSMathValue",
  "CSSMatrixComponent",
  "CSSMediaRule",
  "CSSMozDocumentRule",
  "CSSNameSpaceRule",
  "CSSNamespaceRule",
  "CSSNestedDeclarations",
  "CSSNumericArray",
  "CSSNumericValue",
  "CSSPageDescriptors",
  "CSSPageRule",
  "CSSPerspective",
  "CSSPositionTryDescriptors",
  "CSSPositionTryRule",
  "CSSPositionValue",
  "CSSPrimitiveValue",
  "CSSPropertyRule",
  "CSSRotate",
  "CSSRule",
  "CSSRuleList",
  "CSSScale",
  "CSSScopeRule",
  "CSSSkew",
  "CSSSkewX",
  "CSSSkewY",
  "CSSStartingStyleRule",
  "CSSStyleDeclaration",
  "CSSStyleRule",
  "CSSStyleSheet",
  "CSSStyleValue",
  "CSSSupportsRule",
  "CSSTransformComponent",
  "CSSTransformValue",
  "CSSTransition",
  "CSSTranslate",
  "CSSUnitValue",
  "CSSUnknownRule",
  "CSSUnparsedValue",
  "CSSValue",
  "CSSValueList",
  "CSSVariableReferenceValue",
  "CSSVariablesDeclaration",
  "CSSVariablesRule",
  "CSSViewTransitionRule",
  "CSSViewportRule",
  "CSS_ATTR",
  "CSS_CM",
  "CSS_COUNTER",
  "CSS_CUSTOM",
  "CSS_DEG",
  "CSS_DIMENSION",
  "CSS_EMS",
  "CSS_EXS",
  "CSS_FILTER_BLUR",
  "CSS_FILTER_BRIGHTNESS",
  "CSS_FILTER_CONTRAST",
  "CSS_FILTER_CUSTOM",
  "CSS_FILTER_DROP_SHADOW",
  "CSS_FILTER_GRAYSCALE",
  "CSS_FILTER_HUE_ROTATE",
  "CSS_FILTER_INVERT",
  "CSS_FILTER_OPACITY",
  "CSS_FILTER_REFERENCE",
  "CSS_FILTER_SATURATE",
  "CSS_FILTER_SEPIA",
  "CSS_GRAD",
  "CSS_HZ",
  "CSS_IDENT",
  "CSS_IN",
  "CSS_INHERIT",
  "CSS_KHZ",
  "CSS_MATRIX",
  "CSS_MATRIX3D",
  "CSS_MM",
  "CSS_MS",
  "CSS_NUMBER",
  "CSS_PC",
  "CSS_PERCENTAGE",
  "CSS_PERSPECTIVE",
  "CSS_PRIMITIVE_VALUE",
  "CSS_PT",
  "CSS_PX",
  "CSS_RAD",
  "CSS_RECT",
  "CSS_RGBCOLOR",
  "CSS_ROTATE",
  "CSS_ROTATE3D",
  "CSS_ROTATEX",
  "CSS_ROTATEY",
  "CSS_ROTATEZ",
  "CSS_S",
  "CSS_SCALE",
  "CSS_SCALE3D",
  "CSS_SCALEX",
  "CSS_SCALEY",
  "CSS_SCALEZ",
  "CSS_SKEW",
  "CSS_SKEWX",
  "CSS_SKEWY",
  "CSS_STRING",
  "CSS_TRANSLATE",
  "CSS_TRANSLATE3D",
  "CSS_TRANSLATEX",
  "CSS_TRANSLATEY",
  "CSS_TRANSLATEZ",
  "CSS_UNKNOWN",
  "CSS_URI",
  "CSS_VALUE_LIST",
  "CSS_VH",
  "CSS_VMAX",
  "CSS_VMIN",
  "CSS_VW",
  "CULL_FACE",
  "CULL_FACE_MODE",
  "CURRENT_PROGRAM",
  "CURRENT_QUERY",
  "CURRENT_VERTEX_ATTRIB",
  "CUSTOM",
  "CW",
  "Cache",
  "CacheStorage",
  "CanvasCaptureMediaStream",
  "CanvasCaptureMediaStreamTrack",
  "CanvasGradient",
  "CanvasPattern",
  "CanvasRenderingContext2D",
  "CaptureController",
  "CaretPosition",
  "ChannelMergerNode",
  "ChannelSplitterNode",
  "ChapterInformation",
  "CharacterBoundsUpdateEvent",
  "CharacterData",
  "ClientRect",
  "ClientRectList",
  "Clipboard",
  "ClipboardEvent",
  "ClipboardItem",
  "CloseEvent",
  "CloseWatcher",
  "Collator",
  "ColorArray",
  "ColorValue",
  "CommandEvent",
  "Comment",
  "CompileError",
  "CompositionEvent",
  "CompressionStream",
  "Console",
  "ConstantSourceNode",
  "ContentVisibilityAutoStateChangeEvent",
  "ContextFilter",
  "ContextType",
  "Controllers",
  "ConvolverNode",
  "CookieChangeEvent",
  "CookieStore",
  "CookieStoreManager",
  "CountQueuingStrategy",
  "Counter",
  "CreateType",
  "Credential",
  "CredentialsContainer",
  "CropTarget",
  "Crypto",
  "CryptoKey",
  "CustomElementRegistry",
  "CustomEvent",
  "CustomStateSet",
  "DATABASE_ERR",
  "DATA_CLONE_ERR",
  "DATA_ERR",
  "DBLCLICK",
  "DECR",
  "DECR_WRAP",
  "DELETE_STATUS",
  "DEPTH",
  "DEPTH24_STENCIL8",
  "DEPTH32F_STENCIL8",
  "DEPTH_ATTACHMENT",
  "DEPTH_BITS",
  "DEPTH_BUFFER_BIT",
  "DEPTH_CLEAR_VALUE",
  "DEPTH_COMPONENT",
  "DEPTH_COMPONENT16",
  "DEPTH_COMPONENT24",
  "DEPTH_COMPONENT32F",
  "DEPTH_FUNC",
  "DEPTH_RANGE",
  "DEPTH_STENCIL",
  "DEPTH_STENCIL_ATTACHMENT",
  "DEPTH_TEST",
  "DEPTH_WRITEMASK",
  "DEVICE_INELIGIBLE",
  "DIRECTION_DOWN",
  "DIRECTION_LEFT",
  "DIRECTION_RIGHT",
  "DIRECTION_UP",
  "DISABLED",
  "DISPATCH_REQUEST_ERR",
  "DITHER",
  "DOCUMENT_FRAGMENT_NODE",
  "DOCUMENT_NODE",
  "DOCUMENT_POSITION_CONTAINED_BY",
  "DOCUMENT_POSITION_CONTAINS",
  "DOCUMENT_POSITION_DISCONNECTED",
  "DOCUMENT_POSITION_FOLLOWING",
  "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC",
  "DOCUMENT_POSITION_PRECEDING",
  "DOCUMENT_TYPE_NODE",
  "DOMCursor",
  "DOMError",
  "DOMException",
  "DOMImplementation",
  "DOMImplementationLS",
  "DOMMatrix",
  "DOMMatrixReadOnly",
  "DOMParser",
  "DOMPoint",
  "DOMPointReadOnly",
  "DOMQuad",
  "DOMRect",
  "DOMRectList",
  "DOMRectReadOnly",
  "DOMRequest",
  "DOMSTRING_SIZE_ERR",
  "DOMSettableTokenList",
  "DOMStringList",
  "DOMStringMap",
  "DOMTokenList",
  "DOMTransactionEvent",
  "DOM_DELTA_LINE",
  "DOM_DELTA_PAGE",
  "DOM_DELTA_PIXEL",
  "DOM_INPUT_METHOD_DROP",
  "DOM_INPUT_METHOD_HANDWRITING",
  "DOM_INPUT_METHOD_IME",
  "DOM_INPUT_METHOD_KEYBOARD",
  "DOM_INPUT_METHOD_MULTIMODAL",
  "DOM_INPUT_METHOD_OPTION",
  "DOM_INPUT_METHOD_PASTE",
  "DOM_INPUT_METHOD_SCRIPT",
  "DOM_INPUT_METHOD_UNKNOWN",
  "DOM_INPUT_METHOD_VOICE",
  "DOM_KEY_LOCATION_JOYSTICK",
  "DOM_KEY_LOCATION_LEFT",
  "DOM_KEY_LOCATION_MOBILE",
  "DOM_KEY_LOCATION_NUMPAD",
  "DOM_KEY_LOCATION_RIGHT",
  "DOM_KEY_LOCATION_STANDARD",
  "DOM_VK_0",
  "DOM_VK_1",
  "DOM_VK_2",
  "DOM_VK_3",
  "DOM_VK_4",
  "DOM_VK_5",
  "DOM_VK_6",
  "DOM_VK_7",
  "DOM_VK_8",
  "DOM_VK_9",
  "DOM_VK_A",
  "DOM_VK_ACCEPT",
  "DOM_VK_ADD",
  "DOM_VK_ALT",
  "DOM_VK_ALTGR",
  "DOM_VK_AMPERSAND",
  "DOM_VK_ASTERISK",
  "DOM_VK_AT",
  "DOM_VK_ATTN",
  "DOM_VK_B",
  "DOM_VK_BACKSPACE",
  "DOM_VK_BACK_QUOTE",
  "DOM_VK_BACK_SLASH",
  "DOM_VK_BACK_SPACE",
  "DOM_VK_C",
  "DOM_VK_CANCEL",
  "DOM_VK_CAPS_LOCK",
  "DOM_VK_CIRCUMFLEX",
  "DOM_VK_CLEAR",
  "DOM_VK_CLOSE_BRACKET",
  "DOM_VK_CLOSE_CURLY_BRACKET",
  "DOM_VK_CLOSE_PAREN",
  "DOM_VK_COLON",
  "DOM_VK_COMMA",
  "DOM_VK_CONTEXT_MENU",
  "DOM_VK_CONTROL",
  "DOM_VK_CONVERT",
  "DOM_VK_CRSEL",
  "DOM_VK_CTRL",
  "DOM_VK_D",
  "DOM_VK_DECIMAL",
  "DOM_VK_DELETE",
  "DOM_VK_DIVIDE",
  "DOM_VK_DOLLAR",
  "DOM_VK_DOUBLE_QUOTE",
  "DOM_VK_DOWN",
  "DOM_VK_E",
  "DOM_VK_EISU",
  "DOM_VK_END",
  "DOM_VK_ENTER",
  "DOM_VK_EQUALS",
  "DOM_VK_EREOF",
  "DOM_VK_ESCAPE",
  "DOM_VK_EXCLAMATION",
  "DOM_VK_EXECUTE",
  "DOM_VK_EXSEL",
  "DOM_VK_F",
  "DOM_VK_F1",
  "DOM_VK_F10",
  "DOM_VK_F11",
  "DOM_VK_F12",
  "DOM_VK_F13",
  "DOM_VK_F14",
  "DOM_VK_F15",
  "DOM_VK_F16",
  "DOM_VK_F17",
  "DOM_VK_F18",
  "DOM_VK_F19",
  "DOM_VK_F2",
  "DOM_VK_F20",
  "DOM_VK_F21",
  "DOM_VK_F22",
  "DOM_VK_F23",
  "DOM_VK_F24",
  "DOM_VK_F25",
  "DOM_VK_F26",
  "DOM_VK_F27",
  "DOM_VK_F28",
  "DOM_VK_F29",
  "DOM_VK_F3",
  "DOM_VK_F30",
  "DOM_VK_F31",
  "DOM_VK_F32",
  "DOM_VK_F33",
  "DOM_VK_F34",
  "DOM_VK_F35",
  "DOM_VK_F36",
  "DOM_VK_F4",
  "DOM_VK_F5",
  "DOM_VK_F6",
  "DOM_VK_F7",
  "DOM_VK_F8",
  "DOM_VK_F9",
  "DOM_VK_FINAL",
  "DOM_VK_FRONT",
  "DOM_VK_G",
  "DOM_VK_GREATER_THAN",
  "DOM_VK_H",
  "DOM_VK_HANGUL",
  "DOM_VK_HANJA",
  "DOM_VK_HASH",
  "DOM_VK_HELP",
  "DOM_VK_HK_TOGGLE",
  "DOM_VK_HOME",
  "DOM_VK_HYPHEN_MINUS",
  "DOM_VK_I",
  "DOM_VK_INSERT",
  "DOM_VK_J",
  "DOM_VK_JUNJA",
  "DOM_VK_K",
  "DOM_VK_KANA",
  "DOM_VK_KANJI",
  "DOM_VK_L",
  "DOM_VK_LEFT",
  "DOM_VK_LEFT_TAB",
  "DOM_VK_LESS_THAN",
  "DOM_VK_M",
  "DOM_VK_META",
  "DOM_VK_MODECHANGE",
  "DOM_VK_MULTIPLY",
  "DOM_VK_N",
  "DOM_VK_NONCONVERT",
  "DOM_VK_NUMPAD0",
  "DOM_VK_NUMPAD1",
  "DOM_VK_NUMPAD2",
  "DOM_VK_NUMPAD3",
  "DOM_VK_NUMPAD4",
  "DOM_VK_NUMPAD5",
  "DOM_VK_NUMPAD6",
  "DOM_VK_NUMPAD7",
  "DOM_VK_NUMPAD8",
  "DOM_VK_NUMPAD9",
  "DOM_VK_NUM_LOCK",
  "DOM_VK_O",
  "DOM_VK_OEM_1",
  "DOM_VK_OEM_102",
  "DOM_VK_OEM_2",
  "DOM_VK_OEM_3",
  "DOM_VK_OEM_4",
  "DOM_VK_OEM_5",
  "DOM_VK_OEM_6",
  "DOM_VK_OEM_7",
  "DOM_VK_OEM_8",
  "DOM_VK_OEM_COMMA",
  "DOM_VK_OEM_MINUS",
  "DOM_VK_OEM_PERIOD",
  "DOM_VK_OEM_PLUS",
  "DOM_VK_OPEN_BRACKET",
  "DOM_VK_OPEN_CURLY_BRACKET",
  "DOM_VK_OPEN_PAREN",
  "DOM_VK_P",
  "DOM_VK_PA1",
  "DOM_VK_PAGEDOWN",
  "DOM_VK_PAGEUP",
  "DOM_VK_PAGE_DOWN",
  "DOM_VK_PAGE_UP",
  "DOM_VK_PAUSE",
  "DOM_VK_PERCENT",
  "DOM_VK_PERIOD",
  "DOM_VK_PIPE",
  "DOM_VK_PLAY",
  "DOM_VK_PLUS",
  "DOM_VK_PRINT",
  "DOM_VK_PRINTSCREEN",
  "DOM_VK_PROCESSKEY",
  "DOM_VK_PROPERITES",
  "DOM_VK_Q",
  "DOM_VK_QUESTION_MARK",
  "DOM_VK_QUOTE",
  "DOM_VK_R",
  "DOM_VK_REDO",
  "DOM_VK_RETURN",
  "DOM_VK_RIGHT",
  "DOM_VK_S",
  "DOM_VK_SCROLL_LOCK",
  "DOM_VK_SELECT",
  "DOM_VK_SEMICOLON",
  "DOM_VK_SEPARATOR",
  "DOM_VK_SHIFT",
  "DOM_VK_SLASH",
  "DOM_VK_SLEEP",
  "DOM_VK_SPACE",
  "DOM_VK_SUBTRACT",
  "DOM_VK_T",
  "DOM_VK_TAB",
  "DOM_VK_TILDE",
  "DOM_VK_U",
  "DOM_VK_UNDERSCORE",
  "DOM_VK_UNDO",
  "DOM_VK_UNICODE",
  "DOM_VK_UP",
  "DOM_VK_V",
  "DOM_VK_VOLUME_DOWN",
  "DOM_VK_VOLUME_MUTE",
  "DOM_VK_VOLUME_UP",
  "DOM_VK_W",
  "DOM_VK_WIN",
  "DOM_VK_WINDOW",
  "DOM_VK_WIN_ICO_00",
  "DOM_VK_WIN_ICO_CLEAR",
  "DOM_VK_WIN_ICO_HELP",
  "DOM_VK_WIN_OEM_ATTN",
  "DOM_VK_WIN_OEM_AUTO",
  "DOM_VK_WIN_OEM_BACKTAB",
  "DOM_VK_WIN_OEM_CLEAR",
  "DOM_VK_WIN_OEM_COPY",
  "DOM_VK_WIN_OEM_CUSEL",
  "DOM_VK_WIN_OEM_ENLW",
  "DOM_VK_WIN_OEM_FINISH",
  "DOM_VK_WIN_OEM_FJ_JISHO",
  "DOM_VK_WIN_OEM_FJ_LOYA",
  "DOM_VK_WIN_OEM_FJ_MASSHOU",
  "DOM_VK_WIN_OEM_FJ_ROYA",
  "DOM_VK_WIN_OEM_FJ_TOUROKU",
  "DOM_VK_WIN_OEM_JUMP",
  "DOM_VK_WIN_OEM_PA1",
  "DOM_VK_WIN_OEM_PA2",
  "DOM_VK_WIN_OEM_PA3",
  "DOM_VK_WIN_OEM_RESET",
  "DOM_VK_WIN_OEM_WSCTRL",
  "DOM_VK_X",
  "DOM_VK_XF86XK_ADD_FAVORITE",
  "DOM_VK_XF86XK_APPLICATION_LEFT",
  "DOM_VK_XF86XK_APPLICATION_RIGHT",
  "DOM_VK_XF86XK_AUDIO_CYCLE_TRACK",
  "DOM_VK_XF86XK_AUDIO_FORWARD",
  "DOM_VK_XF86XK_AUDIO_LOWER_VOLUME",
  "DOM_VK_XF86XK_AUDIO_MEDIA",
  "DOM_VK_XF86XK_AUDIO_MUTE",
  "DOM_VK_XF86XK_AUDIO_NEXT",
  "DOM_VK_XF86XK_AUDIO_PAUSE",
  "DOM_VK_XF86XK_AUDIO_PLAY",
  "DOM_VK_XF86XK_AUDIO_PREV",
  "DOM_VK_XF86XK_AUDIO_RAISE_VOLUME",
  "DOM_VK_XF86XK_AUDIO_RANDOM_PLAY",
  "DOM_VK_XF86XK_AUDIO_RECORD",
  "DOM_VK_XF86XK_AUDIO_REPEAT",
  "DOM_VK_XF86XK_AUDIO_REWIND",
  "DOM_VK_XF86XK_AUDIO_STOP",
  "DOM_VK_XF86XK_AWAY",
  "DOM_VK_XF86XK_BACK",
  "DOM_VK_XF86XK_BACK_FORWARD",
  "DOM_VK_XF86XK_BATTERY",
  "DOM_VK_XF86XK_BLUE",
  "DOM_VK_XF86XK_BLUETOOTH",
  "DOM_VK_XF86XK_BOOK",
  "DOM_VK_XF86XK_BRIGHTNESS_ADJUST",
  "DOM_VK_XF86XK_CALCULATOR",
  "DOM_VK_XF86XK_CALENDAR",
  "DOM_VK_XF86XK_CD",
  "DOM_VK_XF86XK_CLOSE",
  "DOM_VK_XF86XK_COMMUNITY",
  "DOM_VK_XF86XK_CONTRAST_ADJUST",
  "DOM_VK_XF86XK_COPY",
  "DOM_VK_XF86XK_CUT",
  "DOM_VK_XF86XK_CYCLE_ANGLE",
  "DOM_VK_XF86XK_DISPLAY",
  "DOM_VK_XF86XK_DOCUMENTS",
  "DOM_VK_XF86XK_DOS",
  "DOM_VK_XF86XK_EJECT",
  "DOM_VK_XF86XK_EXCEL",
  "DOM_VK_XF86XK_EXPLORER",
  "DOM_VK_XF86XK_FAVORITES",
  "DOM_VK_XF86XK_FINANCE",
  "DOM_VK_XF86XK_FORWARD",
  "DOM_VK_XF86XK_FRAME_BACK",
  "DOM_VK_XF86XK_FRAME_FORWARD",
  "DOM_VK_XF86XK_GAME",
  "DOM_VK_XF86XK_GO",
  "DOM_VK_XF86XK_GREEN",
  "DOM_VK_XF86XK_HIBERNATE",
  "DOM_VK_XF86XK_HISTORY",
  "DOM_VK_XF86XK_HOME_PAGE",
  "DOM_VK_XF86XK_HOT_LINKS",
  "DOM_VK_XF86XK_I_TOUCH",
  "DOM_VK_XF86XK_KBD_BRIGHTNESS_DOWN",
  "DOM_VK_XF86XK_KBD_BRIGHTNESS_UP",
  "DOM_VK_XF86XK_KBD_LIGHT_ON_OFF",
  "DOM_VK_XF86XK_LAUNCH0",
  "DOM_VK_XF86XK_LAUNCH1",
  "DOM_VK_XF86XK_LAUNCH2",
  "DOM_VK_XF86XK_LAUNCH3",
  "DOM_VK_XF86XK_LAUNCH4",
  "DOM_VK_XF86XK_LAUNCH5",
  "DOM_VK_XF86XK_LAUNCH6",
  "DOM_VK_XF86XK_LAUNCH7",
  "DOM_VK_XF86XK_LAUNCH8",
  "DOM_VK_XF86XK_LAUNCH9",
  "DOM_VK_XF86XK_LAUNCH_A",
  "DOM_VK_XF86XK_LAUNCH_B",
  "DOM_VK_XF86XK_LAUNCH_C",
  "DOM_VK_XF86XK_LAUNCH_D",
  "DOM_VK_XF86XK_LAUNCH_E",
  "DOM_VK_XF86XK_LAUNCH_F",
  "DOM_VK_XF86XK_LIGHT_BULB",
  "DOM_VK_XF86XK_LOG_OFF",
  "DOM_VK_XF86XK_MAIL",
  "DOM_VK_XF86XK_MAIL_FORWARD",
  "DOM_VK_XF86XK_MARKET",
  "DOM_VK_XF86XK_MEETING",
  "DOM_VK_XF86XK_MEMO",
  "DOM_VK_XF86XK_MENU_KB",
  "DOM_VK_XF86XK_MENU_PB",
  "DOM_VK_XF86XK_MESSENGER",
  "DOM_VK_XF86XK_MON_BRIGHTNESS_DOWN",
  "DOM_VK_XF86XK_MON_BRIGHTNESS_UP",
  "DOM_VK_XF86XK_MUSIC",
  "DOM_VK_XF86XK_MY_COMPUTER",
  "DOM_VK_XF86XK_MY_SITES",
  "DOM_VK_XF86XK_NEW",
  "DOM_VK_XF86XK_NEWS",
  "DOM_VK_XF86XK_OFFICE_HOME",
  "DOM_VK_XF86XK_OPEN",
  "DOM_VK_XF86XK_OPEN_URL",
  "DOM_VK_XF86XK_OPTION",
  "DOM_VK_XF86XK_PASTE",
  "DOM_VK_XF86XK_PHONE",
  "DOM_VK_XF86XK_PICTURES",
  "DOM_VK_XF86XK_POWER_DOWN",
  "DOM_VK_XF86XK_POWER_OFF",
  "DOM_VK_XF86XK_RED",
  "DOM_VK_XF86XK_REFRESH",
  "DOM_VK_XF86XK_RELOAD",
  "DOM_VK_XF86XK_REPLY",
  "DOM_VK_XF86XK_ROCKER_DOWN",
  "DOM_VK_XF86XK_ROCKER_ENTER",
  "DOM_VK_XF86XK_ROCKER_UP",
  "DOM_VK_XF86XK_ROTATE_WINDOWS",
  "DOM_VK_XF86XK_ROTATION_KB",
  "DOM_VK_XF86XK_ROTATION_PB",
  "DOM_VK_XF86XK_SAVE",
  "DOM_VK_XF86XK_SCREEN_SAVER",
  "DOM_VK_XF86XK_SCROLL_CLICK",
  "DOM_VK_XF86XK_SCROLL_DOWN",
  "DOM_VK_XF86XK_SCROLL_UP",
  "DOM_VK_XF86XK_SEARCH",
  "DOM_VK_XF86XK_SEND",
  "DOM_VK_XF86XK_SHOP",
  "DOM_VK_XF86XK_SPELL",
  "DOM_VK_XF86XK_SPLIT_SCREEN",
  "DOM_VK_XF86XK_STANDBY",
  "DOM_VK_XF86XK_START",
  "DOM_VK_XF86XK_STOP",
  "DOM_VK_XF86XK_SUBTITLE",
  "DOM_VK_XF86XK_SUPPORT",
  "DOM_VK_XF86XK_SUSPEND",
  "DOM_VK_XF86XK_TASK_PANE",
  "DOM_VK_XF86XK_TERMINAL",
  "DOM_VK_XF86XK_TIME",
  "DOM_VK_XF86XK_TOOLS",
  "DOM_VK_XF86XK_TOP_MENU",
  "DOM_VK_XF86XK_TO_DO_LIST",
  "DOM_VK_XF86XK_TRAVEL",
  "DOM_VK_XF86XK_USER1KB",
  "DOM_VK_XF86XK_USER2KB",
  "DOM_VK_XF86XK_USER_PB",
  "DOM_VK_XF86XK_UWB",
  "DOM_VK_XF86XK_VENDOR_HOME",
  "DOM_VK_XF86XK_VIDEO",
  "DOM_VK_XF86XK_VIEW",
  "DOM_VK_XF86XK_WAKE_UP",
  "DOM_VK_XF86XK_WEB_CAM",
  "DOM_VK_XF86XK_WHEEL_BUTTON",
  "DOM_VK_XF86XK_WLAN",
  "DOM_VK_XF86XK_WORD",
  "DOM_VK_XF86XK_WWW",
  "DOM_VK_XF86XK_XFER",
  "DOM_VK_XF86XK_YELLOW",
  "DOM_VK_XF86XK_ZOOM_IN",
  "DOM_VK_XF86XK_ZOOM_OUT",
  "DOM_VK_Y",
  "DOM_VK_Z",
  "DOM_VK_ZOOM",
  "DONE",
  "DONT_CARE",
  "DOWNLOADING",
  "DRAGDROP",
  "DRAW_BUFFER0",
  "DRAW_BUFFER1",
  "DRAW_BUFFER10",
  "DRAW_BUFFER11",
  "DRAW_BUFFER12",
  "DRAW_BUFFER13",
  "DRAW_BUFFER14",
  "DRAW_BUFFER15",
  "DRAW_BUFFER2",
  "DRAW_BUFFER3",
  "DRAW_BUFFER4",
  "DRAW_BUFFER5",
  "DRAW_BUFFER6",
  "DRAW_BUFFER7",
  "DRAW_BUFFER8",
  "DRAW_BUFFER9",
  "DRAW_FRAMEBUFFER",
  "DRAW_FRAMEBUFFER_BINDING",
  "DST_ALPHA",
  "DST_COLOR",
  "DYNAMIC_COPY",
  "DYNAMIC_DRAW",
  "DYNAMIC_READ",
  "DataChannel",
  "DataTransfer",
  "DataTransferItem",
  "DataTransferItemList",
  "DataView",
  "Date",
  "DateTimeFormat",
  "DecompressionStream",
  "DelayNode",
  "DelegatedInkTrailPresenter",
  "DeprecationReportBody",
  "DesktopNotification",
  "DesktopNotificationCenter",
  "Details",
  "DeviceLightEvent",
  "DeviceMotionEvent",
  "DeviceMotionEventAcceleration",
  "DeviceMotionEventRotationRate",
  "DeviceOrientationEvent",
  "DeviceProximityEvent",
  "DeviceStorage",
  "DeviceStorageChangeEvent",
  "Directory",
  "DisplayNames",
  "Document",
  "DocumentFragment",
  "DocumentPictureInPicture",
  "DocumentPictureInPictureEvent",
  "DocumentTimeline",
  "DocumentType",
  "DragEvent",
  "DurationFormat",
  "DynamicsCompressorNode",
  "E",
  "ELEMENT_ARRAY_BUFFER",
  "ELEMENT_ARRAY_BUFFER_BINDING",
  "ELEMENT_NODE",
  "EMPTY",
  "ENCODING_ERR",
  "ENDED",
  "END_TO_END",
  "END_TO_START",
  "ENTITY_NODE",
  "ENTITY_REFERENCE_NODE",
  "EPSILON",
  "EQUAL",
  "EQUALPOWER",
  "ERROR",
  "EXPONENTIAL_DISTANCE",
  "EditContext",
  "Element",
  "ElementInternals",
  "ElementQuery",
  "EncodedAudioChunk",
  "EncodedVideoChunk",
  "EnterPictureInPictureEvent",
  "Entity",
  "EntityReference",
  "Error",
  "ErrorEvent",
  "EvalError",
  "Event",
  "EventCounts",
  "EventException",
  "EventSource",
  "EventTarget",
  "Exception",
  "ExtensionContext",
  "ExtensionDisabledReason",
  "ExtensionInfo",
  "ExtensionInstallType",
  "ExtensionType",
  "External",
  "EyeDropper",
  "FASTEST",
  "FIDOSDK",
  "FILTER_ACCEPT",
  "FILTER_INTERRUPT",
  "FILTER_REJECT",
  "FILTER_SKIP",
  "FINISHED_STATE",
  "FIRST_ORDERED_NODE_TYPE",
  "FLOAT",
  "FLOAT_32_UNSIGNED_INT_24_8_REV",
  "FLOAT_MAT2",
  "FLOAT_MAT2x3",
  "FLOAT_MAT2x4",
  "FLOAT_MAT3",
  "FLOAT_MAT3x2",
  "FLOAT_MAT3x4",
  "FLOAT_MAT4",
  "FLOAT_MAT4x2",
  "FLOAT_MAT4x3",
  "FLOAT_VEC2",
  "FLOAT_VEC3",
  "FLOAT_VEC4",
  "FOCUS",
  "FONT_FACE_RULE",
  "FONT_FEATURE_VALUES_RULE",
  "FRAGMENT",
  "FRAGMENT_SHADER",
  "FRAGMENT_SHADER_DERIVATIVE_HINT",
  "FRAGMENT_SHADER_DERIVATIVE_HINT_OES",
  "FRAMEBUFFER",
  "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE",
  "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE",
  "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING",
  "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE",
  "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE",
  "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE",
  "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",
  "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",
  "FRAMEBUFFER_ATTACHMENT_RED_SIZE",
  "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE",
  "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",
  "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER",
  "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",
  "FRAMEBUFFER_BINDING",
  "FRAMEBUFFER_COMPLETE",
  "FRAMEBUFFER_DEFAULT",
  "FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
  "FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
  "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
  "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE",
  "FRAMEBUFFER_UNSUPPORTED",
  "FRONT",
  "FRONT_AND_BACK",
  "FRONT_FACE",
  "FUNC_ADD",
  "FUNC_REVERSE_SUBTRACT",
  "FUNC_SUBTRACT",
  "FeaturePolicy",
  "FeaturePolicyViolationReportBody",
  "FederatedCredential",
  "Feed",
  "FeedEntry",
  "Fence",
  "FencedFrameConfig",
  "File",
  "FileError",
  "FileList",
  "FileReader",
  "FileSystem",
  "FileSystemDirectoryEntry",
  "FileSystemDirectoryHandle",
  "FileSystemDirectoryReader",
  "FileSystemEntry",
  "FileSystemFileEntry",
  "FileSystemFileHandle",
  "FileSystemHandle",
  "FileSystemWritableFileStream",
  "FinalizationRegistry",
  "FindInPage",
  "Float16Array",
  "Float32Array",
  "Float64Array",
  "FocusEvent",
  "FontData",
  "FontFace",
  "FontFaceSet",
  "FontFaceSetLoadEvent",
  "FormData",
  "FormDataEvent",
  "FragmentDirective",
  "Function",
  "GENERATE_MIPMAP_HINT",
  "GEQUAL",
  "GPU",
  "GPUAdapter",
  "GPUAdapterInfo",
  "GPUBindGroup",
  "GPUBindGroupLayout",
  "GPUBuffer",
  "GPUBufferUsage",
  "GPUCanvasContext",
  "GPUColorWrite",
  "GPUCommandBuffer",
  "GPUCommandEncoder",
  "GPUCompilationInfo",
  "GPUCompilationMessage",
  "GPUComputePassEncoder",
  "GPUComputePipeline",
  "GPUDevice",
  "GPUDeviceLostInfo",
  "GPUError",
  "GPUExternalTexture",
  "GPUInternalError",
  "GPUMapMode",
  "GPUOutOfMemoryError",
  "GPUPipelineError",
  "GPUPipelineLayout",
  "GPUQuerySet",
  "GPUQueue",
  "GPURenderBundle",
  "GPURenderBundleEncoder",
  "GPURenderPassEncoder",
  "GPURenderPipeline",
  "GPUSampler",
  "GPUShaderModule",
  "GPUShaderStage",
  "GPUSupportedFeatures",
  "GPUSupportedLimits",
  "GPUTexture",
  "GPUTextureUsage",
  "GPUTextureView",
  "GPUUncapturedErrorEvent",
  "GPUValidationError",
  "GREATER",
  "GREEN",
  "GREEN_BITS",
  "GainNode",
  "Gamepad",
  "GamepadAxisMoveEvent",
  "GamepadButton",
  "GamepadButtonEvent",
  "GamepadEvent",
  "GamepadHapticActuator",
  "GamepadPose",
  "Geolocation",
  "GeolocationCoordinates",
  "GeolocationPosition",
  "GeolocationPositionError",
  "GestureEvent",
  "GetInfo",
  "Global",
  "GravitySensor",
  "Gyroscope",
  "HALF_FLOAT",
  "HAVE_CURRENT_DATA",
  "HAVE_ENOUGH_DATA",
  "HAVE_FUTURE_DATA",
  "HAVE_METADATA",
  "HAVE_NOTHING",
  "HEADERS_RECEIVED",
  "HID",
  "HIDConnectionEvent",
  "HIDDEN",
  "HIDDevice",
  "HIDInputReportEvent",
  "HIERARCHY_REQUEST_ERR",
  "HIGHPASS",
  "HIGHSHELF",
  "HIGH_FLOAT",
  "HIGH_INT",
  "HORIZONTAL",
  "HORIZONTAL_AXIS",
  "HRTF",
  "HTMLAllCollection",
  "HTMLAnchorElement",
  "HTMLAppletElement",
  "HTMLAreaElement",
  "HTMLAudioElement",
  "HTMLBRElement",
  "HTMLBaseElement",
  "HTMLBaseFontElement",
  "HTMLBlockquoteElement",
  "HTMLBodyElement",
  "HTMLButtonElement",
  "HTMLCanvasElement",
  "HTMLCollection",
  "HTMLCommandElement",
  "HTMLContentElement",
  "HTMLDListElement",
  "HTMLDataElement",
  "HTMLDataListElement",
  "HTMLDetailsElement",
  "HTMLDialogElement",
  "HTMLDirectoryElement",
  "HTMLDivElement",
  "HTMLDocument",
  "HTMLElement",
  "HTMLEmbedElement",
  "HTMLFencedFrameElement",
  "HTMLFieldSetElement",
  "HTMLFontElement",
  "HTMLFormControlsCollection",
  "HTMLFormElement",
  "HTMLFrameElement",
  "HTMLFrameSetElement",
  "HTMLHRElement",
  "HTMLHeadElement",
  "HTMLHeadingElement",
  "HTMLHtmlElement",
  "HTMLIFrameElement",
  "HTMLImageElement",
  "HTMLInputElement",
  "HTMLIsIndexElement",
  "HTMLKeygenElement",
  "HTMLLIElement",
  "HTMLLabelElement",
  "HTMLLegendElement",
  "HTMLLinkElement",
  "HTMLMapElement",
  "HTMLMarqueeElement",
  "HTMLMediaElement",
  "HTMLMenuElement",
  "HTMLMenuItemElement",
  "HTMLMetaElement",
  "HTMLMeterElement",
  "HTMLModElement",
  "HTMLOListElement",
  "HTMLObjectElement",
  "HTMLOptGroupElement",
  "HTMLOptionElement",
  "HTMLOptionsCollection",
  "HTMLOutputElement",
  "HTMLParagraphElement",
  "HTMLParamElement",
  "HTMLPictureElement",
  "HTMLPreElement",
  "HTMLProgressElement",
  "HTMLPropertiesCollection",
  "HTMLQuoteElement",
  "HTMLScriptElement",
  "HTMLSelectElement",
  "HTMLShadowElement",
  "HTMLSlotElement",
  "HTMLSourceElement",
  "HTMLSpanElement",
  "HTMLStyleElement",
  "HTMLTableCaptionElement",
  "HTMLTableCellElement",
  "HTMLTableColElement",
  "HTMLTableElement",
  "HTMLTableRowElement",
  "HTMLTableSectionElement",
  "HTMLTemplateElement",
  "HTMLTextAreaElement",
  "HTMLTimeElement",
  "HTMLTitleElement",
  "HTMLTrackElement",
  "HTMLUListElement",
  "HTMLUnknownElement",
  "HTMLVideoElement",
  "HashChangeEvent",
  "Headers",
  "Highlight",
  "HighlightRegistry",
  "History",
  "Hz",
  "ICE_CHECKING",
  "ICE_CLOSED",
  "ICE_COMPLETED",
  "ICE_CONNECTED",
  "ICE_FAILED",
  "ICE_GATHERING",
  "ICE_WAITING",
  "IDBCursor",
  "IDBCursorWithValue",
  "IDBDatabase",
  "IDBDatabaseException",
  "IDBFactory",
  "IDBFileHandle",
  "IDBFileRequest",
  "IDBIndex",
  "IDBKeyRange",
  "IDBMutableFile",
  "IDBObjectStore",
  "IDBOpenDBRequest",
  "IDBRequest",
  "IDBTransaction",
  "IDBVersionChangeEvent",
  "IDLE",
  "IIRFilterNode",
  "IMPLEMENTATION_COLOR_READ_FORMAT",
  "IMPLEMENTATION_COLOR_READ_TYPE",
  "IMPORT_RULE",
  "INCR",
  "INCR_WRAP",
  "INDEX",
  "INDEX_SIZE_ERR",
  "INDIRECT",
  "INT",
  "INTERLEAVED_ATTRIBS",
  "INT_2_10_10_10_REV",
  "INT_SAMPLER_2D",
  "INT_SAMPLER_2D_ARRAY",
  "INT_SAMPLER_3D",
  "INT_SAMPLER_CUBE",
  "INT_VEC2",
  "INT_VEC3",
  "INT_VEC4",
  "INUSE_ATTRIBUTE_ERR",
  "INVALID_ACCESS_ERR",
  "INVALID_CHARACTER_ERR",
  "INVALID_ENUM",
  "INVALID_EXPRESSION_ERR",
  "INVALID_FRAMEBUFFER_OPERATION",
  "INVALID_INDEX",
  "INVALID_MODIFICATION_ERR",
  "INVALID_NODE_TYPE_ERR",
  "INVALID_OPERATION",
  "INVALID_STATE_ERR",
  "INVALID_VALUE",
  "INVERSE_DISTANCE",
  "INVERT",
  "IceCandidate",
  "IconInfo",
  "IdentityCredential",
  "IdentityCredentialError",
  "IdentityProvider",
  "IdleDeadline",
  "IdleDetector",
  "Image",
  "ImageBitmap",
  "ImageBitmapRenderingContext",
  "ImageCapture",
  "ImageData",
  "ImageDataType",
  "ImageDecoder",
  "ImageTrack",
  "ImageTrackList",
  "Infinity",
  "Ink",
  "InputDeviceCapabilities",
  "InputDeviceInfo",
  "InputEvent",
  "InputMethodContext",
  "InstallTrigger",
  "InstallTriggerImpl",
  "Instance",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Intent",
  "InternalError",
  "IntersectionObserver",
  "IntersectionObserverEntry",
  "Intl",
  "IsSearchProviderInstalled",
  "Iterator",
  "JSON",
  "JSTag",
  "KEEP",
  "KEYDOWN",
  "KEYFRAMES_RULE",
  "KEYFRAME_RULE",
  "KEYPRESS",
  "KEYUP",
  "KeyEvent",
  "Keyboard",
  "KeyboardEvent",
  "KeyboardLayoutMap",
  "KeyframeEffect",
  "LENGTHADJUST_SPACING",
  "LENGTHADJUST_SPACINGANDGLYPHS",
  "LENGTHADJUST_UNKNOWN",
  "LEQUAL",
  "LESS",
  "LINEAR",
  "LINEAR_DISTANCE",
  "LINEAR_MIPMAP_LINEAR",
  "LINEAR_MIPMAP_NEAREST",
  "LINES",
  "LINE_LOOP",
  "LINE_STRIP",
  "LINE_WIDTH",
  "LINK_STATUS",
  "LIVE",
  "LN10",
  "LN2",
  "LOADED",
  "LOADING",
  "LOG10E",
  "LOG2E",
  "LOWPASS",
  "LOWSHELF",
  "LOW_FLOAT",
  "LOW_INT",
  "LSException",
  "LSParserFilter",
  "LUMINANCE",
  "LUMINANCE_ALPHA",
  "LanguageCode",
  "LargestContentfulPaint",
  "LaunchParams",
  "LaunchQueue",
  "LaunchType",
  "LayoutShift",
  "LayoutShiftAttribution",
  "LinearAccelerationSensor",
  "LinkError",
  "ListFormat",
  "LocalMediaStream",
  "Locale",
  "Location",
  "Lock",
  "LockManager",
  "MAP_READ",
  "MAP_WRITE",
  "MARGIN_RULE",
  "MAX",
  "MAX_3D_TEXTURE_SIZE",
  "MAX_ARRAY_TEXTURE_LAYERS",
  "MAX_CAPTURE_VISIBLE_TAB_CALLS_PER_SECOND",
  "MAX_CLIENT_WAIT_TIMEOUT_WEBGL",
  "MAX_COLOR_ATTACHMENTS",
  "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS",
  "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
  "MAX_COMBINED_UNIFORM_BLOCKS",
  "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS",
  "MAX_CUBE_MAP_TEXTURE_SIZE",
  "MAX_DRAW_BUFFERS",
  "MAX_ELEMENTS_INDICES",
  "MAX_ELEMENTS_VERTICES",
  "MAX_ELEMENT_INDEX",
  "MAX_FRAGMENT_INPUT_COMPONENTS",
  "MAX_FRAGMENT_UNIFORM_BLOCKS",
  "MAX_FRAGMENT_UNIFORM_COMPONENTS",
  "MAX_FRAGMENT_UNIFORM_VECTORS",
  "MAX_PROGRAM_TEXEL_OFFSET",
  "MAX_RENDERBUFFER_SIZE",
  "MAX_SAFE_INTEGER",
  "MAX_SAMPLES",
  "MAX_SERVER_WAIT_TIMEOUT",
  "MAX_TEXTURE_IMAGE_UNITS",
  "MAX_TEXTURE_LOD_BIAS",
  "MAX_TEXTURE_MAX_ANISOTROPY_EXT",
  "MAX_TEXTURE_SIZE",
  "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",
  "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS",
  "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS",
  "MAX_UNIFORM_BLOCK_SIZE",
  "MAX_UNIFORM_BUFFER_BINDINGS",
  "MAX_VALUE",
  "MAX_VARYING_COMPONENTS",
  "MAX_VARYING_VECTORS",
  "MAX_VERTEX_ATTRIBS",
  "MAX_VERTEX_OUTPUT_COMPONENTS",
  "MAX_VERTEX_TEXTURE_IMAGE_UNITS",
  "MAX_VERTEX_UNIFORM_BLOCKS",
  "MAX_VERTEX_UNIFORM_COMPONENTS",
  "MAX_VERTEX_UNIFORM_VECTORS",
  "MAX_VIEWPORT_DIMS",
  "MEDIA_ERR_ABORTED",
  "MEDIA_ERR_DECODE",
  "MEDIA_ERR_ENCRYPTED",
  "MEDIA_ERR_NETWORK",
  "MEDIA_ERR_SRC_NOT_SUPPORTED",
  "MEDIA_KEYERR_CLIENT",
  "MEDIA_KEYERR_DOMAIN",
  "MEDIA_KEYERR_HARDWARECHANGE",
  "MEDIA_KEYERR_OUTPUT",
  "MEDIA_KEYERR_SERVICE",
  "MEDIA_KEYERR_UNKNOWN",
  "MEDIA_RULE",
  "MEDIUM_FLOAT",
  "MEDIUM_INT",
  "META_MASK",
  "MIDIAccess",
  "MIDIConnectionEvent",
  "MIDIInput",
  "MIDIInputMap",
  "MIDIMessageEvent",
  "MIDIOutput",
  "MIDIOutputMap",
  "MIDIPort",
  "MIN",
  "MIN_PROGRAM_TEXEL_OFFSET",
  "MIN_SAFE_INTEGER",
  "MIN_VALUE",
  "MIRRORED_REPEAT",
  "MODE_ASYNCHRONOUS",
  "MODE_SYNCHRONOUS",
  "MODIFICATION",
  "MOUSEDOWN",
  "MOUSEDRAG",
  "MOUSEMOVE",
  "MOUSEOUT",
  "MOUSEOVER",
  "MOUSEUP",
  "MOZ_KEYFRAMES_RULE",
  "MOZ_KEYFRAME_RULE",
  "MOZ_SOURCE_CURSOR",
  "MOZ_SOURCE_ERASER",
  "MOZ_SOURCE_KEYBOARD",
  "MOZ_SOURCE_MOUSE",
  "MOZ_SOURCE_PEN",
  "MOZ_SOURCE_TOUCH",
  "MOZ_SOURCE_UNKNOWN",
  "MSGESTURE_FLAG_BEGIN",
  "MSGESTURE_FLAG_CANCEL",
  "MSGESTURE_FLAG_END",
  "MSGESTURE_FLAG_INERTIA",
  "MSGESTURE_FLAG_NONE",
  "MSPOINTER_TYPE_MOUSE",
  "MSPOINTER_TYPE_PEN",
  "MSPOINTER_TYPE_TOUCH",
  "MS_ASYNC_CALLBACK_STATUS_ASSIGN_DELEGATE",
  "MS_ASYNC_CALLBACK_STATUS_CANCEL",
  "MS_ASYNC_CALLBACK_STATUS_CHOOSEANY",
  "MS_ASYNC_CALLBACK_STATUS_ERROR",
  "MS_ASYNC_CALLBACK_STATUS_JOIN",
  "MS_ASYNC_OP_STATUS_CANCELED",
  "MS_ASYNC_OP_STATUS_ERROR",
  "MS_ASYNC_OP_STATUS_SUCCESS",
  "MS_MANIPULATION_STATE_ACTIVE",
  "MS_MANIPULATION_STATE_CANCELLED",
  "MS_MANIPULATION_STATE_COMMITTED",
  "MS_MANIPULATION_STATE_DRAGGING",
  "MS_MANIPULATION_STATE_INERTIA",
  "MS_MANIPULATION_STATE_PRESELECT",
  "MS_MANIPULATION_STATE_SELECTING",
  "MS_MANIPULATION_STATE_STOPPED",
  "MS_MEDIA_ERR_ENCRYPTED",
  "MS_MEDIA_KEYERR_CLIENT",
  "MS_MEDIA_KEYERR_DOMAIN",
  "MS_MEDIA_KEYERR_HARDWARECHANGE",
  "MS_MEDIA_KEYERR_OUTPUT",
  "MS_MEDIA_KEYERR_SERVICE",
  "MS_MEDIA_KEYERR_UNKNOWN",
  "Map",
  "Math",
  "MathMLElement",
  "MediaCapabilities",
  "MediaCapabilitiesInfo",
  "MediaController",
  "MediaDeviceInfo",
  "MediaDevices",
  "MediaElementAudioSourceNode",
  "MediaEncryptedEvent",
  "MediaError",
  "MediaKeyError",
  "MediaKeyEvent",
  "MediaKeyMessageEvent",
  "MediaKeyNeededEvent",
  "MediaKeySession",
  "MediaKeyStatusMap",
  "MediaKeySystemAccess",
  "MediaKeys",
  "MediaList",
  "MediaMetadata",
  "MediaQueryList",
  "MediaQueryListEvent",
  "MediaRecorder",
  "MediaRecorderErrorEvent",
  "MediaSession",
  "MediaSettingsRange",
  "MediaSource",
  "MediaSourceHandle",
  "MediaStream",
  "MediaStreamAudioDestinationNode",
  "MediaStreamAudioSourceNode",
  "MediaStreamEvent",
  "MediaStreamTrack",
  "MediaStreamTrackAudioSourceNode",
  "MediaStreamTrackAudioStats",
  "MediaStreamTrackEvent",
  "MediaStreamTrackGenerator",
  "MediaStreamTrackProcessor",
  "MediaStreamTrackVideoStats",
  "Memory",
  "MessageChannel",
  "MessageEvent",
  "MessagePort",
  "MessageSender",
  "Methods",
  "MimeType",
  "MimeTypeArray",
  "Module",
  "MouseEvent",
  "MouseScrollEvent",
  "MozAnimation",
  "MozAnimationDelay",
  "MozAnimationDirection",
  "MozAnimationDuration",
  "MozAnimationFillMode",
  "MozAnimationIterationCount",
  "MozAnimationName",
  "MozAnimationPlayState",
  "MozAnimationTimingFunction",
  "MozAppearance",
  "MozBackfaceVisibility",
  "MozBinding",
  "MozBorderBottomColors",
  "MozBorderEnd",
  "MozBorderEndColor",
  "MozBorderEndStyle",
  "MozBorderEndWidth",
  "MozBorderImage",
  "MozBorderLeftColors",
  "MozBorderRightColors",
  "MozBorderStart",
  "MozBorderStartColor",
  "MozBorderStartStyle",
  "MozBorderStartWidth",
  "MozBorderTopColors",
  "MozBoxAlign",
  "MozBoxDirection",
  "MozBoxFlex",
  "MozBoxOrdinalGroup",
  "MozBoxOrient",
  "MozBoxPack",
  "MozBoxSizing",
  "MozCSSKeyframeRule",
  "MozCSSKeyframesRule",
  "MozColumnCount",
  "MozColumnFill",
  "MozColumnGap",
  "MozColumnRule",
  "MozColumnRuleColor",
  "MozColumnRuleStyle",
  "MozColumnRuleWidth",
  "MozColumnWidth",
  "MozColumns",
  "MozContactChangeEvent",
  "MozFloatEdge",
  "MozFontFeatureSettings",
  "MozFontLanguageOverride",
  "MozForceBrokenImageIcon",
  "MozHyphens",
  "MozImageRegion",
  "MozMarginEnd",
  "MozMarginStart",
  "MozMmsEvent",
  "MozMmsMessage",
  "MozMobileMessageThread",
  "MozOSXFontSmoothing",
  "MozOrient",
  "MozOsxFontSmoothing",
  "MozOutlineRadius",
  "MozOutlineRadiusBottomleft",
  "MozOutlineRadiusBottomright",
  "MozOutlineRadiusTopleft",
  "MozOutlineRadiusTopright",
  "MozPaddingEnd",
  "MozPaddingStart",
  "MozPerspective",
  "MozPerspectiveOrigin",
  "MozPowerManager",
  "MozSettingsEvent",
  "MozSmsEvent",
  "MozSmsMessage",
  "MozStackSizing",
  "MozTabSize",
  "MozTextAlignLast",
  "MozTextDecorationColor",
  "MozTextDecorationLine",
  "MozTextDecorationStyle",
  "MozTextSizeAdjust",
  "MozTransform",
  "MozTransformOrigin",
  "MozTransformStyle",
  "MozTransition",
  "MozTransitionDelay",
  "MozTransitionDuration",
  "MozTransitionProperty",
  "MozTransitionTimingFunction",
  "MozUserFocus",
  "MozUserInput",
  "MozUserModify",
  "MozUserSelect",
  "MozWindowDragging",
  "MozWindowShadow",
  "MutationEvent",
  "MutationObserver",
  "MutationRecord",
  "MutedInfo",
  "MutedInfoReason",
  "NAMESPACE_ERR",
  "NAMESPACE_RULE",
  "NEAREST",
  "NEAREST_MIPMAP_LINEAR",
  "NEAREST_MIPMAP_NEAREST",
  "NEGATIVE_INFINITY",
  "NETWORK_EMPTY",
  "NETWORK_ERR",
  "NETWORK_IDLE",
  "NETWORK_LOADED",
  "NETWORK_LOADING",
  "NETWORK_NO_SOURCE",
  "NEVER",
  "NEW",
  "NEXT",
  "NEXT_NO_DUPLICATE",
  "NICEST",
  "NODE_AFTER",
  "NODE_BEFORE",
  "NODE_BEFORE_AND_AFTER",
  "NODE_INSIDE",
  "NONE",
  "NON_TRANSIENT_ERR",
  "NOTATION_NODE",
  "NOTCH",
  "NOTEQUAL",
  "NOT_ALLOWED_ERR",
  "NOT_FOUND_ERR",
  "NOT_READABLE_ERR",
  "NOT_SUPPORTED_ERR",
  "NO_DATA_ALLOWED_ERR",
  "NO_ERR",
  "NO_ERROR",
  "NO_MODIFICATION_ALLOWED_ERR",
  "NUMBER_TYPE",
  "NUM_COMPRESSED_TEXTURE_FORMATS",
  "NaN",
  "NamedNodeMap",
  "NavigateEvent",
  "Navigation",
  "NavigationActivation",
  "NavigationCurrentEntryChangeEvent",
  "NavigationDestination",
  "NavigationHistoryEntry",
  "NavigationPreloadManager",
  "NavigationTransition",
  "Navigator",
  "NavigatorLogin",
  "NavigatorManagedData",
  "NavigatorUAData",
  "NearbyLinks",
  "NetworkInformation",
  "Node",
  "NodeFilter",
  "NodeIterator",
  "NodeList",
  "NotRestoredReasonDetails",
  "NotRestoredReasons",
  "Notation",
  "Notification",
  "NotifyPaintEvent",
  "Number",
  "NumberFormat",
  "OBJECT_TYPE",
  "OBSOLETE",
  "OK",
  "ONE",
  "ONE_MINUS_CONSTANT_ALPHA",
  "ONE_MINUS_CONSTANT_COLOR",
  "ONE_MINUS_DST_ALPHA",
  "ONE_MINUS_DST_COLOR",
  "ONE_MINUS_SRC_ALPHA",
  "ONE_MINUS_SRC_COLOR",
  "OPEN",
  "OPENED",
  "OPENING",
  "ORDERED_NODE_ITERATOR_TYPE",
  "ORDERED_NODE_SNAPSHOT_TYPE",
  "OTHER_ERROR",
  "OTPCredential",
  "OUT_OF_MEMORY",
  "Object",
  "OfflineAudioCompletionEvent",
  "OfflineAudioContext",
  "OfflineResourceList",
  "OffscreenCanvas",
  "OffscreenCanvasRenderingContext2D",
  "OnClickData",
  "OnInstalledReason",
  "OnPerformanceWarningCategory",
  "OnPerformanceWarningSeverity",
  "OnRestartRequiredReason",
  "Option",
  "OrientationSensor",
  "OscillatorNode",
  "OverconstrainedError",
  "OverflowEvent",
  "PACK_ALIGNMENT",
  "PACK_ROW_LENGTH",
  "PACK_SKIP_PIXELS",
  "PACK_SKIP_ROWS",
  "PAGE_RULE",
  "PARSE_ERR",
  "PATHSEG_ARC_ABS",
  "PATHSEG_ARC_REL",
  "PATHSEG_CLOSEPATH",
  "PATHSEG_CURVETO_CUBIC_ABS",
  "PATHSEG_CURVETO_CUBIC_REL",
  "PATHSEG_CURVETO_CUBIC_SMOOTH_ABS",
  "PATHSEG_CURVETO_CUBIC_SMOOTH_REL",
  "PATHSEG_CURVETO_QUADRATIC_ABS",
  "PATHSEG_CURVETO_QUADRATIC_REL",
  "PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS",
  "PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL",
  "PATHSEG_LINETO_ABS",
  "PATHSEG_LINETO_HORIZONTAL_ABS",
  "PATHSEG_LINETO_HORIZONTAL_REL",
  "PATHSEG_LINETO_REL",
  "PATHSEG_LINETO_VERTICAL_ABS",
  "PATHSEG_LINETO_VERTICAL_REL",
  "PATHSEG_MOVETO_ABS",
  "PATHSEG_MOVETO_REL",
  "PATHSEG_UNKNOWN",
  "PATH_EXISTS_ERR",
  "PEAKING",
  "PERMISSION_DENIED",
  "PERSISTENT",
  "PI",
  "PIXEL_PACK_BUFFER",
  "PIXEL_PACK_BUFFER_BINDING",
  "PIXEL_UNPACK_BUFFER",
  "PIXEL_UNPACK_BUFFER_BINDING",
  "PLAYING_STATE",
  "POINTS",
  "POLYGON_OFFSET_FACTOR",
  "POLYGON_OFFSET_FILL",
  "POLYGON_OFFSET_UNITS",
  "POSITION_UNAVAILABLE",
  "POSITIVE_INFINITY",
  "PREV",
  "PREV_NO_DUPLICATE",
  "PROCESSING_INSTRUCTION_NODE",
  "PageChangeEvent",
  "PageRevealEvent",
  "PageSettings",
  "PageSwapEvent",
  "PageTransitionEvent",
  "PaintRequest",
  "PaintRequestList",
  "PannerNode",
  "PasswordCredential",
  "Path2D",
  "PaymentAddress",
  "PaymentInstruments",
  "PaymentManager",
  "PaymentMethodChangeEvent",
  "PaymentRequest",
  "PaymentRequestUpdateEvent",
  "PaymentResponse",
  "Performance",
  "PerformanceElementTiming",
  "PerformanceEntry",
  "PerformanceEventTiming",
  "PerformanceLongAnimationFrameTiming",
  "PerformanceLongTaskTiming",
  "PerformanceMark",
  "PerformanceMeasure",
  "PerformanceNavigation",
  "PerformanceNavigationTiming",
  "PerformanceObserver",
  "PerformanceObserverEntryList",
  "PerformancePaintTiming",
  "PerformanceResourceTiming",
  "PerformanceScriptTiming",
  "PerformanceServerTiming",
  "PerformanceTiming",
  "PeriodicSyncManager",
  "PeriodicWave",
  "PermissionStatus",
  "Permissions",
  "PhotoCapabilities",
  "PictureInPictureEvent",
  "PictureInPictureWindow",
  "PlatformArch",
  "PlatformInfo",
  "PlatformNaclArch",
  "PlatformOs",
  "Plugin",
  "PluginArray",
  "PluralRules",
  "PointerEvent",
  "PopStateEvent",
  "PopupBlockedEvent",
  "Port",
  "Presentation",
  "PresentationAvailability",
  "PresentationConnection",
  "PresentationConnectionAvailableEvent",
  "PresentationConnectionCloseEvent",
  "PresentationConnectionList",
  "PresentationReceiver",
  "PresentationRequest",
  "PressureObserver",
  "PressureRecord",
  "ProcessingInstruction",
  "Profiler",
  "ProgressEvent",
  "Promise",
  "PromiseRejectionEvent",
  "PropertyNodeList",
  "ProtectedAudience",
  "Proxy",
  "PublicKeyCredential",
  "PushManager",
  "PushSubscription",
  "PushSubscriptionOptions",
  "Q",
  "QUERY_RESOLVE",
  "QUERY_RESULT",
  "QUERY_RESULT_AVAILABLE",
  "QUOTA_ERR",
  "QUOTA_EXCEEDED_ERR",
  "QueryInterface",
  "R11F_G11F_B10F",
  "R16F",
  "R16I",
  "R16UI",
  "R32F",
  "R32I",
  "R32UI",
  "R8",
  "R8I",
  "R8UI",
  "R8_SNORM",
  "RASTERIZER_DISCARD",
  "READ",
  "READ_BUFFER",
  "READ_FRAMEBUFFER",
  "READ_FRAMEBUFFER_BINDING",
  "READ_ONLY",
  "READ_ONLY_ERR",
  "READ_WRITE",
  "RED",
  "RED_BITS",
  "RED_INTEGER",
  "REMOVAL",
  "RENDERBUFFER",
  "RENDERBUFFER_ALPHA_SIZE",
  "RENDERBUFFER_BINDING",
  "RENDERBUFFER_BLUE_SIZE",
  "RENDERBUFFER_DEPTH_SIZE",
  "RENDERBUFFER_GREEN_SIZE",
  "RENDERBUFFER_HEIGHT",
  "RENDERBUFFER_INTERNAL_FORMAT",
  "RENDERBUFFER_RED_SIZE",
  "RENDERBUFFER_SAMPLES",
  "RENDERBUFFER_STENCIL_SIZE",
  "RENDERBUFFER_WIDTH",
  "RENDERER",
  "RENDERING_INTENT_ABSOLUTE_COLORIMETRIC",
  "RENDERING_INTENT_AUTO",
  "RENDERING_INTENT_PERCEPTUAL",
  "RENDERING_INTENT_RELATIVE_COLORIMETRIC",
  "RENDERING_INTENT_SATURATION",
  "RENDERING_INTENT_UNKNOWN",
  "RENDER_ATTACHMENT",
  "REPEAT",
  "REPLACE",
  "RG",
  "RG16F",
  "RG16I",
  "RG16UI",
  "RG32F",
  "RG32I",
  "RG32UI",
  "RG8",
  "RG8I",
  "RG8UI",
  "RG8_SNORM",
  "RGB",
  "RGB10_A2",
  "RGB10_A2UI",
  "RGB16F",
  "RGB16I",
  "RGB16UI",
  "RGB32F",
  "RGB32I",
  "RGB32UI",
  "RGB565",
  "RGB5_A1",
  "RGB8",
  "RGB8I",
  "RGB8UI",
  "RGB8_SNORM",
  "RGB9_E5",
  "RGBA",
  "RGBA16F",
  "RGBA16I",
  "RGBA16UI",
  "RGBA32F",
  "RGBA32I",
  "RGBA32UI",
  "RGBA4",
  "RGBA8",
  "RGBA8I",
  "RGBA8UI",
  "RGBA8_SNORM",
  "RGBA_INTEGER",
  "RGBColor",
  "RGB_INTEGER",
  "RG_INTEGER",
  "ROTATION_CLOCKWISE",
  "ROTATION_COUNTERCLOCKWISE",
  "RTCCertificate",
  "RTCDTMFSender",
  "RTCDTMFToneChangeEvent",
  "RTCDataChannel",
  "RTCDataChannelEvent",
  "RTCDtlsTransport",
  "RTCEncodedAudioFrame",
  "RTCEncodedVideoFrame",
  "RTCError",
  "RTCErrorEvent",
  "RTCIceCandidate",
  "RTCIceTransport",
  "RTCPeerConnection",
  "RTCPeerConnectionIceErrorEvent",
  "RTCPeerConnectionIceEvent",
  "RTCRtpReceiver",
  "RTCRtpScriptTransform",
  "RTCRtpSender",
  "RTCRtpTransceiver",
  "RTCSctpTransport",
  "RTCSessionDescription",
  "RTCStatsReport",
  "RTCTrackEvent",
  "RadioNodeList",
  "Range",
  "RangeError",
  "RangeException",
  "ReadableByteStreamController",
  "ReadableStream",
  "ReadableStreamBYOBReader",
  "ReadableStreamBYOBRequest",
  "ReadableStreamDefaultController",
  "ReadableStreamDefaultReader",
  "RecordErrorEvent",
  "Rect",
  "ReferenceError",
  "Reflect",
  "RegExp",
  "RelativeOrientationSensor",
  "RelativeTimeFormat",
  "RemotePlayback",
  "Report",
  "ReportBody",
  "ReportingObserver",
  "Request",
  "RequestUpdateCheckStatus",
  "ResizeObserver",
  "ResizeObserverEntry",
  "ResizeObserverSize",
  "Response",
  "RuntimeError",
  "SAMPLER_2D",
  "SAMPLER_2D_ARRAY",
  "SAMPLER_2D_ARRAY_SHADOW",
  "SAMPLER_2D_SHADOW",
  "SAMPLER_3D",
  "SAMPLER_BINDING",
  "SAMPLER_CUBE",
  "SAMPLER_CUBE_SHADOW",
  "SAMPLES",
  "SAMPLE_ALPHA_TO_COVERAGE",
  "SAMPLE_BUFFERS",
  "SAMPLE_COVERAGE",
  "SAMPLE_COVERAGE_INVERT",
  "SAMPLE_COVERAGE_VALUE",
  "SAWTOOTH",
  "SCHEDULED_STATE",
  "SCISSOR_BOX",
  "SCISSOR_TEST",
  "SCROLL_PAGE_DOWN",
  "SCROLL_PAGE_UP",
  "SDP_ANSWER",
  "SDP_OFFER",
  "SDP_PRANSWER",
  "SECURITY_ERR",
  "SELECT",
  "SEPARATE_ATTRIBS",
  "SERIALIZE_ERR",
  "SEVERITY_ERROR",
  "SEVERITY_FATAL_ERROR",
  "SEVERITY_WARNING",
  "SHADER_COMPILER",
  "SHADER_TYPE",
  "SHADING_LANGUAGE_VERSION",
  "SHIFT_MASK",
  "SHORT",
  "SHOWING",
  "SHOW_ALL",
  "SHOW_ATTRIBUTE",
  "SHOW_CDATA_SECTION",
  "SHOW_COMMENT",
  "SHOW_DOCUMENT",
  "SHOW_DOCUMENT_FRAGMENT",
  "SHOW_DOCUMENT_TYPE",
  "SHOW_ELEMENT",
  "SHOW_ENTITY",
  "SHOW_ENTITY_REFERENCE",
  "SHOW_NOTATION",
  "SHOW_PROCESSING_INSTRUCTION",
  "SHOW_TEXT",
  "SIGNALED",
  "SIGNED_NORMALIZED",
  "SINE",
  "SOUNDFIELD",
  "SQLException",
  "SQRT1_2",
  "SQRT2",
  "SQUARE",
  "SRC_ALPHA",
  "SRC_ALPHA_SATURATE",
  "SRC_COLOR",
  "SRGB",
  "SRGB8",
  "SRGB8_ALPHA8",
  "START_TO_END",
  "START_TO_START",
  "STATIC_COPY",
  "STATIC_DRAW",
  "STATIC_READ",
  "STENCIL",
  "STENCIL_ATTACHMENT",
  "STENCIL_BACK_FAIL",
  "STENCIL_BACK_FUNC",
  "STENCIL_BACK_PASS_DEPTH_FAIL",
  "STENCIL_BACK_PASS_DEPTH_PASS",
  "STENCIL_BACK_REF",
  "STENCIL_BACK_VALUE_MASK",
  "STENCIL_BACK_WRITEMASK",
  "STENCIL_BITS",
  "STENCIL_BUFFER_BIT",
  "STENCIL_CLEAR_VALUE",
  "STENCIL_FAIL",
  "STENCIL_FUNC",
  "STENCIL_INDEX",
  "STENCIL_INDEX8",
  "STENCIL_PASS_DEPTH_FAIL",
  "STENCIL_PASS_DEPTH_PASS",
  "STENCIL_REF",
  "STENCIL_TEST",
  "STENCIL_VALUE_MASK",
  "STENCIL_WRITEMASK",
  "STORAGE",
  "STORAGE_BINDING",
  "STREAM_COPY",
  "STREAM_DRAW",
  "STREAM_READ",
  "STRING_TYPE",
  "STYLE_RULE",
  "SUBPIXEL_BITS",
  "SUPPORTS_RULE",
  "SVGAElement",
  "SVGAltGlyphDefElement",
  "SVGAltGlyphElement",
  "SVGAltGlyphItemElement",
  "SVGAngle",
  "SVGAnimateColorElement",
  "SVGAnimateElement",
  "SVGAnimateMotionElement",
  "SVGAnimateTransformElement",
  "SVGAnimatedAngle",
  "SVGAnimatedBoolean",
  "SVGAnimatedEnumeration",
  "SVGAnimatedInteger",
  "SVGAnimatedLength",
  "SVGAnimatedLengthList",
  "SVGAnimatedNumber",
  "SVGAnimatedNumberList",
  "SVGAnimatedPreserveAspectRatio",
  "SVGAnimatedRect",
  "SVGAnimatedString",
  "SVGAnimatedTransformList",
  "SVGAnimationElement",
  "SVGCircleElement",
  "SVGClipPathElement",
  "SVGColor",
  "SVGComponentTransferFunctionElement",
  "SVGCursorElement",
  "SVGDefsElement",
  "SVGDescElement",
  "SVGDiscardElement",
  "SVGDocument",
  "SVGElement",
  "SVGElementInstance",
  "SVGElementInstanceList",
  "SVGEllipseElement",
  "SVGException",
  "SVGFEBlendElement",
  "SVGFEColorMatrixElement",
  "SVGFEComponentTransferElement",
  "SVGFECompositeElement",
  "SVGFEConvolveMatrixElement",
  "SVGFEDiffuseLightingElement",
  "SVGFEDisplacementMapElement",
  "SVGFEDistantLightElement",
  "SVGFEDropShadowElement",
  "SVGFEFloodElement",
  "SVGFEFuncAElement",
  "SVGFEFuncBElement",
  "SVGFEFuncGElement",
  "SVGFEFuncRElement",
  "SVGFEGaussianBlurElement",
  "SVGFEImageElement",
  "SVGFEMergeElement",
  "SVGFEMergeNodeElement",
  "SVGFEMorphologyElement",
  "SVGFEOffsetElement",
  "SVGFEPointLightElement",
  "SVGFESpecularLightingElement",
  "SVGFESpotLightElement",
  "SVGFETileElement",
  "SVGFETurbulenceElement",
  "SVGFilterElement",
  "SVGFontElement",
  "SVGFontFaceElement",
  "SVGFontFaceFormatElement",
  "SVGFontFaceNameElement",
  "SVGFontFaceSrcElement",
  "SVGFontFaceUriElement",
  "SVGForeignObjectElement",
  "SVGGElement",
  "SVGGeometryElement",
  "SVGGlyphElement",
  "SVGGlyphRefElement",
  "SVGGradientElement",
  "SVGGraphicsElement",
  "SVGHKernElement",
  "SVGImageElement",
  "SVGLength",
  "SVGLengthList",
  "SVGLineElement",
  "SVGLinearGradientElement",
  "SVGMPathElement",
  "SVGMarkerElement",
  "SVGMaskElement",
  "SVGMatrix",
  "SVGMetadataElement",
  "SVGMissingGlyphElement",
  "SVGNumber",
  "SVGNumberList",
  "SVGPaint",
  "SVGPathElement",
  "SVGPathSeg",
  "SVGPathSegArcAbs",
  "SVGPathSegArcRel",
  "SVGPathSegClosePath",
  "SVGPathSegCurvetoCubicAbs",
  "SVGPathSegCurvetoCubicRel",
  "SVGPathSegCurvetoCubicSmoothAbs",
  "SVGPathSegCurvetoCubicSmoothRel",
  "SVGPathSegCurvetoQuadraticAbs",
  "SVGPathSegCurvetoQuadraticRel",
  "SVGPathSegCurvetoQuadraticSmoothAbs",
  "SVGPathSegCurvetoQuadraticSmoothRel",
  "SVGPathSegLinetoAbs",
  "SVGPathSegLinetoHorizontalAbs",
  "SVGPathSegLinetoHorizontalRel",
  "SVGPathSegLinetoRel",
  "SVGPathSegLinetoVerticalAbs",
  "SVGPathSegLinetoVerticalRel",
  "SVGPathSegList",
  "SVGPathSegMovetoAbs",
  "SVGPathSegMovetoRel",
  "SVGPatternElement",
  "SVGPoint",
  "SVGPointList",
  "SVGPolygonElement",
  "SVGPolylineElement",
  "SVGPreserveAspectRatio",
  "SVGRadialGradientElement",
  "SVGRect",
  "SVGRectElement",
  "SVGRenderingIntent",
  "SVGSVGElement",
  "SVGScriptElement",
  "SVGSetElement",
  "SVGStopElement",
  "SVGStringList",
  "SVGStyleElement",
  "SVGSwitchElement",
  "SVGSymbolElement",
  "SVGTRefElement",
  "SVGTSpanElement",
  "SVGTextContentElement",
  "SVGTextElement",
  "SVGTextPathElement",
  "SVGTextPositioningElement",
  "SVGTitleElement",
  "SVGTransform",
  "SVGTransformList",
  "SVGUnitTypes",
  "SVGUseElement",
  "SVGVKernElement",
  "SVGViewElement",
  "SVGViewSpec",
  "SVGZoomAndPan",
  "SVGZoomEvent",
  "SVG_ANGLETYPE_DEG",
  "SVG_ANGLETYPE_GRAD",
  "SVG_ANGLETYPE_RAD",
  "SVG_ANGLETYPE_UNKNOWN",
  "SVG_ANGLETYPE_UNSPECIFIED",
  "SVG_CHANNEL_A",
  "SVG_CHANNEL_B",
  "SVG_CHANNEL_G",
  "SVG_CHANNEL_R",
  "SVG_CHANNEL_UNKNOWN",
  "SVG_COLORTYPE_CURRENTCOLOR",
  "SVG_COLORTYPE_RGBCOLOR",
  "SVG_COLORTYPE_RGBCOLOR_ICCCOLOR",
  "SVG_COLORTYPE_UNKNOWN",
  "SVG_EDGEMODE_DUPLICATE",
  "SVG_EDGEMODE_NONE",
  "SVG_EDGEMODE_UNKNOWN",
  "SVG_EDGEMODE_WRAP",
  "SVG_FEBLEND_MODE_COLOR",
  "SVG_FEBLEND_MODE_COLOR_BURN",
  "SVG_FEBLEND_MODE_COLOR_DODGE",
  "SVG_FEBLEND_MODE_DARKEN",
  "SVG_FEBLEND_MODE_DIFFERENCE",
  "SVG_FEBLEND_MODE_EXCLUSION",
  "SVG_FEBLEND_MODE_HARD_LIGHT",
  "SVG_FEBLEND_MODE_HUE",
  "SVG_FEBLEND_MODE_LIGHTEN",
  "SVG_FEBLEND_MODE_LUMINOSITY",
  "SVG_FEBLEND_MODE_MULTIPLY",
  "SVG_FEBLEND_MODE_NORMAL",
  "SVG_FEBLEND_MODE_OVERLAY",
  "SVG_FEBLEND_MODE_SATURATION",
  "SVG_FEBLEND_MODE_SCREEN",
  "SVG_FEBLEND_MODE_SOFT_LIGHT",
  "SVG_FEBLEND_MODE_UNKNOWN",
  "SVG_FECOLORMATRIX_TYPE_HUEROTATE",
  "SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA",
  "SVG_FECOLORMATRIX_TYPE_MATRIX",
  "SVG_FECOLORMATRIX_TYPE_SATURATE",
  "SVG_FECOLORMATRIX_TYPE_UNKNOWN",
  "SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE",
  "SVG_FECOMPONENTTRANSFER_TYPE_GAMMA",
  "SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY",
  "SVG_FECOMPONENTTRANSFER_TYPE_LINEAR",
  "SVG_FECOMPONENTTRANSFER_TYPE_TABLE",
  "SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN",
  "SVG_FECOMPOSITE_OPERATOR_ARITHMETIC",
  "SVG_FECOMPOSITE_OPERATOR_ATOP",
  "SVG_FECOMPOSITE_OPERATOR_IN",
  "SVG_FECOMPOSITE_OPERATOR_LIGHTER",
  "SVG_FECOMPOSITE_OPERATOR_OUT",
  "SVG_FECOMPOSITE_OPERATOR_OVER",
  "SVG_FECOMPOSITE_OPERATOR_UNKNOWN",
  "SVG_FECOMPOSITE_OPERATOR_XOR",
  "SVG_INVALID_VALUE_ERR",
  "SVG_LENGTHTYPE_CM",
  "SVG_LENGTHTYPE_EMS",
  "SVG_LENGTHTYPE_EXS",
  "SVG_LENGTHTYPE_IN",
  "SVG_LENGTHTYPE_MM",
  "SVG_LENGTHTYPE_NUMBER",
  "SVG_LENGTHTYPE_PC",
  "SVG_LENGTHTYPE_PERCENTAGE",
  "SVG_LENGTHTYPE_PT",
  "SVG_LENGTHTYPE_PX",
  "SVG_LENGTHTYPE_UNKNOWN",
  "SVG_MARKERUNITS_STROKEWIDTH",
  "SVG_MARKERUNITS_UNKNOWN",
  "SVG_MARKERUNITS_USERSPACEONUSE",
  "SVG_MARKER_ORIENT_ANGLE",
  "SVG_MARKER_ORIENT_AUTO",
  "SVG_MARKER_ORIENT_AUTO_START_REVERSE",
  "SVG_MARKER_ORIENT_UNKNOWN",
  "SVG_MASKTYPE_ALPHA",
  "SVG_MASKTYPE_LUMINANCE",
  "SVG_MATRIX_NOT_INVERTABLE",
  "SVG_MEETORSLICE_MEET",
  "SVG_MEETORSLICE_SLICE",
  "SVG_MEETORSLICE_UNKNOWN",
  "SVG_MORPHOLOGY_OPERATOR_DILATE",
  "SVG_MORPHOLOGY_OPERATOR_ERODE",
  "SVG_MORPHOLOGY_OPERATOR_UNKNOWN",
  "SVG_PAINTTYPE_CURRENTCOLOR",
  "SVG_PAINTTYPE_NONE",
  "SVG_PAINTTYPE_RGBCOLOR",
  "SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR",
  "SVG_PAINTTYPE_UNKNOWN",
  "SVG_PAINTTYPE_URI",
  "SVG_PAINTTYPE_URI_CURRENTCOLOR",
  "SVG_PAINTTYPE_URI_NONE",
  "SVG_PAINTTYPE_URI_RGBCOLOR",
  "SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR",
  "SVG_PRESERVEASPECTRATIO_NONE",
  "SVG_PRESERVEASPECTRATIO_UNKNOWN",
  "SVG_PRESERVEASPECTRATIO_XMAXYMAX",
  "SVG_PRESERVEASPECTRATIO_XMAXYMID",
  "SVG_PRESERVEASPECTRATIO_XMAXYMIN",
  "SVG_PRESERVEASPECTRATIO_XMIDYMAX",
  "SVG_PRESERVEASPECTRATIO_XMIDYMID",
  "SVG_PRESERVEASPECTRATIO_XMIDYMIN",
  "SVG_PRESERVEASPECTRATIO_XMINYMAX",
  "SVG_PRESERVEASPECTRATIO_XMINYMID",
  "SVG_PRESERVEASPECTRATIO_XMINYMIN",
  "SVG_SPREADMETHOD_PAD",
  "SVG_SPREADMETHOD_REFLECT",
  "SVG_SPREADMETHOD_REPEAT",
  "SVG_SPREADMETHOD_UNKNOWN",
  "SVG_STITCHTYPE_NOSTITCH",
  "SVG_STITCHTYPE_STITCH",
  "SVG_STITCHTYPE_UNKNOWN",
  "SVG_TRANSFORM_MATRIX",
  "SVG_TRANSFORM_ROTATE",
  "SVG_TRANSFORM_SCALE",
  "SVG_TRANSFORM_SKEWX",
  "SVG_TRANSFORM_SKEWY",
  "SVG_TRANSFORM_TRANSLATE",
  "SVG_TRANSFORM_UNKNOWN",
  "SVG_TURBULENCE_TYPE_FRACTALNOISE",
  "SVG_TURBULENCE_TYPE_TURBULENCE",
  "SVG_TURBULENCE_TYPE_UNKNOWN",
  "SVG_UNIT_TYPE_OBJECTBOUNDINGBOX",
  "SVG_UNIT_TYPE_UNKNOWN",
  "SVG_UNIT_TYPE_USERSPACEONUSE",
  "SVG_WRONG_TYPE_ERR",
  "SVG_ZOOMANDPAN_DISABLE",
  "SVG_ZOOMANDPAN_MAGNIFY",
  "SVG_ZOOMANDPAN_UNKNOWN",
  "SYNC_CONDITION",
  "SYNC_FENCE",
  "SYNC_FLAGS",
  "SYNC_FLUSH_COMMANDS_BIT",
  "SYNC_GPU_COMMANDS_COMPLETE",
  "SYNC_STATUS",
  "SYNTAX_ERR",
  "SavedPages",
  "Scheduler",
  "Scheduling",
  "Screen",
  "ScreenDetailed",
  "ScreenDetails",
  "ScreenOrientation",
  "Script",
  "ScriptProcessorNode",
  "ScrollAreaEvent",
  "ScrollTimeline",
  "SecurityPolicyViolationEvent",
  "Segmenter",
  "Selection",
  "Sensor",
  "SensorErrorEvent",
  "Serial",
  "SerialPort",
  "ServiceWorker",
  "ServiceWorkerContainer",
  "ServiceWorkerRegistration",
  "SessionDescription",
  "Set",
  "ShadowRoot",
  "SharedArrayBuffer",
  "SharedStorage",
  "SharedStorageWorklet",
  "SharedWorker",
  "SharingState",
  "SimpleGestureEvent",
  "SnapEvent",
  "SourceBuffer",
  "SourceBufferList",
  "SpeechSynthesis",
  "SpeechSynthesisErrorEvent",
  "SpeechSynthesisEvent",
  "SpeechSynthesisUtterance",
  "SpeechSynthesisVoice",
  "StaticRange",
  "StereoPannerNode",
  "StopIteration",
  "Storage",
  "StorageBucket",
  "StorageBucketManager",
  "StorageEvent",
  "StorageManager",
  "String",
  "StructType",
  "StylePropertyMap",
  "StylePropertyMapReadOnly",
  "StyleSheet",
  "StyleSheetList",
  "SubmitEvent",
  "SubtleCrypto",
  "Symbol",
  "SyncManager",
  "SyntaxError",
  "TAB_ID_NONE",
  "TAB_INDEX_NONE",
  "TEMPORARY",
  "TEXTPATH_METHODTYPE_ALIGN",
  "TEXTPATH_METHODTYPE_STRETCH",
  "TEXTPATH_METHODTYPE_UNKNOWN",
  "TEXTPATH_SPACINGTYPE_AUTO",
  "TEXTPATH_SPACINGTYPE_EXACT",
  "TEXTPATH_SPACINGTYPE_UNKNOWN",
  "TEXTURE",
  "TEXTURE0",
  "TEXTURE1",
  "TEXTURE10",
  "TEXTURE11",
  "TEXTURE12",
  "TEXTURE13",
  "TEXTURE14",
  "TEXTURE15",
  "TEXTURE16",
  "TEXTURE17",
  "TEXTURE18",
  "TEXTURE19",
  "TEXTURE2",
  "TEXTURE20",
  "TEXTURE21",
  "TEXTURE22",
  "TEXTURE23",
  "TEXTURE24",
  "TEXTURE25",
  "TEXTURE26",
  "TEXTURE27",
  "TEXTURE28",
  "TEXTURE29",
  "TEXTURE3",
  "TEXTURE30",
  "TEXTURE31",
  "TEXTURE4",
  "TEXTURE5",
  "TEXTURE6",
  "TEXTURE7",
  "TEXTURE8",
  "TEXTURE9",
  "TEXTURE_2D",
  "TEXTURE_2D_ARRAY",
  "TEXTURE_3D",
  "TEXTURE_BASE_LEVEL",
  "TEXTURE_BINDING",
  "TEXTURE_BINDING_2D",
  "TEXTURE_BINDING_2D_ARRAY",
  "TEXTURE_BINDING_3D",
  "TEXTURE_BINDING_CUBE_MAP",
  "TEXTURE_COMPARE_FUNC",
  "TEXTURE_COMPARE_MODE",
  "TEXTURE_CUBE_MAP",
  "TEXTURE_CUBE_MAP_NEGATIVE_X",
  "TEXTURE_CUBE_MAP_NEGATIVE_Y",
  "TEXTURE_CUBE_MAP_NEGATIVE_Z",
  "TEXTURE_CUBE_MAP_POSITIVE_X",
  "TEXTURE_CUBE_MAP_POSITIVE_Y",
  "TEXTURE_CUBE_MAP_POSITIVE_Z",
  "TEXTURE_IMMUTABLE_FORMAT",
  "TEXTURE_IMMUTABLE_LEVELS",
  "TEXTURE_MAG_FILTER",
  "TEXTURE_MAX_ANISOTROPY_EXT",
  "TEXTURE_MAX_LEVEL",
  "TEXTURE_MAX_LOD",
  "TEXTURE_MIN_FILTER",
  "TEXTURE_MIN_LOD",
  "TEXTURE_WRAP_R",
  "TEXTURE_WRAP_S",
  "TEXTURE_WRAP_T",
  "TEXT_NODE",
  "TIMEOUT",
  "TIMEOUT_ERR",
  "TIMEOUT_EXPIRED",
  "TIMEOUT_IGNORED",
  "TOO_LARGE_ERR",
  "TRANSACTION_INACTIVE_ERR",
  "TRANSFORM_FEEDBACK",
  "TRANSFORM_FEEDBACK_ACTIVE",
  "TRANSFORM_FEEDBACK_BINDING",
  "TRANSFORM_FEEDBACK_BUFFER",
  "TRANSFORM_FEEDBACK_BUFFER_BINDING",
  "TRANSFORM_FEEDBACK_BUFFER_MODE",
  "TRANSFORM_FEEDBACK_BUFFER_SIZE",
  "TRANSFORM_FEEDBACK_BUFFER_START",
  "TRANSFORM_FEEDBACK_PAUSED",
  "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN",
  "TRANSFORM_FEEDBACK_VARYINGS",
  "TRIANGLE",
  "TRIANGLES",
  "TRIANGLE_FAN",
  "TRIANGLE_STRIP",
  "TYPE_BACK_FORWARD",
  "TYPE_ERR",
  "TYPE_MISMATCH_ERR",
  "TYPE_NAVIGATE",
  "TYPE_RELOAD",
  "TYPE_RESERVED",
  "Tab",
  "TabStatus",
  "Table",
  "Tag",
  "TaskAttributionTiming",
  "TaskController",
  "TaskPriorityChangeEvent",
  "TaskSignal",
  "Text",
  "TextDecoder",
  "TextDecoderStream",
  "TextEncoder",
  "TextEncoderStream",
  "TextEvent",
  "TextFormat",
  "TextFormatUpdateEvent",
  "TextMetrics",
  "TextTrack",
  "TextTrackCue",
  "TextTrackCueList",
  "TextTrackList",
  "TextUpdateEvent",
  "TimeEvent",
  "TimeRanges",
  "ToggleEvent",
  "Touch",
  "TouchEvent",
  "TouchList",
  "TrackEvent",
  "TransformStream",
  "TransformStreamDefaultController",
  "TransitionEvent",
  "TreeWalker",
  "TrustedHTML",
  "TrustedScript",
  "TrustedScriptURL",
  "TrustedTypePolicy",
  "TrustedTypePolicyFactory",
  "TypeError",
  "TypedObject",
  "U2F",
  "UIEvent",
  "UNCACHED",
  "UNIFORM",
  "UNIFORM_ARRAY_STRIDE",
  "UNIFORM_BLOCK_ACTIVE_UNIFORMS",
  "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES",
  "UNIFORM_BLOCK_BINDING",
  "UNIFORM_BLOCK_DATA_SIZE",
  "UNIFORM_BLOCK_INDEX",
  "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER",
  "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER",
  "UNIFORM_BUFFER",
  "UNIFORM_BUFFER_BINDING",
  "UNIFORM_BUFFER_OFFSET_ALIGNMENT",
  "UNIFORM_BUFFER_SIZE",
  "UNIFORM_BUFFER_START",
  "UNIFORM_IS_ROW_MAJOR",
  "UNIFORM_MATRIX_STRIDE",
  "UNIFORM_OFFSET",
  "UNIFORM_SIZE",
  "UNIFORM_TYPE",
  "UNKNOWN_ERR",
  "UNKNOWN_RULE",
  "UNMASKED_RENDERER_WEBGL",
  "UNMASKED_VENDOR_WEBGL",
  "UNORDERED_NODE_ITERATOR_TYPE",
  "UNORDERED_NODE_SNAPSHOT_TYPE",
  "UNPACK_ALIGNMENT",
  "UNPACK_COLORSPACE_CONVERSION_WEBGL",
  "UNPACK_FLIP_Y_WEBGL",
  "UNPACK_IMAGE_HEIGHT",
  "UNPACK_PREMULTIPLY_ALPHA_WEBGL",
  "UNPACK_ROW_LENGTH",
  "UNPACK_SKIP_IMAGES",
  "UNPACK_SKIP_PIXELS",
  "UNPACK_SKIP_ROWS",
  "UNSCHEDULED_STATE",
  "UNSENT",
  "UNSIGNALED",
  "UNSIGNED_BYTE",
  "UNSIGNED_INT",
  "UNSIGNED_INT_10F_11F_11F_REV",
  "UNSIGNED_INT_24_8",
  "UNSIGNED_INT_2_10_10_10_REV",
  "UNSIGNED_INT_5_9_9_9_REV",
  "UNSIGNED_INT_SAMPLER_2D",
  "UNSIGNED_INT_SAMPLER_2D_ARRAY",
  "UNSIGNED_INT_SAMPLER_3D",
  "UNSIGNED_INT_SAMPLER_CUBE",
  "UNSIGNED_INT_VEC2",
  "UNSIGNED_INT_VEC3",
  "UNSIGNED_INT_VEC4",
  "UNSIGNED_NORMALIZED",
  "UNSIGNED_SHORT",
  "UNSIGNED_SHORT_4_4_4_4",
  "UNSIGNED_SHORT_5_5_5_1",
  "UNSIGNED_SHORT_5_6_5",
  "UNSPECIFIED_EVENT_TYPE_ERR",
  "UPDATEREADY",
  "URIError",
  "URL",
  "URLPattern",
  "URLSearchParams",
  "URLUnencoded",
  "URL_MISMATCH_ERR",
  "USB",
  "USBAlternateInterface",
  "USBConfiguration",
  "USBConnectionEvent",
  "USBDevice",
  "USBEndpoint",
  "USBInTransferResult",
  "USBInterface",
  "USBIsochronousInTransferPacket",
  "USBIsochronousInTransferResult",
  "USBIsochronousOutTransferPacket",
  "USBIsochronousOutTransferResult",
  "USBOutTransferResult",
  "UTC",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "UpdateFilter",
  "UpdatePropertyName",
  "UserActivation",
  "UserMessageHandler",
  "UserMessageHandlersNamespace",
  "UserProximityEvent",
  "VALIDATE_STATUS",
  "VALIDATION_ERR",
  "VARIABLES_RULE",
  "VENDOR",
  "VERSION",
  "VERSION_CHANGE",
  "VERSION_ERR",
  "VERTEX",
  "VERTEX_ARRAY_BINDING",
  "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",
  "VERTEX_ATTRIB_ARRAY_DIVISOR",
  "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE",
  "VERTEX_ATTRIB_ARRAY_ENABLED",
  "VERTEX_ATTRIB_ARRAY_INTEGER",
  "VERTEX_ATTRIB_ARRAY_NORMALIZED",
  "VERTEX_ATTRIB_ARRAY_POINTER",
  "VERTEX_ATTRIB_ARRAY_SIZE",
  "VERTEX_ATTRIB_ARRAY_STRIDE",
  "VERTEX_ATTRIB_ARRAY_TYPE",
  "VERTEX_SHADER",
  "VERTICAL",
  "VERTICAL_AXIS",
  "VER_ERR",
  "VIEWPORT",
  "VIEWPORT_RULE",
  "VRDisplay",
  "VRDisplayCapabilities",
  "VRDisplayEvent",
  "VREyeParameters",
  "VRFieldOfView",
  "VRFrameData",
  "VRPose",
  "VRStageParameters",
  "VTTCue",
  "VTTRegion",
  "ValidityState",
  "VideoColorSpace",
  "VideoDecoder",
  "VideoEncoder",
  "VideoFrame",
  "VideoPlaybackQuality",
  "VideoStreamTrack",
  "ViewTimeline",
  "ViewTransition",
  "ViewTransitionTypeSet",
  "ViewType",
  "VirtualKeyboard",
  "VirtualKeyboardGeometryChangeEvent",
  "VisibilityStateEntry",
  "VisualViewport",
  "WAIT_FAILED",
  "WEBKIT_FILTER_RULE",
  "WEBKIT_KEYFRAMES_RULE",
  "WEBKIT_KEYFRAME_RULE",
  "WEBKIT_REGION_RULE",
  "WGSLLanguageFeatures",
  "WINDOW_ID_CURRENT",
  "WINDOW_ID_NONE",
  "WRITE",
  "WRONG_DOCUMENT_ERR",
  "WakeLock",
  "WakeLockSentinel",
  "WasmAnyRef",
  "WaveShaperNode",
  "WeakMap",
  "WeakRef",
  "WeakSet",
  "WebAssembly",
  "WebGL2RenderingContext",
  "WebGLActiveInfo",
  "WebGLBuffer",
  "WebGLContextEvent",
  "WebGLFramebuffer",
  "WebGLObject",
  "WebGLProgram",
  "WebGLQuery",
  "WebGLRenderbuffer",
  "WebGLRenderingContext",
  "WebGLSampler",
  "WebGLShader",
  "WebGLShaderPrecisionFormat",
  "WebGLSync",
  "WebGLTexture",
  "WebGLTransformFeedback",
  "WebGLUniformLocation",
  "WebGLVertexArray",
  "WebGLVertexArrayObject",
  "WebKitAnimationEvent",
  "WebKitBlobBuilder",
  "WebKitCSSFilterRule",
  "WebKitCSSFilterValue",
  "WebKitCSSKeyframeRule",
  "WebKitCSSKeyframesRule",
  "WebKitCSSMatrix",
  "WebKitCSSRegionRule",
  "WebKitCSSTransformValue",
  "WebKitDataCue",
  "WebKitGamepad",
  "WebKitMediaKeyError",
  "WebKitMediaKeyMessageEvent",
  "WebKitMediaKeySession",
  "WebKitMediaKeys",
  "WebKitMediaSource",
  "WebKitMutationObserver",
  "WebKitNamespace",
  "WebKitPlaybackTargetAvailabilityEvent",
  "WebKitPoint",
  "WebKitShadowRoot",
  "WebKitSourceBuffer",
  "WebKitSourceBufferList",
  "WebKitTransitionEvent",
  "WebSocket",
  "WebSocketError",
  "WebSocketStream",
  "WebTransport",
  "WebTransportBidirectionalStream",
  "WebTransportDatagramDuplexStream",
  "WebTransportError",
  "WebTransportReceiveStream",
  "WebTransportSendStream",
  "WebkitAlignContent",
  "WebkitAlignItems",
  "WebkitAlignSelf",
  "WebkitAnimation",
  "WebkitAnimationDelay",
  "WebkitAnimationDirection",
  "WebkitAnimationDuration",
  "WebkitAnimationFillMode",
  "WebkitAnimationIterationCount",
  "WebkitAnimationName",
  "WebkitAnimationPlayState",
  "WebkitAnimationTimingFunction",
  "WebkitAppearance",
  "WebkitBackfaceVisibility",
  "WebkitBackgroundClip",
  "WebkitBackgroundOrigin",
  "WebkitBackgroundSize",
  "WebkitBorderBottomLeftRadius",
  "WebkitBorderBottomRightRadius",
  "WebkitBorderImage",
  "WebkitBorderRadius",
  "WebkitBorderTopLeftRadius",
  "WebkitBorderTopRightRadius",
  "WebkitBoxAlign",
  "WebkitBoxDirection",
  "WebkitBoxFlex",
  "WebkitBoxOrdinalGroup",
  "WebkitBoxOrient",
  "WebkitBoxPack",
  "WebkitBoxShadow",
  "WebkitBoxSizing",
  "WebkitClipPath",
  "WebkitFilter",
  "WebkitFlex",
  "WebkitFlexBasis",
  "WebkitFlexDirection",
  "WebkitFlexFlow",
  "WebkitFlexGrow",
  "WebkitFlexShrink",
  "WebkitFlexWrap",
  "WebkitFontFeatureSettings",
  "WebkitJustifyContent",
  "WebkitLineClamp",
  "WebkitMask",
  "WebkitMaskClip",
  "WebkitMaskComposite",
  "WebkitMaskImage",
  "WebkitMaskOrigin",
  "WebkitMaskPosition",
  "WebkitMaskPositionX",
  "WebkitMaskPositionY",
  "WebkitMaskRepeat",
  "WebkitMaskSize",
  "WebkitOrder",
  "WebkitPerspective",
  "WebkitPerspectiveOrigin",
  "WebkitTextFillColor",
  "WebkitTextSecurity",
  "WebkitTextSizeAdjust",
  "WebkitTextStroke",
  "WebkitTextStrokeColor",
  "WebkitTextStrokeWidth",
  "WebkitTransform",
  "WebkitTransformOrigin",
  "WebkitTransformStyle",
  "WebkitTransition",
  "WebkitTransitionDelay",
  "WebkitTransitionDuration",
  "WebkitTransitionProperty",
  "WebkitTransitionTimingFunction",
  "WebkitUserSelect",
  "WheelEvent",
  "Window",
  "WindowControlsOverlay",
  "WindowControlsOverlayGeometryChangeEvent",
  "WindowState",
  "WindowType",
  "Worker",
  "Worklet",
  "WritableStream",
  "WritableStreamDefaultController",
  "WritableStreamDefaultWriter",
  "XMLDocument",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestException",
  "XMLHttpRequestProgressEvent",
  "XMLHttpRequestUpload",
  "XMLSerializer",
  "XMLStylesheetProcessingInstruction",
  "XPathEvaluator",
  "XPathException",
  "XPathExpression",
  "XPathNSResolver",
  "XPathResult",
  "XRAnchor",
  "XRAnchorSet",
  "XRBoundedReferenceSpace",
  "XRCPUDepthInformation",
  "XRCamera",
  "XRDOMOverlayState",
  "XRDepthInformation",
  "XRFrame",
  "XRHand",
  "XRHitTestResult",
  "XRHitTestSource",
  "XRInputSource",
  "XRInputSourceArray",
  "XRInputSourceEvent",
  "XRInputSourcesChangeEvent",
  "XRJointPose",
  "XRJointSpace",
  "XRLayer",
  "XRLightEstimate",
  "XRLightProbe",
  "XRPose",
  "XRRay",
  "XRReferenceSpace",
  "XRReferenceSpaceEvent",
  "XRRenderState",
  "XRRigidTransform",
  "XRSession",
  "XRSessionEvent",
  "XRSpace",
  "XRSystem",
  "XRTransientInputHitTestResult",
  "XRTransientInputHitTestSource",
  "XRView",
  "XRViewerPose",
  "XRViewport",
  "XRWebGLBinding",
  "XRWebGLDepthInformation",
  "XRWebGLLayer",
  "XSLTProcessor",
  "ZERO",
  "ZoomSettings",
  "ZoomSettingsMode",
  "ZoomSettingsScope",
  "_XD0M_",
  "_YD0M_",
  "__REACT_DEVTOOLS_GLOBAL_HOOK__",
  "__brand",
  "__defineGetter__",
  "__defineSetter__",
  "__lookupGetter__",
  "__lookupSetter__",
  "__opera",
  "__proto__",
  "_browserjsran",
  "a",
  "aLink",
  "abbr",
  "abort",
  "aborted",
  "aboutConfigPrefs",
  "abs",
  "absolute",
  "acceleration",
  "accelerationIncludingGravity",
  "accelerator",
  "accent-color",
  "accentColor",
  "accept",
  "acceptCharset",
  "acceptNode",
  "access",
  "accessKey",
  "accessKeyLabel",
  "accuracy",
  "acos",
  "acosh",
  "action",
  "actionURL",
  "actions",
  "activated",
  "activation",
  "activationStart",
  "active",
  "activeCues",
  "activeElement",
  "activeSourceBuffers",
  "activeSourceCount",
  "activeTexture",
  "activeVRDisplays",
  "activityLog",
  "actualBoundingBoxAscent",
  "actualBoundingBoxDescent",
  "actualBoundingBoxLeft",
  "actualBoundingBoxRight",
  "adAuctionComponents",
  "adAuctionHeaders",
  "add",
  "addAll",
  "addBehavior",
  "addCandidate",
  "addColorStop",
  "addCue",
  "addElement",
  "addEventListener",
  "addFilter",
  "addFromString",
  "addFromUri",
  "addIceCandidate",
  "addImport",
  "addListener",
  "addModule",
  "addNamed",
  "addPageRule",
  "addPath",
  "addPointer",
  "addRange",
  "addRegion",
  "addRule",
  "addSearchEngine",
  "addSourceBuffer",
  "addStream",
  "addTextTrack",
  "addTrack",
  "addTransceiver",
  "addWakeLockListener",
  "added",
  "addedNodes",
  "additionalName",
  "additiveSymbols",
  "addons",
  "address",
  "addressLine",
  "addressModeU",
  "addressModeV",
  "addressModeW",
  "adoptNode",
  "adoptedCallback",
  "adoptedStyleSheets",
  "adr",
  "advance",
  "after",
  "alarms",
  "album",
  "alert",
  "algorithm",
  "align",
  "align-content",
  "align-items",
  "align-self",
  "alignContent",
  "alignItems",
  "alignSelf",
  "alignmentBaseline",
  "alinkColor",
  "all",
  "allSettled",
  "allocationSize",
  "allow",
  "allowFullscreen",
  "allowPaymentRequest",
  "allowedDirections",
  "allowedFeatures",
  "allowedToPlay",
  "allowsFeature",
  "alpha",
  "alphaMode",
  "alphaToCoverageEnabled",
  "alphabeticBaseline",
  "alt",
  "altGraphKey",
  "altHtml",
  "altKey",
  "altLeft",
  "alternate",
  "alternateSetting",
  "alternates",
  "altitude",
  "altitudeAccuracy",
  "altitudeAngle",
  "amplitude",
  "ancestorOrigins",
  "anchor",
  "anchorNode",
  "anchorOffset",
  "anchorSpace",
  "anchors",
  "and",
  "angle",
  "angularAcceleration",
  "angularVelocity",
  "animVal",
  "animate",
  "animated",
  "animatedInstanceRoot",
  "animatedNormalizedPathSegList",
  "animatedPathSegList",
  "animatedPoints",
  "animation",
  "animation-composition",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "animationComposition",
  "animationDelay",
  "animationDirection",
  "animationDuration",
  "animationFillMode",
  "animationIterationCount",
  "animationName",
  "animationPlayState",
  "animationStartTime",
  "animationTimingFunction",
  "animationsPaused",
  "anniversary",
  "antialias",
  "anticipatedRemoval",
  "any",
  "app",
  "appCodeName",
  "appMinorVersion",
  "appName",
  "appNotifications",
  "appVersion",
  "appearance",
  "append",
  "appendBuffer",
  "appendChild",
  "appendData",
  "appendItem",
  "appendMedium",
  "appendNamed",
  "appendRule",
  "appendStream",
  "appendWindowEnd",
  "appendWindowStart",
  "applets",
  "applicationCache",
  "applicationServerKey",
  "apply",
  "applyConstraints",
  "applyElement",
  "arc",
  "arcTo",
  "arch",
  "architecture",
  "archive",
  "areas",
  "arguments",
  "ariaAtomic",
  "ariaAutoComplete",
  "ariaBrailleLabel",
  "ariaBrailleRoleDescription",
  "ariaBusy",
  "ariaChecked",
  "ariaColCount",
  "ariaColIndex",
  "ariaColIndexText",
  "ariaColSpan",
  "ariaCurrent",
  "ariaDescription",
  "ariaDisabled",
  "ariaExpanded",
  "ariaHasPopup",
  "ariaHidden",
  "ariaInvalid",
  "ariaKeyShortcuts",
  "ariaLabel",
  "ariaLevel",
  "ariaLive",
  "ariaModal",
  "ariaMultiLine",
  "ariaMultiSelectable",
  "ariaOrientation",
  "ariaPlaceholder",
  "ariaPosInSet",
  "ariaPressed",
  "ariaReadOnly",
  "ariaRelevant",
  "ariaRequired",
  "ariaRoleDescription",
  "ariaRowCount",
  "ariaRowIndex",
  "ariaRowIndexText",
  "ariaRowSpan",
  "ariaSelected",
  "ariaSetSize",
  "ariaSort",
  "ariaValueMax",
  "ariaValueMin",
  "ariaValueNow",
  "ariaValueText",
  "arrayBuffer",
  "arrayLayerCount",
  "arrayStride",
  "artist",
  "artwork",
  "as",
  "asIntN",
  "asUintN",
  "ascentOverride",
  "asin",
  "asinh",
  "aspect",
  "aspect-ratio",
  "aspectRatio",
  "assert",
  "assign",
  "assignedElements",
  "assignedNodes",
  "assignedSlot",
  "async",
  "asyncDispose",
  "asyncIterator",
  "at",
  "atEnd",
  "atan",
  "atan2",
  "atanh",
  "atob",
  "attachEvent",
  "attachInternals",
  "attachShader",
  "attachShadow",
  "attachedElements",
  "attachments",
  "attack",
  "attestationObject",
  "attrChange",
  "attrName",
  "attributeChangedCallback",
  "attributeFilter",
  "attributeName",
  "attributeNamespace",
  "attributeOldValue",
  "attributeStyleMap",
  "attributes",
  "attribution",
  "attributionSrc",
  "audioBitrateMode",
  "audioBitsPerSecond",
  "audioTracks",
  "audioWorklet",
  "authenticatedSignedWrites",
  "authenticatorAttachment",
  "authenticatorData",
  "autoIncrement",
  "autobuffer",
  "autocapitalize",
  "autocomplete",
  "autocorrect",
  "autofocus",
  "automationRate",
  "autoplay",
  "availHeight",
  "availLeft",
  "availTop",
  "availWidth",
  "availability",
  "available",
  "averageLatency",
  "aversion",
  "ax",
  "axes",
  "axis",
  "ay",
  "azimuth",
  "azimuthAngle",
  "b",
  "back",
  "backdrop-filter",
  "backdropFilter",
  "backends",
  "backface-visibility",
  "backfaceVisibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-position-x",
  "background-position-y",
  "background-repeat",
  "background-size",
  "backgroundAttachment",
  "backgroundBlendMode",
  "backgroundClip",
  "backgroundColor",
  "backgroundFetch",
  "backgroundImage",
  "backgroundOrigin",
  "backgroundPosition",
  "backgroundPositionX",
  "backgroundPositionY",
  "backgroundRepeat",
  "backgroundSize",
  "badInput",
  "badge",
  "balance",
  "baseArrayLayer",
  "baseFrequencyX",
  "baseFrequencyY",
  "baseLatency",
  "baseLayer",
  "baseMipLevel",
  "baseNode",
  "baseOffset",
  "basePalette",
  "baseURI",
  "baseVal",
  "baseline-source",
  "baselineShift",
  "baselineSource",
  "battery",
  "bday",
  "before",
  "beginComputePass",
  "beginElement",
  "beginElementAt",
  "beginOcclusionQuery",
  "beginPath",
  "beginQuery",
  "beginRenderPass",
  "beginTransformFeedback",
  "beginningOfPassWriteIndex",
  "behavior",
  "behaviorCookie",
  "behaviorPart",
  "behaviorUrns",
  "beta",
  "bezierCurveTo",
  "bgColor",
  "bgProperties",
  "bias",
  "big",
  "bigint64",
  "biguint64",
  "binaryType",
  "bind",
  "bindAttribLocation",
  "bindBuffer",
  "bindBufferBase",
  "bindBufferRange",
  "bindFramebuffer",
  "bindGroupLayouts",
  "bindRenderbuffer",
  "bindSampler",
  "bindTexture",
  "bindTransformFeedback",
  "bindVertexArray",
  "binding",
  "bitness",
  "blend",
  "blendColor",
  "blendEquation",
  "blendEquationSeparate",
  "blendFunc",
  "blendFuncSeparate",
  "blink",
  "blitFramebuffer",
  "blob",
  "block-size",
  "blockDirection",
  "blockSize",
  "blockedURI",
  "blocking",
  "blockingDuration",
  "blue",
  "bluetooth",
  "blur",
  "body",
  "bodyUsed",
  "bold",
  "bookmarks",
  "booleanValue",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "borderBlock",
  "borderBlockColor",
  "borderBlockEnd",
  "borderBlockEndColor",
  "borderBlockEndStyle",
  "borderBlockEndWidth",
  "borderBlockStart",
  "borderBlockStartColor",
  "borderBlockStartStyle",
  "borderBlockStartWidth",
  "borderBlockStyle",
  "borderBlockWidth",
  "borderBottom",
  "borderBottomColor",
  "borderBottomLeftRadius",
  "borderBottomRightRadius",
  "borderBottomStyle",
  "borderBottomWidth",
  "borderBoxSize",
  "borderCollapse",
  "borderColor",
  "borderColorDark",
  "borderColorLight",
  "borderEndEndRadius",
  "borderEndStartRadius",
  "borderImage",
  "borderImageOutset",
  "borderImageRepeat",
  "borderImageSlice",
  "borderImageSource",
  "borderImageWidth",
  "borderInline",
  "borderInlineColor",
  "borderInlineEnd",
  "borderInlineEndColor",
  "borderInlineEndStyle",
  "borderInlineEndWidth",
  "borderInlineStart",
  "borderInlineStartColor",
  "borderInlineStartStyle",
  "borderInlineStartWidth",
  "borderInlineStyle",
  "borderInlineWidth",
  "borderLeft",
  "borderLeftColor",
  "borderLeftStyle",
  "borderLeftWidth",
  "borderRadius",
  "borderRight",
  "borderRightColor",
  "borderRightStyle",
  "borderRightWidth",
  "borderSpacing",
  "borderStartEndRadius",
  "borderStartStartRadius",
  "borderStyle",
  "borderTop",
  "borderTopColor",
  "borderTopLeftRadius",
  "borderTopRightRadius",
  "borderTopStyle",
  "borderTopWidth",
  "borderWidth",
  "bottom",
  "bottomMargin",
  "bound",
  "boundElements",
  "boundingClientRect",
  "boundingHeight",
  "boundingLeft",
  "boundingRect",
  "boundingTop",
  "boundingWidth",
  "bounds",
  "boundsGeometry",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "boxDecorationBreak",
  "boxShadow",
  "boxSizing",
  "brand",
  "brands",
  "break-after",
  "break-before",
  "break-inside",
  "breakAfter",
  "breakBefore",
  "breakInside",
  "broadcast",
  "browser",
  "browserLanguage",
  "browserSettings",
  "browsingData",
  "browsingTopics",
  "btoa",
  "bubbles",
  "buffer",
  "bufferData",
  "bufferDepth",
  "bufferSize",
  "bufferSubData",
  "buffered",
  "bufferedAmount",
  "bufferedAmountLowThreshold",
  "buffers",
  "buildID",
  "buildNumber",
  "button",
  "buttonID",
  "buttons",
  "byobRequest",
  "byteLength",
  "byteOffset",
  "bytes",
  "bytesPerRow",
  "bytesWritten",
  "c",
  "cache",
  "caches",
  "call",
  "caller",
  "camera",
  "canBeFormatted",
  "canBeMounted",
  "canBeShared",
  "canConstructInDedicatedWorker",
  "canGoBack",
  "canGoForward",
  "canHaveChildren",
  "canHaveHTML",
  "canInsertDTMF",
  "canIntercept",
  "canLoadAdAuctionFencedFrame",
  "canLoadOpaqueURL",
  "canMakePayment",
  "canParse",
  "canPlayType",
  "canPresent",
  "canShare",
  "canTransition",
  "canTrickleIceCandidates",
  "cancel",
  "cancelAndHoldAtTime",
  "cancelAnimationFrame",
  "cancelBubble",
  "cancelIdleCallback",
  "cancelScheduledValues",
  "cancelVideoFrameCallback",
  "cancelWatchAvailability",
  "cancelable",
  "candidate",
  "canonicalUUID",
  "canvas",
  "cap",
  "capabilities",
  "caption",
  "caption-side",
  "captionSide",
  "captivePortal",
  "capture",
  "captureEvents",
  "captureStackTrace",
  "captureStream",
  "captureTab",
  "captureVisibleTab",
  "caret-color",
  "caretBidiLevel",
  "caretColor",
  "caretPositionFromPoint",
  "caretRangeFromPoint",
  "cast",
  "catch",
  "category",
  "cbrt",
  "cd",
  "ceil",
  "cellIndex",
  "cellPadding",
  "cellSpacing",
  "cells",
  "ch",
  "chOff",
  "chain",
  "challenge",
  "changeType",
  "changed",
  "changedTouches",
  "channel",
  "channelCount",
  "channelCountMode",
  "channelInterpretation",
  "chapterInfo",
  "char",
  "charAt",
  "charCode",
  "charCodeAt",
  "charIndex",
  "charLength",
  "characterBounds",
  "characterBoundsRangeStart",
  "characterData",
  "characterDataOldValue",
  "characterSet",
  "characteristic",
  "charging",
  "chargingTime",
  "charset",
  "check",
  "checkDCE",
  "checkEnclosure",
  "checkFramebufferStatus",
  "checkIntersection",
  "checkValidity",
  "checkVisibility",
  "checked",
  "childElementCount",
  "childList",
  "childNodes",
  "children",
  "chrome",
  "ciphertext",
  "cite",
  "city",
  "claimInterface",
  "claimed",
  "classList",
  "className",
  "classid",
  "clear",
  "clearAppBadge",
  "clearAttributes",
  "clearBuffer",
  "clearBufferfi",
  "clearBufferfv",
  "clearBufferiv",
  "clearBufferuiv",
  "clearColor",
  "clearData",
  "clearDepth",
  "clearHalt",
  "clearImmediate",
  "clearInterval",
  "clearLiveSeekableRange",
  "clearMarks",
  "clearMaxGCPauseAccumulator",
  "clearMeasures",
  "clearOriginJoinedAdInterestGroups",
  "clearParameters",
  "clearRect",
  "clearResourceTimings",
  "clearShadow",
  "clearStencil",
  "clearTimeout",
  "clearValue",
  "clearWatch",
  "click",
  "clickCount",
  "clientDataJSON",
  "clientHeight",
  "clientInformation",
  "clientLeft",
  "clientRect",
  "clientRects",
  "clientTop",
  "clientWaitSync",
  "clientWidth",
  "clientX",
  "clientY",
  "clip",
  "clip-path",
  "clip-rule",
  "clipBottom",
  "clipLeft",
  "clipPath",
  "clipPathUnits",
  "clipRight",
  "clipRule",
  "clipTop",
  "clipboard",
  "clipboardData",
  "clonable",
  "clone",
  "cloneContents",
  "cloneNode",
  "cloneRange",
  "close",
  "closeCode",
  "closePath",
  "closed",
  "closest",
  "clz",
  "clz32",
  "cm",
  "cmp",
  "code",
  "codeBase",
  "codePointAt",
  "codeType",
  "codedHeight",
  "codedRect",
  "codedWidth",
  "colSpan",
  "collapse",
  "collapseToEnd",
  "collapseToStart",
  "collapsed",
  "collect",
  "collections",
  "colno",
  "color",
  "color-adjust",
  "color-interpolation",
  "color-interpolation-filters",
  "color-scheme",
  "colorAdjust",
  "colorAttachments",
  "colorDepth",
  "colorFormats",
  "colorInterpolation",
  "colorInterpolationFilters",
  "colorMask",
  "colorScheme",
  "colorSpace",
  "colorType",
  "cols",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columnCount",
  "columnFill",
  "columnGap",
  "columnNumber",
  "columnRule",
  "columnRuleColor",
  "columnRuleStyle",
  "columnRuleWidth",
  "columnSpan",
  "columnWidth",
  "columns",
  "command",
  "commands",
  "commit",
  "commitLoadTime",
  "commitPreferences",
  "commitStyles",
  "commonAncestorContainer",
  "compact",
  "compare",
  "compareBoundaryPoints",
  "compareDocumentPosition",
  "compareEndPoints",
  "compareExchange",
  "compareNode",
  "comparePoint",
  "compatMode",
  "compatible",
  "compile",
  "compileShader",
  "compileStreaming",
  "complete",
  "completed",
  "component",
  "componentFromPoint",
  "composed",
  "composedPath",
  "composite",
  "compositionEndOffset",
  "compositionStartOffset",
  "compressedTexImage2D",
  "compressedTexImage3D",
  "compressedTexSubImage2D",
  "compressedTexSubImage3D",
  "compute",
  "computedStyleMap",
  "concat",
  "conditionText",
  "coneInnerAngle",
  "coneOuterAngle",
  "coneOuterGain",
  "config",
  "configurable",
  "configuration",
  "configurationName",
  "configurationValue",
  "configurations",
  "configure",
  "confirm",
  "confirmComposition",
  "confirmSiteSpecificTrackingException",
  "confirmWebWideTrackingException",
  "congestionControl",
  "connect",
  "connectEnd",
  "connectNative",
  "connectShark",
  "connectStart",
  "connected",
  "connectedCallback",
  "connection",
  "connectionInfo",
  "connectionList",
  "connectionSpeed",
  "connectionState",
  "connections",
  "console",
  "consolidate",
  "constants",
  "constraint",
  "constrictionActive",
  "construct",
  "constructor",
  "contactID",
  "contain",
  "contain-intrinsic-block-size",
  "contain-intrinsic-height",
  "contain-intrinsic-inline-size",
  "contain-intrinsic-size",
  "contain-intrinsic-width",
  "containIntrinsicBlockSize",
  "containIntrinsicHeight",
  "containIntrinsicInlineSize",
  "containIntrinsicSize",
  "containIntrinsicWidth",
  "container",
  "container-name",
  "container-type",
  "containerId",
  "containerName",
  "containerQuery",
  "containerSrc",
  "containerType",
  "contains",
  "containsNode",
  "content",
  "content-visibility",
  "contentBoxSize",
  "contentDocument",
  "contentEditable",
  "contentHint",
  "contentOverflow",
  "contentRect",
  "contentScriptType",
  "contentStyleType",
  "contentType",
  "contentVisibility",
  "contentWindow",
  "context",
  "contextId",
  "contextIds",
  "contextMenu",
  "contextMenus",
  "contextType",
  "contextTypes",
  "contextmenu",
  "contextualIdentities",
  "continue",
  "continuePrimaryKey",
  "continuous",
  "control",
  "controlTransferIn",
  "controlTransferOut",
  "controller",
  "controls",
  "controlsList",
  "convertPointFromNode",
  "convertQuadFromNode",
  "convertRectFromNode",
  "convertToBlob",
  "convertToSpecifiedUnits",
  "cookie",
  "cookieEnabled",
  "cookieStore",
  "cookies",
  "coords",
  "copyBufferSubData",
  "copyBufferToBuffer",
  "copyBufferToTexture",
  "copyExternalImageToTexture",
  "copyFromChannel",
  "copyTexImage2D",
  "copyTexSubImage2D",
  "copyTexSubImage3D",
  "copyTextureToBuffer",
  "copyTextureToTexture",
  "copyTo",
  "copyToChannel",
  "copyWithin",
  "correspondingElement",
  "correspondingUseElement",
  "corruptedVideoFrames",
  "cos",
  "cosh",
  "count",
  "countReset",
  "counter-increment",
  "counter-reset",
  "counter-set",
  "counterIncrement",
  "counterReset",
  "counterSet",
  "country",
  "cpuClass",
  "cpuSleepAllowed",
  "cqb",
  "cqh",
  "cqi",
  "cqmax",
  "cqmin",
  "cqw",
  "create",
  "createAnalyser",
  "createAnchor",
  "createAnswer",
  "createAttribute",
  "createAttributeNS",
  "createAuctionNonce",
  "createBidirectionalStream",
  "createBindGroup",
  "createBindGroupLayout",
  "createBiquadFilter",
  "createBuffer",
  "createBufferSource",
  "createCDATASection",
  "createCSSStyleSheet",
  "createCaption",
  "createChannelMerger",
  "createChannelSplitter",
  "createCommandEncoder",
  "createComment",
  "createComputePipeline",
  "createComputePipelineAsync",
  "createConicGradient",
  "createConstantSource",
  "createContextualFragment",
  "createControlRange",
  "createConvolver",
  "createDTMFSender",
  "createDataChannel",
  "createDelay",
  "createDelayNode",
  "createDocument",
  "createDocumentFragment",
  "createDocumentType",
  "createDynamicsCompressor",
  "createElement",
  "createElementNS",
  "createEncodedStreams",
  "createEntityReference",
  "createEvent",
  "createEventObject",
  "createExpression",
  "createFramebuffer",
  "createFunction",
  "createGain",
  "createGainNode",
  "createHTML",
  "createHTMLDocument",
  "createIIRFilter",
  "createImageBitmap",
  "createImageData",
  "createIndex",
  "createJavaScriptNode",
  "createLinearGradient",
  "createMediaElementSource",
  "createMediaKeys",
  "createMediaStreamDestination",
  "createMediaStreamSource",
  "createMediaStreamTrackSource",
  "createMutableFile",
  "createNSResolver",
  "createNodeIterator",
  "createNotification",
  "createObjectStore",
  "createObjectURL",
  "createOffer",
  "createOscillator",
  "createPanner",
  "createPattern",
  "createPeriodicWave",
  "createPipelineLayout",
  "createPolicy",
  "createPopup",
  "createProcessingInstruction",
  "createProgram",
  "createQuery",
  "createQuerySet",
  "createRadialGradient",
  "createRange",
  "createRangeCollection",
  "createReader",
  "createRenderBundleEncoder",
  "createRenderPipeline",
  "createRenderPipelineAsync",
  "createRenderbuffer",
  "createSVGAngle",
  "createSVGLength",
  "createSVGMatrix",
  "createSVGNumber",
  "createSVGPathSegArcAbs",
  "createSVGPathSegArcRel",
  "createSVGPathSegClosePath",
  "createSVGPathSegCurvetoCubicAbs",
  "createSVGPathSegCurvetoCubicRel",
  "createSVGPathSegCurvetoCubicSmoothAbs",
  "createSVGPathSegCurvetoCubicSmoothRel",
  "createSVGPathSegCurvetoQuadraticAbs",
  "createSVGPathSegCurvetoQuadraticRel",
  "createSVGPathSegCurvetoQuadraticSmoothAbs",
  "createSVGPathSegCurvetoQuadraticSmoothRel",
  "createSVGPathSegLinetoAbs",
  "createSVGPathSegLinetoHorizontalAbs",
  "createSVGPathSegLinetoHorizontalRel",
  "createSVGPathSegLinetoRel",
  "createSVGPathSegLinetoVerticalAbs",
  "createSVGPathSegLinetoVerticalRel",
  "createSVGPathSegMovetoAbs",
  "createSVGPathSegMovetoRel",
  "createSVGPoint",
  "createSVGRect",
  "createSVGTransform",
  "createSVGTransformFromMatrix",
  "createSampler",
  "createScript",
  "createScriptProcessor",
  "createScriptURL",
  "createSession",
  "createShader",
  "createShaderModule",
  "createShadowRoot",
  "createStereoPanner",
  "createStyleSheet",
  "createTBody",
  "createTFoot",
  "createTHead",
  "createTask",
  "createTextNode",
  "createTextRange",
  "createTexture",
  "createTouch",
  "createTouchList",
  "createTransformFeedback",
  "createTreeWalker",
  "createUnidirectionalStream",
  "createVertexArray",
  "createView",
  "createWaveShaper",
  "createWorklet",
  "createWritable",
  "creationTime",
  "credentialless",
  "credentials",
  "criticalCHRestart",
  "cropTo",
  "crossOrigin",
  "crossOriginIsolated",
  "crypto",
  "csi",
  "csp",
  "cssFloat",
  "cssRules",
  "cssText",
  "cssValueType",
  "ctrlKey",
  "ctrlLeft",
  "cues",
  "cullFace",
  "cullMode",
  "currentCSSZoom",
  "currentDirection",
  "currentEntry",
  "currentLocalDescription",
  "currentNode",
  "currentPage",
  "currentRect",
  "currentRemoteDescription",
  "currentScale",
  "currentScreen",
  "currentScript",
  "currentSrc",
  "currentState",
  "currentStyle",
  "currentTarget",
  "currentTime",
  "currentTranslate",
  "currentView",
  "cursor",
  "curve",
  "customElements",
  "customError",
  "cx",
  "cy",
  "d",
  "data",
  "dataFld",
  "dataFormatAs",
  "dataLoss",
  "dataLossMessage",
  "dataPageSize",
  "dataSrc",
  "dataTransfer",
  "database",
  "databases",
  "datagrams",
  "dataset",
  "dateTime",
  "db",
  "debug",
  "debuggerEnabled",
  "declarativeNetRequest",
  "declare",
  "decode",
  "decodeAudioData",
  "decodeQueueSize",
  "decodeURI",
  "decodeURIComponent",
  "decodedBodySize",
  "decoding",
  "decodingInfo",
  "decrypt",
  "default",
  "defaultCharset",
  "defaultChecked",
  "defaultMuted",
  "defaultPlaybackRate",
  "defaultPolicy",
  "defaultPrevented",
  "defaultQueue",
  "defaultRequest",
  "defaultSelected",
  "defaultStatus",
  "defaultURL",
  "defaultValue",
  "defaultView",
  "defaultstatus",
  "defer",
  "define",
  "defineMagicFunction",
  "defineMagicVariable",
  "defineProperties",
  "defineProperty",
  "deg",
  "delay",
  "delayTime",
  "delegatesFocus",
  "delete",
  "deleteBuffer",
  "deleteCaption",
  "deleteCell",
  "deleteContents",
  "deleteData",
  "deleteDatabase",
  "deleteFramebuffer",
  "deleteFromDocument",
  "deleteIndex",
  "deleteMedium",
  "deleteObjectStore",
  "deleteProgram",
  "deleteProperty",
  "deleteQuery",
  "deleteRenderbuffer",
  "deleteRow",
  "deleteRule",
  "deleteSampler",
  "deleteShader",
  "deleteSync",
  "deleteTFoot",
  "deleteTHead",
  "deleteTexture",
  "deleteTransformFeedback",
  "deleteVertexArray",
  "deleted",
  "deliverChangeRecords",
  "deliveredFrames",
  "deliveredFramesDuration",
  "delivery",
  "deliveryInfo",
  "deliveryStatus",
  "deliveryTimestamp",
  "deliveryType",
  "delta",
  "deltaMode",
  "deltaX",
  "deltaY",
  "deltaZ",
  "dependentLocality",
  "deprecatedReplaceInURN",
  "deprecatedRunAdAuctionEnforcesKAnonymity",
  "deprecatedURNToURL",
  "depthBias",
  "depthBiasClamp",
  "depthBiasSlopeScale",
  "depthClearValue",
  "depthCompare",
  "depthDataFormat",
  "depthFailOp",
  "depthFar",
  "depthFunc",
  "depthLoadOp",
  "depthMask",
  "depthNear",
  "depthOrArrayLayers",
  "depthRange",
  "depthReadOnly",
  "depthStencil",
  "depthStencilAttachment",
  "depthStencilFormat",
  "depthStoreOp",
  "depthUsage",
  "depthWriteEnabled",
  "deref",
  "deriveBits",
  "deriveKey",
  "descentOverride",
  "description",
  "deselectAll",
  "designMode",
  "desiredSize",
  "destination",
  "destinationURL",
  "destroy",
  "detach",
  "detachEvent",
  "detachShader",
  "detached",
  "detail",
  "details",
  "detect",
  "detectLanguage",
  "detune",
  "device",
  "deviceClass",
  "deviceId",
  "deviceMemory",
  "devicePixelContentBoxSize",
  "devicePixelRatio",
  "deviceProtocol",
  "deviceSubclass",
  "deviceVersionMajor",
  "deviceVersionMinor",
  "deviceVersionSubminor",
  "deviceXDPI",
  "deviceYDPI",
  "devtools",
  "devtools_panels",
  "didTimeout",
  "difference",
  "diffuseConstant",
  "digest",
  "dimension",
  "dimensions",
  "dir",
  "dirName",
  "direction",
  "dirxml",
  "disable",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "disableVertexAttribArray",
  "disabled",
  "discard",
  "discardedFrames",
  "dischargingTime",
  "disconnect",
  "disconnectShark",
  "disconnectedCallback",
  "dispatchEvent",
  "dispatchWorkgroups",
  "dispatchWorkgroupsIndirect",
  "display",
  "displayHeight",
  "displayId",
  "displayName",
  "displayWidth",
  "dispose",
  "disposition",
  "distanceModel",
  "div",
  "divisor",
  "djsapi",
  "djsproxy",
  "dns",
  "doImport",
  "doNotTrack",
  "doScroll",
  "doctype",
  "document",
  "documentElement",
  "documentId",
  "documentIds",
  "documentLifecycle",
  "documentMode",
  "documentOrigin",
  "documentOrigins",
  "documentPictureInPicture",
  "documentURI",
  "documentUrl",
  "documentUrls",
  "dolphin",
  "dolphinGameCenter",
  "dolphininfo",
  "dolphinmeta",
  "dom",
  "domComplete",
  "domContentLoadedEventEnd",
  "domContentLoadedEventStart",
  "domInteractive",
  "domLoading",
  "domOverlayState",
  "domain",
  "domainLookupEnd",
  "domainLookupStart",
  "dominant-baseline",
  "dominantBaseline",
  "done",
  "dopplerFactor",
  "dotAll",
  "downDegrees",
  "downlink",
  "download",
  "downloadRequest",
  "downloadTotal",
  "downloaded",
  "downloads",
  "dpcm",
  "dpi",
  "dppx",
  "dragDrop",
  "draggable",
  "draw",
  "drawArrays",
  "drawArraysInstanced",
  "drawArraysInstancedANGLE",
  "drawBuffers",
  "drawCustomFocusRing",
  "drawElements",
  "drawElementsInstanced",
  "drawElementsInstancedANGLE",
  "drawFocusIfNeeded",
  "drawImage",
  "drawImageFromRect",
  "drawIndexed",
  "drawIndexedIndirect",
  "drawIndirect",
  "drawRangeElements",
  "drawSystemFocusRing",
  "drawingBufferColorSpace",
  "drawingBufferFormat",
  "drawingBufferHeight",
  "drawingBufferStorage",
  "drawingBufferWidth",
  "drop",
  "dropEffect",
  "droppedVideoFrames",
  "dropzone",
  "dstFactor",
  "dtmf",
  "dump",
  "dumpProfile",
  "duplex",
  "duplicate",
  "durability",
  "duration",
  "dvb",
  "dvh",
  "dvi",
  "dvmax",
  "dvmin",
  "dvname",
  "dvnum",
  "dvw",
  "dx",
  "dy",
  "dynamicId",
  "dynsrc",
  "e",
  "edgeMode",
  "editContext",
  "effect",
  "effectAllowed",
  "effectiveDirective",
  "effectiveType",
  "effects",
  "elapsedTime",
  "element",
  "elementFromPoint",
  "elementTiming",
  "elements",
  "elementsFromPoint",
  "elevation",
  "ellipse",
  "em",
  "emHeightAscent",
  "emHeightDescent",
  "email",
  "embeds",
  "emit",
  "emma",
  "empty",
  "empty-cells",
  "emptyCells",
  "emptyHTML",
  "emptyScript",
  "emulatedPosition",
  "enable",
  "enableBackground",
  "enableDelegations",
  "enableStyleSheetsForSet",
  "enableVertexAttribArray",
  "enabled",
  "enabledFeatures",
  "enabledPlugin",
  "encode",
  "encodeInto",
  "encodeQueueSize",
  "encodeURI",
  "encodeURIComponent",
  "encodedBodySize",
  "encoding",
  "encodingInfo",
  "encrypt",
  "enctype",
  "end",
  "endContainer",
  "endElement",
  "endElementAt",
  "endOcclusionQuery",
  "endOfPassWriteIndex",
  "endOfStream",
  "endOffset",
  "endQuery",
  "endTime",
  "endTransformFeedback",
  "ended",
  "endpoint",
  "endpointNumber",
  "endpoints",
  "endsWith",
  "enqueue",
  "enterKeyHint",
  "entities",
  "entries",
  "entry",
  "entryPoint",
  "entryType",
  "enumerable",
  "enumerate",
  "enumerateDevices",
  "enumerateEditable",
  "environmentBlendMode",
  "equals",
  "error",
  "errorCode",
  "errorDetail",
  "errorText",
  "escape",
  "estimate",
  "eval",
  "evaluate",
  "event",
  "eventCounts",
  "eventPhase",
  "events",
  "every",
  "ex",
  "exception",
  "exchange",
  "exec",
  "execCommand",
  "execCommandShowHelp",
  "execScript",
  "executeBundles",
  "executionStart",
  "exitFullscreen",
  "exitPictureInPicture",
  "exitPointerLock",
  "exitPresent",
  "exp",
  "expand",
  "expandEntityReferences",
  "expando",
  "expansion",
  "expectedImprovement",
  "experiments",
  "expiration",
  "expirationTime",
  "expires",
  "expiryDate",
  "explicitOriginalTarget",
  "expm1",
  "exponent",
  "exponentialRampToValueAtTime",
  "exportKey",
  "exports",
  "extend",
  "extension",
  "extensionTypes",
  "extensions",
  "extentNode",
  "extentOffset",
  "external",
  "externalResourcesRequired",
  "externalTexture",
  "extractContents",
  "extractable",
  "eye",
  "f",
  "f16round",
  "face",
  "factoryReset",
  "failOp",
  "failureReason",
  "fallback",
  "family",
  "familyName",
  "farthestViewportElement",
  "fastSeek",
  "fatal",
  "featureId",
  "featurePolicy",
  "featureSettings",
  "features",
  "fence",
  "fenceSync",
  "fetch",
  "fetchPriority",
  "fetchStart",
  "fftSize",
  "fgColor",
  "fieldOfView",
  "file",
  "fileCreatedDate",
  "fileHandle",
  "fileModifiedDate",
  "fileName",
  "fileSize",
  "fileUpdatedDate",
  "filename",
  "files",
  "filesystem",
  "fill",
  "fill-opacity",
  "fill-rule",
  "fillJointRadii",
  "fillLightMode",
  "fillOpacity",
  "fillPoses",
  "fillRect",
  "fillRule",
  "fillStyle",
  "fillText",
  "filter",
  "filterResX",
  "filterResY",
  "filterUnits",
  "filters",
  "finally",
  "find",
  "findIndex",
  "findLast",
  "findLastIndex",
  "findRule",
  "findText",
  "finish",
  "finishDocumentLoadTime",
  "finishLoadTime",
  "finished",
  "fireEvent",
  "firesTouchEvents",
  "firstChild",
  "firstElementChild",
  "firstInterimResponseStart",
  "firstPage",
  "firstPaintAfterLoadTime",
  "firstPaintTime",
  "firstUIEventTimestamp",
  "fixed",
  "flags",
  "flat",
  "flatMap",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "flexBasis",
  "flexDirection",
  "flexFlow",
  "flexGrow",
  "flexShrink",
  "flexWrap",
  "flipX",
  "flipY",
  "float",
  "float32",
  "float64",
  "flood-color",
  "flood-opacity",
  "floodColor",
  "floodOpacity",
  "floor",
  "flush",
  "focus",
  "focusNode",
  "focusOffset",
  "font",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-optical-sizing",
  "font-palette",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-synthesis-position",
  "font-synthesis-small-caps",
  "font-synthesis-style",
  "font-synthesis-weight",
  "font-variant",
  "font-variant-alternates",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "fontBoundingBoxAscent",
  "fontBoundingBoxDescent",
  "fontFamily",
  "fontFeatureSettings",
  "fontKerning",
  "fontLanguageOverride",
  "fontOpticalSizing",
  "fontPalette",
  "fontSize",
  "fontSizeAdjust",
  "fontSmoothingEnabled",
  "fontStretch",
  "fontStyle",
  "fontSynthesis",
  "fontSynthesisPosition",
  "fontSynthesisSmallCaps",
  "fontSynthesisStyle",
  "fontSynthesisWeight",
  "fontVariant",
  "fontVariantAlternates",
  "fontVariantCaps",
  "fontVariantEastAsian",
  "fontVariantLigatures",
  "fontVariantNumeric",
  "fontVariantPosition",
  "fontVariationSettings",
  "fontWeight",
  "fontcolor",
  "fontfaces",
  "fonts",
  "fontsize",
  "for",
  "forEach",
  "force",
  "forceFallbackAdapter",
  "forceRedraw",
  "forced-color-adjust",
  "forcedColorAdjust",
  "forcedStyleAndLayoutDuration",
  "forget",
  "form",
  "formAction",
  "formData",
  "formEnctype",
  "formMethod",
  "formNoValidate",
  "formTarget",
  "format",
  "formatToParts",
  "forms",
  "forward",
  "forwardX",
  "forwardY",
  "forwardZ",
  "foundation",
  "fr",
  "fragment",
  "fragmentDirective",
  "frame",
  "frameBorder",
  "frameCount",
  "frameElement",
  "frameId",
  "frameIds",
  "frameSpacing",
  "framebuffer",
  "framebufferHeight",
  "framebufferRenderbuffer",
  "framebufferTexture2D",
  "framebufferTextureLayer",
  "framebufferWidth",
  "frames",
  "freeSpace",
  "freeze",
  "frequency",
  "frequencyBinCount",
  "from",
  "fromAsync",
  "fromBase64",
  "fromCharCode",
  "fromCodePoint",
  "fromElement",
  "fromEntries",
  "fromFloat32Array",
  "fromFloat64Array",
  "fromHex",
  "fromMatrix",
  "fromPoint",
  "fromQuad",
  "fromRect",
  "frontFace",
  "fround",
  "fullName",
  "fullPath",
  "fullRange",
  "fullScreen",
  "fullVersionList",
  "fullscreen",
  "fullscreenElement",
  "fullscreenEnabled",
  "fx",
  "fy",
  "g",
  "gain",
  "gamepad",
  "gamma",
  "gap",
  "gatheringState",
  "gatt",
  "geckoProfiler",
  "genderIdentity",
  "generateCertificate",
  "generateKey",
  "generateMipmap",
  "generateRequest",
  "geolocation",
  "gestureObject",
  "get",
  "getAcceptLanguages",
  "getActiveAttrib",
  "getActiveUniform",
  "getActiveUniformBlockName",
  "getActiveUniformBlockParameter",
  "getActiveUniforms",
  "getAdjacentText",
  "getAll",
  "getAllKeys",
  "getAllResponseHeaders",
  "getAllowlistForFeature",
  "getAnimations",
  "getAsFile",
  "getAsFileSystemHandle",
  "getAsString",
  "getAttachedShaders",
  "getAttribLocation",
  "getAttribute",
  "getAttributeNS",
  "getAttributeNames",
  "getAttributeNode",
  "getAttributeNodeNS",
  "getAttributeType",
  "getAudioTracks",
  "getAuthenticatorData",
  "getAutoplayPolicy",
  "getAvailability",
  "getBBox",
  "getBackgroundPage",
  "getBadgeBackgroundColor",
  "getBadgeText",
  "getBadgeTextColor",
  "getBattery",
  "getBigInt64",
  "getBigUint64",
  "getBindGroupLayout",
  "getBlob",
  "getBookmark",
  "getBoundingClientRect",
  "getBounds",
  "getBoxQuads",
  "getBrowserInfo",
  "getBufferParameter",
  "getBufferSubData",
  "getByteFrequencyData",
  "getByteTimeDomainData",
  "getCSSCanvasContext",
  "getCTM",
  "getCameraImage",
  "getCandidateWindowClientRect",
  "getCanonicalLocales",
  "getCapabilities",
  "getCaptureHandle",
  "getChannelData",
  "getCharNumAtPosition",
  "getCharacteristic",
  "getCharacteristics",
  "getClientExtensionResults",
  "getClientRect",
  "getClientRects",
  "getCoalescedEvents",
  "getCompilationInfo",
  "getCompositionAlternatives",
  "getComputedStyle",
  "getComputedTextLength",
  "getComputedTiming",
  "getConfiguration",
  "getConstraints",
  "getContext",
  "getContextAttributes",
  "getContexts",
  "getContributingSources",
  "getCounterValue",
  "getCueAsHTML",
  "getCueById",
  "getCurrent",
  "getCurrentPosition",
  "getCurrentTexture",
  "getCurrentTime",
  "getData",
  "getDatabaseNames",
  "getDate",
  "getDay",
  "getDefaultComputedStyle",
  "getDepthInMeters",
  "getDepthInformation",
  "getDescriptor",
  "getDescriptors",
  "getDestinationInsertionPoints",
  "getDevices",
  "getDirectory",
  "getDirectoryHandle",
  "getDisplayMedia",
  "getDistributedNodes",
  "getEditable",
  "getElementById",
  "getElementsByClassName",
  "getElementsByName",
  "getElementsByTagName",
  "getElementsByTagNameNS",
  "getEnclosureList",
  "getEndPositionOfChar",
  "getEntries",
  "getEntriesByName",
  "getEntriesByType",
  "getError",
  "getExtension",
  "getExtentOfChar",
  "getEyeParameters",
  "getFeature",
  "getFiberRoots",
  "getFile",
  "getFileHandle",
  "getFiles",
  "getFilesAndDirectories",
  "getFingerprints",
  "getFloat16",
  "getFloat32",
  "getFloat64",
  "getFloatFrequencyData",
  "getFloatTimeDomainData",
  "getFloatValue",
  "getFragDataLocation",
  "getFrameData",
  "getFrameId",
  "getFramebufferAttachmentParameter",
  "getFrequencyResponse",
  "getFullYear",
  "getGamepads",
  "getHTML",
  "getHeaderExtensionsToNegotiate",
  "getHighEntropyValues",
  "getHitTestResults",
  "getHitTestResultsForTransientInput",
  "getHours",
  "getIdentityAssertion",
  "getIds",
  "getImageData",
  "getIndexedParameter",
  "getInfo",
  "getInnerHTML",
  "getInstalledRelatedApps",
  "getInt16",
  "getInt32",
  "getInt8",
  "getInterestGroupAdAuctionData",
  "getInternalModuleRanges",
  "getInternalformatParameter",
  "getIntersectionList",
  "getItem",
  "getItems",
  "getJointPose",
  "getKey",
  "getKeyframes",
  "getLastFocused",
  "getLayers",
  "getLayoutMap",
  "getLightEstimate",
  "getLineDash",
  "getLocalCandidates",
  "getLocalParameters",
  "getLocalStreams",
  "getManagedConfiguration",
  "getManifest",
  "getMappedRange",
  "getMarks",
  "getMatchedCSSRules",
  "getMaxGCPauseSinceClear",
  "getMeasures",
  "getMessage",
  "getMetadata",
  "getMilliseconds",
  "getMinutes",
  "getModifierState",
  "getMonth",
  "getName",
  "getNamedItem",
  "getNamedItemNS",
  "getNativeFramebufferScaleFactor",
  "getNegotiatedHeaderExtensions",
  "getNestedConfigs",
  "getNotifications",
  "getNotifier",
  "getNumberOfChars",
  "getOffsetReferenceSpace",
  "getOutputTimestamp",
  "getOverrideHistoryNavigationMode",
  "getOverrideStyle",
  "getOwnPropertyDescriptor",
  "getOwnPropertyDescriptors",
  "getOwnPropertyNames",
  "getOwnPropertySymbols",
  "getPackageDirectoryEntry",
  "getParameter",
  "getParameters",
  "getParent",
  "getPathSegAtLength",
  "getPermissionWarningsByManifest",
  "getPhotoCapabilities",
  "getPhotoSettings",
  "getPlatformInfo",
  "getPointAtLength",
  "getPopup",
  "getPorts",
  "getPose",
  "getPredictedEvents",
  "getPreference",
  "getPreferenceDefault",
  "getPreferredCanvasFormat",
  "getPresentationAttribute",
  "getPreventDefault",
  "getPrimaryService",
  "getPrimaryServices",
  "getProgramInfoLog",
  "getProgramParameter",
  "getPropertyCSSValue",
  "getPropertyPriority",
  "getPropertyShorthand",
  "getPropertyType",
  "getPropertyValue",
  "getPrototypeOf",
  "getPublicKey",
  "getPublicKeyAlgorithm",
  "getQuery",
  "getQueryParameter",
  "getRGBColorValue",
  "getRandomValues",
  "getRangeAt",
  "getReader",
  "getReceivers",
  "getRectValue",
  "getReflectionCubeMap",
  "getRegistration",
  "getRegistrations",
  "getRemoteCandidates",
  "getRemoteCertificates",
  "getRemoteParameters",
  "getRemoteStreams",
  "getRenderbufferParameter",
  "getResponseHeader",
  "getRoot",
  "getRootNode",
  "getRotationOfChar",
  "getSVGDocument",
  "getSamplerParameter",
  "getScreenCTM",
  "getScreenDetails",
  "getSeconds",
  "getSelectedCandidatePair",
  "getSelection",
  "getSelf",
  "getSenders",
  "getService",
  "getSetCookie",
  "getSettings",
  "getShaderInfoLog",
  "getShaderParameter",
  "getShaderPrecisionFormat",
  "getShaderSource",
  "getSignals",
  "getSimpleDuration",
  "getSiteIcons",
  "getSources",
  "getSpeculativeParserUrls",
  "getStartPositionOfChar",
  "getStartTime",
  "getState",
  "getStats",
  "getStatusForPolicy",
  "getStorageUpdates",
  "getStreamById",
  "getStringValue",
  "getSubStringLength",
  "getSubscription",
  "getSubscriptions",
  "getSupportedConstraints",
  "getSupportedExtensions",
  "getSupportedFormats",
  "getSyncParameter",
  "getSynchronizationSources",
  "getTags",
  "getTargetRanges",
  "getTexParameter",
  "getTextFormats",
  "getTime",
  "getTimezoneOffset",
  "getTiming",
  "getTitle",
  "getTitlebarAreaRect",
  "getTotalLength",
  "getTrackById",
  "getTracks",
  "getTransceivers",
  "getTransform",
  "getTransformFeedbackVarying",
  "getTransformToElement",
  "getTransports",
  "getType",
  "getTypeMapping",
  "getUILanguage",
  "getURL",
  "getUTCDate",
  "getUTCDay",
  "getUTCFullYear",
  "getUTCHours",
  "getUTCMilliseconds",
  "getUTCMinutes",
  "getUTCMonth",
  "getUTCSeconds",
  "getUint16",
  "getUint32",
  "getUint8",
  "getUniform",
  "getUniformBlockIndex",
  "getUniformIndices",
  "getUniformLocation",
  "getUserInfo",
  "getUserMedia",
  "getUserSettings",
  "getVRDisplays",
  "getValues",
  "getVarDate",
  "getVariableValue",
  "getVertexAttrib",
  "getVertexAttribOffset",
  "getVideoPlaybackQuality",
  "getVideoTracks",
  "getViewerPose",
  "getViewport",
  "getViews",
  "getVoices",
  "getWakeLockState",
  "getWriter",
  "getYear",
  "getZoom",
  "getZoomSettings",
  "givenName",
  "global",
  "globalAlpha",
  "globalCompositeOperation",
  "globalPrivacyControl",
  "globalThis",
  "glyphOrientationHorizontal",
  "glyphOrientationVertical",
  "glyphRef",
  "go",
  "goBack",
  "goForward",
  "gpu",
  "grabFrame",
  "grad",
  "gradientTransform",
  "gradientUnits",
  "grammars",
  "green",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-gap",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-gap",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "gridArea",
  "gridAutoColumns",
  "gridAutoFlow",
  "gridAutoRows",
  "gridColumn",
  "gridColumnEnd",
  "gridColumnGap",
  "gridColumnStart",
  "gridGap",
  "gridRow",
  "gridRowEnd",
  "gridRowGap",
  "gridRowStart",
  "gridTemplate",
  "gridTemplateAreas",
  "gridTemplateColumns",
  "gridTemplateRows",
  "gripSpace",
  "group",
  "groupBy",
  "groupCollapsed",
  "groupEnd",
  "groupId",
  "groups",
  "grow",
  "growable",
  "guestProcessId",
  "guestRenderFrameRoutingId",
  "hadRecentInput",
  "hand",
  "handedness",
  "hangingBaseline",
  "hapticActuators",
  "hardwareConcurrency",
  "has",
  "hasAttribute",
  "hasAttributeNS",
  "hasAttributes",
  "hasBeenActive",
  "hasChildNodes",
  "hasComposition",
  "hasDynamicOffset",
  "hasEnrolledInstrument",
  "hasExtension",
  "hasExternalDisplay",
  "hasFeature",
  "hasFocus",
  "hasIndices",
  "hasInstance",
  "hasLayout",
  "hasOrientation",
  "hasOwn",
  "hasOwnProperty",
  "hasPointerCapture",
  "hasPosition",
  "hasPrivateToken",
  "hasReading",
  "hasRedemptionRecord",
  "hasRegExpGroups",
  "hasStorageAccess",
  "hasUAVisualTransition",
  "hasUnpartitionedCookieAccess",
  "hash",
  "hashChange",
  "head",
  "headers",
  "heading",
  "height",
  "hid",
  "hidden",
  "hide",
  "hideFocus",
  "hidePopover",
  "high",
  "highWaterMark",
  "highlight",
  "highlights",
  "hint",
  "hints",
  "history",
  "honorificPrefix",
  "honorificSuffix",
  "horizontalOverflow",
  "host",
  "hostCandidate",
  "hostname",
  "href",
  "hrefTranslate",
  "hreflang",
  "hspace",
  "html5TagCheckInerface",
  "htmlFor",
  "htmlText",
  "httpEquiv",
  "httpRequestStatusCode",
  "hwTimestamp",
  "hyphenate-character",
  "hyphenateCharacter",
  "hyphens",
  "hypot",
  "i18n",
  "ic",
  "iccId",
  "iceConnectionState",
  "iceGatheringState",
  "iceTransport",
  "icon",
  "iconURL",
  "id",
  "identifier",
  "identity",
  "ideographicBaseline",
  "idle",
  "idpLoginUrl",
  "ignoreBOM",
  "ignoreCase",
  "ignoreDepthValues",
  "image",
  "image-orientation",
  "image-rendering",
  "imageHeight",
  "imageOrientation",
  "imageRendering",
  "imageSizes",
  "imageSmoothingEnabled",
  "imageSmoothingQuality",
  "imageSrcset",
  "imageWidth",
  "images",
  "ime-mode",
  "imeMode",
  "implementation",
  "importExternalTexture",
  "importKey",
  "importNode",
  "importStylesheet",
  "imports",
  "impp",
  "imul",
  "in",
  "in1",
  "in2",
  "inBandMetadataTrackDispatchType",
  "inIncognitoContext",
  "inRange",
  "includes",
  "incognito",
  "incomingBidirectionalStreams",
  "incomingHighWaterMark",
  "incomingMaxAge",
  "incomingUnidirectionalStreams",
  "incremental",
  "indeterminate",
  "index",
  "indexNames",
  "indexOf",
  "indexedDB",
  "indicate",
  "indices",
  "inert",
  "inertiaDestinationX",
  "inertiaDestinationY",
  "info",
  "inherits",
  "init",
  "initAnimationEvent",
  "initBeforeLoadEvent",
  "initClipboardEvent",
  "initCloseEvent",
  "initCommandEvent",
  "initCompositionEvent",
  "initCustomEvent",
  "initData",
  "initDataType",
  "initDeviceMotionEvent",
  "initDeviceOrientationEvent",
  "initDragEvent",
  "initErrorEvent",
  "initEvent",
  "initFocusEvent",
  "initGestureEvent",
  "initHashChangeEvent",
  "initKeyEvent",
  "initKeyboardEvent",
  "initMSManipulationEvent",
  "initMessageEvent",
  "initMouseEvent",
  "initMouseScrollEvent",
  "initMouseWheelEvent",
  "initMutationEvent",
  "initNSMouseEvent",
  "initOverflowEvent",
  "initPageEvent",
  "initPageTransitionEvent",
  "initPointerEvent",
  "initPopStateEvent",
  "initProgressEvent",
  "initScrollAreaEvent",
  "initSimpleGestureEvent",
  "initStorageEvent",
  "initTextEvent",
  "initTimeEvent",
  "initTouchEvent",
  "initTransitionEvent",
  "initUIEvent",
  "initWebKitAnimationEvent",
  "initWebKitTransitionEvent",
  "initWebKitWheelEvent",
  "initWheelEvent",
  "initialTime",
  "initialValue",
  "initialize",
  "initiatorType",
  "inject",
  "ink",
  "inline-size",
  "inlineSize",
  "inlineVerticalFieldOfView",
  "inner",
  "innerHTML",
  "innerHeight",
  "innerText",
  "innerWidth",
  "input",
  "inputBuffer",
  "inputEncoding",
  "inputMethod",
  "inputMode",
  "inputSource",
  "inputSources",
  "inputType",
  "inputs",
  "insertAdjacentElement",
  "insertAdjacentHTML",
  "insertAdjacentText",
  "insertBefore",
  "insertCell",
  "insertDTMF",
  "insertData",
  "insertDebugMarker",
  "insertItemBefore",
  "insertNode",
  "insertRow",
  "insertRule",
  "inset",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "insetBlock",
  "insetBlockEnd",
  "insetBlockStart",
  "insetInline",
  "insetInlineEnd",
  "insetInlineStart",
  "install",
  "installing",
  "instanceRoot",
  "instantiate",
  "instantiateStreaming",
  "instruments",
  "int16",
  "int32",
  "int8",
  "integrity",
  "interactionId",
  "interactionMode",
  "intercept",
  "interfaceClass",
  "interfaceName",
  "interfaceNumber",
  "interfaceProtocol",
  "interfaceSubclass",
  "interfaces",
  "interimResults",
  "internalSubset",
  "interpretation",
  "intersection",
  "intersectionRatio",
  "intersectionRect",
  "intersectsNode",
  "interval",
  "invalidIteratorState",
  "invalidateFramebuffer",
  "invalidateSubFramebuffer",
  "inverse",
  "invertSelf",
  "invoker",
  "invokerType",
  "is",
  "is2D",
  "isActive",
  "isAllowedFileSchemeAccess",
  "isAllowedIncognitoAccess",
  "isAlternate",
  "isArray",
  "isAutoSelected",
  "isBingCurrentSearchDefault",
  "isBuffer",
  "isCandidateWindowVisible",
  "isChar",
  "isCollapsed",
  "isComposing",
  "isConcatSpreadable",
  "isConditionalMediationAvailable",
  "isConfigSupported",
  "isConnected",
  "isContentEditable",
  "isContentHandlerRegistered",
  "isContextLost",
  "isDefaultNamespace",
  "isDirectory",
  "isDisabled",
  "isDisjointFrom",
  "isEnabled",
  "isEqual",
  "isEqualNode",
  "isExtended",
  "isExtensible",
  "isExternalCTAP2SecurityKeySupported",
  "isFallbackAdapter",
  "isFile",
  "isFinite",
  "isFirstPersonObserver",
  "isFramebuffer",
  "isFrozen",
  "isGenerator",
  "isHTML",
  "isHistoryNavigation",
  "isId",
  "isIdentity",
  "isInjected",
  "isInputPending",
  "isInteger",
  "isInternal",
  "isIntersecting",
  "isLockFree",
  "isMap",
  "isMultiLine",
  "isNaN",
  "isOpen",
  "isPointInFill",
  "isPointInPath",
  "isPointInRange",
  "isPointInStroke",
  "isPrefAlternate",
  "isPresenting",
  "isPrimary",
  "isProgram",
  "isPropertyImplicit",
  "isProtocolHandlerRegistered",
  "isPrototypeOf",
  "isQuery",
  "isRawJSON",
  "isRenderbuffer",
  "isSafeInteger",
  "isSameEntry",
  "isSameNode",
  "isSampler",
  "isScript",
  "isScriptURL",
  "isSealed",
  "isSecureContext",
  "isSessionSupported",
  "isShader",
  "isSubsetOf",
  "isSupersetOf",
  "isSupported",
  "isSync",
  "isTextEdit",
  "isTexture",
  "isTransformFeedback",
  "isTrusted",
  "isTypeSupported",
  "isUserVerifyingPlatformAuthenticatorAvailable",
  "isVertexArray",
  "isView",
  "isVisible",
  "isWellFormed",
  "isochronousTransferIn",
  "isochronousTransferOut",
  "isolation",
  "italics",
  "item",
  "itemId",
  "itemProp",
  "itemRef",
  "itemScope",
  "itemType",
  "itemValue",
  "items",
  "iterateNext",
  "iterationComposite",
  "iterator",
  "javaEnabled",
  "jitterBufferTarget",
  "jobTitle",
  "join",
  "joinAdInterestGroup",
  "jointName",
  "json",
  "justify-content",
  "justify-items",
  "justify-self",
  "justifyContent",
  "justifyItems",
  "justifySelf",
  "k1",
  "k2",
  "k3",
  "k4",
  "kHz",
  "keepalive",
  "kernelMatrix",
  "kernelUnitLengthX",
  "kernelUnitLengthY",
  "kerning",
  "key",
  "keyCode",
  "keyFor",
  "keyIdentifier",
  "keyLightEnabled",
  "keyLocation",
  "keyPath",
  "keyStatuses",
  "keySystem",
  "keyText",
  "keyUsage",
  "keyboard",
  "keys",
  "keytype",
  "kind",
  "knee",
  "knownSources",
  "label",
  "labels",
  "lang",
  "language",
  "languages",
  "largeArcFlag",
  "lastChild",
  "lastElementChild",
  "lastError",
  "lastEventId",
  "lastIndex",
  "lastIndexOf",
  "lastInputTime",
  "lastMatch",
  "lastMessageSubject",
  "lastMessageType",
  "lastModified",
  "lastModifiedDate",
  "lastPage",
  "lastParen",
  "lastState",
  "lastStyleSheetSet",
  "latency",
  "latitude",
  "launchQueue",
  "layerName",
  "layerX",
  "layerY",
  "layout",
  "layoutFlow",
  "layoutGrid",
  "layoutGridChar",
  "layoutGridLine",
  "layoutGridMode",
  "layoutGridType",
  "lbound",
  "leaveAdInterestGroup",
  "left",
  "leftContext",
  "leftDegrees",
  "leftMargin",
  "leftProjectionMatrix",
  "leftViewMatrix",
  "length",
  "lengthAdjust",
  "lengthComputable",
  "letter-spacing",
  "letterSpacing",
  "level",
  "lh",
  "lighting-color",
  "lightingColor",
  "limitingConeAngle",
  "limits",
  "line",
  "line-break",
  "line-height",
  "lineAlign",
  "lineBreak",
  "lineCap",
  "lineDashOffset",
  "lineGapOverride",
  "lineHeight",
  "lineJoin",
  "lineNum",
  "lineNumber",
  "linePos",
  "lineTo",
  "lineWidth",
  "linearAcceleration",
  "linearRampToValueAtTime",
  "linearVelocity",
  "lineno",
  "lines",
  "link",
  "linkColor",
  "linkProgram",
  "links",
  "list",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "listStyle",
  "listStyleImage",
  "listStylePosition",
  "listStyleType",
  "listener",
  "listeners",
  "load",
  "loadEventEnd",
  "loadEventStart",
  "loadOp",
  "loadTime",
  "loadTimes",
  "loaded",
  "loading",
  "localDescription",
  "localName",
  "localService",
  "localStorage",
  "locale",
  "localeCompare",
  "location",
  "locationbar",
  "lock",
  "locked",
  "lockedFile",
  "locks",
  "lodMaxClamp",
  "lodMinClamp",
  "log",
  "log10",
  "log1p",
  "log2",
  "logicalXDPI",
  "logicalYDPI",
  "login",
  "loglevel",
  "longDesc",
  "longitude",
  "lookupNamespaceURI",
  "lookupPrefix",
  "loop",
  "loopEnd",
  "loopStart",
  "looping",
  "lost",
  "low",
  "lower",
  "lowerBound",
  "lowerOpen",
  "lowsrc",
  "lvb",
  "lvh",
  "lvi",
  "lvmax",
  "lvmin",
  "lvw",
  "m11",
  "m12",
  "m13",
  "m14",
  "m21",
  "m22",
  "m23",
  "m24",
  "m31",
  "m32",
  "m33",
  "m34",
  "m41",
  "m42",
  "m43",
  "m44",
  "magFilter",
  "makeXRCompatible",
  "managed",
  "management",
  "manifest",
  "manufacturer",
  "manufacturerName",
  "map",
  "mapAsync",
  "mapState",
  "mappedAtCreation",
  "mapping",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marginBlock",
  "marginBlockEnd",
  "marginBlockStart",
  "marginBottom",
  "marginHeight",
  "marginInline",
  "marginInlineEnd",
  "marginInlineStart",
  "marginLeft",
  "marginRight",
  "marginTop",
  "marginWidth",
  "mark",
  "marker",
  "marker-end",
  "marker-mid",
  "marker-offset",
  "marker-start",
  "markerEnd",
  "markerHeight",
  "markerMid",
  "markerOffset",
  "markerStart",
  "markerUnits",
  "markerWidth",
  "marks",
  "mask",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-position-x",
  "mask-position-y",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "maskClip",
  "maskComposite",
  "maskContentUnits",
  "maskImage",
  "maskMode",
  "maskOrigin",
  "maskPosition",
  "maskPositionX",
  "maskPositionY",
  "maskRepeat",
  "maskSize",
  "maskType",
  "maskUnits",
  "match",
  "matchAll",
  "matchMedia",
  "matchMedium",
  "matchPatterns",
  "matches",
  "math-depth",
  "math-style",
  "mathDepth",
  "mathStyle",
  "matrix",
  "matrixTransform",
  "max",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "maxActions",
  "maxAlternatives",
  "maxAnisotropy",
  "maxBindGroups",
  "maxBindGroupsPlusVertexBuffers",
  "maxBindingsPerBindGroup",
  "maxBlockSize",
  "maxBufferSize",
  "maxByteLength",
  "maxChannelCount",
  "maxChannels",
  "maxColorAttachmentBytesPerSample",
  "maxColorAttachments",
  "maxComputeInvocationsPerWorkgroup",
  "maxComputeWorkgroupSizeX",
  "maxComputeWorkgroupSizeY",
  "maxComputeWorkgroupSizeZ",
  "maxComputeWorkgroupStorageSize",
  "maxComputeWorkgroupsPerDimension",
  "maxConnectionsPerServer",
  "maxDatagramSize",
  "maxDecibels",
  "maxDistance",
  "maxDrawCount",
  "maxDynamicStorageBuffersPerPipelineLayout",
  "maxDynamicUniformBuffersPerPipelineLayout",
  "maxHeight",
  "maxInlineSize",
  "maxInterStageShaderComponents",
  "maxInterStageShaderVariables",
  "maxLayers",
  "maxLength",
  "maxMessageSize",
  "maxPacketLifeTime",
  "maxRetransmits",
  "maxSampledTexturesPerShaderStage",
  "maxSamplersPerShaderStage",
  "maxStorageBufferBindingSize",
  "maxStorageBuffersPerShaderStage",
  "maxStorageTexturesPerShaderStage",
  "maxTextureArrayLayers",
  "maxTextureDimension1D",
  "maxTextureDimension2D",
  "maxTextureDimension3D",
  "maxTouchPoints",
  "maxUniformBufferBindingSize",
  "maxUniformBuffersPerShaderStage",
  "maxValue",
  "maxVertexAttributes",
  "maxVertexBufferArrayStride",
  "maxVertexBuffers",
  "maxWidth",
  "maximumLatency",
  "measure",
  "measureText",
  "media",
  "mediaCapabilities",
  "mediaDevices",
  "mediaElement",
  "mediaGroup",
  "mediaKeys",
  "mediaSession",
  "mediaStream",
  "mediaText",
  "meetOrSlice",
  "memory",
  "menubar",
  "menus",
  "menusChild",
  "menusInternal",
  "mergeAttributes",
  "message",
  "messageClass",
  "messageHandlers",
  "messageType",
  "messages",
  "metaKey",
  "metadata",
  "method",
  "methodDetails",
  "methodName",
  "mid",
  "mimeType",
  "mimeTypes",
  "min",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "minBindingSize",
  "minBlockSize",
  "minDecibels",
  "minFilter",
  "minHeight",
  "minInlineSize",
  "minLength",
  "minStorageBufferOffsetAlignment",
  "minUniformBufferOffsetAlignment",
  "minValue",
  "minWidth",
  "minimumLatency",
  "mipLevel",
  "mipLevelCount",
  "mipmapFilter",
  "miterLimit",
  "mix-blend-mode",
  "mixBlendMode",
  "mm",
  "mobile",
  "mode",
  "model",
  "modify",
  "module",
  "mount",
  "move",
  "moveBy",
  "moveEnd",
  "moveFirst",
  "moveFocusDown",
  "moveFocusLeft",
  "moveFocusRight",
  "moveFocusUp",
  "moveInSuccession",
  "moveNext",
  "moveRow",
  "moveStart",
  "moveTo",
  "moveToBookmark",
  "moveToElementText",
  "moveToPoint",
  "movementX",
  "movementY",
  "mozAdd",
  "mozAnimationStartTime",
  "mozAnon",
  "mozApps",
  "mozAudioCaptured",
  "mozAudioChannelType",
  "mozAutoplayEnabled",
  "mozCancelAnimationFrame",
  "mozCancelFullScreen",
  "mozCancelRequestAnimationFrame",
  "mozCaptureStream",
  "mozCaptureStreamUntilEnded",
  "mozClearDataAt",
  "mozContact",
  "mozContacts",
  "mozCreateFileHandle",
  "mozCurrentTransform",
  "mozCurrentTransformInverse",
  "mozCursor",
  "mozDash",
  "mozDashOffset",
  "mozDecodedFrames",
  "mozExitPointerLock",
  "mozFillRule",
  "mozFragmentEnd",
  "mozFrameDelay",
  "mozFullScreen",
  "mozFullScreenElement",
  "mozFullScreenEnabled",
  "mozGetAll",
  "mozGetAllKeys",
  "mozGetAsFile",
  "mozGetDataAt",
  "mozGetMetadata",
  "mozGetUserMedia",
  "mozHasAudio",
  "mozHasItem",
  "mozHidden",
  "mozImageSmoothingEnabled",
  "mozIndexedDB",
  "mozInnerScreenX",
  "mozInnerScreenY",
  "mozInputSource",
  "mozIsTextField",
  "mozItem",
  "mozItemCount",
  "mozItems",
  "mozLength",
  "mozLockOrientation",
  "mozMatchesSelector",
  "mozMovementX",
  "mozMovementY",
  "mozOpaque",
  "mozOrientation",
  "mozPaintCount",
  "mozPaintedFrames",
  "mozParsedFrames",
  "mozPay",
  "mozPointerLockElement",
  "mozPresentedFrames",
  "mozPreservesPitch",
  "mozPressure",
  "mozPrintCallback",
  "mozRTCIceCandidate",
  "mozRTCPeerConnection",
  "mozRTCSessionDescription",
  "mozRemove",
  "mozRequestAnimationFrame",
  "mozRequestFullScreen",
  "mozRequestPointerLock",
  "mozSetDataAt",
  "mozSetImageElement",
  "mozSourceNode",
  "mozSrcObject",
  "mozSystem",
  "mozTCPSocket",
  "mozTextStyle",
  "mozTypesAt",
  "mozUnlockOrientation",
  "mozUserCancelled",
  "mozVisibilityState",
  "ms",
  "msAnimation",
  "msAnimationDelay",
  "msAnimationDirection",
  "msAnimationDuration",
  "msAnimationFillMode",
  "msAnimationIterationCount",
  "msAnimationName",
  "msAnimationPlayState",
  "msAnimationStartTime",
  "msAnimationTimingFunction",
  "msBackfaceVisibility",
  "msBlockProgression",
  "msCSSOMElementFloatMetrics",
  "msCaching",
  "msCachingEnabled",
  "msCancelRequestAnimationFrame",
  "msCapsLockWarningOff",
  "msClearImmediate",
  "msClose",
  "msContentZoomChaining",
  "msContentZoomFactor",
  "msContentZoomLimit",
  "msContentZoomLimitMax",
  "msContentZoomLimitMin",
  "msContentZoomSnap",
  "msContentZoomSnapPoints",
  "msContentZoomSnapType",
  "msContentZooming",
  "msConvertURL",
  "msCrypto",
  "msDoNotTrack",
  "msElementsFromPoint",
  "msElementsFromRect",
  "msExitFullscreen",
  "msExtendedCode",
  "msFillRule",
  "msFirstPaint",
  "msFlex",
  "msFlexAlign",
  "msFlexDirection",
  "msFlexFlow",
  "msFlexItemAlign",
  "msFlexLinePack",
  "msFlexNegative",
  "msFlexOrder",
  "msFlexPack",
  "msFlexPositive",
  "msFlexPreferredSize",
  "msFlexWrap",
  "msFlowFrom",
  "msFlowInto",
  "msFontFeatureSettings",
  "msFullscreenElement",
  "msFullscreenEnabled",
  "msGetInputContext",
  "msGetRegionContent",
  "msGetUntransformedBounds",
  "msGraphicsTrustStatus",
  "msGridColumn",
  "msGridColumnAlign",
  "msGridColumnSpan",
  "msGridColumns",
  "msGridRow",
  "msGridRowAlign",
  "msGridRowSpan",
  "msGridRows",
  "msHidden",
  "msHighContrastAdjust",
  "msHyphenateLimitChars",
  "msHyphenateLimitLines",
  "msHyphenateLimitZone",
  "msHyphens",
  "msImageSmoothingEnabled",
  "msImeAlign",
  "msIndexedDB",
  "msInterpolationMode",
  "msIsStaticHTML",
  "msKeySystem",
  "msKeys",
  "msLaunchUri",
  "msLockOrientation",
  "msManipulationViewsEnabled",
  "msMatchMedia",
  "msMatchesSelector",
  "msMaxTouchPoints",
  "msOrientation",
  "msOverflowStyle",
  "msPerspective",
  "msPerspectiveOrigin",
  "msPlayToDisabled",
  "msPlayToPreferredSourceUri",
  "msPlayToPrimary",
  "msPointerEnabled",
  "msRegionOverflow",
  "msReleasePointerCapture",
  "msRequestAnimationFrame",
  "msRequestFullscreen",
  "msSaveBlob",
  "msSaveOrOpenBlob",
  "msScrollChaining",
  "msScrollLimit",
  "msScrollLimitXMax",
  "msScrollLimitXMin",
  "msScrollLimitYMax",
  "msScrollLimitYMin",
  "msScrollRails",
  "msScrollSnapPointsX",
  "msScrollSnapPointsY",
  "msScrollSnapType",
  "msScrollSnapX",
  "msScrollSnapY",
  "msScrollTranslation",
  "msSetImmediate",
  "msSetMediaKeys",
  "msSetPointerCapture",
  "msTextCombineHorizontal",
  "msTextSizeAdjust",
  "msToBlob",
  "msTouchAction",
  "msTouchSelect",
  "msTraceAsyncCallbackCompleted",
  "msTraceAsyncCallbackStarting",
  "msTraceAsyncOperationCompleted",
  "msTraceAsyncOperationStarting",
  "msTransform",
  "msTransformOrigin",
  "msTransformStyle",
  "msTransition",
  "msTransitionDelay",
  "msTransitionDuration",
  "msTransitionProperty",
  "msTransitionTimingFunction",
  "msUnlockOrientation",
  "msUpdateAsyncCallbackRelation",
  "msUserSelect",
  "msVisibilityState",
  "msWrapFlow",
  "msWrapMargin",
  "msWrapThrough",
  "msWriteProfilerMark",
  "msZoom",
  "msZoomTo",
  "mt",
  "mul",
  "multiEntry",
  "multiSelectionObj",
  "multiline",
  "multiple",
  "multiply",
  "multiplySelf",
  "multisample",
  "multisampled",
  "mutableFile",
  "muted",
  "n",
  "nacl_arch",
  "name",
  "nameList",
  "nameProp",
  "namedItem",
  "namedRecordset",
  "names",
  "namespaceURI",
  "namespaces",
  "nativeApplication",
  "nativeMap",
  "nativeObjectCreate",
  "nativeSet",
  "nativeWeakMap",
  "naturalHeight",
  "naturalWidth",
  "navigate",
  "navigation",
  "navigationMode",
  "navigationPreload",
  "navigationStart",
  "navigationType",
  "navigator",
  "near",
  "nearestViewportElement",
  "negative",
  "negotiated",
  "netscape",
  "networkState",
  "networkStatus",
  "newScale",
  "newState",
  "newTranslate",
  "newURL",
  "newValue",
  "newValueSpecifiedUnits",
  "newVersion",
  "newhome",
  "next",
  "nextElementSibling",
  "nextHopProtocol",
  "nextNode",
  "nextPage",
  "nextSibling",
  "nickname",
  "noHref",
  "noModule",
  "noResize",
  "noShade",
  "noValidate",
  "noWrap",
  "node",
  "nodeName",
  "nodeType",
  "nodeValue",
  "nonce",
  "normDepthBufferFromNormView",
  "normalize",
  "normalizedPathSegList",
  "normandyAddonStudy",
  "notRestoredReasons",
  "notationName",
  "notations",
  "note",
  "noteGrainOn",
  "noteOff",
  "noteOn",
  "notifications",
  "notify",
  "now",
  "npnNegotiatedProtocol",
  "numOctaves",
  "number",
  "numberOfChannels",
  "numberOfFrames",
  "numberOfInputs",
  "numberOfItems",
  "numberOfOutputs",
  "numberValue",
  "oMatchesSelector",
  "object",
  "object-fit",
  "object-position",
  "objectFit",
  "objectPosition",
  "objectStore",
  "objectStoreNames",
  "objectType",
  "observe",
  "occlusionQuerySet",
  "of",
  "off",
  "offscreenBuffering",
  "offset",
  "offset-anchor",
  "offset-distance",
  "offset-path",
  "offset-position",
  "offset-rotate",
  "offsetAnchor",
  "offsetDistance",
  "offsetHeight",
  "offsetLeft",
  "offsetNode",
  "offsetParent",
  "offsetPath",
  "offsetPosition",
  "offsetRotate",
  "offsetTop",
  "offsetWidth",
  "offsetX",
  "offsetY",
  "ok",
  "oldState",
  "oldURL",
  "oldValue",
  "oldVersion",
  "olderShadowRoot",
  "omnibox",
  "on",
  "onActivated",
  "onAdded",
  "onAttached",
  "onBoundsChanged",
  "onBrowserUpdateAvailable",
  "onClicked",
  "onCommitFiberRoot",
  "onCommitFiberUnmount",
  "onConnect",
  "onConnectExternal",
  "onConnectNative",
  "onCreated",
  "onDetached",
  "onDisabled",
  "onEnabled",
  "onFocusChanged",
  "onHighlighted",
  "onInstalled",
  "onLine",
  "onMessage",
  "onMessageExternal",
  "onMoved",
  "onPerformanceWarning",
  "onPostCommitFiberRoot",
  "onRemoved",
  "onReplaced",
  "onRestartRequired",
  "onStartup",
  "onSubmittedWorkDone",
  "onSuspend",
  "onSuspendCanceled",
  "onUninstalled",
  "onUpdateAvailable",
  "onUpdated",
  "onUserScriptConnect",
  "onUserScriptMessage",
  "onUserSettingsChanged",
  "onZoomChange",
  "onabort",
  "onabsolutedeviceorientation",
  "onactivate",
  "onactive",
  "onaddsourcebuffer",
  "onaddstream",
  "onaddtrack",
  "onafterprint",
  "onafterscriptexecute",
  "onafterupdate",
  "onanimationcancel",
  "onanimationend",
  "onanimationiteration",
  "onanimationstart",
  "onappinstalled",
  "onaudioend",
  "onaudioprocess",
  "onaudiostart",
  "onautocomplete",
  "onautocompleteerror",
  "onauxclick",
  "onbeforeactivate",
  "onbeforecopy",
  "onbeforecut",
  "onbeforedeactivate",
  "onbeforeeditfocus",
  "onbeforeinput",
  "onbeforeinstallprompt",
  "onbeforematch",
  "onbeforepaste",
  "onbeforeprint",
  "onbeforescriptexecute",
  "onbeforetoggle",
  "onbeforeunload",
  "onbeforeupdate",
  "onbeforexrselect",
  "onbegin",
  "onblocked",
  "onblur",
  "onbounce",
  "onboundary",
  "onbufferedamountlow",
  "oncached",
  "oncancel",
  "oncandidatewindowhide",
  "oncandidatewindowshow",
  "oncandidatewindowupdate",
  "oncanplay",
  "oncanplaythrough",
  "oncapturehandlechange",
  "once",
  "oncellchange",
  "onchange",
  "oncharacterboundsupdate",
  "oncharacteristicvaluechanged",
  "onchargingchange",
  "onchargingtimechange",
  "onchecking",
  "onclick",
  "onclose",
  "onclosing",
  "oncompassneedscalibration",
  "oncomplete",
  "oncompositionend",
  "oncompositionstart",
  "onconnect",
  "onconnecting",
  "onconnectionavailable",
  "onconnectionstatechange",
  "oncontentvisibilityautostatechange",
  "oncontextlost",
  "oncontextmenu",
  "oncontextrestored",
  "oncontrollerchange",
  "oncontrolselect",
  "oncopy",
  "oncuechange",
  "oncurrententrychange",
  "oncurrentscreenchange",
  "oncut",
  "ondataavailable",
  "ondatachannel",
  "ondatasetchanged",
  "ondatasetcomplete",
  "ondblclick",
  "ondeactivate",
  "ondequeue",
  "ondevicechange",
  "ondevicelight",
  "ondevicemotion",
  "ondeviceorientation",
  "ondeviceorientationabsolute",
  "ondeviceproximity",
  "ondischargingtimechange",
  "ondisconnect",
  "ondisplay",
  "ondispose",
  "ondownloading",
  "ondrag",
  "ondragend",
  "ondragenter",
  "ondragexit",
  "ondragleave",
  "ondragover",
  "ondragstart",
  "ondrop",
  "ondurationchange",
  "onemptied",
  "onencrypted",
  "onend",
  "onended",
  "onenter",
  "onenterpictureinpicture",
  "onerror",
  "onerrorupdate",
  "onexit",
  "onfencedtreeclick",
  "onfilterchange",
  "onfinish",
  "onfocus",
  "onfocusin",
  "onfocusout",
  "onformdata",
  "onfreeze",
  "onfullscreenchange",
  "onfullscreenerror",
  "ongamepadconnected",
  "ongamepaddisconnected",
  "ongatheringstatechange",
  "ongattserverdisconnected",
  "ongeometrychange",
  "ongesturechange",
  "ongestureend",
  "ongesturestart",
  "ongotpointercapture",
  "onhashchange",
  "onhelp",
  "onicecandidate",
  "onicecandidateerror",
  "oniceconnectionstatechange",
  "onicegatheringstatechange",
  "oninactive",
  "oninput",
  "oninputreport",
  "oninputsourceschange",
  "oninvalid",
  "onkeydown",
  "onkeypress",
  "onkeystatuseschange",
  "onkeyup",
  "onlanguagechange",
  "onlayoutcomplete",
  "onleavepictureinpicture",
  "onlevelchange",
  "onload",
  "onloadT",
  "onloadeddata",
  "onloadedmetadata",
  "onloadend",
  "onloading",
  "onloadingdone",
  "onloadingerror",
  "onloadstart",
  "onlosecapture",
  "onlostpointercapture",
  "only",
  "onmanagedconfigurationchange",
  "onmark",
  "onmessage",
  "onmessageerror",
  "onmidimessage",
  "onmousedown",
  "onmouseenter",
  "onmouseleave",
  "onmousemove",
  "onmouseout",
  "onmouseover",
  "onmouseup",
  "onmousewheel",
  "onmove",
  "onmoveend",
  "onmovestart",
  "onmozfullscreenchange",
  "onmozfullscreenerror",
  "onmozorientationchange",
  "onmozpointerlockchange",
  "onmozpointerlockerror",
  "onmscontentzoom",
  "onmsfullscreenchange",
  "onmsfullscreenerror",
  "onmsgesturechange",
  "onmsgesturedoubletap",
  "onmsgestureend",
  "onmsgesturehold",
  "onmsgesturestart",
  "onmsgesturetap",
  "onmsgotpointercapture",
  "onmsinertiastart",
  "onmslostpointercapture",
  "onmsmanipulationstatechanged",
  "onmsneedkey",
  "onmsorientationchange",
  "onmspointercancel",
  "onmspointerdown",
  "onmspointerenter",
  "onmspointerhover",
  "onmspointerleave",
  "onmspointermove",
  "onmspointerout",
  "onmspointerover",
  "onmspointerup",
  "onmssitemodejumplistitemremoved",
  "onmsthumbnailclick",
  "onmute",
  "onnavigate",
  "onnavigateerror",
  "onnavigatesuccess",
  "onnegotiationneeded",
  "onnomatch",
  "onnoupdate",
  "onobsolete",
  "onoffline",
  "ononline",
  "onopen",
  "onorientationchange",
  "onpagechange",
  "onpagehide",
  "onpagereveal",
  "onpageshow",
  "onpageswap",
  "onpaste",
  "onpause",
  "onpayerdetailchange",
  "onpaymentmethodchange",
  "onplay",
  "onplaying",
  "onpluginstreamstart",
  "onpointercancel",
  "onpointerdown",
  "onpointerenter",
  "onpointerleave",
  "onpointerlockchange",
  "onpointerlockerror",
  "onpointermove",
  "onpointerout",
  "onpointerover",
  "onpointerrawupdate",
  "onpointerup",
  "onpopstate",
  "onprerenderingchange",
  "onprioritychange",
  "onprocessorerror",
  "onprogress",
  "onpropertychange",
  "onratechange",
  "onreading",
  "onreadystatechange",
  "onreflectionchange",
  "onrejectionhandled",
  "onrelease",
  "onremove",
  "onremovesourcebuffer",
  "onremovestream",
  "onremovetrack",
  "onrepeat",
  "onreset",
  "onresize",
  "onresizeend",
  "onresizestart",
  "onresourcetimingbufferfull",
  "onresult",
  "onresume",
  "onrowenter",
  "onrowexit",
  "onrowsdelete",
  "onrowsinserted",
  "onscreenschange",
  "onscroll",
  "onscrollend",
  "onscrollsnapchange",
  "onscrollsnapchanging",
  "onsearch",
  "onsecuritypolicyviolation",
  "onseeked",
  "onseeking",
  "onselect",
  "onselectedcandidatepairchange",
  "onselectend",
  "onselectionchange",
  "onselectstart",
  "onshippingaddresschange",
  "onshippingoptionchange",
  "onshow",
  "onsignalingstatechange",
  "onsinkchange",
  "onslotchange",
  "onsoundend",
  "onsoundstart",
  "onsourceclose",
  "onsourceclosed",
  "onsourceended",
  "onsourceopen",
  "onspeechend",
  "onspeechstart",
  "onsqueeze",
  "onsqueezeend",
  "onsqueezestart",
  "onstalled",
  "onstart",
  "onstatechange",
  "onstop",
  "onstorage",
  "onstoragecommit",
  "onsubmit",
  "onsuccess",
  "onsuspend",
  "onterminate",
  "ontextformatupdate",
  "ontextinput",
  "ontextupdate",
  "ontimeout",
  "ontimeupdate",
  "ontoggle",
  "ontonechange",
  "ontouchcancel",
  "ontouchend",
  "ontouchmove",
  "ontouchstart",
  "ontrack",
  "ontransitioncancel",
  "ontransitionend",
  "ontransitionrun",
  "ontransitionstart",
  "onuncapturederror",
  "onunhandledrejection",
  "onunload",
  "onunmute",
  "onupdate",
  "onupdateend",
  "onupdatefound",
  "onupdateready",
  "onupdatestart",
  "onupgradeneeded",
  "onuserproximity",
  "onversionchange",
  "onvisibilitychange",
  "onvoiceschanged",
  "onvolumechange",
  "onvrdisplayactivate",
  "onvrdisplayconnect",
  "onvrdisplaydeactivate",
  "onvrdisplaydisconnect",
  "onvrdisplaypresentchange",
  "onwaiting",
  "onwaitingforkey",
  "onwarning",
  "onwebkitanimationend",
  "onwebkitanimationiteration",
  "onwebkitanimationstart",
  "onwebkitcurrentplaybacktargetiswirelesschanged",
  "onwebkitfullscreenchange",
  "onwebkitfullscreenerror",
  "onwebkitkeyadded",
  "onwebkitkeyerror",
  "onwebkitkeymessage",
  "onwebkitneedkey",
  "onwebkitorientationchange",
  "onwebkitplaybacktargetavailabilitychanged",
  "onwebkitpointerlockchange",
  "onwebkitpointerlockerror",
  "onwebkitresourcetimingbufferfull",
  "onwebkittransitionend",
  "onwheel",
  "onzoom",
  "opacity",
  "open",
  "openCursor",
  "openDatabase",
  "openKeyCursor",
  "openOptionsPage",
  "openOrClosedShadowRoot",
  "openPopup",
  "opened",
  "opener",
  "opera",
  "operation",
  "operationType",
  "operator",
  "opr",
  "optimum",
  "options",
  "or",
  "order",
  "orderX",
  "orderY",
  "ordered",
  "org",
  "organization",
  "orient",
  "orientAngle",
  "orientType",
  "orientation",
  "orientationX",
  "orientationY",
  "orientationZ",
  "origin",
  "originAgentCluster",
  "originalPolicy",
  "originalTarget",
  "orphans",
  "os",
  "oscpu",
  "outerHTML",
  "outerHeight",
  "outerText",
  "outerWidth",
  "outgoingHighWaterMark",
  "outgoingMaxAge",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "outlineColor",
  "outlineOffset",
  "outlineStyle",
  "outlineWidth",
  "outputBuffer",
  "outputChannelCount",
  "outputLatency",
  "outputs",
  "overflow",
  "overflow-anchor",
  "overflow-block",
  "overflow-clip-margin",
  "overflow-inline",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "overflowAnchor",
  "overflowBlock",
  "overflowClipMargin",
  "overflowInline",
  "overflowWrap",
  "overflowX",
  "overflowY",
  "overlaysContent",
  "overrideColors",
  "overrideMimeType",
  "oversample",
  "overscroll-behavior",
  "overscroll-behavior-block",
  "overscroll-behavior-inline",
  "overscroll-behavior-x",
  "overscroll-behavior-y",
  "overscrollBehavior",
  "overscrollBehaviorBlock",
  "overscrollBehaviorInline",
  "overscrollBehaviorX",
  "overscrollBehaviorY",
  "ownKeys",
  "ownerDocument",
  "ownerElement",
  "ownerNode",
  "ownerRule",
  "ownerSVGElement",
  "owningElement",
  "p1",
  "p2",
  "p3",
  "p4",
  "packetSize",
  "packets",
  "pad",
  "padEnd",
  "padStart",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "paddingBlock",
  "paddingBlockEnd",
  "paddingBlockStart",
  "paddingBottom",
  "paddingInline",
  "paddingInlineEnd",
  "paddingInlineStart",
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  "page",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "page-orientation",
  "pageAction",
  "pageBreakAfter",
  "pageBreakBefore",
  "pageBreakInside",
  "pageCount",
  "pageLeft",
  "pageOrientation",
  "pageT",
  "pageTop",
  "pageX",
  "pageXOffset",
  "pageY",
  "pageYOffset",
  "pages",
  "paint-order",
  "paintOrder",
  "paintRequests",
  "paintType",
  "paintWorklet",
  "palette",
  "pan",
  "panningModel",
  "parameterData",
  "parameters",
  "parent",
  "parentElement",
  "parentNode",
  "parentRule",
  "parentStyleSheet",
  "parentTextEdit",
  "parentWindow",
  "parse",
  "parseAll",
  "parseCreationOptionsFromJSON",
  "parseFloat",
  "parseFromString",
  "parseHTMLUnsafe",
  "parseInt",
  "parseRequestOptionsFromJSON",
  "part",
  "participants",
  "passOp",
  "passive",
  "password",
  "pasteHTML",
  "path",
  "pathLength",
  "pathSegList",
  "pathSegType",
  "pathSegTypeAsLetter",
  "pathname",
  "pattern",
  "patternContentUnits",
  "patternMismatch",
  "patternTransform",
  "patternUnits",
  "pause",
  "pauseAnimations",
  "pauseDuration",
  "pauseOnExit",
  "pauseProfilers",
  "pauseTransformFeedback",
  "paused",
  "payerEmail",
  "payerName",
  "payerPhone",
  "paymentManager",
  "pc",
  "pdfViewerEnabled",
  "peerIdentity",
  "pending",
  "pendingLocalDescription",
  "pendingRemoteDescription",
  "percent",
  "performance",
  "periodicSync",
  "permission",
  "permissionState",
  "permissions",
  "persist",
  "persisted",
  "persistentDeviceId",
  "personalbar",
  "perspective",
  "perspective-origin",
  "perspectiveOrigin",
  "phone",
  "phoneticFamilyName",
  "phoneticGivenName",
  "photo",
  "pictureInPictureChild",
  "pictureInPictureElement",
  "pictureInPictureEnabled",
  "pictureInPictureWindow",
  "ping",
  "pipeThrough",
  "pipeTo",
  "pitch",
  "pixelBottom",
  "pixelDepth",
  "pixelHeight",
  "pixelLeft",
  "pixelRight",
  "pixelStorei",
  "pixelTop",
  "pixelUnitToMillimeterX",
  "pixelUnitToMillimeterY",
  "pixelWidth",
  "pkcs11",
  "place-content",
  "place-items",
  "place-self",
  "placeContent",
  "placeItems",
  "placeSelf",
  "placeholder",
  "platform",
  "platformVersion",
  "platforms",
  "play",
  "playEffect",
  "playState",
  "playbackRate",
  "playbackState",
  "playbackTime",
  "played",
  "playoutDelayHint",
  "playsInline",
  "plugins",
  "pluginspage",
  "pname",
  "pointer-events",
  "pointerBeforeReferenceNode",
  "pointerEnabled",
  "pointerEvents",
  "pointerId",
  "pointerLockElement",
  "pointerType",
  "points",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "polygonOffset",
  "pop",
  "popDebugGroup",
  "popErrorScope",
  "popover",
  "popoverTargetAction",
  "popoverTargetElement",
  "populateMatrix",
  "popupWindowFeatures",
  "popupWindowName",
  "popupWindowURI",
  "port",
  "port1",
  "port2",
  "ports",
  "posBottom",
  "posHeight",
  "posLeft",
  "posRight",
  "posTop",
  "posWidth",
  "pose",
  "position",
  "position-anchor",
  "position-area",
  "positionAlign",
  "positionAnchor",
  "positionArea",
  "positionX",
  "positionY",
  "positionZ",
  "postError",
  "postMessage",
  "postTask",
  "postalCode",
  "poster",
  "postscriptName",
  "pow",
  "powerEfficient",
  "powerOff",
  "powerPreference",
  "preMultiplySelf",
  "precision",
  "preferredReflectionFormat",
  "preferredStyleSheetSet",
  "preferredStylesheetSet",
  "prefix",
  "preload",
  "premultipliedAlpha",
  "prepend",
  "prerendering",
  "presentation",
  "presentationArea",
  "presentationStyle",
  "preserveAlpha",
  "preserveAspectRatio",
  "preserveAspectRatioString",
  "preservesPitch",
  "pressed",
  "pressure",
  "prevValue",
  "preventDefault",
  "preventExtensions",
  "preventSilentAccess",
  "previousElementSibling",
  "previousNode",
  "previousPage",
  "previousPriority",
  "previousRect",
  "previousScale",
  "previousSibling",
  "previousTranslate",
  "primaries",
  "primaryKey",
  "primaryLightDirection",
  "primaryLightIntensity",
  "primitive",
  "primitiveType",
  "primitiveUnits",
  "principals",
  "print",
  "print-color-adjust",
  "printColorAdjust",
  "printPreview",
  "priority",
  "privacy",
  "privateKey",
  "privateToken",
  "probablySupportsContext",
  "probeSpace",
  "process",
  "processIceMessage",
  "processingEnd",
  "processingStart",
  "processorOptions",
  "product",
  "productId",
  "productName",
  "productSub",
  "profile",
  "profileEnd",
  "profiles",
  "projectionMatrix",
  "promise",
  "prompt",
  "properties",
  "propertyIsEnumerable",
  "propertyName",
  "protectedAudience",
  "protocol",
  "protocolLong",
  "prototype",
  "provider",
  "proxy",
  "pseudoClass",
  "pseudoElement",
  "pt",
  "publicId",
  "publicKey",
  "published",
  "pulse",
  "push",
  "pushDebugGroup",
  "pushErrorScope",
  "pushManager",
  "pushNotification",
  "pushState",
  "put",
  "putImageData",
  "px",
  "quadraticCurveTo",
  "qualifier",
  "quaternion",
  "query",
  "queryCommandEnabled",
  "queryCommandIndeterm",
  "queryCommandState",
  "queryCommandSupported",
  "queryCommandText",
  "queryCommandValue",
  "queryFeatureSupport",
  "queryLocalFonts",
  "queryPermission",
  "querySelector",
  "querySelectorAll",
  "querySet",
  "queue",
  "queueMicrotask",
  "quote",
  "quotes",
  "r",
  "r1",
  "r2",
  "race",
  "rad",
  "radiogroup",
  "radius",
  "radiusX",
  "radiusY",
  "random",
  "randomUUID",
  "range",
  "rangeCount",
  "rangeEnd",
  "rangeMax",
  "rangeMin",
  "rangeOffset",
  "rangeOverflow",
  "rangeParent",
  "rangeStart",
  "rangeUnderflow",
  "rate",
  "ratio",
  "raw",
  "rawId",
  "rawJSON",
  "rawValueToMeters",
  "rcap",
  "rch",
  "read",
  "readAsArrayBuffer",
  "readAsBinaryString",
  "readAsBlob",
  "readAsDataURL",
  "readAsText",
  "readBuffer",
  "readEntries",
  "readOnly",
  "readPixels",
  "readReportRequested",
  "readText",
  "readValue",
  "readable",
  "ready",
  "readyState",
  "reason",
  "reasons",
  "reboot",
  "receiveFeatureReport",
  "receivedAlert",
  "receiver",
  "receivers",
  "recipient",
  "recommendedViewportScale",
  "reconnect",
  "recordNumber",
  "recordsAvailable",
  "recordset",
  "rect",
  "red",
  "redEyeReduction",
  "redirect",
  "redirectCount",
  "redirectEnd",
  "redirectStart",
  "redirected",
  "reduce",
  "reduceRight",
  "reduction",
  "refDistance",
  "refX",
  "refY",
  "referenceNode",
  "referenceSpace",
  "referrer",
  "referrerPolicy",
  "refresh",
  "region",
  "regionAnchorX",
  "regionAnchorY",
  "regionId",
  "regions",
  "register",
  "registerContentHandler",
  "registerElement",
  "registerInternalModuleStart",
  "registerInternalModuleStop",
  "registerProperty",
  "registerProtocolHandler",
  "reject",
  "rel",
  "relList",
  "relatedAddress",
  "relatedNode",
  "relatedPort",
  "relatedTarget",
  "relayProtocol",
  "release",
  "releaseCapture",
  "releaseEvents",
  "releaseInterface",
  "releaseLock",
  "releasePointerCapture",
  "releaseShaderCompiler",
  "released",
  "reliability",
  "reliable",
  "reliableWrite",
  "reload",
  "rem",
  "remainingSpace",
  "remote",
  "remoteDescription",
  "remove",
  "removeAllRanges",
  "removeAttribute",
  "removeAttributeNS",
  "removeAttributeNode",
  "removeBehavior",
  "removeChild",
  "removeCue",
  "removeEntry",
  "removeEventListener",
  "removeFilter",
  "removeImport",
  "removeItem",
  "removeListener",
  "removeNamedItem",
  "removeNamedItemNS",
  "removeNode",
  "removeParameter",
  "removeProperty",
  "removeRange",
  "removeRegion",
  "removeRule",
  "removeSiteSpecificTrackingException",
  "removeSourceBuffer",
  "removeStream",
  "removeTrack",
  "removeVariable",
  "removeWakeLockListener",
  "removeWebWideTrackingException",
  "removed",
  "removedNodes",
  "renderBlockingStatus",
  "renderHeight",
  "renderStart",
  "renderState",
  "renderTime",
  "renderWidth",
  "renderbufferStorage",
  "renderbufferStorageMultisample",
  "renderedBuffer",
  "rendererInterfaces",
  "renderers",
  "renderingMode",
  "renotify",
  "repeat",
  "repetitionCount",
  "replace",
  "replaceAdjacentText",
  "replaceAll",
  "replaceChild",
  "replaceChildren",
  "replaceData",
  "replaceId",
  "replaceItem",
  "replaceNode",
  "replaceState",
  "replaceSync",
  "replaceTrack",
  "replaceWholeText",
  "replaceWith",
  "reportError",
  "reportEvent",
  "reportId",
  "reportValidity",
  "request",
  "requestAdapter",
  "requestAdapterInfo",
  "requestAnimationFrame",
  "requestAutocomplete",
  "requestClose",
  "requestData",
  "requestDevice",
  "requestFrame",
  "requestFullscreen",
  "requestHitTestSource",
  "requestHitTestSourceForTransientInput",
  "requestId",
  "requestIdleCallback",
  "requestLightProbe",
  "requestMIDIAccess",
  "requestMediaKeySystemAccess",
  "requestPermission",
  "requestPictureInPicture",
  "requestPointerLock",
  "requestPort",
  "requestPresent",
  "requestPresenter",
  "requestReferenceSpace",
  "requestSession",
  "requestStart",
  "requestStorageAccess",
  "requestStorageAccessFor",
  "requestSubmit",
  "requestTime",
  "requestUpdateCheck",
  "requestVideoFrameCallback",
  "requestViewportScale",
  "requestWindow",
  "requestingWindow",
  "requireInteraction",
  "required",
  "requiredExtensions",
  "requiredFeatures",
  "requiredLimits",
  "reset",
  "resetLatency",
  "resetPose",
  "resetTransform",
  "resizable",
  "resize",
  "resizeBy",
  "resizeTo",
  "resolve",
  "resolveQuerySet",
  "resolveTarget",
  "resource",
  "respond",
  "respondWithNewView",
  "response",
  "responseBody",
  "responseEnd",
  "responseReady",
  "responseStart",
  "responseStatus",
  "responseText",
  "responseType",
  "responseURL",
  "responseXML",
  "restart",
  "restartAfterDelay",
  "restartIce",
  "restore",
  "result",
  "resultIndex",
  "resultType",
  "results",
  "resume",
  "resumeProfilers",
  "resumeTransformFeedback",
  "retry",
  "returnValue",
  "rev",
  "reverse",
  "reversed",
  "revocable",
  "revokeObjectURL",
  "rex",
  "rgbColor",
  "ric",
  "right",
  "rightContext",
  "rightDegrees",
  "rightMargin",
  "rightProjectionMatrix",
  "rightViewMatrix",
  "rlh",
  "role",
  "rolloffFactor",
  "root",
  "rootBounds",
  "rootElement",
  "rootMargin",
  "rotate",
  "rotateAxisAngle",
  "rotateAxisAngleSelf",
  "rotateFromVector",
  "rotateFromVectorSelf",
  "rotateSelf",
  "rotation",
  "rotationAngle",
  "rotationRate",
  "round",
  "roundRect",
  "row-gap",
  "rowGap",
  "rowIndex",
  "rowSpan",
  "rows",
  "rowsPerImage",
  "rtcpTransport",
  "rtt",
  "ruby-align",
  "ruby-position",
  "rubyAlign",
  "rubyOverhang",
  "rubyPosition",
  "rules",
  "run",
  "runAdAuction",
  "runtime",
  "runtimeStyle",
  "rx",
  "ry",
  "s",
  "safari",
  "sameDocument",
  "sample",
  "sampleCount",
  "sampleCoverage",
  "sampleInterval",
  "sampleRate",
  "sampleType",
  "sampler",
  "samplerParameterf",
  "samplerParameteri",
  "sandbox",
  "save",
  "saveAsPDF",
  "saveData",
  "scale",
  "scale3d",
  "scale3dSelf",
  "scaleNonUniform",
  "scaleNonUniformSelf",
  "scaleSelf",
  "scheduler",
  "scheduling",
  "scheme",
  "scissor",
  "scope",
  "scopeName",
  "scoped",
  "screen",
  "screenBrightness",
  "screenEnabled",
  "screenLeft",
  "screenPixelToMillimeterX",
  "screenPixelToMillimeterY",
  "screenState",
  "screenTop",
  "screenX",
  "screenY",
  "screens",
  "scriptURL",
  "scripting",
  "scripts",
  "scroll",
  "scroll-behavior",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollAmount",
  "scrollBehavior",
  "scrollBy",
  "scrollByLines",
  "scrollByPages",
  "scrollDelay",
  "scrollHeight",
  "scrollIntoView",
  "scrollIntoViewIfNeeded",
  "scrollLeft",
  "scrollLeftMax",
  "scrollMargin",
  "scrollMarginBlock",
  "scrollMarginBlockEnd",
  "scrollMarginBlockStart",
  "scrollMarginBottom",
  "scrollMarginInline",
  "scrollMarginInlineEnd",
  "scrollMarginInlineStart",
  "scrollMarginLeft",
  "scrollMarginRight",
  "scrollMarginTop",
  "scrollMaxX",
  "scrollMaxY",
  "scrollPadding",
  "scrollPaddingBlock",
  "scrollPaddingBlockEnd",
  "scrollPaddingBlockStart",
  "scrollPaddingBottom",
  "scrollPaddingInline",
  "scrollPaddingInlineEnd",
  "scrollPaddingInlineStart",
  "scrollPaddingLeft",
  "scrollPaddingRight",
  "scrollPaddingTop",
  "scrollRestoration",
  "scrollSnapAlign",
  "scrollSnapStop",
  "scrollSnapType",
  "scrollTo",
  "scrollTop",
  "scrollTopMax",
  "scrollWidth",
  "scrollX",
  "scrollY",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "scrollbar3dLightColor",
  "scrollbarArrowColor",
  "scrollbarBaseColor",
  "scrollbarColor",
  "scrollbarDarkShadowColor",
  "scrollbarFaceColor",
  "scrollbarGutter",
  "scrollbarHighlightColor",
  "scrollbarShadowColor",
  "scrollbarTrackColor",
  "scrollbarWidth",
  "scrollbars",
  "scrolling",
  "scrollingElement",
  "sctp",
  "sctpCauseCode",
  "sdp",
  "sdpLineNumber",
  "sdpMLineIndex",
  "sdpMid",
  "seal",
  "search",
  "searchBox",
  "searchBoxJavaBridge_",
  "searchParams",
  "sectionRowIndex",
  "secureConnectionStart",
  "security",
  "seed",
  "seek",
  "seekToNextFrame",
  "seekable",
  "seeking",
  "select",
  "selectAllChildren",
  "selectAlternateInterface",
  "selectAudioOutput",
  "selectConfiguration",
  "selectNode",
  "selectNodeContents",
  "selectNodes",
  "selectSingleNode",
  "selectSubString",
  "selectURL",
  "selected",
  "selectedIndex",
  "selectedOptions",
  "selectedStyleSheetSet",
  "selectedStylesheetSet",
  "selectedTrack",
  "selection",
  "selectionDirection",
  "selectionEnd",
  "selectionStart",
  "selector",
  "selectorText",
  "self",
  "send",
  "sendAsBinary",
  "sendBeacon",
  "sendFeatureReport",
  "sendMessage",
  "sendNativeMessage",
  "sendOrder",
  "sendReport",
  "sender",
  "sentAlert",
  "sentTimestamp",
  "separator",
  "serial",
  "serialNumber",
  "serializable",
  "serializeToString",
  "serverTiming",
  "service",
  "serviceWorker",
  "session",
  "sessionId",
  "sessionStorage",
  "sessions",
  "set",
  "setActionHandler",
  "setActive",
  "setAlpha",
  "setAppBadge",
  "setAttribute",
  "setAttributeNS",
  "setAttributeNode",
  "setAttributeNodeNS",
  "setAttributionReporting",
  "setBadgeBackgroundColor",
  "setBadgeText",
  "setBadgeTextColor",
  "setBaseAndExtent",
  "setBigInt64",
  "setBigUint64",
  "setBindGroup",
  "setBingCurrentSearchDefault",
  "setBlendConstant",
  "setCameraActive",
  "setCapture",
  "setCaptureHandleConfig",
  "setCodecPreferences",
  "setColor",
  "setCompositeOperation",
  "setConfiguration",
  "setConsumer",
  "setCurrentTime",
  "setCustomValidity",
  "setData",
  "setDate",
  "setDragImage",
  "setEnabled",
  "setEnd",
  "setEndAfter",
  "setEndBefore",
  "setEndPoint",
  "setExpires",
  "setFillColor",
  "setFilterRes",
  "setFloat16",
  "setFloat32",
  "setFloat64",
  "setFloatValue",
  "setFocusBehavior",
  "setFormValue",
  "setFromBase64",
  "setFromHex",
  "setFullYear",
  "setHTMLUnsafe",
  "setHeaderExtensionsToNegotiate",
  "setHeaderValue",
  "setHours",
  "setIcon",
  "setIdentityProvider",
  "setImmediate",
  "setIndexBuffer",
  "setInt16",
  "setInt32",
  "setInt8",
  "setInterval",
  "setItem",
  "setKeyframes",
  "setLineCap",
  "setLineDash",
  "setLineJoin",
  "setLineWidth",
  "setLiveSeekableRange",
  "setLocalDescription",
  "setMatrix",
  "setMatrixValue",
  "setMediaKeys",
  "setMicrophoneActive",
  "setMilliseconds",
  "setMinutes",
  "setMiterLimit",
  "setMonth",
  "setNamedItem",
  "setNamedItemNS",
  "setNonUserCodeExceptions",
  "setOrientToAngle",
  "setOrientToAuto",
  "setOrientation",
  "setOverrideHistoryNavigationMode",
  "setPaint",
  "setParameter",
  "setParameters",
  "setPeriodicWave",
  "setPipeline",
  "setPointerCapture",
  "setPopup",
  "setPosition",
  "setPositionState",
  "setPreference",
  "setPriority",
  "setPrivateToken",
  "setProperty",
  "setPrototypeOf",
  "setRGBColor",
  "setRGBColorICCColor",
  "setRadius",
  "setRangeText",
  "setRemoteDescription",
  "setReportEventDataForAutomaticBeacons",
  "setRequestHeader",
  "setResizable",
  "setResourceTimingBufferSize",
  "setRotate",
  "setScale",
  "setScissorRect",
  "setSeconds",
  "setSelectionRange",
  "setServerCertificate",
  "setShadow",
  "setSharedStorageContext",
  "setSignals",
  "setSinkId",
  "setSkewX",
  "setSkewY",
  "setStart",
  "setStartAfter",
  "setStartBefore",
  "setStatus",
  "setStdDeviation",
  "setStencilReference",
  "setStreams",
  "setStrictMode",
  "setStringValue",
  "setStrokeColor",
  "setSuggestResult",
  "setTargetAtTime",
  "setTargetValueAtTime",
  "setTime",
  "setTimeout",
  "setTitle",
  "setTransform",
  "setTranslate",
  "setUTCDate",
  "setUTCFullYear",
  "setUTCHours",
  "setUTCMilliseconds",
  "setUTCMinutes",
  "setUTCMonth",
  "setUTCSeconds",
  "setUint16",
  "setUint32",
  "setUint8",
  "setUninstallURL",
  "setUpdateUrlData",
  "setUri",
  "setValidity",
  "setValueAtTime",
  "setValueCurveAtTime",
  "setVariable",
  "setVelocity",
  "setVersion",
  "setVertexBuffer",
  "setViewport",
  "setYear",
  "setZoom",
  "setZoomSettings",
  "settingName",
  "settingValue",
  "sex",
  "shaderLocation",
  "shaderSource",
  "shadowBlur",
  "shadowColor",
  "shadowOffsetX",
  "shadowOffsetY",
  "shadowRoot",
  "shadowRootClonable",
  "shadowRootDelegatesFocus",
  "shadowRootMode",
  "shadowRootSerializable",
  "shape",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "shape-rendering",
  "shapeImageThreshold",
  "shapeMargin",
  "shapeOutside",
  "shapeRendering",
  "share",
  "sharedStorage",
  "sharedStorageWritable",
  "sheet",
  "shift",
  "shiftKey",
  "shiftLeft",
  "shippingAddress",
  "shippingOption",
  "shippingType",
  "show",
  "showDirectoryPicker",
  "showHelp",
  "showModal",
  "showModalDialog",
  "showModelessDialog",
  "showNotification",
  "showOpenFilePicker",
  "showPicker",
  "showPopover",
  "showSaveFilePicker",
  "sidebar",
  "sidebarAction",
  "sign",
  "signal",
  "signalingState",
  "signature",
  "silent",
  "sin",
  "singleNodeValue",
  "sinh",
  "sinkId",
  "sittingToStandingTransform",
  "size",
  "sizeAdjust",
  "sizeToContent",
  "sizeX",
  "sizeZ",
  "sizes",
  "skewX",
  "skewXSelf",
  "skewY",
  "skewYSelf",
  "skipTransition",
  "skipped",
  "slice",
  "slope",
  "slot",
  "slotAssignment",
  "small",
  "smil",
  "smooth",
  "smoothingTimeConstant",
  "snapTargetBlock",
  "snapTargetInline",
  "snapToLines",
  "snapshotItem",
  "snapshotLength",
  "some",
  "sort",
  "sortingCode",
  "source",
  "sourceBuffer",
  "sourceBuffers",
  "sourceCapabilities",
  "sourceCharPosition",
  "sourceFile",
  "sourceFunctionName",
  "sourceIndex",
  "sourceMap",
  "sourceURL",
  "sources",
  "spacing",
  "span",
  "speak",
  "speakAs",
  "speaking",
  "species",
  "specified",
  "specularConstant",
  "specularExponent",
  "speechSynthesis",
  "speed",
  "speedOfSound",
  "spellcheck",
  "sphericalHarmonicsCoefficients",
  "splice",
  "split",
  "splitText",
  "spreadMethod",
  "sqrt",
  "src",
  "srcElement",
  "srcFactor",
  "srcFilter",
  "srcObject",
  "srcUrn",
  "srcdoc",
  "srclang",
  "srcset",
  "stack",
  "stackTraceLimit",
  "stacktrace",
  "stageParameters",
  "standalone",
  "standby",
  "start",
  "startContainer",
  "startE",
  "startIce",
  "startLoadTime",
  "startMessages",
  "startNotifications",
  "startOffset",
  "startProfiling",
  "startRendering",
  "startShark",
  "startTime",
  "startViewTransition",
  "startsWith",
  "state",
  "states",
  "stats",
  "status",
  "statusCode",
  "statusMessage",
  "statusText",
  "statusbar",
  "stdDeviationX",
  "stdDeviationY",
  "stencilBack",
  "stencilClearValue",
  "stencilFront",
  "stencilFunc",
  "stencilFuncSeparate",
  "stencilLoadOp",
  "stencilMask",
  "stencilMaskSeparate",
  "stencilOp",
  "stencilOpSeparate",
  "stencilReadMask",
  "stencilReadOnly",
  "stencilStoreOp",
  "stencilWriteMask",
  "step",
  "stepDown",
  "stepMismatch",
  "stepMode",
  "stepUp",
  "sticky",
  "stitchTiles",
  "stop",
  "stop-color",
  "stop-opacity",
  "stopColor",
  "stopImmediatePropagation",
  "stopNotifications",
  "stopOpacity",
  "stopProfiling",
  "stopPropagation",
  "stopShark",
  "stopped",
  "storage",
  "storageArea",
  "storageBuckets",
  "storageName",
  "storageStatus",
  "storageTexture",
  "store",
  "storeOp",
  "storeSiteSpecificTrackingException",
  "storeWebWideTrackingException",
  "stpVersion",
  "stream",
  "streamErrorCode",
  "streams",
  "stretch",
  "strike",
  "string",
  "stringValue",
  "stringify",
  "stripIndexFormat",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeRect",
  "strokeStyle",
  "strokeText",
  "strokeWidth",
  "structuredClone",
  "style",
  "styleAndLayoutStart",
  "styleFloat",
  "styleMap",
  "styleMedia",
  "styleSheet",
  "styleSheetSets",
  "styleSheets",
  "sub",
  "subarray",
  "subject",
  "submit",
  "submitFrame",
  "submitter",
  "subscribe",
  "substr",
  "substring",
  "substringData",
  "subtle",
  "subtree",
  "suffix",
  "suffixes",
  "summary",
  "sup",
  "supported",
  "supportedContentEncodings",
  "supportedEntryTypes",
  "supportedValuesOf",
  "supports",
  "supportsFiber",
  "supportsSession",
  "supportsText",
  "surfaceScale",
  "surroundContents",
  "suspend",
  "suspendRedraw",
  "svb",
  "svh",
  "svi",
  "svmax",
  "svmin",
  "svw",
  "swapCache",
  "swapNode",
  "sweepFlag",
  "symbols",
  "symmetricDifference",
  "sync",
  "syntax",
  "sysexEnabled",
  "system",
  "systemCode",
  "systemId",
  "systemLanguage",
  "systemXDPI",
  "systemYDPI",
  "tBodies",
  "tFoot",
  "tHead",
  "tab",
  "tab-size",
  "tabId",
  "tabIds",
  "tabIndex",
  "tabSize",
  "table",
  "table-layout",
  "tableLayout",
  "tableValues",
  "tabs",
  "tag",
  "tagName",
  "tagUrn",
  "tags",
  "taintEnabled",
  "take",
  "takePhoto",
  "takeRecords",
  "tan",
  "tangentialPressure",
  "tanh",
  "target",
  "targetAddressSpace",
  "targetElement",
  "targetRayMode",
  "targetRaySpace",
  "targetTouches",
  "targetURL",
  "targetX",
  "targetY",
  "targets",
  "tcpType",
  "tee",
  "tel",
  "telemetry",
  "terminate",
  "test",
  "texImage2D",
  "texImage3D",
  "texParameterf",
  "texParameteri",
  "texStorage2D",
  "texStorage3D",
  "texSubImage2D",
  "texSubImage3D",
  "text",
  "text-align",
  "text-align-last",
  "text-anchor",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-skip-ink",
  "text-decoration-style",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-offset",
  "text-underline-position",
  "text-wrap",
  "text-wrap-mode",
  "text-wrap-style",
  "textAlign",
  "textAlignLast",
  "textAnchor",
  "textAutospace",
  "textBaseline",
  "textCombineUpright",
  "textContent",
  "textDecoration",
  "textDecorationBlink",
  "textDecorationColor",
  "textDecorationLine",
  "textDecorationLineThrough",
  "textDecorationNone",
  "textDecorationOverline",
  "textDecorationSkipInk",
  "textDecorationStyle",
  "textDecorationThickness",
  "textDecorationUnderline",
  "textEmphasis",
  "textEmphasisColor",
  "textEmphasisPosition",
  "textEmphasisStyle",
  "textIndent",
  "textJustify",
  "textJustifyTrim",
  "textKashida",
  "textKashidaSpace",
  "textLength",
  "textOrientation",
  "textOverflow",
  "textRendering",
  "textShadow",
  "textTracks",
  "textTransform",
  "textUnderlineOffset",
  "textUnderlinePosition",
  "textWrap",
  "textWrapMode",
  "textWrapStyle",
  "texture",
  "theme",
  "then",
  "threadId",
  "threshold",
  "thresholds",
  "throwIfAborted",
  "tiltX",
  "tiltY",
  "time",
  "timeEnd",
  "timeLog",
  "timeOrigin",
  "timeRemaining",
  "timeStamp",
  "timecode",
  "timeline",
  "timelineTime",
  "timeout",
  "timestamp",
  "timestampOffset",
  "timestampWrites",
  "timing",
  "title",
  "titlebarAreaRect",
  "tlsChannelId",
  "to",
  "toArray",
  "toBase64",
  "toBlob",
  "toDataURL",
  "toDateString",
  "toElement",
  "toExponential",
  "toFixed",
  "toFloat32Array",
  "toFloat64Array",
  "toGMTString",
  "toHex",
  "toISOString",
  "toJSON",
  "toLocaleDateString",
  "toLocaleFormat",
  "toLocaleLowerCase",
  "toLocaleString",
  "toLocaleTimeString",
  "toLocaleUpperCase",
  "toLowerCase",
  "toMatrix",
  "toMethod",
  "toPrecision",
  "toPrimitive",
  "toReversed",
  "toSdp",
  "toSorted",
  "toSource",
  "toSpliced",
  "toStaticHTML",
  "toString",
  "toStringTag",
  "toSum",
  "toTimeString",
  "toUTCString",
  "toUpperCase",
  "toWellFormed",
  "toggle",
  "toggleAttribute",
  "toggleLongPressEnabled",
  "togglePopover",
  "toggleReaderMode",
  "token",
  "tone",
  "toneBuffer",
  "tooLong",
  "tooShort",
  "toolbar",
  "top",
  "topMargin",
  "topSites",
  "topology",
  "total",
  "totalFrameDelay",
  "totalFrames",
  "totalFramesDuration",
  "totalVideoFrames",
  "touch-action",
  "touchAction",
  "touched",
  "touches",
  "trace",
  "track",
  "trackVisibility",
  "trackedAnchors",
  "tracks",
  "tran",
  "transaction",
  "transactions",
  "transceiver",
  "transfer",
  "transferControlToOffscreen",
  "transferFromImageBitmap",
  "transferImageBitmap",
  "transferIn",
  "transferOut",
  "transferSize",
  "transferToFixedLength",
  "transferToImageBitmap",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transformBox",
  "transformFeedbackVaryings",
  "transformOrigin",
  "transformPoint",
  "transformString",
  "transformStyle",
  "transformToDocument",
  "transformToFragment",
  "transition",
  "transition-behavior",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "transitionBehavior",
  "transitionDelay",
  "transitionDuration",
  "transitionProperty",
  "transitionTimingFunction",
  "translate",
  "translateSelf",
  "translationX",
  "translationY",
  "transport",
  "traverseTo",
  "trim",
  "trimEnd",
  "trimLeft",
  "trimRight",
  "trimStart",
  "trueSpeed",
  "trunc",
  "truncate",
  "trustedTypes",
  "try",
  "turn",
  "twist",
  "type",
  "typeDetail",
  "typeMismatch",
  "typeMustMatch",
  "types",
  "u2f",
  "ubound",
  "uint16",
  "uint32",
  "uint8",
  "uint8Clamped",
  "unadjustedMovement",
  "unclippedDepth",
  "unconfigure",
  "undefined",
  "underlineStyle",
  "underlineThickness",
  "unescape",
  "uneval",
  "ungroup",
  "unicode",
  "unicode-bidi",
  "unicodeBidi",
  "unicodeRange",
  "unicodeSets",
  "uniform1f",
  "uniform1fv",
  "uniform1i",
  "uniform1iv",
  "uniform1ui",
  "uniform1uiv",
  "uniform2f",
  "uniform2fv",
  "uniform2i",
  "uniform2iv",
  "uniform2ui",
  "uniform2uiv",
  "uniform3f",
  "uniform3fv",
  "uniform3i",
  "uniform3iv",
  "uniform3ui",
  "uniform3uiv",
  "uniform4f",
  "uniform4fv",
  "uniform4i",
  "uniform4iv",
  "uniform4ui",
  "uniform4uiv",
  "uniformBlockBinding",
  "uniformMatrix2fv",
  "uniformMatrix2x3fv",
  "uniformMatrix2x4fv",
  "uniformMatrix3fv",
  "uniformMatrix3x2fv",
  "uniformMatrix3x4fv",
  "uniformMatrix4fv",
  "uniformMatrix4x2fv",
  "uniformMatrix4x3fv",
  "uninstallSelf",
  "union",
  "unique",
  "uniqueID",
  "uniqueNumber",
  "unit",
  "unitType",
  "units",
  "unloadEventEnd",
  "unloadEventStart",
  "unlock",
  "unmap",
  "unmount",
  "unobserve",
  "unpackColorSpace",
  "unpause",
  "unpauseAnimations",
  "unreadCount",
  "unregister",
  "unregisterContentHandler",
  "unregisterProtocolHandler",
  "unscopables",
  "unselectable",
  "unshift",
  "unsubscribe",
  "unsuspendRedraw",
  "unsuspendRedrawAll",
  "unwatch",
  "unwrapKey",
  "upDegrees",
  "upX",
  "upY",
  "upZ",
  "update",
  "updateAdInterestGroups",
  "updateCallbackDone",
  "updateCharacterBounds",
  "updateCommands",
  "updateControlBounds",
  "updateCurrentEntry",
  "updateIce",
  "updateInkTrailStartPoint",
  "updateInterval",
  "updatePlaybackRate",
  "updateRangeEnd",
  "updateRangeStart",
  "updateRenderState",
  "updateSelection",
  "updateSelectionBounds",
  "updateSettings",
  "updateText",
  "updateTiming",
  "updateViaCache",
  "updateWith",
  "updated",
  "updating",
  "upgrade",
  "upload",
  "uploadTotal",
  "uploaded",
  "upper",
  "upperBound",
  "upperOpen",
  "uri",
  "url",
  "urn",
  "urns",
  "usage",
  "usages",
  "usb",
  "usbVersionMajor",
  "usbVersionMinor",
  "usbVersionSubminor",
  "useCurrentView",
  "useMap",
  "useProgram",
  "usedSpace",
  "user-select",
  "userActivation",
  "userAgent",
  "userAgentData",
  "userChoice",
  "userHandle",
  "userHint",
  "userInitiated",
  "userLanguage",
  "userSelect",
  "userState",
  "userVisibleOnly",
  "username",
  "usernameFragment",
  "utterance",
  "uuid",
  "v8BreakIterator",
  "vAlign",
  "vLink",
  "valid",
  "validate",
  "validateProgram",
  "validationMessage",
  "validity",
  "value",
  "valueAsDate",
  "valueAsNumber",
  "valueAsString",
  "valueInSpecifiedUnits",
  "valueMissing",
  "valueOf",
  "valueText",
  "valueType",
  "values",
  "variable",
  "variant",
  "variationSettings",
  "vb",
  "vector-effect",
  "vectorEffect",
  "velocityAngular",
  "velocityExpansion",
  "velocityX",
  "velocityY",
  "vendor",
  "vendorId",
  "vendorSub",
  "verify",
  "version",
  "vertex",
  "vertexAttrib1f",
  "vertexAttrib1fv",
  "vertexAttrib2f",
  "vertexAttrib2fv",
  "vertexAttrib3f",
  "vertexAttrib3fv",
  "vertexAttrib4f",
  "vertexAttrib4fv",
  "vertexAttribDivisor",
  "vertexAttribDivisorANGLE",
  "vertexAttribI4i",
  "vertexAttribI4iv",
  "vertexAttribI4ui",
  "vertexAttribI4uiv",
  "vertexAttribIPointer",
  "vertexAttribPointer",
  "vertical",
  "vertical-align",
  "verticalAlign",
  "verticalOverflow",
  "vh",
  "vi",
  "vibrate",
  "vibrationActuator",
  "videoBitsPerSecond",
  "videoHeight",
  "videoTracks",
  "videoWidth",
  "view",
  "viewBox",
  "viewBoxString",
  "viewDimension",
  "viewFormats",
  "viewTarget",
  "viewTargetString",
  "viewTransition",
  "viewport",
  "viewportAnchorX",
  "viewportAnchorY",
  "viewportElement",
  "views",
  "violatedDirective",
  "virtualKeyboard",
  "virtualKeyboardPolicy",
  "visibility",
  "visibilityState",
  "visible",
  "visibleRect",
  "visualViewport",
  "vlinkColor",
  "vmax",
  "vmin",
  "voice",
  "voiceURI",
  "volume",
  "vrml",
  "vspace",
  "vw",
  "w",
  "wait",
  "waitAsync",
  "waitSync",
  "waiting",
  "wake",
  "wakeLock",
  "wand",
  "warmup",
  "warn",
  "wasAlternateProtocolAvailable",
  "wasClean",
  "wasDiscarded",
  "wasFetchedViaSpdy",
  "wasNpnNegotiated",
  "watch",
  "watchAvailability",
  "watchPosition",
  "webNavigation",
  "webRequest",
  "webdriver",
  "webkitAddKey",
  "webkitAlignContent",
  "webkitAlignItems",
  "webkitAlignSelf",
  "webkitAnimation",
  "webkitAnimationDelay",
  "webkitAnimationDirection",
  "webkitAnimationDuration",
  "webkitAnimationFillMode",
  "webkitAnimationIterationCount",
  "webkitAnimationName",
  "webkitAnimationPlayState",
  "webkitAnimationTimingFunction",
  "webkitAppearance",
  "webkitAudioContext",
  "webkitAudioDecodedByteCount",
  "webkitAudioPannerNode",
  "webkitBackfaceVisibility",
  "webkitBackground",
  "webkitBackgroundAttachment",
  "webkitBackgroundClip",
  "webkitBackgroundColor",
  "webkitBackgroundImage",
  "webkitBackgroundOrigin",
  "webkitBackgroundPosition",
  "webkitBackgroundPositionX",
  "webkitBackgroundPositionY",
  "webkitBackgroundRepeat",
  "webkitBackgroundSize",
  "webkitBackingStorePixelRatio",
  "webkitBorderBottomLeftRadius",
  "webkitBorderBottomRightRadius",
  "webkitBorderImage",
  "webkitBorderImageOutset",
  "webkitBorderImageRepeat",
  "webkitBorderImageSlice",
  "webkitBorderImageSource",
  "webkitBorderImageWidth",
  "webkitBorderRadius",
  "webkitBorderTopLeftRadius",
  "webkitBorderTopRightRadius",
  "webkitBoxAlign",
  "webkitBoxDirection",
  "webkitBoxFlex",
  "webkitBoxOrdinalGroup",
  "webkitBoxOrient",
  "webkitBoxPack",
  "webkitBoxShadow",
  "webkitBoxSizing",
  "webkitCancelAnimationFrame",
  "webkitCancelFullScreen",
  "webkitCancelKeyRequest",
  "webkitCancelRequestAnimationFrame",
  "webkitClearResourceTimings",
  "webkitClipPath",
  "webkitClosedCaptionsVisible",
  "webkitConvertPointFromNodeToPage",
  "webkitConvertPointFromPageToNode",
  "webkitCreateShadowRoot",
  "webkitCurrentFullScreenElement",
  "webkitCurrentPlaybackTargetIsWireless",
  "webkitDecodedFrameCount",
  "webkitDirectionInvertedFromDevice",
  "webkitDisplayingFullscreen",
  "webkitDroppedFrameCount",
  "webkitEnterFullScreen",
  "webkitEnterFullscreen",
  "webkitEntries",
  "webkitExitFullScreen",
  "webkitExitFullscreen",
  "webkitExitPointerLock",
  "webkitFilter",
  "webkitFlex",
  "webkitFlexBasis",
  "webkitFlexDirection",
  "webkitFlexFlow",
  "webkitFlexGrow",
  "webkitFlexShrink",
  "webkitFlexWrap",
  "webkitFontFeatureSettings",
  "webkitFullScreenKeyboardInputAllowed",
  "webkitFullscreenElement",
  "webkitFullscreenEnabled",
  "webkitGenerateKeyRequest",
  "webkitGetAsEntry",
  "webkitGetDatabaseNames",
  "webkitGetEntries",
  "webkitGetEntriesByName",
  "webkitGetEntriesByType",
  "webkitGetFlowByName",
  "webkitGetGamepads",
  "webkitGetImageDataHD",
  "webkitGetNamedFlows",
  "webkitGetRegionFlowRanges",
  "webkitGetUserMedia",
  "webkitHasClosedCaptions",
  "webkitHidden",
  "webkitIDBCursor",
  "webkitIDBDatabase",
  "webkitIDBDatabaseError",
  "webkitIDBDatabaseException",
  "webkitIDBFactory",
  "webkitIDBIndex",
  "webkitIDBKeyRange",
  "webkitIDBObjectStore",
  "webkitIDBRequest",
  "webkitIDBTransaction",
  "webkitImageSmoothingEnabled",
  "webkitIndexedDB",
  "webkitInitMessageEvent",
  "webkitIsFullScreen",
  "webkitJustifyContent",
  "webkitKeys",
  "webkitLineClamp",
  "webkitLineDashOffset",
  "webkitLockOrientation",
  "webkitMask",
  "webkitMaskClip",
  "webkitMaskComposite",
  "webkitMaskImage",
  "webkitMaskOrigin",
  "webkitMaskPosition",
  "webkitMaskPositionX",
  "webkitMaskPositionY",
  "webkitMaskRepeat",
  "webkitMaskSize",
  "webkitMatchesSelector",
  "webkitMediaStream",
  "webkitNotifications",
  "webkitOfflineAudioContext",
  "webkitOrder",
  "webkitOrientation",
  "webkitPeerConnection00",
  "webkitPersistentStorage",
  "webkitPerspective",
  "webkitPerspectiveOrigin",
  "webkitPointerLockElement",
  "webkitPostMessage",
  "webkitPreservesPitch",
  "webkitPutImageDataHD",
  "webkitRTCPeerConnection",
  "webkitRegionOverset",
  "webkitRelativePath",
  "webkitRequestAnimationFrame",
  "webkitRequestFileSystem",
  "webkitRequestFullScreen",
  "webkitRequestFullscreen",
  "webkitRequestPointerLock",
  "webkitResolveLocalFileSystemURL",
  "webkitSetMediaKeys",
  "webkitSetResourceTimingBufferSize",
  "webkitShadowRoot",
  "webkitShowPlaybackTargetPicker",
  "webkitSlice",
  "webkitSpeechGrammar",
  "webkitSpeechGrammarList",
  "webkitSpeechRecognition",
  "webkitSpeechRecognitionError",
  "webkitSpeechRecognitionEvent",
  "webkitStorageInfo",
  "webkitSupportsFullscreen",
  "webkitTemporaryStorage",
  "webkitTextFillColor",
  "webkitTextSecurity",
  "webkitTextSizeAdjust",
  "webkitTextStroke",
  "webkitTextStrokeColor",
  "webkitTextStrokeWidth",
  "webkitTransform",
  "webkitTransformOrigin",
  "webkitTransformStyle",
  "webkitTransition",
  "webkitTransitionDelay",
  "webkitTransitionDuration",
  "webkitTransitionProperty",
  "webkitTransitionTimingFunction",
  "webkitURL",
  "webkitUnlockOrientation",
  "webkitUserSelect",
  "webkitVideoDecodedByteCount",
  "webkitVisibilityState",
  "webkitWirelessVideoPlaybackDisabled",
  "webkitdirectory",
  "webkitdropzone",
  "webstore",
  "weight",
  "wgslLanguageFeatures",
  "whatToShow",
  "wheelDelta",
  "wheelDeltaX",
  "wheelDeltaY",
  "whenDefined",
  "which",
  "white-space",
  "white-space-collapse",
  "whiteSpace",
  "whiteSpaceCollapse",
  "wholeText",
  "widows",
  "width",
  "will-change",
  "willChange",
  "willValidate",
  "window",
  "windowAttribution",
  "windowControlsOverlay",
  "windowId",
  "windowIds",
  "windows",
  "with",
  "withCredentials",
  "withResolvers",
  "word-break",
  "word-spacing",
  "word-wrap",
  "wordBreak",
  "wordSpacing",
  "wordWrap",
  "workerStart",
  "worklet",
  "wow64",
  "wrap",
  "wrapKey",
  "writable",
  "writableAuxiliaries",
  "write",
  "writeBuffer",
  "writeMask",
  "writeText",
  "writeTexture",
  "writeTimestamp",
  "writeValue",
  "writeValueWithResponse",
  "writeValueWithoutResponse",
  "writeWithoutResponse",
  "writeln",
  "writing-mode",
  "writingMode",
  "writingSuggestions",
  "x",
  "x1",
  "x2",
  "xChannelSelector",
  "xmlEncoding",
  "xmlStandalone",
  "xmlVersion",
  "xmlbase",
  "xmllang",
  "xmlspace",
  "xor",
  "xr",
  "y",
  "y1",
  "y2",
  "yChannelSelector",
  "yandex",
  "yield",
  "z",
  "z-index",
  "zIndex",
  "zoom",
  "zoomAndPan",
  "zoomRectScreen"
];

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/propmangle.js
function find_builtins(reserved) {
  domprops.forEach(add6);
  var new_globals = ["Symbol", "Map", "Promise", "Proxy", "Reflect", "Set", "WeakMap", "WeakSet"];
  var objects = {};
  var global_ref = typeof global === "object" ? global : self;
  new_globals.forEach(function(new_global) {
    objects[new_global] = global_ref[new_global] || function() {
    };
  });
  [
    "null",
    "true",
    "false",
    "NaN",
    "Infinity",
    "-Infinity",
    "undefined"
  ].forEach(add6);
  [
    Object,
    Array,
    Function,
    Number,
    String,
    Boolean,
    Error,
    Math,
    Date,
    RegExp,
    objects.Symbol,
    ArrayBuffer,
    DataView,
    decodeURI,
    decodeURIComponent,
    encodeURI,
    encodeURIComponent,
    eval,
    EvalError,
    Float32Array,
    Float64Array,
    Int8Array,
    Int16Array,
    Int32Array,
    isFinite,
    isNaN,
    JSON,
    objects.Map,
    parseFloat,
    parseInt,
    objects.Promise,
    objects.Proxy,
    RangeError,
    ReferenceError,
    objects.Reflect,
    objects.Set,
    SyntaxError,
    TypeError,
    Uint8Array,
    Uint8ClampedArray,
    Uint16Array,
    Uint32Array,
    URIError,
    objects.WeakMap,
    objects.WeakSet
  ].forEach(function(ctor) {
    Object.getOwnPropertyNames(ctor).map(add6);
    if (ctor.prototype) {
      Object.getOwnPropertyNames(ctor.prototype).map(add6);
    }
  });
  function add6(name) {
    reserved.add(name);
  }
}
function reserve_quoted_keys(ast, reserved) {
  function add6(name) {
    push_uniq(reserved, name);
  }
  ast.walk(new TreeWalker(function(node) {
    if (node instanceof AST_ObjectKeyVal && node.quote) {
      add6(node.key);
    } else if (node instanceof AST_ObjectProperty && node.quote) {
      add6(node.key.name);
    } else if (node instanceof AST_Sub) {
      addStrings(node.property, add6);
    }
  }));
}
function addStrings(node, add6) {
  node.walk(new TreeWalker(function(node2) {
    if (node2 instanceof AST_Sequence) {
      addStrings(node2.tail_node(), add6);
    } else if (node2 instanceof AST_String) {
      add6(node2.value);
    } else if (node2 instanceof AST_Conditional) {
      addStrings(node2.consequent, add6);
      addStrings(node2.alternative, add6);
    }
    return true;
  }));
}
function mangle_private_properties(ast, options) {
  var cprivate = -1;
  var private_cache = /* @__PURE__ */ new Map();
  var nth_identifier = options.nth_identifier || base54;
  ast = ast.transform(new TreeTransformer(function(node) {
    if (node instanceof AST_ClassPrivateProperty || node instanceof AST_PrivateMethod || node instanceof AST_PrivateGetter || node instanceof AST_PrivateSetter || node instanceof AST_PrivateIn) {
      node.key.name = mangle_private(node.key.name);
    } else if (node instanceof AST_DotHash) {
      node.property = mangle_private(node.property);
    }
  }));
  return ast;
  function mangle_private(name) {
    let mangled = private_cache.get(name);
    if (!mangled) {
      mangled = nth_identifier.get(++cprivate);
      private_cache.set(name, mangled);
    }
    return mangled;
  }
}
function find_annotated_props(ast) {
  var annotated_props = /* @__PURE__ */ new Set();
  walk2(ast, (node) => {
    if (node instanceof AST_ClassPrivateProperty || node instanceof AST_PrivateMethod || node instanceof AST_PrivateGetter || node instanceof AST_PrivateSetter || node instanceof AST_DotHash) ; else if (node instanceof AST_ObjectKeyVal) {
      if (typeof node.key == "string" && has_annotation(node, _MANGLEPROP)) {
        annotated_props.add(node.key);
      }
    } else if (node instanceof AST_ObjectProperty) {
      if (has_annotation(node, _MANGLEPROP)) {
        annotated_props.add(node.key.name);
      }
    } else if (node instanceof AST_Dot) {
      if (has_annotation(node, _MANGLEPROP)) {
        annotated_props.add(node.property);
      }
    } else if (node instanceof AST_Sub) {
      if (node.property instanceof AST_String && has_annotation(node, _MANGLEPROP)) {
        annotated_props.add(node.property.value);
      }
    }
  });
  return annotated_props;
}
function mangle_properties(ast, options, annotated_props = find_annotated_props(ast)) {
  options = defaults2(options, {
    builtins: false,
    cache: null,
    debug: false,
    keep_quoted: false,
    nth_identifier: base54,
    only_cache: false,
    regex: null,
    reserved: null,
    undeclared: false,
    only_annotated: false
  }, true);
  var nth_identifier = options.nth_identifier;
  var reserved_option = options.reserved;
  if (!Array.isArray(reserved_option)) reserved_option = [reserved_option];
  var reserved = new Set(reserved_option);
  if (!options.builtins) find_builtins(reserved);
  var cname = -1;
  var cache3;
  if (options.cache) {
    cache3 = options.cache.props;
  } else {
    cache3 = /* @__PURE__ */ new Map();
  }
  var only_annotated = options.only_annotated;
  var regex = options.regex && new RegExp(options.regex);
  var debug4 = options.debug !== false;
  var debug_name_suffix;
  if (debug4) {
    debug_name_suffix = options.debug === true ? "" : options.debug;
  }
  var names_to_mangle = /* @__PURE__ */ new Set();
  var unmangleable = /* @__PURE__ */ new Set();
  cache3.forEach((mangled_name) => unmangleable.add(mangled_name));
  var keep_quoted = !!options.keep_quoted;
  ast.walk(new TreeWalker(function(node) {
    if (node instanceof AST_ClassPrivateProperty || node instanceof AST_PrivateMethod || node instanceof AST_PrivateGetter || node instanceof AST_PrivateSetter || node instanceof AST_DotHash) ; else if (node instanceof AST_ObjectKeyVal) {
      if (typeof node.key == "string" && (!keep_quoted || !node.quote)) {
        add6(node.key);
      }
    } else if (node instanceof AST_ObjectProperty) {
      if (!keep_quoted || !node.quote) {
        add6(node.key.name);
      }
    } else if (node instanceof AST_Dot) {
      var declared = !!options.undeclared;
      if (!declared) {
        var root = node;
        while (root.expression) {
          root = root.expression;
        }
        declared = !(root.thedef && root.thedef.undeclared);
      }
      if (declared && (!keep_quoted || !node.quote)) {
        add6(node.property);
      }
    } else if (node instanceof AST_Sub) {
      if (!keep_quoted) {
        addStrings(node.property, add6);
      }
    } else if (node instanceof AST_Call && node.expression.print_to_string() == "Object.defineProperty") {
      addStrings(node.args[1], add6);
    } else if (node instanceof AST_Binary && node.operator === "in") {
      addStrings(node.left, add6);
    } else if (node instanceof AST_String && has_annotation(node, _KEY)) {
      add6(node.value);
    }
  }));
  return ast.transform(new TreeTransformer(function(node) {
    if (node instanceof AST_ClassPrivateProperty || node instanceof AST_PrivateMethod || node instanceof AST_PrivateGetter || node instanceof AST_PrivateSetter || node instanceof AST_DotHash) ; else if (node instanceof AST_ObjectKeyVal) {
      if (typeof node.key == "string" && (!keep_quoted || !node.quote)) {
        node.key = mangle(node.key);
      }
    } else if (node instanceof AST_ObjectProperty) {
      if (!keep_quoted || !node.quote) {
        if (!node.computed_key()) {
          node.key.name = mangle(node.key.name);
        }
      }
    } else if (node instanceof AST_Dot) {
      if (!keep_quoted || !node.quote) {
        node.property = mangle(node.property);
      }
    } else if (!keep_quoted && node instanceof AST_Sub) {
      node.property = mangleStrings(node.property);
    } else if (node instanceof AST_Call && node.expression.print_to_string() == "Object.defineProperty") {
      node.args[1] = mangleStrings(node.args[1]);
    } else if (node instanceof AST_Binary && node.operator === "in") {
      node.left = mangleStrings(node.left);
    } else if (node instanceof AST_String && has_annotation(node, _KEY)) {
      clear_annotation(node);
      node.value = mangle(node.value);
    }
  }));
  function can_mangle(name) {
    if (unmangleable.has(name)) return false;
    if (reserved.has(name)) return false;
    if (options.only_cache) {
      return cache3.has(name);
    }
    if (/^-?[0-9]+(\.[0-9]+)?(e[+-][0-9]+)?$/.test(name)) return false;
    return true;
  }
  function should_mangle(name) {
    if (only_annotated && !annotated_props.has(name)) return false;
    if (regex && !regex.test(name)) {
      return annotated_props.has(name);
    }
    if (reserved.has(name)) return false;
    return cache3.has(name) || names_to_mangle.has(name);
  }
  function add6(name) {
    if (can_mangle(name)) {
      names_to_mangle.add(name);
    }
    if (!should_mangle(name)) {
      unmangleable.add(name);
    }
  }
  function mangle(name) {
    if (!should_mangle(name)) {
      return name;
    }
    var mangled = cache3.get(name);
    if (!mangled) {
      if (debug4) {
        var debug_mangled = "_$" + name + "$" + debug_name_suffix + "_";
        if (can_mangle(debug_mangled)) {
          mangled = debug_mangled;
        }
      }
      if (!mangled) {
        do {
          mangled = nth_identifier.get(++cname);
        } while (!can_mangle(mangled));
      }
      cache3.set(name, mangled);
    }
    return mangled;
  }
  function mangleStrings(node) {
    return node.transform(new TreeTransformer(function(node2) {
      if (node2 instanceof AST_Sequence) {
        var last6 = node2.expressions.length - 1;
        node2.expressions[last6] = mangleStrings(node2.expressions[last6]);
      } else if (node2 instanceof AST_String) {
        clear_annotation(node2);
        node2.value = mangle(node2.value);
      } else if (node2 instanceof AST_Conditional) {
        node2.consequent = mangleStrings(node2.consequent);
        node2.alternative = mangleStrings(node2.alternative);
      }
      return node2;
    }));
  }
}

// node_modules/.pnpm/terser@5.39.0/node_modules/terser/lib/minify.js
var to_ascii = typeof Buffer !== "undefined" ? (b64) => Buffer.from(b64, "base64").toString() : (b64) => decodeURIComponent(escape(atob(b64)));
var to_base64 = typeof Buffer !== "undefined" ? (str) => Buffer.from(str).toString("base64") : (str) => btoa(unescape(encodeURIComponent(str)));
function read_source_map(code) {
  var match18 = /(?:^|[^.])\/\/# sourceMappingURL=data:application\/json(;[\w=-]*)?;base64,([+/0-9A-Za-z]*=*)\s*$/.exec(code);
  if (!match18) {
    console.warn("inline source map not found");
    return null;
  }
  return to_ascii(match18[2]);
}
function set_shorthand(name, options, keys5) {
  if (options[name]) {
    keys5.forEach(function(key) {
      if (options[key]) {
        if (typeof options[key] != "object") options[key] = {};
        if (!(name in options[key])) options[key][name] = options[name];
      }
    });
  }
}
function init_cache(cache3) {
  if (!cache3) return;
  if (!("props" in cache3)) {
    cache3.props = /* @__PURE__ */ new Map();
  } else if (!(cache3.props instanceof Map)) {
    cache3.props = map_from_object(cache3.props);
  }
}
function cache_to_json(cache3) {
  return {
    props: map_to_object(cache3.props)
  };
}
function* minify_sync_or_async(files, options, _fs_module) {
  options = defaults2(options, {
    compress: {},
    ecma: void 0,
    enclose: false,
    ie8: false,
    keep_classnames: void 0,
    keep_fnames: false,
    mangle: {},
    module: false,
    nameCache: null,
    output: null,
    format: null,
    parse: {},
    rename: void 0,
    safari10: false,
    sourceMap: false,
    spidermonkey: false,
    timings: false,
    toplevel: false,
    warnings: false,
    wrap: false
  }, true);
  var timings = options.timings && {
    start: Date.now()
  };
  if (options.keep_classnames === void 0) {
    options.keep_classnames = options.keep_fnames;
  }
  if (options.rename === void 0) {
    options.rename = options.compress && options.mangle;
  }
  if (options.output && options.format) {
    throw new Error("Please only specify either output or format option, preferrably format.");
  }
  options.format = options.format || options.output || {};
  set_shorthand("ecma", options, ["parse", "compress", "format"]);
  set_shorthand("ie8", options, ["compress", "mangle", "format"]);
  set_shorthand("keep_classnames", options, ["compress", "mangle"]);
  set_shorthand("keep_fnames", options, ["compress", "mangle"]);
  set_shorthand("module", options, ["parse", "compress", "mangle"]);
  set_shorthand("safari10", options, ["mangle", "format"]);
  set_shorthand("toplevel", options, ["compress", "mangle"]);
  set_shorthand("warnings", options, ["compress"]);
  var quoted_props;
  if (options.mangle) {
    options.mangle = defaults2(options.mangle, {
      cache: options.nameCache && (options.nameCache.vars || {}),
      eval: false,
      ie8: false,
      keep_classnames: false,
      keep_fnames: false,
      module: false,
      nth_identifier: base54,
      properties: false,
      reserved: [],
      safari10: false,
      toplevel: false
    }, true);
    if (options.mangle.properties) {
      if (typeof options.mangle.properties != "object") {
        options.mangle.properties = {};
      }
      if (options.mangle.properties.keep_quoted) {
        quoted_props = options.mangle.properties.reserved;
        if (!Array.isArray(quoted_props)) quoted_props = [];
        options.mangle.properties.reserved = quoted_props;
      }
      if (options.nameCache && !("cache" in options.mangle.properties)) {
        options.mangle.properties.cache = options.nameCache.props || {};
      }
    }
    init_cache(options.mangle.cache);
    init_cache(options.mangle.properties.cache);
  }
  if (options.sourceMap) {
    options.sourceMap = defaults2(options.sourceMap, {
      asObject: false,
      content: null,
      filename: null,
      includeSources: false,
      root: null,
      url: null
    }, true);
  }
  if (timings) timings.parse = Date.now();
  var toplevel;
  if (files instanceof AST_Toplevel) {
    toplevel = files;
  } else {
    if (typeof files == "string" || options.parse.spidermonkey && !Array.isArray(files)) {
      files = [files];
    }
    options.parse = options.parse || {};
    options.parse.toplevel = null;
    if (options.parse.spidermonkey) {
      options.parse.toplevel = AST_Node.from_mozilla_ast(Object.keys(files).reduce(function(toplevel2, name2) {
        if (!toplevel2) return files[name2];
        toplevel2.body = toplevel2.body.concat(files[name2].body);
        return toplevel2;
      }, null));
    } else {
      delete options.parse.spidermonkey;
      for (var name in files) if (HOP(files, name)) {
        options.parse.filename = name;
        options.parse.toplevel = parse(files[name], options.parse);
        if (options.sourceMap && options.sourceMap.content == "inline") {
          if (Object.keys(files).length > 1)
            throw new Error("inline source map only works with singular input");
          options.sourceMap.content = read_source_map(files[name]);
        }
      }
    }
    if (options.parse.toplevel === null) {
      throw new Error("no source file given");
    }
    toplevel = options.parse.toplevel;
  }
  if (quoted_props && options.mangle.properties.keep_quoted !== "strict") {
    reserve_quoted_keys(toplevel, quoted_props);
  }
  var annotated_props;
  if (options.mangle && options.mangle.properties) {
    annotated_props = find_annotated_props(toplevel);
  }
  if (options.wrap) {
    toplevel = toplevel.wrap_commonjs(options.wrap);
  }
  if (options.enclose) {
    toplevel = toplevel.wrap_enclose(options.enclose);
  }
  if (timings) timings.rename = Date.now();
  if (timings) timings.compress = Date.now();
  if (options.compress) {
    toplevel = new Compressor(options.compress, {
      mangle_options: options.mangle
    }).compress(toplevel);
  }
  if (timings) timings.scope = Date.now();
  if (options.mangle) toplevel.figure_out_scope(options.mangle);
  if (timings) timings.mangle = Date.now();
  if (options.mangle) {
    toplevel.compute_char_frequency(options.mangle);
    toplevel.mangle_names(options.mangle);
    toplevel = mangle_private_properties(toplevel, options.mangle);
  }
  if (timings) timings.properties = Date.now();
  if (options.mangle && options.mangle.properties) {
    toplevel = mangle_properties(toplevel, options.mangle.properties, annotated_props);
  }
  if (timings) timings.format = Date.now();
  var result = {};
  if (options.format.ast) {
    result.ast = toplevel;
  }
  if (options.format.spidermonkey) {
    result.ast = toplevel.to_mozilla_ast();
  }
  let format_options;
  if (!HOP(options.format, "code") || options.format.code) {
    format_options = { ...options.format };
    if (!format_options.ast) {
      format_options._destroy_ast = true;
      walk2(toplevel, (node) => {
        if (node instanceof AST_Scope) {
          node.variables = void 0;
          node.enclosed = void 0;
          node.parent_scope = void 0;
        }
        if (node.block_scope) {
          node.block_scope.variables = void 0;
          node.block_scope.enclosed = void 0;
          node.block_scope.parent_scope = void 0;
        }
      });
    }
    if (options.sourceMap) {
      if (options.sourceMap.includeSources && files instanceof AST_Toplevel) {
        throw new Error("original source content unavailable");
      }
      format_options.source_map = yield* SourceMap({
        file: options.sourceMap.filename,
        orig: options.sourceMap.content,
        root: options.sourceMap.root,
        files: options.sourceMap.includeSources ? files : null
      });
    }
    delete format_options.ast;
    delete format_options.code;
    delete format_options.spidermonkey;
    var stream = OutputStream(format_options);
    toplevel.print(stream);
    result.code = stream.get();
    if (options.sourceMap) {
      Object.defineProperty(result, "map", {
        configurable: true,
        enumerable: true,
        get() {
          const map26 = format_options.source_map.getEncoded();
          return result.map = options.sourceMap.asObject ? map26 : JSON.stringify(map26);
        },
        set(value) {
          Object.defineProperty(result, "map", {
            value,
            writable: true
          });
        }
      });
      result.decoded_map = format_options.source_map.getDecoded();
      if (options.sourceMap.url == "inline") {
        var sourceMap = typeof result.map === "object" ? JSON.stringify(result.map) : result.map;
        result.code += "\n//# sourceMappingURL=data:application/json;charset=utf-8;base64," + to_base64(sourceMap);
      } else if (options.sourceMap.url) {
        result.code += "\n//# sourceMappingURL=" + options.sourceMap.url;
      }
    }
  }
  if (options.nameCache && options.mangle) {
    if (options.mangle.cache) options.nameCache.vars = cache_to_json(options.mangle.cache);
    if (options.mangle.properties && options.mangle.properties.cache) {
      options.nameCache.props = cache_to_json(options.mangle.properties.cache);
    }
  }
  if (format_options && format_options.source_map) {
    format_options.source_map.destroy();
  }
  if (timings) {
    timings.end = Date.now();
    result.timings = {
      parse: 1e-3 * (timings.rename - timings.parse),
      rename: 1e-3 * (timings.compress - timings.rename),
      compress: 1e-3 * (timings.scope - timings.compress),
      scope: 1e-3 * (timings.mangle - timings.scope),
      mangle: 1e-3 * (timings.properties - timings.mangle),
      properties: 1e-3 * (timings.format - timings.properties),
      format: 1e-3 * (timings.end - timings.format),
      total: 1e-3 * (timings.end - timings.start)
    };
  }
  return result;
}
async function minify(files, options, _fs_module) {
  const gen3 = minify_sync_or_async(files, options);
  let yielded;
  let val;
  do {
    val = gen3.next(await yielded);
    yielded = val.value;
  } while (!val.done);
  return val.value;
}

// node_modules/.pnpm/@rollup+plugin-terser@0.4.4_@rollup+wasm-node@4.37.0/node_modules/@rollup/plugin-terser/dist/es/index.js
var import_serialize_javascript = __toESM(require_serialize_javascript());
var taskInfo = Symbol("taskInfo");
var freeWorker = Symbol("freeWorker");
var workerPoolWorkerFlag = "WorkerPoolWorker";
function isWorkerContextSerialized(input2) {
  return isObject2(input2) && hasOwnProperty(input2, "code") && typeof input2.code === "string" && hasOwnProperty(input2, "options") && typeof input2.options === "string";
}
function runWorker() {
  if (worker_threads.isMainThread || !worker_threads.parentPort || worker_threads.workerData !== workerPoolWorkerFlag) {
    return;
  }
  const eval2 = eval;
  worker_threads.parentPort.on("message", async (data) => {
    if (!isWorkerContextSerialized(data)) {
      return;
    }
    const options = eval2(`(${data.options})`);
    const result = await minify(data.code, options);
    const output = {
      code: result.code || data.code,
      nameCache: options.nameCache
    };
    if (typeof result.map === "string") {
      output.sourceMap = JSON.parse(result.map);
    }
    if (isObject2(result.map)) {
      output.sourceMap = result.map;
    }
    worker_threads.parentPort === null || worker_threads.parentPort === void 0 ? void 0 : worker_threads.parentPort.postMessage(output);
  });
}
var WorkerPoolTaskInfo = class extends async_hooks.AsyncResource {
  constructor(callback) {
    super("WorkerPoolTaskInfo");
    this.callback = callback;
  }
  done(err, result) {
    this.runInAsyncScope(this.callback, null, err, result);
    this.emitDestroy();
  }
};
var WorkerPool = class extends events.EventEmitter {
  constructor(options) {
    super();
    this.tasks = [];
    this.workers = [];
    this.freeWorkers = [];
    this.maxInstances = options.maxWorkers || os.cpus().length;
    this.filePath = options.filePath;
    this.on(freeWorker, () => {
      if (this.tasks.length > 0) {
        const { context: context8, cb } = this.tasks.shift();
        this.runTask(context8, cb);
      }
    });
  }
  get numWorkers() {
    return this.workers.length;
  }
  addAsync(context8) {
    return new Promise((resolve9, reject) => {
      this.runTask(context8, (err, output) => {
        if (err) {
          reject(err);
          return;
        }
        if (!output) {
          reject(new Error("The output is empty"));
          return;
        }
        resolve9(output);
      });
    });
  }
  close() {
    for (let i = 0; i < this.workers.length; i++) {
      const worker = this.workers[i];
      worker.terminate();
    }
  }
  addNewWorker() {
    const worker = new worker_threads.Worker(this.filePath, {
      workerData: workerPoolWorkerFlag
    });
    worker.on("message", (result) => {
      var _a2;
      (_a2 = worker[taskInfo]) === null || _a2 === void 0 ? void 0 : _a2.done(null, result);
      worker[taskInfo] = null;
      this.freeWorkers.push(worker);
      this.emit(freeWorker);
    });
    worker.on("error", (err) => {
      if (worker[taskInfo]) {
        worker[taskInfo].done(err, null);
      } else {
        this.emit("error", err);
      }
      this.workers.splice(this.workers.indexOf(worker), 1);
      this.addNewWorker();
    });
    this.workers.push(worker);
    this.freeWorkers.push(worker);
    this.emit(freeWorker);
  }
  runTask(context8, cb) {
    if (this.freeWorkers.length === 0) {
      this.tasks.push({ context: context8, cb });
      if (this.numWorkers < this.maxInstances) {
        this.addNewWorker();
      }
      return;
    }
    const worker = this.freeWorkers.pop();
    if (worker) {
      worker[taskInfo] = new WorkerPoolTaskInfo(cb);
      worker.postMessage({
        code: context8.code,
        options: (0, import_serialize_javascript.default)(context8.options)
      });
    }
  }
};
function terser(input2 = {}) {
  const { maxWorkers, ...options } = input2;
  let workerPool;
  let numOfChunks = 0;
  let numOfWorkersUsed = 0;
  return {
    name: "terser",
    async renderChunk(code, chunk5, outputOptions) {
      if (!workerPool) {
        workerPool = new WorkerPool({
          filePath: url$1.fileURLToPath((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('index.js', document.baseURI).href))),
          maxWorkers
        });
      }
      numOfChunks += 1;
      const defaultOptions2 = {
        sourceMap: outputOptions.sourcemap === true || typeof outputOptions.sourcemap === "string"
      };
      if (outputOptions.format === "es") {
        defaultOptions2.module = true;
      }
      if (outputOptions.format === "cjs") {
        defaultOptions2.toplevel = true;
      }
      try {
        const { code: result, nameCache, sourceMap } = await workerPool.addAsync({
          code,
          options: merge11({}, options || {}, defaultOptions2)
        });
        if (options.nameCache && nameCache) {
          let vars = {
            props: {}
          };
          if (hasOwnProperty(options.nameCache, "vars") && isObject2(options.nameCache.vars)) {
            vars = merge11({}, options.nameCache.vars || {}, vars);
          }
          if (hasOwnProperty(nameCache, "vars") && isObject2(nameCache.vars)) {
            vars = merge11({}, nameCache.vars, vars);
          }
          options.nameCache.vars = vars;
          let props = {};
          if (hasOwnProperty(options.nameCache, "props") && isObject2(options.nameCache.props)) {
            props = options.nameCache.props;
          }
          if (hasOwnProperty(nameCache, "props") && isObject2(nameCache.props)) {
            props = merge11({}, nameCache.props, props);
          }
          options.nameCache.props = props;
        }
        if ((!!defaultOptions2.sourceMap || !!options.sourceMap) && isObject2(sourceMap)) {
          return {
            code: result,
            map: sourceMap
          };
        }
        return result;
      } catch (e) {
        return Promise.reject(e);
      } finally {
        numOfChunks -= 1;
        if (numOfChunks === 0) {
          numOfWorkersUsed = workerPool.numWorkers;
          workerPool.close();
          workerPool = null;
        }
      }
    },
    get numOfWorkersUsed() {
      return numOfWorkersUsed;
    }
  };
}
runWorker();

// node_modules/.pnpm/@rollup+wasm-node@4.37.0/node_modules/@rollup/wasm-node/dist/es/rollup.js
init_node_entry();
init_parseAst();
__toESM(require_native());

// node_modules/.pnpm/rollup-plugin-esbuild@6.2.1_@rollup+wasm-node@4.37.0_esbuild@0.25.1/node_modules/rollup-plugin-esbuild/dist/index.mjs
var import_esbuild = __toESM(require_main());

// node_modules/.pnpm/pathe@2.0.3/node_modules/pathe/dist/shared/pathe.M-eThtNZ.mjs
var _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input2 = "") {
  if (!input2) {
    return input2;
  }
  return input2.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
}
var _UNC_REGEX = /^[/\\]{2}/;
var _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
var _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
var normalize3 = function(path3) {
  if (path3.length === 0) {
    return ".";
  }
  path3 = normalizeWindowsPath(path3);
  const isUNCPath = path3.match(_UNC_REGEX);
  const isPathAbsolute = isAbsolute4(path3);
  const trailingSeparator = path3[path3.length - 1] === "/";
  path3 = normalizeString(path3, !isPathAbsolute);
  if (path3.length === 0) {
    if (isPathAbsolute) {
      return "/";
    }
    return trailingSeparator ? "./" : ".";
  }
  if (trailingSeparator) {
    path3 += "/";
  }
  if (_DRIVE_LETTER_RE.test(path3)) {
    path3 += "/";
  }
  if (isUNCPath) {
    if (!isPathAbsolute) {
      return `//./${path3}`;
    }
    return `//${path3}`;
  }
  return isPathAbsolute && !isAbsolute4(path3) ? `/${path3}` : path3;
};
var join4 = function(...segments) {
  let path3 = "";
  for (const seg of segments) {
    if (!seg) {
      continue;
    }
    if (path3.length > 0) {
      const pathTrailing = path3[path3.length - 1] === "/";
      const segLeading = seg[0] === "/";
      const both2 = pathTrailing && segLeading;
      if (both2) {
        path3 += seg.slice(1);
      } else {
        path3 += pathTrailing || segLeading ? seg : `/${seg}`;
      }
    } else {
      path3 += seg;
    }
  }
  return normalize3(path3);
};
function cwd() {
  if (typeof process !== "undefined" && typeof process.cwd === "function") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
var resolve7 = function(...arguments_) {
  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
    const path3 = index >= 0 ? arguments_[index] : cwd();
    if (!path3 || path3.length === 0) {
      continue;
    }
    resolvedPath = `${path3}/${resolvedPath}`;
    resolvedAbsolute = isAbsolute4(path3);
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute && !isAbsolute4(resolvedPath)) {
    return `/${resolvedPath}`;
  }
  return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path3, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0; index <= path3.length; ++index) {
    if (index < path3.length) {
      char = path3[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1) ;
      else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path3.slice(lastSlash + 1, index)}`;
        } else {
          res = path3.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var isAbsolute4 = function(p3) {
  return _IS_ABSOLUTE_RE.test(p3);
};

// node_modules/.pnpm/unplugin-utils@0.2.4/node_modules/unplugin-utils/dist/index.js
var import_picomatch2 = __toESM(require_picomatch2());
function normalizePath4(filename) {
  return filename.replaceAll("\\", "/");
}
var isArray3 = Array.isArray;
function toArray4(thing) {
  if (isArray3(thing)) return thing;
  if (thing == null) return [];
  return [thing];
}
var escapeMark = "[_#EsCaPe#_]";
function getMatcherString2(id2, resolutionBase) {
  if (isAbsolute4(id2) || id2.startsWith("**")) return normalizePath4(id2);
  const basePath = normalizePath4(resolve7("")).replaceAll(/[-^$*+?.()|[\]{}]/g, `${escapeMark}$&`);
  return join4(basePath, normalizePath4(id2)).replaceAll(escapeMark, "\\");
}
function createFilter3(include, exclude3, options) {
  const getMatcher = (id2) => id2 instanceof RegExp ? id2 : { test: (what) => {
    const pattern = getMatcherString2(id2);
    const fn2 = (0, import_picomatch2.default)(pattern, { dot: true });
    const result = fn2(what);
    return result;
  } };
  const includeMatchers = toArray4(include).map(getMatcher);
  const excludeMatchers = toArray4(exclude3).map(getMatcher);
  if (!includeMatchers.length && !excludeMatchers.length) return (id2) => typeof id2 === "string" && !id2.includes("\0");
  return function result(id2) {
    if (typeof id2 !== "string") return false;
    if (id2.includes("\0")) return false;
    const pathId = normalizePath4(id2);
    for (const matcher of excludeMatchers) {
      if (matcher instanceof RegExp) matcher.lastIndex = 0;
      if (matcher.test(pathId)) return false;
    }
    for (const matcher of includeMatchers) {
      if (matcher instanceof RegExp) matcher.lastIndex = 0;
      if (matcher.test(pathId)) return true;
    }
    return !includeMatchers.length;
  };
}

// node_modules/.pnpm/rollup-plugin-esbuild@6.2.1_@rollup+wasm-node@4.37.0_esbuild@0.25.1/node_modules/rollup-plugin-esbuild/dist/index.mjs
var import_debug2 = __toESM(require_src());
var import_esbuild2 = __toESM(require_main());
var import_esbuild3 = __toESM(require_main());
var import_esbuild4 = __toESM(require_main());

// node_modules/.pnpm/es-module-lexer@1.6.0/node_modules/es-module-lexer/dist/lexer.js
var ImportType;
!function(A3) {
  A3[A3.Static = 1] = "Static", A3[A3.Dynamic = 2] = "Dynamic", A3[A3.ImportMeta = 3] = "ImportMeta", A3[A3.StaticSourcePhase = 4] = "StaticSourcePhase", A3[A3.DynamicSourcePhase = 5] = "DynamicSourcePhase";
}(ImportType || (ImportType = {}));
var A = 1 === new Uint8Array(new Uint16Array([1]).buffer)[0];
function parse5(E4, g = "@") {
  if (!C2) return init.then(() => parse5(E4));
  const I2 = E4.length + 1, w2 = (C2.__heap_base.value || C2.__heap_base) + 4 * I2 - C2.memory.buffer.byteLength;
  w2 > 0 && C2.memory.grow(Math.ceil(w2 / 65536));
  const K2 = C2.sa(I2 - 1);
  if ((A ? B : Q)(E4, new Uint16Array(C2.memory.buffer, K2, I2)), !C2.parse()) throw Object.assign(new Error(`Parse error ${g}:${E4.slice(0, C2.e()).split("\n").length}:${C2.e() - E4.lastIndexOf("\n", C2.e() - 1)}`), { idx: C2.e() });
  const o2 = [], D = [];
  for (; C2.ri(); ) {
    const A3 = C2.is(), Q3 = C2.ie(), B3 = C2.it(), g2 = C2.ai(), I3 = C2.id(), w3 = C2.ss(), K3 = C2.se();
    let D2;
    C2.ip() && (D2 = k(E4.slice(-1 === I3 ? A3 - 1 : A3, -1 === I3 ? Q3 + 1 : Q3))), o2.push({ n: D2, t: B3, s: A3, e: Q3, ss: w3, se: K3, d: I3, a: g2 });
  }
  for (; C2.re(); ) {
    const A3 = C2.es(), Q3 = C2.ee(), B3 = C2.els(), g2 = C2.ele(), I3 = E4.slice(A3, Q3), w3 = I3[0], K3 = B3 < 0 ? void 0 : E4.slice(B3, g2), o3 = K3 ? K3[0] : "";
    D.push({ s: A3, e: Q3, ls: B3, le: g2, n: '"' === w3 || "'" === w3 ? k(I3) : I3, ln: '"' === o3 || "'" === o3 ? k(K3) : K3 });
  }
  function k(A3) {
    try {
      return (0, eval)(A3);
    } catch (A4) {
    }
  }
  return [o2, D, !!C2.f(), !!C2.ms()];
}
function Q(A3, Q3) {
  const B3 = A3.length;
  let C4 = 0;
  for (; C4 < B3; ) {
    const B4 = A3.charCodeAt(C4);
    Q3[C4++] = (255 & B4) << 8 | B4 >>> 8;
  }
}
function B(A3, Q3) {
  const B3 = A3.length;
  let C4 = 0;
  for (; C4 < B3; ) Q3[C4] = A3.charCodeAt(C4++);
}
var C2;
var E = () => {
  return A3 = "AGFzbQEAAAABKwhgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gA39/fwADMTAAAQECAgICAgICAgICAgICAgICAgIAAwMDBAQAAAUAAAAAAAMDAwAGAAAABwAGAgUEBQFwAQEBBQMBAAEGDwJ/AUHA8gALfwBBwPIACwd6FQZtZW1vcnkCAAJzYQAAAWUAAwJpcwAEAmllAAUCc3MABgJzZQAHAml0AAgCYWkACQJpZAAKAmlwAAsCZXMADAJlZQANA2VscwAOA2VsZQAPAnJpABACcmUAEQFmABICbXMAEwVwYXJzZQAUC19faGVhcF9iYXNlAwEKm0EwaAEBf0EAIAA2AoAKQQAoAtwJIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgKECkEAIAA2AogKQQBBADYC4AlBAEEANgLwCUEAQQA2AugJQQBBADYC5AlBAEEANgL4CUEAQQA2AuwJIAEL0wEBA39BACgC8AkhBEEAQQAoAogKIgU2AvAJQQAgBDYC9AlBACAFQSRqNgKICiAEQSBqQeAJIAQbIAU2AgBBACgC1AkhBEEAKALQCSEGIAUgATYCACAFIAA2AgggBSACIAJBAmpBACAGIANGIgAbIAQgA0YiBBs2AgwgBSADNgIUIAVBADYCECAFIAI2AgQgBUEANgIgIAVBA0EBQQIgABsgBBs2AhwgBUEAKALQCSADRiICOgAYAkACQCACDQBBACgC1AkgA0cNAQtBAEEBOgCMCgsLXgEBf0EAKAL4CSIEQRBqQeQJIAQbQQAoAogKIgQ2AgBBACAENgL4CUEAIARBFGo2AogKQQBBAToAjAogBEEANgIQIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCAAsIAEEAKAKQCgsVAEEAKALoCSgCAEEAKALcCWtBAXULHgEBf0EAKALoCSgCBCIAQQAoAtwJa0EBdUF/IAAbCxUAQQAoAugJKAIIQQAoAtwJa0EBdQseAQF/QQAoAugJKAIMIgBBACgC3AlrQQF1QX8gABsLCwBBACgC6AkoAhwLHgEBf0EAKALoCSgCECIAQQAoAtwJa0EBdUF/IAAbCzsBAX8CQEEAKALoCSgCFCIAQQAoAtAJRw0AQX8PCwJAIABBACgC1AlHDQBBfg8LIABBACgC3AlrQQF1CwsAQQAoAugJLQAYCxUAQQAoAuwJKAIAQQAoAtwJa0EBdQsVAEEAKALsCSgCBEEAKALcCWtBAXULHgEBf0EAKALsCSgCCCIAQQAoAtwJa0EBdUF/IAAbCx4BAX9BACgC7AkoAgwiAEEAKALcCWtBAXVBfyAAGwslAQF/QQBBACgC6AkiAEEgakHgCSAAGygCACIANgLoCSAAQQBHCyUBAX9BAEEAKALsCSIAQRBqQeQJIAAbKAIAIgA2AuwJIABBAEcLCABBAC0AlAoLCABBAC0AjAoL3Q0BBX8jAEGA0ABrIgAkAEEAQQE6AJQKQQBBACgC2Ak2ApwKQQBBACgC3AlBfmoiATYCsApBACABQQAoAoAKQQF0aiICNgK0CkEAQQA6AIwKQQBBADsBlgpBAEEAOwGYCkEAQQA6AKAKQQBBADYCkApBAEEAOgD8CUEAIABBgBBqNgKkCkEAIAA2AqgKQQBBADoArAoCQAJAAkACQANAQQAgAUECaiIDNgKwCiABIAJPDQECQCADLwEAIgJBd2pBBUkNAAJAAkACQAJAAkAgAkGbf2oOBQEICAgCAAsgAkEgRg0EIAJBL0YNAyACQTtGDQIMBwtBAC8BmAoNASADEBVFDQEgAUEEakGCCEEKEC8NARAWQQAtAJQKDQFBAEEAKAKwCiIBNgKcCgwHCyADEBVFDQAgAUEEakGMCEEKEC8NABAXC0EAQQAoArAKNgKcCgwBCwJAIAEvAQQiA0EqRg0AIANBL0cNBBAYDAELQQEQGQtBACgCtAohAkEAKAKwCiEBDAALC0EAIQIgAyEBQQAtAPwJDQIMAQtBACABNgKwCkEAQQA6AJQKCwNAQQAgAUECaiIDNgKwCgJAAkACQAJAAkACQAJAIAFBACgCtApPDQAgAy8BACICQXdqQQVJDQYCQAJAAkACQAJAAkACQAJAAkACQCACQWBqDgoQDwYPDw8PBQECAAsCQAJAAkACQCACQaB/ag4KCxISAxIBEhISAgALIAJBhX9qDgMFEQYJC0EALwGYCg0QIAMQFUUNECABQQRqQYIIQQoQLw0QEBYMEAsgAxAVRQ0PIAFBBGpBjAhBChAvDQ8QFwwPCyADEBVFDQ4gASkABELsgISDsI7AOVINDiABLwEMIgNBd2oiAUEXSw0MQQEgAXRBn4CABHFFDQwMDQtBAEEALwGYCiIBQQFqOwGYCkEAKAKkCiABQQN0aiIBQQE2AgAgAUEAKAKcCjYCBAwNC0EALwGYCiIDRQ0JQQAgA0F/aiIDOwGYCkEALwGWCiICRQ0MQQAoAqQKIANB//8DcUEDdGooAgBBBUcNDAJAIAJBAnRBACgCqApqQXxqKAIAIgMoAgQNACADQQAoApwKQQJqNgIEC0EAIAJBf2o7AZYKIAMgAUEEajYCDAwMCwJAQQAoApwKIgEvAQBBKUcNAEEAKALwCSIDRQ0AIAMoAgQgAUcNAEEAQQAoAvQJIgM2AvAJAkAgA0UNACADQQA2AiAMAQtBAEEANgLgCQtBAEEALwGYCiIDQQFqOwGYCkEAKAKkCiADQQN0aiIDQQZBAkEALQCsChs2AgAgAyABNgIEQQBBADoArAoMCwtBAC8BmAoiAUUNB0EAIAFBf2oiATsBmApBACgCpAogAUH//wNxQQN0aigCAEEERg0EDAoLQScQGgwJC0EiEBoMCAsgAkEvRw0HAkACQCABLwEEIgFBKkYNACABQS9HDQEQGAwKC0EBEBkMCQsCQAJAAkACQEEAKAKcCiIBLwEAIgMQG0UNAAJAAkAgA0FVag4EAAkBAwkLIAFBfmovAQBBK0YNAwwICyABQX5qLwEAQS1GDQIMBwsgA0EpRw0BQQAoAqQKQQAvAZgKIgJBA3RqKAIEEBxFDQIMBgsgAUF+ai8BAEFQakH//wNxQQpPDQULQQAvAZgKIQILAkACQCACQf//A3EiAkUNACADQeYARw0AQQAoAqQKIAJBf2pBA3RqIgQoAgBBAUcNACABQX5qLwEAQe8ARw0BIAQoAgRBlghBAxAdRQ0BDAULIANB/QBHDQBBACgCpAogAkEDdGoiAigCBBAeDQQgAigCAEEGRg0ECyABEB8NAyADRQ0DIANBL0ZBAC0AoApBAEdxDQMCQEEAKAL4CSICRQ0AIAEgAigCAEkNACABIAIoAgRNDQQLIAFBfmohAUEAKALcCSECAkADQCABQQJqIgQgAk0NAUEAIAE2ApwKIAEvAQAhAyABQX5qIgQhASADECBFDQALIARBAmohBAsCQCADQf//A3EQIUUNACAEQX5qIQECQANAIAFBAmoiAyACTQ0BQQAgATYCnAogAS8BACEDIAFBfmoiBCEBIAMQIQ0ACyAEQQJqIQMLIAMQIg0EC0EAQQE6AKAKDAcLQQAoAqQKQQAvAZgKIgFBA3QiA2pBACgCnAo2AgRBACABQQFqOwGYCkEAKAKkCiADakEDNgIACxAjDAULQQAtAPwJQQAvAZYKQQAvAZgKcnJFIQIMBwsQJEEAQQA6AKAKDAMLECVBACECDAULIANBoAFHDQELQQBBAToArAoLQQBBACgCsAo2ApwKC0EAKAKwCiEBDAALCyAAQYDQAGokACACCxoAAkBBACgC3AkgAEcNAEEBDwsgAEF+ahAmC/4KAQZ/QQBBACgCsAoiAEEMaiIBNgKwCkEAKAL4CSECQQEQKSEDAkACQAJAAkACQAJAAkACQAJAQQAoArAKIgQgAUcNACADEChFDQELAkACQAJAAkACQAJAAkAgA0EqRg0AIANB+wBHDQFBACAEQQJqNgKwCkEBECkhA0EAKAKwCiEEA0ACQAJAIANB//8DcSIDQSJGDQAgA0EnRg0AIAMQLBpBACgCsAohAwwBCyADEBpBAEEAKAKwCkECaiIDNgKwCgtBARApGgJAIAQgAxAtIgNBLEcNAEEAQQAoArAKQQJqNgKwCkEBECkhAwsgA0H9AEYNA0EAKAKwCiIFIARGDQ8gBSEEIAVBACgCtApNDQAMDwsLQQAgBEECajYCsApBARApGkEAKAKwCiIDIAMQLRoMAgtBAEEAOgCUCgJAAkACQAJAAkACQCADQZ9/ag4MAgsEAQsDCwsLCwsFAAsgA0H2AEYNBAwKC0EAIARBDmoiAzYCsAoCQAJAAkBBARApQZ9/ag4GABICEhIBEgtBACgCsAoiBSkAAkLzgOSD4I3AMVINESAFLwEKECFFDRFBACAFQQpqNgKwCkEAECkaC0EAKAKwCiIFQQJqQbIIQQ4QLw0QIAUvARAiAkF3aiIBQRdLDQ1BASABdEGfgIAEcUUNDQwOC0EAKAKwCiIFKQACQuyAhIOwjsA5Ug0PIAUvAQoiAkF3aiIBQRdNDQYMCgtBACAEQQpqNgKwCkEAECkaQQAoArAKIQQLQQAgBEEQajYCsAoCQEEBECkiBEEqRw0AQQBBACgCsApBAmo2ArAKQQEQKSEEC0EAKAKwCiEDIAQQLBogA0EAKAKwCiIEIAMgBBACQQBBACgCsApBfmo2ArAKDwsCQCAEKQACQuyAhIOwjsA5Ug0AIAQvAQoQIEUNAEEAIARBCmo2ArAKQQEQKSEEQQAoArAKIQMgBBAsGiADQQAoArAKIgQgAyAEEAJBAEEAKAKwCkF+ajYCsAoPC0EAIARBBGoiBDYCsAoLQQAgBEEGajYCsApBAEEAOgCUCkEBECkhBEEAKAKwCiEDIAQQLCEEQQAoArAKIQIgBEHf/wNxIgFB2wBHDQNBACACQQJqNgKwCkEBECkhBUEAKAKwCiEDQQAhBAwEC0EAQQE6AIwKQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0AQQAgA0EIajYCsAogAEEBEClBABArIAJBEGpB5AkgAhshAwNAIAMoAgAiA0UNBSADQgA3AgggA0EQaiEDDAALC0EAIANBfmo2ArAKDAMLQQEgAXRBn4CABHFFDQMMBAtBASEECwNAAkACQCAEDgIAAQELIAVB//8DcRAsGkEBIQQMAQsCQAJAQQAoArAKIgQgA0YNACADIAQgAyAEEAJBARApIQQCQCABQdsARw0AIARBIHJB/QBGDQQLQQAoArAKIQMCQCAEQSxHDQBBACADQQJqNgKwCkEBECkhBUEAKAKwCiEDIAVBIHJB+wBHDQILQQAgA0F+ajYCsAoLIAFB2wBHDQJBACACQX5qNgKwCg8LQQAhBAwACwsPCyACQaABRg0AIAJB+wBHDQQLQQAgBUEKajYCsApBARApIgVB+wBGDQMMAgsCQCACQVhqDgMBAwEACyACQaABRw0CC0EAIAVBEGo2ArAKAkBBARApIgVBKkcNAEEAQQAoArAKQQJqNgKwCkEBECkhBQsgBUEoRg0BC0EAKAKwCiEBIAUQLBpBACgCsAoiBSABTQ0AIAQgAyABIAUQAkEAQQAoArAKQX5qNgKwCg8LIAQgA0EAQQAQAkEAIARBDGo2ArAKDwsQJQvcCAEGf0EAIQBBAEEAKAKwCiIBQQxqIgI2ArAKQQEQKSEDQQAoArAKIQQCQAJAAkACQAJAAkACQAJAIANBLkcNAEEAIARBAmo2ArAKAkBBARApIgNB8wBGDQAgA0HtAEcNB0EAKAKwCiIDQQJqQZwIQQYQLw0HAkBBACgCnAoiBBAqDQAgBC8BAEEuRg0ICyABIAEgA0EIakEAKALUCRABDwtBACgCsAoiA0ECakGiCEEKEC8NBgJAQQAoApwKIgQQKg0AIAQvAQBBLkYNBwsgA0EMaiEDDAELIANB8wBHDQEgBCACTQ0BQQYhAEEAIQIgBEECakGiCEEKEC8NAiAEQQxqIQMCQCAELwEMIgVBd2oiBEEXSw0AQQEgBHRBn4CABHENAQsgBUGgAUcNAgtBACADNgKwCkEBIQBBARApIQMLAkACQAJAAkAgA0H7AEYNACADQShHDQFBACgCpApBAC8BmAoiA0EDdGoiBEEAKAKwCjYCBEEAIANBAWo7AZgKIARBBTYCAEEAKAKcCi8BAEEuRg0HQQBBACgCsAoiBEECajYCsApBARApIQMgAUEAKAKwCkEAIAQQAQJAAkAgAA0AQQAoAvAJIQQMAQtBACgC8AkiBEEFNgIcC0EAQQAvAZYKIgBBAWo7AZYKQQAoAqgKIABBAnRqIAQ2AgACQCADQSJGDQAgA0EnRg0AQQBBACgCsApBfmo2ArAKDwsgAxAaQQBBACgCsApBAmoiAzYCsAoCQAJAAkBBARApQVdqDgQBAgIAAgtBAEEAKAKwCkECajYCsApBARApGkEAKALwCSIEIAM2AgQgBEEBOgAYIARBACgCsAoiAzYCEEEAIANBfmo2ArAKDwtBACgC8AkiBCADNgIEIARBAToAGEEAQQAvAZgKQX9qOwGYCiAEQQAoArAKQQJqNgIMQQBBAC8BlgpBf2o7AZYKDwtBAEEAKAKwCkF+ajYCsAoPCyAADQJBACgCsAohA0EALwGYCg0BA0ACQAJAAkAgA0EAKAK0Ck8NAEEBECkiA0EiRg0BIANBJ0YNASADQf0ARw0CQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0JC0EAIANBCGo2ArAKAkBBARApIgNBIkYNACADQSdHDQkLIAEgA0EAECsPCyADEBoLQQBBACgCsApBAmoiAzYCsAoMAAsLIAANAUEGIQBBACECAkAgA0FZag4EBAMDBAALIANBIkYNAwwCC0EAIANBfmo2ArAKDwtBDCEAQQEhAgtBACgCsAoiAyABIABBAXRqRw0AQQAgA0F+ajYCsAoPC0EALwGYCg0CQQAoArAKIQNBACgCtAohAANAIAMgAE8NAQJAAkAgAy8BACIEQSdGDQAgBEEiRw0BCyABIAQgAhArDwtBACADQQJqIgM2ArAKDAALCxAlCw8LQQBBACgCsApBfmo2ArAKC0cBA39BACgCsApBAmohAEEAKAK0CiEBAkADQCAAIgJBfmogAU8NASACQQJqIQAgAi8BAEF2ag4EAQAAAQALC0EAIAI2ArAKC5gBAQN/QQBBACgCsAoiAUECajYCsAogAUEGaiEBQQAoArQKIQIDQAJAAkACQCABQXxqIAJPDQAgAUF+ai8BACEDAkACQCAADQAgA0EqRg0BIANBdmoOBAIEBAIECyADQSpHDQMLIAEvAQBBL0cNAkEAIAFBfmo2ArAKDAELIAFBfmohAQtBACABNgKwCg8LIAFBAmohAQwACwuIAQEEf0EAKAKwCiEBQQAoArQKIQICQAJAA0AgASIDQQJqIQEgAyACTw0BIAEvAQAiBCAARg0CAkAgBEHcAEYNACAEQXZqDgQCAQECAQsgA0EEaiEBIAMvAQRBDUcNACADQQZqIAEgAy8BBkEKRhshAQwACwtBACABNgKwChAlDwtBACABNgKwCgtsAQF/AkACQCAAQV9qIgFBBUsNAEEBIAF0QTFxDQELIABBRmpB//8DcUEGSQ0AIABBKUcgAEFYakH//wNxQQdJcQ0AAkAgAEGlf2oOBAEAAAEACyAAQf0ARyAAQYV/akH//wNxQQRJcQ8LQQELLgEBf0EBIQECQCAAQaYJQQUQHQ0AIABBlghBAxAdDQAgAEGwCUECEB0hAQsgAQtGAQN/QQAhAwJAIAAgAkEBdCICayIEQQJqIgBBACgC3AkiBUkNACAAIAEgAhAvDQACQCAAIAVHDQBBAQ8LIAQQJiEDCyADC4MBAQJ/QQEhAQJAAkACQAJAAkACQCAALwEAIgJBRWoOBAUEBAEACwJAIAJBm39qDgQDBAQCAAsgAkEpRg0EIAJB+QBHDQMgAEF+akG8CUEGEB0PCyAAQX5qLwEAQT1GDwsgAEF+akG0CUEEEB0PCyAAQX5qQcgJQQMQHQ8LQQAhAQsgAQu0AwECf0EAIQECQAJAAkACQAJAAkACQAJAAkACQCAALwEAQZx/ag4UAAECCQkJCQMJCQQFCQkGCQcJCQgJCwJAAkAgAEF+ai8BAEGXf2oOBAAKCgEKCyAAQXxqQcoIQQIQHQ8LIABBfGpBzghBAxAdDwsCQAJAAkAgAEF+ai8BAEGNf2oOAwABAgoLAkAgAEF8ai8BACICQeEARg0AIAJB7ABHDQogAEF6akHlABAnDwsgAEF6akHjABAnDwsgAEF8akHUCEEEEB0PCyAAQXxqQdwIQQYQHQ8LIABBfmovAQBB7wBHDQYgAEF8ai8BAEHlAEcNBgJAIABBemovAQAiAkHwAEYNACACQeMARw0HIABBeGpB6AhBBhAdDwsgAEF4akH0CEECEB0PCyAAQX5qQfgIQQQQHQ8LQQEhASAAQX5qIgBB6QAQJw0EIABBgAlBBRAdDwsgAEF+akHkABAnDwsgAEF+akGKCUEHEB0PCyAAQX5qQZgJQQQQHQ8LAkAgAEF+ai8BACICQe8ARg0AIAJB5QBHDQEgAEF8akHuABAnDwsgAEF8akGgCUEDEB0hAQsgAQs0AQF/QQEhAQJAIABBd2pB//8DcUEFSQ0AIABBgAFyQaABRg0AIABBLkcgABAocSEBCyABCzABAX8CQAJAIABBd2oiAUEXSw0AQQEgAXRBjYCABHENAQsgAEGgAUYNAEEADwtBAQtOAQJ/QQAhAQJAAkAgAC8BACICQeUARg0AIAJB6wBHDQEgAEF+akH4CEEEEB0PCyAAQX5qLwEAQfUARw0AIABBfGpB3AhBBhAdIQELIAEL3gEBBH9BACgCsAohAEEAKAK0CiEBAkACQAJAA0AgACICQQJqIQAgAiABTw0BAkACQAJAIAAvAQAiA0Gkf2oOBQIDAwMBAAsgA0EkRw0CIAIvAQRB+wBHDQJBACACQQRqIgA2ArAKQQBBAC8BmAoiAkEBajsBmApBACgCpAogAkEDdGoiAkEENgIAIAIgADYCBA8LQQAgADYCsApBAEEALwGYCkF/aiIAOwGYCkEAKAKkCiAAQf//A3FBA3RqKAIAQQNHDQMMBAsgAkEEaiEADAALC0EAIAA2ArAKCxAlCwtwAQJ/AkACQANAQQBBACgCsAoiAEECaiIBNgKwCiAAQQAoArQKTw0BAkACQAJAIAEvAQAiAUGlf2oOAgECAAsCQCABQXZqDgQEAwMEAAsgAUEvRw0CDAQLEC4aDAELQQAgAEEEajYCsAoMAAsLECULCzUBAX9BAEEBOgD8CUEAKAKwCiEAQQBBACgCtApBAmo2ArAKQQAgAEEAKALcCWtBAXU2ApAKC0MBAn9BASEBAkAgAC8BACICQXdqQf//A3FBBUkNACACQYABckGgAUYNAEEAIQEgAhAoRQ0AIAJBLkcgABAqcg8LIAELPQECf0EAIQICQEEAKALcCSIDIABLDQAgAC8BACABRw0AAkAgAyAARw0AQQEPCyAAQX5qLwEAECAhAgsgAgtoAQJ/QQEhAQJAAkAgAEFfaiICQQVLDQBBASACdEExcQ0BCyAAQfj/A3FBKEYNACAAQUZqQf//A3FBBkkNAAJAIABBpX9qIgJBA0sNACACQQFHDQELIABBhX9qQf//A3FBBEkhAQsgAQucAQEDf0EAKAKwCiEBAkADQAJAAkAgAS8BACICQS9HDQACQCABLwECIgFBKkYNACABQS9HDQQQGAwCCyAAEBkMAQsCQAJAIABFDQAgAkF3aiIBQRdLDQFBASABdEGfgIAEcUUNAQwCCyACECFFDQMMAQsgAkGgAUcNAgtBAEEAKAKwCiIDQQJqIgE2ArAKIANBACgCtApJDQALCyACCzEBAX9BACEBAkAgAC8BAEEuRw0AIABBfmovAQBBLkcNACAAQXxqLwEAQS5GIQELIAELnAQBAX8CQCABQSJGDQAgAUEnRg0AECUPC0EAKAKwCiEDIAEQGiAAIANBAmpBACgCsApBACgC0AkQAQJAIAJFDQBBACgC8AlBBDYCHAtBAEEAKAKwCkECajYCsAoCQAJAAkACQEEAECkiAUHhAEYNACABQfcARg0BQQAoArAKIQEMAgtBACgCsAoiAUECakHACEEKEC8NAUEGIQAMAgtBACgCsAoiAS8BAkHpAEcNACABLwEEQfQARw0AQQQhACABLwEGQegARg0BC0EAIAFBfmo2ArAKDwtBACABIABBAXRqNgKwCgJAQQEQKUH7AEYNAEEAIAE2ArAKDwtBACgCsAoiAiEAA0BBACAAQQJqNgKwCgJAAkACQEEBECkiAEEiRg0AIABBJ0cNAUEnEBpBAEEAKAKwCkECajYCsApBARApIQAMAgtBIhAaQQBBACgCsApBAmo2ArAKQQEQKSEADAELIAAQLCEACwJAIABBOkYNAEEAIAE2ArAKDwtBAEEAKAKwCkECajYCsAoCQEEBECkiAEEiRg0AIABBJ0YNAEEAIAE2ArAKDwsgABAaQQBBACgCsApBAmo2ArAKAkACQEEBECkiAEEsRg0AIABB/QBGDQFBACABNgKwCg8LQQBBACgCsApBAmo2ArAKQQEQKUH9AEYNAEEAKAKwCiEADAELC0EAKALwCSIBIAI2AhAgAUEAKAKwCkECajYCDAttAQJ/AkACQANAAkAgAEH//wNxIgFBd2oiAkEXSw0AQQEgAnRBn4CABHENAgsgAUGgAUYNASAAIQIgARAoDQJBACECQQBBACgCsAoiAEECajYCsAogAC8BAiIADQAMAgsLIAAhAgsgAkH//wNxC6sBAQR/AkACQEEAKAKwCiICLwEAIgNB4QBGDQAgASEEIAAhBQwBC0EAIAJBBGo2ArAKQQEQKSECQQAoArAKIQUCQAJAIAJBIkYNACACQSdGDQAgAhAsGkEAKAKwCiEEDAELIAIQGkEAQQAoArAKQQJqIgQ2ArAKC0EBECkhA0EAKAKwCiECCwJAIAIgBUYNACAFIARBACAAIAAgAUYiAhtBACABIAIbEAILIAMLcgEEf0EAKAKwCiEAQQAoArQKIQECQAJAA0AgAEECaiECIAAgAU8NAQJAAkAgAi8BACIDQaR/ag4CAQQACyACIQAgA0F2ag4EAgEBAgELIABBBGohAAwACwtBACACNgKwChAlQQAPC0EAIAI2ArAKQd0AC0kBA39BACEDAkAgAkUNAAJAA0AgAC0AACIEIAEtAAAiBUcNASABQQFqIQEgAEEBaiEAIAJBf2oiAg0ADAILCyAEIAVrIQMLIAMLC+wBAgBBgAgLzgEAAHgAcABvAHIAdABtAHAAbwByAHQAZgBvAHIAZQB0AGEAbwB1AHIAYwBlAHIAbwBtAHUAbgBjAHQAaQBvAG4AcwBzAGUAcgB0AHYAbwB5AGkAZQBkAGUAbABlAGMAbwBuAHQAaQBuAGkAbgBzAHQAYQBuAHQAeQBiAHIAZQBhAHIAZQB0AHUAcgBkAGUAYgB1AGcAZwBlAGEAdwBhAGkAdABoAHIAdwBoAGkAbABlAGkAZgBjAGEAdABjAGYAaQBuAGEAbABsAGUAbABzAABB0AkLEAEAAAACAAAAAAQAAEA5AAA=", "undefined" != typeof Buffer ? Buffer.from(A3, "base64") : Uint8Array.from(atob(A3), (A4) => A4.charCodeAt(0));
  var A3;
};
var init = WebAssembly.compile(E()).then(WebAssembly.instantiate).then(({ exports: A3 }) => {
  C2 = A3;
});

// node_modules/.pnpm/resolve-pkg-maps@1.0.0/node_modules/resolve-pkg-maps/dist/index.mjs
var A2 = (r) => r !== null && typeof r == "object";
var a = (r, t) => Object.assign(new Error(`[${r}]: ${t}`), { code: r });
var _ = "ERR_INVALID_PACKAGE_CONFIG";
var E2 = "ERR_INVALID_PACKAGE_TARGET";
var I = "ERR_PACKAGE_PATH_NOT_EXPORTED";
var R = /^\d+$/;
var O2 = /^(\.{1,2}|node_modules)$/i;
var w = /\/|\\/;
var h = ((r) => (r.Export = "exports", r.Import = "imports", r))(h || {});
var f = (r, t, e, o2, c) => {
  if (t == null) return [];
  if (typeof t == "string") {
    const [n2, ...i] = t.split(w);
    if (n2 === ".." || i.some((l) => O2.test(l))) throw a(E2, `Invalid "${r}" target "${t}" defined in the package config`);
    return [c ? t.replace(/\*/g, c) : t];
  }
  if (Array.isArray(t)) return t.flatMap((n2) => f(r, n2, e, o2, c));
  if (A2(t)) {
    for (const n2 of Object.keys(t)) {
      if (R.test(n2)) throw a(_, "Cannot contain numeric property keys");
      if (n2 === "default" || o2.includes(n2)) return f(r, t[n2], e, o2, c);
    }
    return [];
  }
  throw a(E2, `Invalid "${r}" target "${t}"`);
};
var s = "*";
var m = (r, t) => {
  const e = r.indexOf(s), o2 = t.indexOf(s);
  return e === o2 ? t.length > r.length : o2 > e;
};
function d(r, t) {
  if (!t.includes(s) && r.hasOwnProperty(t)) return [t];
  let e, o2;
  for (const c of Object.keys(r)) if (c.includes(s)) {
    const [n2, i, l] = c.split(s);
    if (l === void 0 && t.startsWith(n2) && t.endsWith(i)) {
      const g = t.slice(n2.length, -i.length || void 0);
      g && (!e || m(e, c)) && (e = c, o2 = g);
    }
  }
  return [e, o2];
}
var p = (r) => Object.keys(r).reduce((t, e) => {
  const o2 = e === "" || e[0] !== ".";
  if (t === void 0 || t === o2) return o2;
  throw a(_, '"exports" cannot contain some keys starting with "." and some not');
}, void 0);
var u = /^\w+:/;
var v = (r, t, e) => {
  if (!r) throw new Error('"exports" is required');
  t = t === "" ? "." : `./${t}`, (typeof r == "string" || Array.isArray(r) || A2(r) && p(r)) && (r = { ".": r });
  const [o2, c] = d(r, t), n2 = f(h.Export, r[o2], t, e, c);
  if (n2.length === 0) throw a(I, t === "." ? 'No "exports" main defined' : `Package subpath '${t}' is not defined by "exports"`);
  for (const i of n2) if (!i.startsWith("./") && !u.test(i)) throw a(E2, `Invalid "exports" target "${i}" defined in the package config`);
  return n2;
};
var de = Object.defineProperty;
var o = (e, t) => de(e, "name", { value: t, configurable: true });
function E3(e) {
  return e.startsWith("\\\\?\\") ? e : e.replace(/\\/g, "/");
}
o(E3, "slash");
var O3 = o((e) => {
  const t = fs__default.default[e];
  return (s2, ...n2) => {
    const l = `${e}:${n2.join(":")}`;
    let i = s2 == null ? void 0 : s2.get(l);
    return i === void 0 && (i = Reflect.apply(t, fs__default.default, n2), s2 == null || s2.set(l, i)), i;
  };
}, "cacheFs");
var B2 = O3("existsSync");
var _e = O3("readFileSync");
var W = O3("statSync");
var le = o((e, t, s2) => {
  for (; ; ) {
    const n2 = p2__default.default.posix.join(e, t);
    if (B2(s2, n2)) return n2;
    const l = p2__default.default.dirname(e);
    if (l === e) return;
    e = l;
  }
}, "findUp");
var G = /^\.{1,2}(\/.*)?$/;
var Q2 = o((e) => {
  const t = E3(e);
  return G.test(t) ? t : `./${t}`;
}, "normalizeRelativePath");
function je(e, t = false) {
  const s2 = e.length;
  let n2 = 0, l = "", i = 0, u2 = 16, f2 = 0, r = 0, g = 0, T = 0, b = 0;
  function _2(c, k) {
    let m2 = 0, F = 0;
    for (; m2 < c; ) {
      let j = e.charCodeAt(n2);
      if (j >= 48 && j <= 57) F = F * 16 + j - 48;
      else if (j >= 65 && j <= 70) F = F * 16 + j - 65 + 10;
      else if (j >= 97 && j <= 102) F = F * 16 + j - 97 + 10;
      else break;
      n2++, m2++;
    }
    return m2 < c && (F = -1), F;
  }
  o(_2, "scanHexDigits");
  function d2(c) {
    n2 = c, l = "", i = 0, u2 = 16, b = 0;
  }
  o(d2, "setPosition");
  function A3() {
    let c = n2;
    if (e.charCodeAt(n2) === 48) n2++;
    else for (n2++; n2 < e.length && h2(e.charCodeAt(n2)); ) n2++;
    if (n2 < e.length && e.charCodeAt(n2) === 46) if (n2++, n2 < e.length && h2(e.charCodeAt(n2))) for (n2++; n2 < e.length && h2(e.charCodeAt(n2)); ) n2++;
    else return b = 3, e.substring(c, n2);
    let k = n2;
    if (n2 < e.length && (e.charCodeAt(n2) === 69 || e.charCodeAt(n2) === 101)) if (n2++, (n2 < e.length && e.charCodeAt(n2) === 43 || e.charCodeAt(n2) === 45) && n2++, n2 < e.length && h2(e.charCodeAt(n2))) {
      for (n2++; n2 < e.length && h2(e.charCodeAt(n2)); ) n2++;
      k = n2;
    } else b = 3;
    return e.substring(c, k);
  }
  o(A3, "scanNumber");
  function w2() {
    let c = "", k = n2;
    for (; ; ) {
      if (n2 >= s2) {
        c += e.substring(k, n2), b = 2;
        break;
      }
      const m2 = e.charCodeAt(n2);
      if (m2 === 34) {
        c += e.substring(k, n2), n2++;
        break;
      }
      if (m2 === 92) {
        if (c += e.substring(k, n2), n2++, n2 >= s2) {
          b = 2;
          break;
        }
        switch (e.charCodeAt(n2++)) {
          case 34:
            c += '"';
            break;
          case 92:
            c += "\\";
            break;
          case 47:
            c += "/";
            break;
          case 98:
            c += "\b";
            break;
          case 102:
            c += "\f";
            break;
          case 110:
            c += `
`;
            break;
          case 114:
            c += "\r";
            break;
          case 116:
            c += "	";
            break;
          case 117:
            const j = _2(4);
            j >= 0 ? c += String.fromCharCode(j) : b = 4;
            break;
          default:
            b = 5;
        }
        k = n2;
        continue;
      }
      if (m2 >= 0 && m2 <= 31) if (N(m2)) {
        c += e.substring(k, n2), b = 2;
        break;
      } else b = 6;
      n2++;
    }
    return c;
  }
  o(w2, "scanString");
  function y() {
    if (l = "", b = 0, i = n2, r = f2, T = g, n2 >= s2) return i = s2, u2 = 17;
    let c = e.charCodeAt(n2);
    if (H(c)) {
      do
        n2++, l += String.fromCharCode(c), c = e.charCodeAt(n2);
      while (H(c));
      return u2 = 15;
    }
    if (N(c)) return n2++, l += String.fromCharCode(c), c === 13 && e.charCodeAt(n2) === 10 && (n2++, l += `
`), f2++, g = n2, u2 = 14;
    switch (c) {
      case 123:
        return n2++, u2 = 1;
      case 125:
        return n2++, u2 = 2;
      case 91:
        return n2++, u2 = 3;
      case 93:
        return n2++, u2 = 4;
      case 58:
        return n2++, u2 = 6;
      case 44:
        return n2++, u2 = 5;
      case 34:
        return n2++, l = w2(), u2 = 10;
      case 47:
        const k = n2 - 1;
        if (e.charCodeAt(n2 + 1) === 47) {
          for (n2 += 2; n2 < s2 && !N(e.charCodeAt(n2)); ) n2++;
          return l = e.substring(k, n2), u2 = 12;
        }
        if (e.charCodeAt(n2 + 1) === 42) {
          n2 += 2;
          const m2 = s2 - 1;
          let F = false;
          for (; n2 < m2; ) {
            const j = e.charCodeAt(n2);
            if (j === 42 && e.charCodeAt(n2 + 1) === 47) {
              n2 += 2, F = true;
              break;
            }
            n2++, N(j) && (j === 13 && e.charCodeAt(n2) === 10 && n2++, f2++, g = n2);
          }
          return F || (n2++, b = 1), l = e.substring(k, n2), u2 = 13;
        }
        return l += String.fromCharCode(c), n2++, u2 = 16;
      case 45:
        if (l += String.fromCharCode(c), n2++, n2 === s2 || !h2(e.charCodeAt(n2))) return u2 = 16;
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return l += A3(), u2 = 11;
      default:
        for (; n2 < s2 && I2(c); ) n2++, c = e.charCodeAt(n2);
        if (i !== n2) {
          switch (l = e.substring(i, n2), l) {
            case "true":
              return u2 = 8;
            case "false":
              return u2 = 9;
            case "null":
              return u2 = 7;
          }
          return u2 = 16;
        }
        return l += String.fromCharCode(c), n2++, u2 = 16;
    }
  }
  o(y, "scanNext");
  function I2(c) {
    if (H(c) || N(c)) return false;
    switch (c) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  o(I2, "isUnknownContentCharacter");
  function L() {
    let c;
    do
      c = y();
    while (c >= 12 && c <= 15);
    return c;
  }
  return o(L, "scanNextNonTrivia"), { setPosition: d2, getPosition: o(() => n2, "getPosition"), scan: t ? L : y, getToken: o(() => u2, "getToken"), getTokenValue: o(() => l, "getTokenValue"), getTokenOffset: o(() => i, "getTokenOffset"), getTokenLength: o(() => n2 - i, "getTokenLength"), getTokenStartLine: o(() => r, "getTokenStartLine"), getTokenStartCharacter: o(() => i - T, "getTokenStartCharacter"), getTokenError: o(() => b, "getTokenError") };
}
o(je, "createScanner");
function H(e) {
  return e === 32 || e === 9;
}
o(H, "isWhiteSpace");
function N(e) {
  return e === 10 || e === 13;
}
o(N, "isLineBreak");
function h2(e) {
  return e >= 48 && e <= 57;
}
o(h2, "isDigit");
var ie;
((function(e) {
  e[e.lineFeed = 10] = "lineFeed", e[e.carriageReturn = 13] = "carriageReturn", e[e.space = 32] = "space", e[e._0 = 48] = "_0", e[e._1 = 49] = "_1", e[e._2 = 50] = "_2", e[e._3 = 51] = "_3", e[e._4 = 52] = "_4", e[e._5 = 53] = "_5", e[e._6 = 54] = "_6", e[e._7 = 55] = "_7", e[e._8 = 56] = "_8", e[e._9 = 57] = "_9", e[e.a = 97] = "a", e[e.b = 98] = "b", e[e.c = 99] = "c", e[e.d = 100] = "d", e[e.e = 101] = "e", e[e.f = 102] = "f", e[e.g = 103] = "g", e[e.h = 104] = "h", e[e.i = 105] = "i", e[e.j = 106] = "j", e[e.k = 107] = "k", e[e.l = 108] = "l", e[e.m = 109] = "m", e[e.n = 110] = "n", e[e.o = 111] = "o", e[e.p = 112] = "p", e[e.q = 113] = "q", e[e.r = 114] = "r", e[e.s = 115] = "s", e[e.t = 116] = "t", e[e.u = 117] = "u", e[e.v = 118] = "v", e[e.w = 119] = "w", e[e.x = 120] = "x", e[e.y = 121] = "y", e[e.z = 122] = "z", e[e.A = 65] = "A", e[e.B = 66] = "B", e[e.C = 67] = "C", e[e.D = 68] = "D", e[e.E = 69] = "E", e[e.F = 70] = "F", e[e.G = 71] = "G", e[e.H = 72] = "H", e[e.I = 73] = "I", e[e.J = 74] = "J", e[e.K = 75] = "K", e[e.L = 76] = "L", e[e.M = 77] = "M", e[e.N = 78] = "N", e[e.O = 79] = "O", e[e.P = 80] = "P", e[e.Q = 81] = "Q", e[e.R = 82] = "R", e[e.S = 83] = "S", e[e.T = 84] = "T", e[e.U = 85] = "U", e[e.V = 86] = "V", e[e.W = 87] = "W", e[e.X = 88] = "X", e[e.Y = 89] = "Y", e[e.Z = 90] = "Z", e[e.asterisk = 42] = "asterisk", e[e.backslash = 92] = "backslash", e[e.closeBrace = 125] = "closeBrace", e[e.closeBracket = 93] = "closeBracket", e[e.colon = 58] = "colon", e[e.comma = 44] = "comma", e[e.dot = 46] = "dot", e[e.doubleQuote = 34] = "doubleQuote", e[e.minus = 45] = "minus", e[e.openBrace = 123] = "openBrace", e[e.openBracket = 91] = "openBracket", e[e.plus = 43] = "plus", e[e.slash = 47] = "slash", e[e.formFeed = 12] = "formFeed", e[e.tab = 9] = "tab";
}))(ie || (ie = {})), new Array(20).fill(0).map((e, t) => " ".repeat(t));
var x = 200;
new Array(x).fill(0).map((e, t) => `
` + " ".repeat(t)), new Array(x).fill(0).map((e, t) => "\r" + " ".repeat(t)), new Array(x).fill(0).map((e, t) => `\r
` + " ".repeat(t)), new Array(x).fill(0).map((e, t) => `
` + "	".repeat(t)), new Array(x).fill(0).map((e, t) => "\r" + "	".repeat(t)), new Array(x).fill(0).map((e, t) => `\r
` + "	".repeat(t));
var M;
(function(e) {
  e.DEFAULT = { allowTrailingComma: false };
})(M || (M = {}));
function ye(e, t = [], s2 = M.DEFAULT) {
  let n2 = null, l = [];
  const i = [];
  function u2(r) {
    Array.isArray(l) ? l.push(r) : n2 !== null && (l[n2] = r);
  }
  return o(u2, "onValue"), Fe(e, { onObjectBegin: o(() => {
    const r = {};
    u2(r), i.push(l), l = r, n2 = null;
  }, "onObjectBegin"), onObjectProperty: o((r) => {
    n2 = r;
  }, "onObjectProperty"), onObjectEnd: o(() => {
    l = i.pop();
  }, "onObjectEnd"), onArrayBegin: o(() => {
    const r = [];
    u2(r), i.push(l), l = r, n2 = null;
  }, "onArrayBegin"), onArrayEnd: o(() => {
    l = i.pop();
  }, "onArrayEnd"), onLiteralValue: u2, onError: o((r, g, T) => {
    t.push({ error: r, offset: g, length: T });
  }, "onError") }, s2), l[0];
}
o(ye, "parse$1");
function Fe(e, t, s2 = M.DEFAULT) {
  const n2 = je(e, false), l = [];
  function i(v2) {
    return v2 ? () => v2(n2.getTokenOffset(), n2.getTokenLength(), n2.getTokenStartLine(), n2.getTokenStartCharacter()) : () => true;
  }
  o(i, "toNoArgVisit");
  function u2(v2) {
    return v2 ? () => v2(n2.getTokenOffset(), n2.getTokenLength(), n2.getTokenStartLine(), n2.getTokenStartCharacter(), () => l.slice()) : () => true;
  }
  o(u2, "toNoArgVisitWithPath");
  function f2(v2) {
    return v2 ? (D) => v2(D, n2.getTokenOffset(), n2.getTokenLength(), n2.getTokenStartLine(), n2.getTokenStartCharacter()) : () => true;
  }
  o(f2, "toOneArgVisit");
  function r(v2) {
    return v2 ? (D) => v2(D, n2.getTokenOffset(), n2.getTokenLength(), n2.getTokenStartLine(), n2.getTokenStartCharacter(), () => l.slice()) : () => true;
  }
  o(r, "toOneArgVisitWithPath");
  const g = u2(t.onObjectBegin), T = r(t.onObjectProperty), b = i(t.onObjectEnd), _2 = u2(t.onArrayBegin), d2 = i(t.onArrayEnd), A3 = r(t.onLiteralValue), w2 = f2(t.onSeparator), y = i(t.onComment), I2 = f2(t.onError), L = s2 && s2.disallowComments, c = s2 && s2.allowTrailingComma;
  function k() {
    for (; ; ) {
      const v2 = n2.scan();
      switch (n2.getTokenError()) {
        case 4:
          m2(14);
          break;
        case 5:
          m2(15);
          break;
        case 3:
          m2(13);
          break;
        case 1:
          L || m2(11);
          break;
        case 2:
          m2(12);
          break;
        case 6:
          m2(16);
          break;
      }
      switch (v2) {
        case 12:
        case 13:
          L ? m2(10) : y();
          break;
        case 16:
          m2(1);
          break;
        case 15:
        case 14:
          break;
        default:
          return v2;
      }
    }
  }
  o(k, "scanNext");
  function m2(v2, D = [], te = []) {
    if (I2(v2), D.length + te.length > 0) {
      let P = n2.getToken();
      for (; P !== 17; ) {
        if (D.indexOf(P) !== -1) {
          k();
          break;
        } else if (te.indexOf(P) !== -1) break;
        P = k();
      }
    }
  }
  o(m2, "handleError");
  function F(v2) {
    const D = n2.getTokenValue();
    return v2 ? A3(D) : (T(D), l.push(D)), k(), true;
  }
  o(F, "parseString");
  function j() {
    switch (n2.getToken()) {
      case 11:
        const v2 = n2.getTokenValue();
        let D = Number(v2);
        isNaN(D) && (m2(2), D = 0), A3(D);
        break;
      case 7:
        A3(null);
        break;
      case 8:
        A3(true);
        break;
      case 9:
        A3(false);
        break;
      default:
        return false;
    }
    return k(), true;
  }
  o(j, "parseLiteral");
  function S() {
    return n2.getToken() !== 10 ? (m2(3, [], [2, 5]), false) : (F(false), n2.getToken() === 6 ? (w2(":"), k(), U() || m2(4, [], [2, 5])) : m2(5, [], [2, 5]), l.pop(), true);
  }
  o(S, "parseProperty");
  function R2() {
    g(), k();
    let v2 = false;
    for (; n2.getToken() !== 2 && n2.getToken() !== 17; ) {
      if (n2.getToken() === 5) {
        if (v2 || m2(4, [], []), w2(","), k(), n2.getToken() === 2 && c) break;
      } else v2 && m2(6, [], []);
      S() || m2(4, [], [2, 5]), v2 = true;
    }
    return b(), n2.getToken() !== 2 ? m2(7, [2], []) : k(), true;
  }
  o(R2, "parseObject");
  function a2() {
    _2(), k();
    let v2 = true, D = false;
    for (; n2.getToken() !== 4 && n2.getToken() !== 17; ) {
      if (n2.getToken() === 5) {
        if (D || m2(4, [], []), w2(","), k(), n2.getToken() === 4 && c) break;
      } else D && m2(6, [], []);
      v2 ? (l.push(0), v2 = false) : l[l.length - 1]++, U() || m2(4, [], [4, 5]), D = true;
    }
    return d2(), v2 || l.pop(), n2.getToken() !== 4 ? m2(8, [4], []) : k(), true;
  }
  o(a2, "parseArray");
  function U() {
    switch (n2.getToken()) {
      case 3:
        return a2();
      case 1:
        return R2();
      case 10:
        return F(true);
      default:
        return j();
    }
  }
  return o(U, "parseValue"), k(), n2.getToken() === 17 ? s2.allowEmptyContent ? true : (m2(4, [], []), false) : U() ? (n2.getToken() !== 17 && m2(9, [], []), true) : (m2(4, [], []), false);
}
o(Fe, "visit");
var oe;
(function(e) {
  e[e.None = 0] = "None", e[e.UnexpectedEndOfComment = 1] = "UnexpectedEndOfComment", e[e.UnexpectedEndOfString = 2] = "UnexpectedEndOfString", e[e.UnexpectedEndOfNumber = 3] = "UnexpectedEndOfNumber", e[e.InvalidUnicode = 4] = "InvalidUnicode", e[e.InvalidEscapeCharacter = 5] = "InvalidEscapeCharacter", e[e.InvalidCharacter = 6] = "InvalidCharacter";
})(oe || (oe = {}));
var ue;
(function(e) {
  e[e.OpenBraceToken = 1] = "OpenBraceToken", e[e.CloseBraceToken = 2] = "CloseBraceToken", e[e.OpenBracketToken = 3] = "OpenBracketToken", e[e.CloseBracketToken = 4] = "CloseBracketToken", e[e.CommaToken = 5] = "CommaToken", e[e.ColonToken = 6] = "ColonToken", e[e.NullKeyword = 7] = "NullKeyword", e[e.TrueKeyword = 8] = "TrueKeyword", e[e.FalseKeyword = 9] = "FalseKeyword", e[e.StringLiteral = 10] = "StringLiteral", e[e.NumericLiteral = 11] = "NumericLiteral", e[e.LineCommentTrivia = 12] = "LineCommentTrivia", e[e.BlockCommentTrivia = 13] = "BlockCommentTrivia", e[e.LineBreakTrivia = 14] = "LineBreakTrivia", e[e.Trivia = 15] = "Trivia", e[e.Unknown = 16] = "Unknown", e[e.EOF = 17] = "EOF";
})(ue || (ue = {}));
var De = ye;
var re;
(function(e) {
  e[e.InvalidSymbol = 1] = "InvalidSymbol", e[e.InvalidNumberFormat = 2] = "InvalidNumberFormat", e[e.PropertyNameExpected = 3] = "PropertyNameExpected", e[e.ValueExpected = 4] = "ValueExpected", e[e.ColonExpected = 5] = "ColonExpected", e[e.CommaExpected = 6] = "CommaExpected", e[e.CloseBraceExpected = 7] = "CloseBraceExpected", e[e.CloseBracketExpected = 8] = "CloseBracketExpected", e[e.EndOfFileExpected = 9] = "EndOfFileExpected", e[e.InvalidCommentToken = 10] = "InvalidCommentToken", e[e.UnexpectedEndOfComment = 11] = "UnexpectedEndOfComment", e[e.UnexpectedEndOfString = 12] = "UnexpectedEndOfString", e[e.UnexpectedEndOfNumber = 13] = "UnexpectedEndOfNumber", e[e.InvalidUnicode = 14] = "InvalidUnicode", e[e.InvalidEscapeCharacter = 15] = "InvalidEscapeCharacter", e[e.InvalidCharacter = 16] = "InvalidCharacter";
})(re || (re = {}));
var fe = o((e, t) => De(_e(t, e, "utf8")), "readJsonc");
var X = Symbol("implicitBaseUrl");
var $ = "${configDir}";
var Ee = o(() => {
  const { findPnpApi: e } = ve__default.default;
  return e && e(process.cwd());
}, "getPnpApi");
var Y = o((e, t, s2, n2) => {
  const l = `resolveFromPackageJsonPath:${e}:${t}:${s2}`;
  if (n2 != null && n2.has(l)) return n2.get(l);
  const i = fe(e, n2);
  if (!i) return;
  let u2 = t || "tsconfig.json";
  if (!s2 && i.exports) try {
    const [f2] = v(i.exports, t, ["require", "types"]);
    u2 = f2;
  } catch {
    return false;
  }
  else !t && i.tsconfig && (u2 = i.tsconfig);
  return u2 = p2__default.default.join(e, "..", u2), n2 == null || n2.set(l, u2), u2;
}, "resolveFromPackageJsonPath");
var Z = "package.json";
var q = "tsconfig.json";
var Be = o((e, t, s2) => {
  let n2 = e;
  if (e === ".." && (n2 = p2__default.default.join(n2, q)), e[0] === "." && (n2 = p2__default.default.resolve(t, n2)), p2__default.default.isAbsolute(n2)) {
    if (B2(s2, n2)) {
      if (W(s2, n2).isFile()) return n2;
    } else if (!n2.endsWith(".json")) {
      const d2 = `${n2}.json`;
      if (B2(s2, d2)) return d2;
    }
    return;
  }
  const [l, ...i] = e.split("/"), u2 = l[0] === "@" ? `${l}/${i.shift()}` : l, f2 = i.join("/"), r = Ee();
  if (r) {
    const { resolveRequest: d2 } = r;
    try {
      if (u2 === e) {
        const A3 = d2(p2__default.default.join(u2, Z), t);
        if (A3) {
          const w2 = Y(A3, f2, false, s2);
          if (w2 && B2(s2, w2)) return w2;
        }
      } else {
        let A3;
        try {
          A3 = d2(e, t, { extensions: [".json"] });
        } catch {
          A3 = d2(p2__default.default.join(e, q), t);
        }
        if (A3) return A3;
      }
    } catch {
    }
  }
  const g = le(p2__default.default.resolve(t), p2__default.default.join("node_modules", u2), s2);
  if (!g || !W(s2, g).isDirectory()) return;
  const T = p2__default.default.join(g, Z);
  if (B2(s2, T)) {
    const d2 = Y(T, f2, false, s2);
    if (d2 === false) return;
    if (d2 && B2(s2, d2) && W(s2, d2).isFile()) return d2;
  }
  const b = p2__default.default.join(g, f2), _2 = b.endsWith(".json");
  if (!_2) {
    const d2 = `${b}.json`;
    if (B2(s2, d2)) return d2;
  }
  if (B2(s2, b)) {
    if (W(s2, b).isDirectory()) {
      const d2 = p2__default.default.join(b, Z);
      if (B2(s2, d2)) {
        const w2 = Y(d2, "", true, s2);
        if (w2 && B2(s2, w2)) return w2;
      }
      const A3 = p2__default.default.join(b, q);
      if (B2(s2, A3)) return A3;
    } else if (_2) return b;
  }
}, "resolveExtendsPath");
var K = o((e, t) => Q2(p2__default.default.relative(e, t)), "pathRelative");
var ce = ["files", "include", "exclude"];
var Ie = o((e, t, s2, n2) => {
  const l = Be(e, t, n2);
  if (!l) throw new Error(`File '${e}' not found.`);
  if (s2.has(l)) throw new Error(`Circularity detected while resolving configuration: ${l}`);
  s2.add(l);
  const i = p2__default.default.dirname(l), u2 = ae(l, n2, s2);
  delete u2.references;
  const { compilerOptions: f2 } = u2;
  if (f2) {
    const { baseUrl: r } = f2;
    r && !r.startsWith($) && (f2.baseUrl = E3(p2__default.default.relative(t, p2__default.default.join(i, r))) || "./");
    let { outDir: g } = f2;
    g && (g.startsWith($) || (g = p2__default.default.relative(t, p2__default.default.join(i, g))), f2.outDir = E3(g) || "./");
  }
  for (const r of ce) {
    const g = u2[r];
    g && (u2[r] = g.map((T) => T.startsWith($) ? T : E3(p2__default.default.relative(t, p2__default.default.join(i, T)))));
  }
  return u2;
}, "resolveExtends");
var Le = ["outDir", "declarationDir"];
var ae = o((e, t, s2 = /* @__PURE__ */ new Set()) => {
  let n2;
  try {
    n2 = fe(e, t) || {};
  } catch {
    throw new Error(`Cannot resolve tsconfig at path: ${e}`);
  }
  if (typeof n2 != "object") throw new SyntaxError(`Failed to parse tsconfig at: ${e}`);
  const l = p2__default.default.dirname(e);
  if (n2.compilerOptions) {
    const { compilerOptions: i } = n2;
    i.paths && !i.baseUrl && (i[X] = l);
  }
  if (n2.extends) {
    const i = Array.isArray(n2.extends) ? n2.extends : [n2.extends];
    delete n2.extends;
    for (const u2 of i.reverse()) {
      const f2 = Ie(u2, l, new Set(s2), t), r = { ...f2, ...n2, compilerOptions: { ...f2.compilerOptions, ...n2.compilerOptions } };
      f2.watchOptions && (r.watchOptions = { ...f2.watchOptions, ...n2.watchOptions }), n2 = r;
    }
  }
  if (n2.compilerOptions) {
    const { compilerOptions: i } = n2, u2 = ["baseUrl", "rootDir"];
    for (const f2 of u2) {
      const r = i[f2];
      if (r && !r.startsWith($)) {
        const g = p2__default.default.resolve(l, r), T = K(l, g);
        i[f2] = T;
      }
    }
    for (const f2 of Le) {
      let r = i[f2];
      r && (Array.isArray(n2.exclude) || (n2.exclude = []), n2.exclude.includes(r) || n2.exclude.push(r), r.startsWith($) || (r = Q2(r)), i[f2] = r);
    }
  } else n2.compilerOptions = {};
  if (n2.include ? (n2.include = n2.include.map(E3), n2.files && delete n2.files) : n2.files && (n2.files = n2.files.map((i) => i.startsWith($) ? i : Q2(i))), n2.watchOptions) {
    const { watchOptions: i } = n2;
    i.excludeDirectories && (i.excludeDirectories = i.excludeDirectories.map((u2) => E3(p2__default.default.resolve(l, u2))));
  }
  return n2;
}, "_parseTsconfig");
var V = o((e, t) => {
  if (e.startsWith($)) return E3(p2__default.default.join(t, e.slice($.length)));
}, "interpolateConfigDir");
var $e = ["outDir", "declarationDir", "outFile", "rootDir", "baseUrl", "tsBuildInfoFile"];
var Ue = o((e) => {
  if (e.strict) {
    const a2 = ["noImplicitAny", "noImplicitThis", "strictNullChecks", "strictFunctionTypes", "strictBindCallApply", "strictPropertyInitialization", "strictBuiltinIteratorReturn", "alwaysStrict", "useUnknownInCatchVariables"];
    for (const U of a2) e[U] === void 0 && (e[U] = true);
  }
  if (e.target) {
    let a2 = e.target.toLowerCase();
    a2 === "es2015" && (a2 = "es6"), e.target = a2, a2 === "esnext" && ((e.module) != null || (e.module = "es6"), (e.moduleResolution) != null || (e.moduleResolution = "classic"), (e.useDefineForClassFields) != null || (e.useDefineForClassFields = true)), (a2 === "es6" || a2 === "es2016" || a2 === "es2017" || a2 === "es2018" || a2 === "es2019" || a2 === "es2020" || a2 === "es2021" || a2 === "es2022" || a2 === "es2023" || a2 === "es2024") && ((e.module) != null || (e.module = "es6"), (e.moduleResolution) != null || (e.moduleResolution = "classic")), (a2 === "es2022" || a2 === "es2023" || a2 === "es2024") && ((e.useDefineForClassFields) != null || (e.useDefineForClassFields = true));
  }
  if (e.module) {
    let a2 = e.module.toLowerCase();
    a2 === "es2015" && (a2 = "es6"), e.module = a2, (a2 === "es6" || a2 === "es2020" || a2 === "es2022" || a2 === "esnext" || a2 === "none" || a2 === "system" || a2 === "umd" || a2 === "amd") && ((e.moduleResolution) != null || (e.moduleResolution = "classic")), a2 === "system" && ((e.allowSyntheticDefaultImports) != null || (e.allowSyntheticDefaultImports = true)), (a2 === "node16" || a2 === "nodenext" || a2 === "preserve") && ((e.esModuleInterop) != null || (e.esModuleInterop = true), (e.allowSyntheticDefaultImports) != null || (e.allowSyntheticDefaultImports = true)), (a2 === "node16" || a2 === "nodenext") && ((e.moduleDetection) != null || (e.moduleDetection = "force"), (e.useDefineForClassFields) != null || (e.useDefineForClassFields = true)), a2 === "node16" && ((e.target) != null || (e.target = "es2022"), (e.moduleResolution) != null || (e.moduleResolution = "node16")), a2 === "nodenext" && ((e.target) != null || (e.target = "esnext"), (e.moduleResolution) != null || (e.moduleResolution = "nodenext")), a2 === "preserve" && ((e.moduleResolution) != null || (e.moduleResolution = "bundler"));
  }
  if (e.moduleResolution) {
    let a2 = e.moduleResolution.toLowerCase();
    a2 === "node" && (a2 = "node10"), e.moduleResolution = a2, (a2 === "node16" || a2 === "nodenext" || a2 === "bundler") && ((e.resolvePackageJsonExports) != null || (e.resolvePackageJsonExports = true), (e.resolvePackageJsonImports) != null || (e.resolvePackageJsonImports = true)), a2 === "bundler" && ((e.allowSyntheticDefaultImports) != null || (e.allowSyntheticDefaultImports = true), (e.resolveJsonModule) != null || (e.resolveJsonModule = true));
  }
  e.esModuleInterop && ((e.allowSyntheticDefaultImports) != null || (e.allowSyntheticDefaultImports = true)), e.verbatimModuleSyntax && ((e.isolatedModules) != null || (e.isolatedModules = true), (e.preserveConstEnums) != null || (e.preserveConstEnums = true)), e.isolatedModules && ((e.preserveConstEnums) != null || (e.preserveConstEnums = true));
}, "normalizeCompilerOptions");
var ge = o((e, t = /* @__PURE__ */ new Map()) => {
  const s2 = p2__default.default.resolve(e), n2 = ae(s2, t), l = p2__default.default.dirname(s2), { compilerOptions: i } = n2;
  if (i) {
    for (const f2 of $e) {
      const r = i[f2];
      if (r) {
        const g = V(r, l);
        i[f2] = g ? K(l, g) : r;
      }
    }
    for (const f2 of ["rootDirs", "typeRoots"]) {
      const r = i[f2];
      r && (i[f2] = r.map((g) => {
        const T = V(g, l);
        return T ? K(l, T) : g;
      }));
    }
    const { paths: u2 } = i;
    if (u2) for (const f2 of Object.keys(u2)) u2[f2] = u2[f2].map((r) => {
      var g;
      return (g = V(r, l)) != null ? g : r;
    });
    Ue(i);
  }
  for (const u2 of ce) {
    const f2 = n2[u2];
    f2 && (n2[u2] = f2.map((r) => {
      var g;
      return (g = V(r, l)) != null ? g : r;
    }));
  }
  return n2;
}, "parseTsconfig");
var he = o((e = process.cwd(), t = "tsconfig.json", s2 = /* @__PURE__ */ new Map()) => {
  const n2 = le(E3(e), t, s2);
  if (!n2) return null;
  const l = ge(n2, s2);
  return { path: n2, config: l };
}, "getTsconfig");
var xe = /\*/g;
var me = o((e, t) => {
  const s2 = e.match(xe);
  if (s2 && s2.length > 1) throw new Error(t);
}, "assertStarCount");
var Ne = o((e) => {
  if (e.includes("*")) {
    const [t, s2] = e.split("*");
    return { prefix: t, suffix: s2 };
  }
  return e;
}, "parsePattern");
var Se = o(({ prefix: e, suffix: t }, s2) => s2.startsWith(e) && s2.endsWith(t), "isPatternMatch");
var Re = o((e, t, s2) => Object.entries(e).map(([n2, l]) => (me(n2, `Pattern '${n2}' can have at most one '*' character.`), { pattern: Ne(n2), substitutions: l.map((i) => {
  if (me(i, `Substitution '${i}' in pattern '${n2}' can have at most one '*' character.`), !t && !G.test(i)) throw new Error("Non-relative paths are not allowed when 'baseUrl' is not set. Did you forget a leading './'?");
  return p2__default.default.resolve(s2, i);
}) })), "parsePaths");
o((e) => {
  const { compilerOptions: t } = e.config;
  if (!t) return null;
  const { baseUrl: s2, paths: n2 } = t;
  if (!s2 && !n2) return null;
  const l = X in t && t[X], i = p2__default.default.resolve(p2__default.default.dirname(e.path), s2 || l || "."), u2 = n2 ? Re(n2, s2, i) : [];
  return (f2) => {
    if (G.test(f2)) return [];
    const r = [];
    for (const _2 of u2) {
      if (_2.pattern === f2) return _2.substitutions.map(E3);
      typeof _2.pattern != "string" && r.push(_2);
    }
    let g, T = -1;
    for (const _2 of r) Se(_2.pattern, f2) && _2.pattern.prefix.length > T && (T = _2.pattern.prefix.length, g = _2);
    if (!g) return s2 ? [E3(p2__default.default.join(i, f2))] : [];
    const b = f2.slice(g.pattern.prefix.length, f2.length - g.pattern.suffix.length);
    return g.substitutions.map((_2) => E3(_2.replace("*", b)));
  };
}, "createPathsMatcher");
var pe = o((e) => {
  let t = "";
  for (let s2 = 0; s2 < e.length; s2 += 1) {
    const n2 = e[s2], l = n2.toUpperCase();
    t += n2 === l ? n2.toLowerCase() : l;
  }
  return t;
}, "s");
var We = 65;
var Me = 97;
var Ve = o(() => Math.floor(Math.random() * 26), "m");
var Je = o((e) => Array.from({ length: e }, () => String.fromCodePoint(Ve() + (Math.random() > 0.5 ? We : Me))).join(""), "S");
var ze = o((e = fs__default.default) => {
  const t = process.execPath;
  if (e.existsSync(t)) return !e.existsSync(pe(t));
  const s2 = `/${Je(10)}`;
  e.writeFileSync(s2, "");
  const n2 = !e.existsSync(pe(s2));
  return e.unlinkSync(s2), n2;
}, "l");
var { join: J } = p2__default.default.posix;
var C3 = { ts: [".ts", ".tsx", ".d.ts"], cts: [".cts", ".d.cts"], mts: [".mts", ".d.mts"] };
var Oe = o((e) => {
  const t = [...C3.ts], s2 = [...C3.cts], n2 = [...C3.mts];
  return e != null && e.allowJs && (t.push(".js", ".jsx"), s2.push(".cjs"), n2.push(".mjs")), [...t, ...s2, ...n2];
}, "getSupportedExtensions");
var Ge = o((e) => {
  const t = [];
  if (!e) return t;
  const { outDir: s2, declarationDir: n2 } = e;
  return s2 && t.push(s2), n2 && t.push(n2), t;
}, "getDefaultExcludeSpec");
var ke = o((e) => e.replaceAll(/[.*+?^${}()|[\]\\]/g, String.raw`\$&`), "escapeForRegexp");
var Qe = ["node_modules", "bower_components", "jspm_packages"];
var ee = `(?!(${Qe.join("|")})(/|$))`;
var He = /(?:^|\/)[^.*?]+$/;
var we = "**/*";
var z = "[^/]";
var ne = "[^./]";
var be = process.platform === "win32";
o(({ config: e, path: t }, s2 = ze()) => {
  if ("extends" in e) throw new Error("tsconfig#extends must be resolved. Use getTsconfig or parseTsconfig to resolve it.");
  if (!p2__default.default.isAbsolute(t)) throw new Error("The tsconfig path must be absolute");
  be && (t = E3(t));
  const n2 = p2__default.default.dirname(t), { files: l, include: i, exclude: u2, compilerOptions: f2 } = e, r = l == null ? void 0 : l.map((w2) => J(n2, w2)), g = Oe(f2), T = s2 ? "" : "i", _2 = (u2 || Ge(f2)).map((w2) => {
    const y = J(n2, w2), I2 = ke(y).replaceAll(String.raw`\*\*/`, "(.+/)?").replaceAll(String.raw`\*`, `${z}*`).replaceAll(String.raw`\?`, z);
    return new RegExp(`^${I2}($|/)`, T);
  }), d2 = l || i ? i : [we], A3 = d2 ? d2.map((w2) => {
    let y = J(n2, w2);
    He.test(y) && (y = J(y, we));
    const I2 = ke(y).replaceAll(String.raw`/\*\*`, `(/${ee}${ne}${z}*)*?`).replaceAll(/(\/)?\\\*/g, (L, c) => {
      const k = `(${ne}|(\\.(?!min\\.js$))?)*`;
      return c ? `/${ee}${ne}${k}` : k;
    }).replaceAll(/(\/)?\\\?/g, (L, c) => {
      const k = z;
      return c ? `/${ee}${k}` : k;
    });
    return new RegExp(`^${I2}$`, T);
  }) : void 0;
  return (w2) => {
    if (!p2__default.default.isAbsolute(w2)) throw new Error("filePath must be absolute");
    if (be && (w2 = E3(w2)), r != null && r.includes(w2)) return e;
    if (!(!g.some((y) => w2.endsWith(y)) || _2.some((y) => y.test(w2))) && A3 && A3.some((y) => y.test(w2))) return e;
  };
}, "createFilesMatcher");

// node_modules/.pnpm/rollup-plugin-esbuild@6.2.1_@rollup+wasm-node@4.37.0_esbuild@0.25.1/node_modules/rollup-plugin-esbuild/dist/index.mjs
var warn3 = async (pluginContext2, messages) => {
  if (messages.length > 0) {
    const warnings = await (0, import_esbuild3.formatMessages)(messages, {
      kind: "warning",
      color: true
    });
    warnings.forEach((warning) => pluginContext2.warn(warning));
  }
};
var getEsbuildFormat = (rollupFormat) => {
  if (rollupFormat === "es") {
    return "esm";
  }
  if (rollupFormat === "cjs") {
    return rollupFormat;
  }
};
var getRenderChunk = ({
  sourceMap = true,
  ...options
}) => async function(code, _2, rollupOptions) {
  if (options.minify || options.minifyWhitespace || options.minifyIdentifiers || options.minifySyntax) {
    const format5 = getEsbuildFormat(rollupOptions.format);
    const result = await (0, import_esbuild2.transform)(code, {
      format: format5,
      loader: "js",
      sourcemap: sourceMap,
      ...options
    });
    await warn3(this, result.warnings);
    if (result.code) {
      return {
        code: result.code,
        map: result.map || null
      };
    }
  }
  return null;
};
var slash = (p3) => p3.replace(/\\/g, "/");
var optimizeDeps = async (options) => {
  var _a2;
  const cacheDir = p2__default.default.join(options.cwd, "node_modules/.optimize_deps");
  await fs__default.default.promises.mkdir(cacheDir, { recursive: true });
  await init;
  await (0, import_esbuild4.build)({
    entryPoints: options.include,
    absWorkingDir: options.cwd,
    bundle: true,
    format: "esm",
    ignoreAnnotations: true,
    metafile: true,
    splitting: true,
    outdir: cacheDir,
    sourcemap: options.sourceMap,
    ...options.esbuildOptions,
    plugins: [
      {
        name: "optimize-deps",
        async setup(build22) {
          build22.onResolve({ filter: /.*/ }, async (args2) => {
            var _a22, _b;
            if ((_a22 = options.exclude) == null ? void 0 : _a22.includes(args2.path)) {
              return {
                external: true
              };
            }
            if ((_b = args2.pluginData) == null ? void 0 : _b.__resolving_dep_path__) {
              return;
            }
            if (options.include.includes(args2.path)) {
              const resolved = await build22.resolve(args2.path, {
                resolveDir: args2.resolveDir,
                kind: "import-statement",
                pluginData: { __resolving_dep_path__: true }
              });
              if (resolved.errors.length > 0 || resolved.warnings.length > 0) {
                return resolved;
              }
              return {
                path: args2.path,
                namespace: "optimize-deps",
                pluginData: {
                  resolveDir: args2.resolveDir,
                  absolute: resolved.path
                }
              };
            }
          });
          build22.onLoad(
            { filter: /.*/, namespace: "optimize-deps" },
            async (args2) => {
              const { absolute, resolveDir } = args2.pluginData;
              const contents = await fs__default.default.promises.readFile(absolute, "utf-8");
              const [, exported] = parse5(contents);
              return {
                contents: exported.length > 0 ? `export * from '${slash(absolute)}'` : `module.exports = require('${slash(absolute)}')`,
                resolveDir
              };
            }
          );
        }
      },
      ...((_a2 = options.esbuildOptions) == null ? void 0 : _a2.plugins) || []
    ]
  });
  const optimized = /* @__PURE__ */ new Map();
  for (const id2 of options.include) {
    optimized.set(id2, { file: p2__default.default.join(cacheDir, `${id2}.js`) });
  }
  return {
    optimized,
    cacheDir
  };
};
var cache2 = /* @__PURE__ */ new Map();
function getTsconfig(searchPath, configName) {
  var _a2;
  return (_a2 = he(searchPath, configName, cache2)) == null ? void 0 : _a2.config;
}
var debugOptimizeDeps = (0, import_debug2.default)("rpe:optimize-deps");
var defaultLoaders = {
  ".js": "js",
  ".jsx": "jsx",
  ".ts": "ts",
  ".tsx": "tsx"
};
var index_default = ({
  include,
  exclude: exclude3,
  sourceMap = true,
  optimizeDeps: optimizeDeps2,
  tsconfig,
  loaders: _loaders,
  ...esbuildOptions
} = {}) => {
  const loaders = {
    ...defaultLoaders
  };
  if (_loaders) {
    for (let [key, value] of Object.entries(_loaders)) {
      key = key[0] === "." ? key : `.${key}`;
      if (typeof value === "string") {
        loaders[key] = value;
      } else if (value === false) {
        delete loaders[key];
      }
    }
  }
  const extensions = Object.keys(loaders);
  const INCLUDE_REGEXP = new RegExp(
    `\\.(${extensions.map((ext) => ext.slice(1)).join("|")})$`
  );
  const EXCLUDE_REGEXP = /node_modules/;
  const filter10 = createFilter3(
    include || INCLUDE_REGEXP,
    exclude3 || EXCLUDE_REGEXP
  );
  const resolveFile = (resolved, index = false) => {
    const fileWithoutExt = resolved.replace(/\.[jt]sx?$/, "");
    for (const ext of extensions) {
      const file = index ? p2.join(resolved, `index${ext}`) : `${fileWithoutExt}${ext}`;
      if (fs.existsSync(file)) return file;
    }
    return null;
  };
  let optimizeDepsResult;
  let cwd2 = process.cwd();
  return {
    name: "esbuild",
    options({ context: context8 }) {
      if (context8) {
        cwd2 = context8;
      }
      return null;
    },
    async buildStart() {
      if (!optimizeDeps2 || optimizeDepsResult) return;
      optimizeDepsResult = await optimizeDeps({
        cwd: cwd2,
        sourceMap,
        ...optimizeDeps2
      });
      debugOptimizeDeps("optimized %O", optimizeDepsResult.optimized);
    },
    async resolveId(id2, importer) {
      if (optimizeDepsResult == null ? void 0 : optimizeDepsResult.optimized.has(id2)) {
        const m2 = optimizeDepsResult.optimized.get(id2);
        debugOptimizeDeps("resolved %s to %s", id2, m2.file);
        return m2.file;
      }
      if (importer && id2[0] === ".") {
        const resolved = p2.resolve(
          importer ? p2.dirname(importer) : process.cwd(),
          id2
        );
        let file = resolveFile(resolved);
        if (file) return file;
        if (!file && fs.existsSync(resolved) && fs.statSync(resolved).isDirectory()) {
          file = resolveFile(resolved, true);
          if (file) return file;
        }
      }
    },
    async transform(code, id2) {
      if (!filter10(id2) || (optimizeDepsResult == null ? void 0 : optimizeDepsResult.optimized.has(id2))) {
        return null;
      }
      const ext = p2.extname(id2);
      const loader = loaders[ext];
      if (!loader) {
        return null;
      }
      const tsconfigRaw = tsconfig === false ? void 0 : getTsconfig(id2, tsconfig || "tsconfig.json");
      const result = await (0, import_esbuild.transform)(code, {
        loader,
        sourcemap: sourceMap,
        sourcefile: id2,
        tsconfigRaw,
        target: "es2020",
        format: [
          "base64",
          "binary",
          "dataurl",
          "text",
          "json"
        ].includes(loader) ? "esm" : void 0,
        ...esbuildOptions
      });
      await warn3(this, result.warnings);
      return result.code && {
        code: result.code,
        map: result.map || null
      };
    },
    renderChunk: getRenderChunk({
      ...esbuildOptions,
      sourceMap
    })
  };
};

// src/Rollup.ts
var RollupError = class extends Data_exports.TaggedError("RollupError") {
};
var Rollup = class extends Effect_exports.Service()("app/Rollup", {
  effect: Effect_exports.gen(function* () {
    const onwarn = (warning, next) => {
      if (warning.code === "THIS_IS_UNDEFINED") {
        return;
      }
      next(warning);
    };
    const plugins = [
      nodeResolve(),
      index_default(),
      terser({ mangle: true, compress: true })
    ];
    const bundle = Effect_exports.fn("Rollup.bundle")(
      function* (input2) {
        const bundle2 = yield* Effect_exports.tryPromise({
          try: () => rollup({ input: input2, onwarn, plugins }),
          catch: (cause3) => new RollupError({ cause: cause3 })
        });
        const encoder = new TextEncoder();
        const chunk5 = yield* Effect_exports.tryPromise({
          try: () => bundle2.generate({ format: "cjs" }),
          catch: (cause3) => new RollupError({ cause: cause3 })
        }).pipe(Effect_exports.map(({ output }) => output[0]));
        const buffer4 = encoder.encode(chunk5.code);
        const sizeInBytes = yield* Stream_exports.succeed(buffer4).pipe(
          NodeStream_exports.pipeThroughSimple(() => zlib.createGzip()),
          Stream_exports.runFold(0, (size16, bytes) => size16 + bytes.length)
        );
        yield* Console_exports.log({ ...chunk5, sizeInBytes });
      }
    );
    return {
      bundle
    };
  })
}) {
};

// src/index.ts
var ConfigProviderLayer = ConfigProvider_exports.fromEnv().pipe(
  ConfigProvider_exports.constantCase,
  Layer_exports.setConfigProvider
);
var main = Effect_exports.gen(function* () {
  const eventName = yield* Config_exports.nonEmptyString("GITHUB_EVENT_NAME");
  if (eventName !== "pull_request") {
    return yield* Effect_exports.dieMessage("Package metrics can only be computed for pull requests");
  }
  const repository = yield* Config_exports.nonEmptyString("GITHUB_REPOSITORY");
  input("base_ref").pipe(
    Config_exports.orElse(() => Config_exports.nonEmptyString("GITHUB_BASE_REF"))
  );
  input("head_ref").pipe(
    Config_exports.orElse(() => Config_exports.nonEmptyString("GITHUB_HEAD_REF"))
  );
  const git = yield* Git2;
  yield* git.clone(`https://github.com/${repository}.git`, "base");
  yield* git.clone(`https://github.com/${repository}.git`, "head");
});
var MainLayer = Layer_exports.mergeAll(
  Git2.Default,
  Rollup.Default
).pipe(Layer_exports.provide(ConfigProviderLayer));
main.pipe(
  Effect_exports.provide(MainLayer),
  NodeRuntime_exports.runMain
);
/*! Bundled license information:

undici/lib/web/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

undici/lib/web/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)

@rollup/wasm-node/dist/es/shared/parseAst.js:
  (*
    @license
  	Rollup.js v4.37.0
  	Sun, 23 Mar 2025 14:56:38 GMT - commit 8b1c634d945dda9294cf579de68c4b223c618e7f
  
  	https://github.com/rollup/rollup
  
  	Released under the MIT License.
  *)

@rollup/wasm-node/dist/es/shared/node-entry.js:
  (*
    @license
  	Rollup.js v4.37.0
  	Sun, 23 Mar 2025 14:56:38 GMT - commit 8b1c634d945dda9294cf579de68c4b223c618e7f
  
  	https://github.com/rollup/rollup
  
  	Released under the MIT License.
  *)

@rollup/wasm-node/dist/es/rollup.js:
  (*
    @license
  	Rollup.js v4.37.0
  	Sun, 23 Mar 2025 14:56:38 GMT - commit 8b1c634d945dda9294cf579de68c4b223c618e7f
  
  	https://github.com/rollup/rollup
  
  	Released under the MIT License.
  *)
*/
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map